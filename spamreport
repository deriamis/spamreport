
# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"perl5/App/FatPacker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_APP_FATPACKER';
  package App::FatPacker;
  
  use strict;
  use warnings FATAL => 'all';
  use 5.008001;
  use Getopt::Long;
  use Cwd qw(cwd);
  use File::Find qw(find);
  use File::Spec::Functions qw(
    catdir splitpath splitdir catpath rel2abs abs2rel
  );
  use File::Spec::Unix;
  use File::Copy qw(copy);
  use File::Path qw(mkpath rmtree);
  use B qw(perlstring);
  
  our $VERSION = '0.010005'; # 0.10.5
  
  $VERSION = eval $VERSION;
  
  sub call_parser {
    my $self = shift;
    my ($args, $options) = @_;
  
    local *ARGV = [ @{$args} ];
    $self->{option_parser}->getoptions(@$options);
  
    return [ @ARGV ];
  }
  
  sub lines_of {
    map +(chomp,$_)[1], do { local @ARGV = ($_[0]); <> };
  }
  
  sub stripspace {
    my ($text) = @_;
    $text =~ /^(\s+)/ && $text =~ s/^$1//mg;
    $text;
  }
  
  sub import {
    $_[1] && $_[1] eq '-run_script'
      and return shift->new->run_script;
  }
  
  sub new {
    bless {
      option_parser => Getopt::Long::Parser->new(
        config => [ qw(require_order pass_through bundling no_auto_abbrev) ]
      ),
    }, $_[0];
  }
  
  sub run_script {
    my ($self, $args) = @_;
    my @args = $args ? @$args : @ARGV;
    (my $cmd = shift @args || 'help') =~ s/-/_/g;
  
    if (my $meth = $self->can("script_command_${cmd}")) {
      $self->$meth(\@args);
    } else {
      die "No such command ${cmd}";
    }
  }
  
  sub script_command_help {
    print "Try `perldoc fatpack` for how to use me\n";
  }
  
  sub script_command_pack {
    my ($self, $args) = @_;
  
    my @modules = split /\r?\n/, $self->trace(args => $args);
    my @packlists = $self->packlists_containing(\@modules);
  
    my $base = catdir(cwd, 'fatlib');
    $self->packlists_to_tree($base, \@packlists);
  
    my $file = shift @$args;
    print $self->fatpack_file($file);
  }
  
  sub script_command_trace {
    my ($self, $args) = @_;
  
    $args = $self->call_parser($args => [
      'to=s' => \my $file,
      'to-stderr' => \my $to_stderr,
      'use=s' => \my @additional_use
    ]);
  
    die "Can't use to and to-stderr on same call" if $file && $to_stderr;
  
    $file ||= 'fatpacker.trace';
  
    if (!$to_stderr and -e $file) {
      unlink $file or die "Couldn't remove old trace file: $!";
    }
    my $arg = do {
      if ($to_stderr) {
        ">&STDERR"
      } elsif ($file) {
        ">>${file}"
      }
    };
  
    $self->trace(
      use => \@additional_use,
      args => $args,
      output => $arg,
    );
  }
  
  sub trace {
    my ($self, %opts) = @_;
  
    my $output = $opts{output};
    my $trace_opts = join ',', $output||'>&STDOUT', @{$opts{use}||[]};
  
    local $ENV{PERL5OPT} = join ' ',
      ($ENV{PERL5OPT}||()), '-MApp::FatPacker::Trace='.$trace_opts;
  
    my @args = @{$opts{args}||[]};
  
    if ($output) {
      # user specified output target, JFDI
      system $^X, @args;
      return;
    } else {
      # no output target specified, slurp
      open my $out_fh, "$^X @args |";
      return do { local $/; <$out_fh> };
    }
  }
  
  sub script_command_packlists_for {
    my ($self, $args) = @_;
    foreach my $pl ($self->packlists_containing($args)) {
      print "${pl}\n";
    }
  }
  
  sub packlists_containing {
    my ($self, $targets) = @_;
    my @targets = @$targets;
    {
      local @INC = ('lib', @INC);
      foreach my $t (@targets) {
        require $t;
      }
    }
    my @search = grep -d $_, map catdir($_, 'auto'), @INC;
    my %pack_rev;
    find({
      no_chdir => 1,
      wanted => sub {
        return unless /[\\\/]\.packlist$/ && -f $_;
        $pack_rev{$_} = $File::Find::name for lines_of $File::Find::name;
      },
    }, @search);
    my %found; @found{map +($pack_rev{Cwd::abs_path($INC{$_})}||()), @targets} = ();
    sort keys %found;
  }
  
  sub script_command_tree {
    my ($self, $args) = @_;
    my $base = catdir(cwd,'fatlib');
    $self->packlists_to_tree($base, $args);
  }
  
  sub packlists_to_tree {
    my ($self, $where, $packlists) = @_;
    rmtree $where;
    mkpath $where;
    foreach my $pl (@$packlists) {
      my ($vol, $dirs, $file) = splitpath $pl;
      my @dir_parts = splitdir $dirs;
      my $pack_base;
      PART: foreach my $p (0 .. $#dir_parts) {
        if ($dir_parts[$p] eq 'auto') {
          # $p-2 since it's <wanted path>/$Config{archname}/auto
          $pack_base = catpath $vol, catdir @dir_parts[0..$p-2];
          last PART;
        }
      }
      die "Couldn't figure out base path of packlist ${pl}" unless $pack_base;
      foreach my $source (lines_of $pl) {
        # there is presumably a better way to do "is this under this base?"
        # but if so, it's not obvious to me in File::Spec
        next unless substr($source,0,length $pack_base) eq $pack_base;
        my $target = rel2abs( abs2rel($source, $pack_base), $where );
        my $target_dir = catpath((splitpath $target)[0,1]);
        mkpath $target_dir;
        copy $source => $target;
      }
    }
  }
  
  sub script_command_file {
    my ($self, $args) = @_;
    my $file = shift @$args;
    print $self->fatpack_file($file);
  }
  
  sub fatpack_file {
    my ($self, $file) = @_;
  
    my $shebang = "";
    my $script = "";
    if ( defined $file and -r $file ) {
      ($shebang, $script) = $self->load_main_script($file);
    }
  
    my @dirs = $self->collect_dirs();
    my %files;
    $self->collect_files($_, \%files) for @dirs;
  
    return join "\n", $shebang, $self->fatpack_code(\%files), $script;
  }
  
  # This method can be overload in sub classes
  # For example to skip POD
  sub load_file {
    my ($self, $file) = @_;
    my $content = do {
      local (@ARGV, $/) = ($file);
      <>
    };
    close ARGV;
    return $content;
  }
  
  sub collect_dirs {
    my ($self) = @_;
    my $cwd = cwd;
    return grep -d, map rel2abs($_, $cwd), ('lib','fatlib');
  }
  
  sub collect_files {
    my ($self, $dir, $files) = @_;
    find(sub {
      return unless -f $_;
      !/\.pm$/ and warn "File ${File::Find::name} isn't a .pm file - can't pack this -- if you hoped we were going to, things may not be what you expected later\n" and return;
      $files->{File::Spec::Unix->abs2rel($File::Find::name,$dir)} =
        $self->load_file($File::Find::name);
    }, $dir);
  }
  
  sub load_main_script {
    my ($self, $file) = @_;
    open my $fh, "<", $file or die("Can't read $file: $!");
    my $shebang = <$fh>;
    my $script = join "", <$fh>;
    close $fh;
    unless ( index($shebang, '#!') == 0 ) {
      $script = $shebang . $script;
      $shebang = "";
    }
    return ($shebang, $script);
  }
  
  sub fatpack_start {
    return stripspace <<'  END_START';
      # This chunk of stuff was generated by App::FatPacker. To find the original
      # file's code, look for the end of this BEGIN block or the string 'FATPACK'
      BEGIN {
      my %fatpacked;
    END_START
  }
  
  sub fatpack_end {
    return stripspace <<'  END_END';
      s/^  //mg for values %fatpacked;
  
      my $class = 'FatPacked::'.(0+\%fatpacked);
      no strict 'refs';
      *{"${class}::files"} = sub { keys %{$_[0]} };
  
      if ($] < 5.008) {
        *{"${class}::INC"} = sub {
          if (my $fat = $_[0]{$_[1]}) {
            my $pos = 0;
            my $last = length $fat;
            return (sub {
              return 0 if $pos == $last;
              my $next = (1 + index $fat, "\n", $pos) || $last;
              $_ .= substr $fat, $pos, $next - $pos;
              $pos = $next;
              return 1;
            });
          }
        };
      }
  
      else {
        *{"${class}::INC"} = sub {
          if (my $fat = $_[0]{$_[1]}) {
            open my $fh, '<', \$fat
              or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
            return $fh;
          }
          return;
        };
      }
  
      unshift @INC, bless \%fatpacked, $class;
    } # END OF FATPACK CODE
    END_END
  }
  
  sub fatpack_code {
    my ($self, $files) = @_;
    my @segments = map {
      (my $stub = $_) =~ s/\.pm$//;
      my $name = uc join '_', split '/', $stub;
      my $data = $files->{$_}; $data =~ s/^/  /mg; $data =~ s/(?<!\n)\z/\n/;
      '$fatpacked{'.perlstring($_).qq!} = '#line '.(1+__LINE__).' "'.__FILE__."\\"\\n".<<'${name}';\n!
      .qq!${data}${name}\n!;
    } sort keys %$files;
  
    return join "\n", $self->fatpack_start, @segments, $self->fatpack_end;
  }
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::FatPacker - pack your dependencies onto your script file
  
  =head1 SYNOPSIS
  
    $ fatpack pack myscript.pl >myscript.packed.pl
  
  Or, with more step-by-step control:
  
    $ fatpack trace myscript.pl
    $ fatpack packlists-for `cat fatpacker.trace` >packlists
    $ fatpack tree `cat packlists`
    $ fatpack file myscript.pl >myscript.packed.pl
  
  See the documentation for the L<fatpack> script itself for more information.
  
  The programmatic API for this code is not yet fully decided, hence the 0.x
  release version. Expect that to be cleaned up for 1.0.
  
  =head1 SEE ALSO
  
  L<article for Perl Advent 2012|http://www.perladvent.org/2012/2012-12-14.html>
  
  =head1 SUPPORT
  
  Bugs may be submitted through L<the RT bug tracker|https://rt.cpan.org/Public/Dist/Display.html?Name=App-FatPacker>
  (or L<bug-App-FatPacker@rt.cpan.org|mailto:bug-App-FatPacker@rt.cpan.org>).
  
  You can normally also obtain assistance on irc, in #toolchain on irc.perl.org.
  
  =head1 AUTHOR
  
  Matt S. Trout (mst) <mst@shadowcat.co.uk>
  
  =head2 CONTRIBUTORS
  
  miyagawa - Tatsuhiko Miyagawa (cpan:MIYAGAWA) <miyagawa@bulknews.net>
  
  tokuhirom - MATSUNO★Tokuhiro (cpan:TOKUHIROM) <tokuhirom@gmail.com>
  
  dg - David Leadbeater (cpan:DGL) <dgl@dgl.cx>
  
  gugod - 劉康民 (cpan:GUGOD) <gugod@cpan.org>
  
  t0m - Tomas Doran (cpan:BOBTFISH) <bobtfish@bobtfish.net>
  
  sawyer - Sawyer X (cpan:XSAWYERX) <xsawyerx@cpan.org>
  
  ether - Karen Etheridge (cpan:ETHER) <ether@cpan.org>
  
  Mithaldu - Christian Walde (cpan:MITHALDU) <walde.christian@googlemail.com>
  
  dolmen - Olivier Mengué (cpan:DOLMEN) <dolmen@cpan.org>
  
  djerius - Diab Jerius (cpan:DJERIUS) <djerius@cpan.org>
  
  haarg - Graham Knop (cpan:HAARG> <haarg@haarg.org>
  
  Many more people are probably owed thanks for ideas. Yet
  another doc nit to fix.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2010 the App::FatPacker L</AUTHOR> and L</CONTRIBUTORS>
  as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself.
  
  =cut
  
  1;
  
PERL5_APP_FATPACKER

$fatpacked{"perl5/App/FatPacker/Trace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_APP_FATPACKER_TRACE';
  package App::FatPacker::Trace;
  
  use strict;
  use warnings FATAL => 'all';
  use B ();
  
  my $trace_file;
  my %initial_inc;
  
  sub import {
    my (undef, $file, @extras) = @_;
  
    $trace_file = $file || '>>fatpacker.trace';
    # For filtering out our own deps later.
    # (Not strictly required as these are core only and won't have packlists, but 
    # looks neater.)
    %initial_inc = %INC;
  
    # Use any extra modules specified
    eval "use $_" for @extras;
  
    B::minus_c;
  }
  
  CHECK {
    return unless $trace_file; # not imported
  
    open my $trace, $trace_file
        or die "Couldn't open $trace_file to trace to: $!";
  
    for my $inc (keys %INC) {
      next if exists $initial_inc{$inc};
      next unless $INC{$inc} =~ /\Q${inc}\E\Z/;
      print $trace "$inc\n";
    }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  App::FatPacker::Trace - Tracing module usage using compilation checking
  
  =head1 SYNOPSIS
  
      # open STDERR for writing
      # will be like: open my $fh, '>', '&STDERR'...
      perl -MApp::FatPacker::Trace=>&STDERR myscript.pl
  
      # open a file for writing
      # will be like: open my $fh, '>>', 'fatpacker.trace'
      perl -MApp::FatPacker::Trace=>>fatpacker.trace myscript.pl
  
  =head1 DESCRIPTION
  
  This module allows tracing the modules being used by your code. It does that
  using clever trickery using the C<import> method, the C<CHECK> block and
  L<B>'s C<minus_c> function.
  
  When App::FatPacker::Trace is being used, the import() method will call
  C<B::minus_c> in order to set up the global compilation-only flag perl
  (the interpreter) has. This will prevent any other code from being run.
  
  Then in the C<CHECK> block which is reached at the end of the compilation
  phase (see L<perlmod>), it will gather all modules that have been loaded,
  using C<%INC>, and will write it to a file or to STDERR, determined by
  parameters sent to the C<import> method.
  
  =head1 METHODS
  
  =head2 import
  
  This method gets run when you just load L<App::FatPacker::Trace>. It will
  note the current C<%INC> and will set up the output to be written to, and
  raise the compilation-only flag, which will prevent anything from being
  run past that point. This flag cannot be unset, so this is most easily run
  from the command line as such:
  
      perl -MApp::FatPacker::Trace [...]
  
  You can control the parameters to the import using an equal sign, as such:
  
      # send the parameter "hello"
      perl -MApp::FatPacker::Trace=hello [...]
  
      # send the parameter ">&STDERR"
      perl -MApp::FatPacker::Trace=>&STDERR [...]
  
  The import method accepts a first parameter telling it which output to open
  and how. These are both sent in a single parameter.
  
      # append to mytrace.txt
      perl -MApp::FatPacker::Trace=>>mytrace.txt myscript.pl
  
      # write to STDERR
      perl -MApp::FatPacker::Trace=>&STDERR myscript.pl
  
  The import method accepts additional parameters of extra modules to load.
  It will then add these modules to the trace. This is helpful if you want
  to explicitly indicate additional modules to trace, even if they aren't
  used in your script. Perhaps you're conditionally using them, perhaps
  they're for additional features, perhaps they're loaded lazily, whatever
  the reason.
  
      # Add Moo to the trace, even if you don't trace it in myscript.pl
      perl -MApp::FatPacker::Trace=>&STDERR,Moo myscript.pl
  
PERL5_APP_FATPACKER_TRACE

$fatpacked{"perl5/App/cpanminus.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_APP_CPANMINUS';
  package App::cpanminus;
  our $VERSION = "1.7040";
  
  =encoding utf8
  
  =head1 NAME
  
  App::cpanminus - get, unpack, build and install modules from CPAN
  
  =head1 SYNOPSIS
  
      cpanm Module
  
  Run C<cpanm -h> or C<perldoc cpanm> for more options.
  
  =head1 DESCRIPTION
  
  cpanminus is a script to get, unpack, build and install modules from
  CPAN and does nothing else.
  
  It's dependency free (can bootstrap itself), requires zero
  configuration, and stands alone. When running, it requires only 10MB
  of RAM.
  
  =head1 INSTALLATION
  
  There are several ways to install cpanminus to your system.
  
  =head2 Package management system
  
  There are Debian packages, RPMs, FreeBSD ports, and packages for other
  operation systems available. If you want to use the package management system,
  search for cpanminus and use the appropriate command to install. This makes it
  easy to install C<cpanm> to your system without thinking about where to
  install, and later upgrade.
  
  =head2 Installing to system perl
  
  You can also use the latest cpanminus to install cpanminus itself:
  
      curl -L https://cpanmin.us | perl - --sudo App::cpanminus
  
  This will install C<cpanm> to your bin directory like
  C</usr/local/bin> and you'll need the C<--sudo> option to write to
  the directory, unless you configured C<INSTALL_BASE> with L<local::lib>.
  
  =head2 Installing to local perl (perlbrew, plenv etc.)
  
  If you have perl in your home directory, which is the case if you use
  tools like L<perlbrew> or plenv, you don't need the C<--sudo> option, since
  you're most likely to have a write permission to the perl's library
  path. You can just do:
  
      curl -L https://cpanmin.us | perl - App::cpanminus
  
  to install the C<cpanm> executable to the perl's bin path, like
  C<~/perl5/perlbrew/bin/cpanm>.
  
  =head2 Downloading the standalone executable
  
  You can also copy the standalone executable to whatever location you'd like.
  
      cd ~/bin
      curl -L https://cpanmin.us/ -o cpanm
      chmod +x cpanm
  
  This just works, but be sure to grab the new version manually when you
  upgrade because C<--self-upgrade> might not work with this installation setup.
  
  =head2 Troubleshoot: HTTPS warnings
  
  When you run C<curl> commands above, you may encounter SSL handshake
  errors or certification warnings. This is due to your HTTP client
  (curl) being old, or SSL certificates installed on your system needs
  to be updated.
  
  You're recommended to update the software or system if you can. If
  that is impossible or difficult, use the C<-k> option with curl or an
  alternative URL, C<https://git.io/cpanm>
  
  =head1 DEPENDENCIES
  
  perl 5.8.1 or later.
  
  =over 4
  
  =item *
  
  'tar' executable (bsdtar or GNU tar version 1.22 are recommended) or Archive::Tar to unpack files.
  
  =item *
  
  C compiler, if you want to build XS modules.
  
  =item *
  
  make
  
  =item *
  
  Module::Build (core in 5.10)
  
  =back
  
  =head1 QUESTIONS
  
  =head2 How does cpanm get/parse/update the CPAN index?
  
  It queries the CPAN Meta DB site at L<http://cpanmetadb.plackperl.org/>.
  The site is updated at least every hour to reflect the latest changes
  from fast syncing mirrors. The script then also falls back to query the
  module at L<http://metacpan.org/> using its search API.
  
  Upon calling these API hosts, cpanm (1.6004 or later) will send the
  local perl versions to the server in User-Agent string by default. You
  can turn it off with C<--no-report-perl-version> option. Read more
  about the option with L<cpanm>, and read more about the privacy policy
  about this data collection at L<http://cpanmetadb.plackperl.org/#privacy>
  
  Fetched files are unpacked in C<~/.cpanm> and automatically cleaned up
  periodically.  You can configure the location of this with the
  C<PERL_CPANM_HOME> environment variable.
  
  =head2 Where does this install modules to? Do I need root access?
  
  It installs to wherever ExtUtils::MakeMaker and Module::Build are
  configured to (via C<PERL_MM_OPT> and C<PERL_MB_OPT>).
  
  By default, it installs to the site_perl directory that belongs to
  your perl. You can see the locations for that by running C<perl -V>
  and it will be likely something under C</opt/local/perl/...> if you're
  using system perl, or under your home directory if you have built perl
  yourself using perlbrew or plenv.
  
  If you've already configured local::lib on your shell, cpanm respects
  that settings and modules will be installed to your local perl5
  directory.
  
  At a boot time, cpanminus checks whether you have already configured
  local::lib, or have a permission to install modules to the site_perl
  directory.  If neither, i.e. you're using system perl and do not run
  cpanm as a root, it automatically sets up local::lib compatible
  installation path in a C<perl5> directory under your home
  directory.
  
  To avoid this, run C<cpanm> either as a root user, with C<--sudo>
  option, or with C<--local-lib> option.
  
  =head2 cpanminus can't install the module XYZ. Is it a bug?
  
  It is more likely a problem with the distribution itself. cpanminus
  doesn't support or may have issues with distributions such as follows:
  
  =over 4
  
  =item *
  
  Tests that require input from STDIN.
  
  =item *
  
  Build.PL or Makefile.PL that prompts for input even when
  C<PERL_MM_USE_DEFAULT> is enabled.
  
  =item *
  
  Modules that have invalid numeric values as VERSION (such as C<1.1a>)
  
  =back
  
  These failures can be reported back to the author of the module so
  that they can fix it accordingly, rather than to cpanminus.
  
  =head2 Does cpanm support the feature XYZ of L<CPAN> and L<CPANPLUS>?
  
  Most likely not. Here are the things that cpanm doesn't do by
  itself.
  
  If you need these features, use L<CPAN>, L<CPANPLUS> or the standalone
  tools that are mentioned.
  
  =over 4
  
  =item *
  
  CPAN testers reporting. See L<App::cpanminus::reporter>
  
  =item *
  
  Building RPM packages from CPAN modules
  
  =item *
  
  Listing the outdated modules that needs upgrading. See L<App::cpanoutdated>
  
  =item *
  
  Showing the changes of the modules you're about to upgrade. See L<cpan-listchanges>
  
  =item *
  
  Patching CPAN modules with distroprefs.
  
  =back
  
  See L<cpanm> or C<cpanm -h> to see what cpanminus I<can> do :)
  
  =head1 COPYRIGHT
  
  Copyright 2010- Tatsuhiko Miyagawa
  
  The standalone executable contains the following modules embedded.
  
  =over 4
  
  =item L<CPAN::DistnameInfo> Copyright 2003 Graham Barr
  
  =item L<local::lib> Copyright 2007-2009 Matt S Trout
  
  =item L<HTTP::Tiny> Copyright 2011 Christian Hansen
  
  =item L<Module::Metadata> Copyright 2001-2006 Ken Williams. 2010 Matt S Trout
  
  =item L<version> Copyright 2004-2010 John Peacock
  
  =item L<JSON::PP> Copyright 2007-2011 by Makamaka Hannyaharamitu
  
  =item L<CPAN::Meta>, L<CPAN::Meta::Requirements> Copyright (c) 2010 by David Golden and Ricardo Signes
  
  =item L<CPAN::Meta::YAML> Copyright 2010 Adam Kennedy
  
  =item L<File::pushd> Copyright 2012 David Golden
  
  =back
  
  =head1 LICENSE
  
  This software is licensed under the same terms as Perl.
  
  =head1 CREDITS
  
  =head2 CONTRIBUTORS
  
  Patches and code improvements were contributed by:
  
  Goro Fuji, Kazuhiro Osawa, Tokuhiro Matsuno, Kenichi Ishigaki, Ian
  Wells, Pedro Melo, Masayoshi Sekimura, Matt S Trout (mst), squeeky,
  horus and Ingy dot Net.
  
  =head2 ACKNOWLEDGEMENTS
  
  Bug reports, suggestions and feedbacks were sent by, or general
  acknowledgement goes to:
  
  Jesse Vincent, David Golden, Andreas Koenig, Jos Boumans, Chris
  Williams, Adam Kennedy, Audrey Tang, J. Shirley, Chris Prather, Jesse
  Luehrs, Marcus Ramberg, Shawn M Moore, chocolateboy, Chirs Nehren,
  Jonathan Rockway, Leon Brocard, Simon Elliott, Ricardo Signes, AEvar
  Arnfjord Bjarmason, Eric Wilhelm, Florian Ragwitz and xaicron.
  
  =head1 COMMUNITY
  
  =over 4
  
  =item L<http://github.com/miyagawa/cpanminus> - source code repository, issue tracker
  
  =item L<irc://irc.perl.org/#cpanm> - discussions about cpanm and its related tools
  
  =back
  
  =head1 NO WARRANTY
  
  This software is provided "as-is," without any express or implied
  warranty. In no event shall the author be held liable for any damages
  arising from the use of the software.
  
  =head1 SEE ALSO
  
  L<CPAN> L<CPANPLUS> L<pip>
  
  =cut
  
  1;
PERL5_APP_CPANMINUS

$fatpacked{"perl5/App/cpanminus/fatscript.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_APP_CPANMINUS_FATSCRIPT';
  package App::cpanminus::fatscript;
  #
  # This is a pre-compiled source code for the cpanm (cpanminus) program.
  # For more details about how to install cpanm, go to the following URL:
  #
  #   https://github.com/miyagawa/cpanminus
  #
  # Quickstart: Run the following command and it will install itself for
  # you. You might want to run it as a root with sudo if you want to install
  # to places like /usr/local/bin.
  #
  #   % curl -L https://cpanmin.us | perl - App::cpanminus
  #
  # If you don't have curl but wget, replace `curl -L` with `wget -O -`.
  
  # DO NOT EDIT -- this is an auto generated file
  
  # This chunk of stuff was generated by App::FatPacker. To find the original
  # file's code, look for the end of this BEGIN block or the string 'FATPACK'
  BEGIN {
  my %fatpacked;
  
  $fatpacked{"App/cpanminus.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPANMINUS';
    package App::cpanminus;
    our $VERSION = "1.7040";
    
    =encoding utf8
    
    =head1 NAME
    
    App::cpanminus - get, unpack, build and install modules from CPAN
    
    =head1 SYNOPSIS
    
        cpanm Module
    
    Run C<cpanm -h> or C<perldoc cpanm> for more options.
    
    =head1 DESCRIPTION
    
    cpanminus is a script to get, unpack, build and install modules from
    CPAN and does nothing else.
    
    It's dependency free (can bootstrap itself), requires zero
    configuration, and stands alone. When running, it requires only 10MB
    of RAM.
    
    =head1 INSTALLATION
    
    There are several ways to install cpanminus to your system.
    
    =head2 Package management system
    
    There are Debian packages, RPMs, FreeBSD ports, and packages for other
    operation systems available. If you want to use the package management system,
    search for cpanminus and use the appropriate command to install. This makes it
    easy to install C<cpanm> to your system without thinking about where to
    install, and later upgrade.
    
    =head2 Installing to system perl
    
    You can also use the latest cpanminus to install cpanminus itself:
    
        curl -L https://cpanmin.us | perl - --sudo App::cpanminus
    
    This will install C<cpanm> to your bin directory like
    C</usr/local/bin> and you'll need the C<--sudo> option to write to
    the directory, unless you configured C<INSTALL_BASE> with L<local::lib>.
    
    =head2 Installing to local perl (perlbrew, plenv etc.)
    
    If you have perl in your home directory, which is the case if you use
    tools like L<perlbrew> or plenv, you don't need the C<--sudo> option, since
    you're most likely to have a write permission to the perl's library
    path. You can just do:
    
        curl -L https://cpanmin.us | perl - App::cpanminus
    
    to install the C<cpanm> executable to the perl's bin path, like
    C<~/perl5/perlbrew/bin/cpanm>.
    
    =head2 Downloading the standalone executable
    
    You can also copy the standalone executable to whatever location you'd like.
    
        cd ~/bin
        curl -L https://cpanmin.us/ -o cpanm
        chmod +x cpanm
    
    This just works, but be sure to grab the new version manually when you
    upgrade because C<--self-upgrade> might not work with this installation setup.
    
    =head2 Troubleshoot: HTTPS warnings
    
    When you run C<curl> commands above, you may encounter SSL handshake
    errors or certification warnings. This is due to your HTTP client
    (curl) being old, or SSL certificates installed on your system needs
    to be updated.
    
    You're recommended to update the software or system if you can. If
    that is impossible or difficult, use the C<-k> option with curl or an
    alternative URL, C<https://git.io/cpanm>
    
    =head1 DEPENDENCIES
    
    perl 5.8.1 or later.
    
    =over 4
    
    =item *
    
    'tar' executable (bsdtar or GNU tar version 1.22 are recommended) or Archive::Tar to unpack files.
    
    =item *
    
    C compiler, if you want to build XS modules.
    
    =item *
    
    make
    
    =item *
    
    Module::Build (core in 5.10)
    
    =back
    
    =head1 QUESTIONS
    
    =head2 How does cpanm get/parse/update the CPAN index?
    
    It queries the CPAN Meta DB site at L<http://cpanmetadb.plackperl.org/>.
    The site is updated at least every hour to reflect the latest changes
    from fast syncing mirrors. The script then also falls back to query the
    module at L<http://metacpan.org/> using its search API.
    
    Upon calling these API hosts, cpanm (1.6004 or later) will send the
    local perl versions to the server in User-Agent string by default. You
    can turn it off with C<--no-report-perl-version> option. Read more
    about the option with L<cpanm>, and read more about the privacy policy
    about this data collection at L<http://cpanmetadb.plackperl.org/#privacy>
    
    Fetched files are unpacked in C<~/.cpanm> and automatically cleaned up
    periodically.  You can configure the location of this with the
    C<PERL_CPANM_HOME> environment variable.
    
    =head2 Where does this install modules to? Do I need root access?
    
    It installs to wherever ExtUtils::MakeMaker and Module::Build are
    configured to (via C<PERL_MM_OPT> and C<PERL_MB_OPT>).
    
    By default, it installs to the site_perl directory that belongs to
    your perl. You can see the locations for that by running C<perl -V>
    and it will be likely something under C</opt/local/perl/...> if you're
    using system perl, or under your home directory if you have built perl
    yourself using perlbrew or plenv.
    
    If you've already configured local::lib on your shell, cpanm respects
    that settings and modules will be installed to your local perl5
    directory.
    
    At a boot time, cpanminus checks whether you have already configured
    local::lib, or have a permission to install modules to the site_perl
    directory.  If neither, i.e. you're using system perl and do not run
    cpanm as a root, it automatically sets up local::lib compatible
    installation path in a C<perl5> directory under your home
    directory.
    
    To avoid this, run C<cpanm> either as a root user, with C<--sudo>
    option, or with C<--local-lib> option.
    
    =head2 cpanminus can't install the module XYZ. Is it a bug?
    
    It is more likely a problem with the distribution itself. cpanminus
    doesn't support or may have issues with distributions such as follows:
    
    =over 4
    
    =item *
    
    Tests that require input from STDIN.
    
    =item *
    
    Build.PL or Makefile.PL that prompts for input even when
    C<PERL_MM_USE_DEFAULT> is enabled.
    
    =item *
    
    Modules that have invalid numeric values as VERSION (such as C<1.1a>)
    
    =back
    
    These failures can be reported back to the author of the module so
    that they can fix it accordingly, rather than to cpanminus.
    
    =head2 Does cpanm support the feature XYZ of L<CPAN> and L<CPANPLUS>?
    
    Most likely not. Here are the things that cpanm doesn't do by
    itself.
    
    If you need these features, use L<CPAN>, L<CPANPLUS> or the standalone
    tools that are mentioned.
    
    =over 4
    
    =item *
    
    CPAN testers reporting. See L<App::cpanminus::reporter>
    
    =item *
    
    Building RPM packages from CPAN modules
    
    =item *
    
    Listing the outdated modules that needs upgrading. See L<App::cpanoutdated>
    
    =item *
    
    Showing the changes of the modules you're about to upgrade. See L<cpan-listchanges>
    
    =item *
    
    Patching CPAN modules with distroprefs.
    
    =back
    
    See L<cpanm> or C<cpanm -h> to see what cpanminus I<can> do :)
    
    =head1 COPYRIGHT
    
    Copyright 2010- Tatsuhiko Miyagawa
    
    The standalone executable contains the following modules embedded.
    
    =over 4
    
    =item L<CPAN::DistnameInfo> Copyright 2003 Graham Barr
    
    =item L<local::lib> Copyright 2007-2009 Matt S Trout
    
    =item L<HTTP::Tiny> Copyright 2011 Christian Hansen
    
    =item L<Module::Metadata> Copyright 2001-2006 Ken Williams. 2010 Matt S Trout
    
    =item L<version> Copyright 2004-2010 John Peacock
    
    =item L<JSON::PP> Copyright 2007-2011 by Makamaka Hannyaharamitu
    
    =item L<CPAN::Meta>, L<CPAN::Meta::Requirements> Copyright (c) 2010 by David Golden and Ricardo Signes
    
    =item L<CPAN::Meta::YAML> Copyright 2010 Adam Kennedy
    
    =item L<File::pushd> Copyright 2012 David Golden
    
    =back
    
    =head1 LICENSE
    
    This software is licensed under the same terms as Perl.
    
    =head1 CREDITS
    
    =head2 CONTRIBUTORS
    
    Patches and code improvements were contributed by:
    
    Goro Fuji, Kazuhiro Osawa, Tokuhiro Matsuno, Kenichi Ishigaki, Ian
    Wells, Pedro Melo, Masayoshi Sekimura, Matt S Trout (mst), squeeky,
    horus and Ingy dot Net.
    
    =head2 ACKNOWLEDGEMENTS
    
    Bug reports, suggestions and feedbacks were sent by, or general
    acknowledgement goes to:
    
    Jesse Vincent, David Golden, Andreas Koenig, Jos Boumans, Chris
    Williams, Adam Kennedy, Audrey Tang, J. Shirley, Chris Prather, Jesse
    Luehrs, Marcus Ramberg, Shawn M Moore, chocolateboy, Chirs Nehren,
    Jonathan Rockway, Leon Brocard, Simon Elliott, Ricardo Signes, AEvar
    Arnfjord Bjarmason, Eric Wilhelm, Florian Ragwitz and xaicron.
    
    =head1 COMMUNITY
    
    =over 4
    
    =item L<http://github.com/miyagawa/cpanminus> - source code repository, issue tracker
    
    =item L<irc://irc.perl.org/#cpanm> - discussions about cpanm and its related tools
    
    =back
    
    =head1 NO WARRANTY
    
    This software is provided "as-is," without any express or implied
    warranty. In no event shall the author be held liable for any damages
    arising from the use of the software.
    
    =head1 SEE ALSO
    
    L<CPAN> L<CPANPLUS> L<pip>
    
    =cut
    
    1;
  APP_CPANMINUS
  
  $fatpacked{"App/cpanminus/Dependency.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPANMINUS_DEPENDENCY';
    package App::cpanminus::Dependency;
    use strict;
    use CPAN::Meta::Requirements;
    
    sub from_prereqs {
        my($class, $prereqs, $phases, $types) = @_;
    
        my @deps;
        for my $type (@$types) {
            push @deps, $class->from_versions(
                $prereqs->merged_requirements($phases, [$type])->as_string_hash,
                $type,
            );
        }
    
        return @deps;
    }
    
    sub from_versions {
        my($class, $versions, $type) = @_;
    
        my @deps;
        while (my($module, $version) = each %$versions) {
            push @deps, $class->new($module, $version, $type)
        }
    
        @deps;
    }
    
    sub merge_with {
        my($self, $requirements) = @_;
    
        # save the original requirement
        $self->{original_version} = $self->version;
    
        # should it clone? not cloning means we upgrade root $requirements on our way
        eval {
            $requirements->add_string_requirement($self->module, $self->version);
        };
        if ($@ =~ /illegal requirements/) {
            # Just give a warning then replace with the root requirements
            # so that later CPAN::Meta::Check can give a valid error
            warn sprintf("Can't merge requirements for %s: '%s' and '%s'",
                        $self->module, $self->version,
                        $requirements->requirements_for_module($self->module));
        }
    
        $self->{version} = $requirements->requirements_for_module($self->module);
    }
    
    sub new {
        my($class, $module, $version, $type) = @_;
    
        bless {
            module => $module,
            version => $version,
            type => $type || 'requires',
        }, $class;
    }
    
    sub module  { $_[0]->{module} }
    sub version { $_[0]->{version} }
    sub type    { $_[0]->{type} }
    
    sub requires_version {
        my $self = shift;
    
        # original_version may be 0
        if (defined $self->{original_version}) {
            return $self->{original_version};
        }
    
        $self->version;
    }
    
    sub is_requirement {
        $_[0]->{type} eq 'requires';
    }
    
    1;
  APP_CPANMINUS_DEPENDENCY
  
  $fatpacked{"App/cpanminus/script.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPANMINUS_SCRIPT';
    package App::cpanminus::script;
    use strict;
    use Config;
    use Cwd ();
    use App::cpanminus;
    use App::cpanminus::Dependency;
    use File::Basename ();
    use File::Find ();
    use File::Path ();
    use File::Spec ();
    use File::Copy ();
    use File::Temp ();
    use Getopt::Long ();
    use Symbol ();
    use String::ShellQuote ();
    use version ();
    
    use constant WIN32 => $^O eq 'MSWin32';
    use constant BAD_TAR => ($^O eq 'solaris' || $^O eq 'hpux');
    use constant CAN_SYMLINK => eval { symlink("", ""); 1 };
    
    our $VERSION = $App::cpanminus::VERSION;
    
    if ($INC{"App/FatPacker/Trace.pm"}) {
        require version::vpp;
    }
    
    my $quote = WIN32 ? q/"/ : q/'/;
    
    sub agent {
        my $self = shift;
        my $agent = "cpanminus/$VERSION";
        $agent .= " perl/$]" if $self->{report_perl_version};
        $agent;
    }
    
    sub determine_home {
        my $class = shift;
    
        my $homedir = $ENV{HOME}
          || eval { require File::HomeDir; File::HomeDir->my_home }
          || join('', @ENV{qw(HOMEDRIVE HOMEPATH)}); # Win32
    
        if (WIN32) {
            require Win32; # no fatpack
            $homedir = Win32::GetShortPathName($homedir);
        }
    
        return "$homedir/.cpanm";
    }
    
    sub new {
        my $class = shift;
    
        bless {
            home => $class->determine_home,
            cmd  => 'install',
            seen => {},
            notest => undef,
            test_only => undef,
            installdeps => undef,
            force => undef,
            sudo => undef,
            make  => undef,
            verbose => undef,
            quiet => undef,
            interactive => undef,
            log => undef,
            mirrors => [],
            mirror_only => undef,
            mirror_index => undef,
            cpanmetadb => "http://cpanmetadb.plackperl.org/v1.0/",
            perl => $^X,
            argv => [],
            local_lib => undef,
            self_contained => undef,
            exclude_vendor => undef,
            prompt_timeout => 0,
            prompt => undef,
            configure_timeout => 60,
            build_timeout => 3600,
            test_timeout => 1800,
            try_lwp => 1,
            try_wget => 1,
            try_curl => 1,
            uninstall_shadows => ($] < 5.012),
            skip_installed => 1,
            skip_satisfied => 0,
            auto_cleanup => 7, # days
            pod2man => 1,
            installed_dists => 0,
            install_types => ['requires'],
            with_develop => 0,
            showdeps => 0,
            scandeps => 0,
            scandeps_tree => [],
            format   => 'tree',
            save_dists => undef,
            skip_configure => 0,
            verify => 0,
            report_perl_version => !$class->maybe_ci,
            build_args => {},
            features => {},
            pure_perl => 0,
            cpanfile_path => 'cpanfile',
            @_,
        }, $class;
    }
    
    sub env {
        my($self, $key) = @_;
        $ENV{"PERL_CPANM_" . $key};
    }
    
    sub maybe_ci {
        my $class = shift;
        grep $ENV{$_}, qw( TRAVIS CI AUTOMATED_TESTING AUTHOR_TESTING );
    }
    
    sub install_type_handlers {
        my $self = shift;
    
        my @handlers;
        for my $type (qw( recommends suggests )) {
            push @handlers, "with-$type" => sub {
                my %uniq;
                $self->{install_types} = [ grep !$uniq{$_}++, @{$self->{install_types}}, $type ];
            };
            push @handlers, "without-$type" => sub {
                $self->{install_types} = [ grep $_ ne $type, @{$self->{install_types}} ];
            };
        }
    
        @handlers;
    }
    
    sub build_args_handlers {
        my $self = shift;
    
        my @handlers;
        for my $phase (qw( configure build test install )) {
            push @handlers, "$phase-args=s" => \($self->{build_args}{$phase});
        }
    
        @handlers;
    }
    
    sub parse_options {
        my $self = shift;
    
        local @ARGV = @{$self->{argv}};
        push @ARGV, grep length, split /\s+/, $self->env('OPT');
        push @ARGV, @_;
    
        Getopt::Long::Configure("bundling");
        Getopt::Long::GetOptions(
            'f|force'   => sub { $self->{skip_installed} = 0; $self->{force} = 1 },
            'n|notest!' => \$self->{notest},
            'test-only' => sub { $self->{notest} = 0; $self->{skip_installed} = 0; $self->{test_only} = 1 },
            'S|sudo!'   => \$self->{sudo},
            'v|verbose' => \$self->{verbose},
            'verify!'   => \$self->{verify},
            'q|quiet!'  => \$self->{quiet},
            'h|help'    => sub { $self->{action} = 'show_help' },
            'V|version' => sub { $self->{action} = 'show_version' },
            'perl=s'    => sub {
                $self->diag("--perl is deprecated since it's known to be fragile in figuring out dependencies. Run `$_[1] -S cpanm` instead.\n", 1);
                $self->{perl} = $_[1];
            },
            'l|local-lib=s' => sub { $self->{local_lib} = $self->maybe_abs($_[1]) },
            'L|local-lib-contained=s' => sub {
                $self->{local_lib} = $self->maybe_abs($_[1]);
                $self->{self_contained} = 1;
                $self->{pod2man} = undef;
            },
            'self-contained!' => \$self->{self_contained},
            'exclude-vendor!' => \$self->{exclude_vendor},
            'mirror=s@' => $self->{mirrors},
            'mirror-only!' => \$self->{mirror_only},
            'mirror-index=s' => sub { $self->{mirror_index} = $self->maybe_abs($_[1]) },
            'M|from=s' => sub {
                $self->{mirrors}     = [$_[1]];
                $self->{mirror_only} = 1;
            },
            'cpanmetadb=s'    => \$self->{cpanmetadb},
            'cascade-search!' => \$self->{cascade_search},
            'prompt!'   => \$self->{prompt},
            'installdeps' => \$self->{installdeps},
            'skip-installed!' => \$self->{skip_installed},
            'skip-satisfied!' => \$self->{skip_satisfied},
            'reinstall'    => sub { $self->{skip_installed} = 0 },
            'interactive!' => \$self->{interactive},
            'i|install'    => sub { $self->{cmd} = 'install' },
            'info'         => sub { $self->{cmd} = 'info' },
            'look'         => sub { $self->{cmd} = 'look'; $self->{skip_installed} = 0 },
            'U|uninstall'  => sub { $self->{cmd} = 'uninstall' },
            'self-upgrade' => sub { $self->{action} = 'self_upgrade' },
            'uninst-shadows!'  => \$self->{uninstall_shadows},
            'lwp!'    => \$self->{try_lwp},
            'wget!'   => \$self->{try_wget},
            'curl!'   => \$self->{try_curl},
            'auto-cleanup=s' => \$self->{auto_cleanup},
            'man-pages!' => \$self->{pod2man},
            'scandeps'   => \$self->{scandeps},
            'showdeps'   => sub { $self->{showdeps} = 1; $self->{skip_installed} = 0 },
            'format=s'   => \$self->{format},
            'save-dists=s' => sub {
                $self->{save_dists} = $self->maybe_abs($_[1]);
            },
            'skip-configure!' => \$self->{skip_configure},
            'dev!'       => \$self->{dev_release},
            'metacpan!'  => \$self->{metacpan},
            'report-perl-version!' => \$self->{report_perl_version},
            'configure-timeout=i' => \$self->{configure_timeout},
            'build-timeout=i' => \$self->{build_timeout},
            'test-timeout=i' => \$self->{test_timeout},
            'with-develop' => \$self->{with_develop},
            'without-develop' => sub { $self->{with_develop} = 0 },
            'with-feature=s' => sub { $self->{features}{$_[1]} = 1 },
            'without-feature=s' => sub { $self->{features}{$_[1]} = 0 },
            'with-all-features' => sub { $self->{features}{__all} = 1 },
            'pp|pureperl!' => \$self->{pure_perl},
            "cpanfile=s" => \$self->{cpanfile_path},
            $self->install_type_handlers,
            $self->build_args_handlers,
        );
    
        if (!@ARGV && $0 ne '-' && !-t STDIN){ # e.g. # cpanm < author/requires.cpanm
            push @ARGV, $self->load_argv_from_fh(\*STDIN);
            $self->{load_from_stdin} = 1;
        }
    
        $self->{argv} = \@ARGV;
    }
    
    sub check_upgrade {
        my $self = shift;
        my $install_base = $ENV{PERL_LOCAL_LIB_ROOT} ? $self->local_lib_target($ENV{PERL_LOCAL_LIB_ROOT}) : $Config{installsitebin};
        if ($0 eq '-') {
            # run from curl, that's fine
            return;
        } elsif ($0 !~ /^$install_base/) {
            if ($0 =~ m!perlbrew/bin!) {
                die <<DIE;
    It appears your cpanm executable was installed via `perlbrew install-cpanm`.
    cpanm --self-upgrade won't upgrade the version of cpanm you're running.
    
    Run the following command to get it upgraded.
    
      perlbrew install-cpanm
    
    DIE
            } else {
                die <<DIE;
    You are running cpanm from the path where your current perl won't install executables to.
    Because of that, cpanm --self-upgrade won't upgrade the version of cpanm you're running.
    
      cpanm path   : $0
      Install path : $Config{installsitebin}
    
    It means you either installed cpanm globally with system perl, or use distro packages such
    as rpm or apt-get, and you have to use them again to upgrade cpanm.
    DIE
            }
        }
    }
    
    sub check_libs {
        my $self = shift;
        return if $self->{_checked}++;
        $self->bootstrap_local_lib;
    }
    
    sub setup_verify {
        my $self = shift;
    
        my $has_modules = eval { require Module::Signature; require Digest::SHA; 1 };
        $self->{cpansign} = $self->which('cpansign');
    
        unless ($has_modules && $self->{cpansign}) {
            warn "WARNING: Module::Signature and Digest::SHA is required for distribution verifications.\n";
            $self->{verify} = 0;
        }
    }
    
    sub parse_module_args {
        my($self, $module) = @_;
    
        # Plack@1.2 -> Plack~"==1.2"
        # BUT don't expand @ in git URLs
        $module =~ s/^([A-Za-z0-9_:]+)@([v\d\._]+)$/$1~== $2/;
    
        # Plack~1.20, DBI~"> 1.0, <= 2.0"
        if ($module =~ /\~[v\d\._,\!<>= ]+$/) {
            return split /\~/, $module, 2;
        } else {
            return $module, undef;
        }
    }
    
    sub doit {
        my $self = shift;
    
        my $code;
        eval {
            $code = ($self->_doit == 0);
        }; if (my $e = $@) {
            warn $e;
            $code = 1;
        }
    
        return $code;
    }
    
    sub _doit {
        my $self = shift;
    
        $self->setup_home;
        $self->init_tools;
        $self->setup_verify if $self->{verify};
    
        if (my $action = $self->{action}) {
            $self->$action() and return 1;
        }
    
        return $self->show_help(1)
            unless @{$self->{argv}} or $self->{load_from_stdin};
    
        $self->configure_mirrors;
    
        my $cwd = Cwd::cwd;
    
        my @fail;
        for my $module (@{$self->{argv}}) {
            if ($module =~ s/\.pm$//i) {
                my ($volume, $dirs, $file) = File::Spec->splitpath($module);
                $module = join '::', grep { $_ } File::Spec->splitdir($dirs), $file;
            }
            ($module, my $version) = $self->parse_module_args($module);
    
            $self->chdir($cwd);
            if ($self->{cmd} eq 'uninstall') {
                $self->uninstall_module($module)
                  or push @fail, $module;
            } else {
                $self->install_module($module, 0, $version)
                    or push @fail, $module;
            }
        }
    
        if ($self->{base} && $self->{auto_cleanup}) {
            $self->cleanup_workdirs;
        }
    
        if ($self->{installed_dists}) {
            my $dists = $self->{installed_dists} > 1 ? "distributions" : "distribution";
            $self->diag("$self->{installed_dists} $dists installed\n", 1);
        }
    
        if ($self->{scandeps}) {
            $self->dump_scandeps();
        }
        # Workaround for older File::Temp's
        # where creating a tempdir with an implicit $PWD
        # causes tempdir non-cleanup if $PWD changes
        # as paths are stored internally without being resolved
        # absolutely.
        # https://rt.cpan.org/Public/Bug/Display.html?id=44924
        $self->chdir($cwd);
    
        return !@fail;
    }
    
    sub setup_home {
        my $self = shift;
    
        $self->{home} = $self->env('HOME') if $self->env('HOME');
    
        unless (_writable($self->{home})) {
            die "Can't write to cpanm home '$self->{home}': You should fix it with chown/chmod first.\n";
        }
    
        $self->{base} = "$self->{home}/work/" . time . ".$$";
        File::Path::mkpath([ $self->{base} ], 0, 0777);
    
        # native path because we use shell redirect
        $self->{log} = File::Spec->catfile($self->{base}, "build.log");
        my $final_log = "$self->{home}/build.log";
    
        { open my $out, ">$self->{log}" or die "$self->{log}: $!" }
    
        if (CAN_SYMLINK) {
            my $build_link = "$self->{home}/latest-build";
            unlink $build_link;
            symlink $self->{base}, $build_link;
    
            unlink $final_log;
            symlink $self->{log}, $final_log;
        } else {
            my $log = $self->{log}; my $home = $self->{home};
            $self->{at_exit} = sub {
                my $self = shift;
                my $temp_log = "$home/build.log." . time . ".$$";
                File::Copy::copy($log, $temp_log)
                    && unlink($final_log);
                rename($temp_log, $final_log);
            }
        }
    
        $self->chat("cpanm (App::cpanminus) $VERSION on perl $] built for $Config{archname}\n" .
                    "Work directory is $self->{base}\n");
    }
    
    sub package_index_for {
        my ($self, $mirror) = @_;
        return $self->source_for($mirror) . "/02packages.details.txt";
    }
    
    sub generate_mirror_index {
        my ($self, $mirror) = @_;
        my $file = $self->package_index_for($mirror);
        my $gz_file = $file . '.gz';
        my $index_mtime = (stat $gz_file)[9];
    
        unless (-e $file && (stat $file)[9] >= $index_mtime) {
            $self->chat("Uncompressing index file...\n");
            if (eval {require Compress::Zlib}) {
                my $gz = Compress::Zlib::gzopen($gz_file, "rb")
                    or do { $self->diag_fail("$Compress::Zlib::gzerrno opening compressed index"); return};
                open my $fh, '>', $file
                    or do { $self->diag_fail("$! opening uncompressed index for write"); return };
                my $buffer;
                while (my $status = $gz->gzread($buffer)) {
                    if ($status < 0) {
                        $self->diag_fail($gz->gzerror . " reading compressed index");
                        return;
                    }
                    print $fh $buffer;
                }
            } else {
                if (system("gunzip -c $gz_file > $file")) {
                    $self->diag_fail("Cannot uncompress -- please install gunzip or Compress::Zlib");
                    return;
                }
            }
            utime $index_mtime, $index_mtime, $file;
        }
        return 1;
    }
    
    sub search_mirror_index {
        my ($self, $mirror, $module, $version) = @_;
        $self->search_mirror_index_file($self->package_index_for($mirror), $module, $version);
    }
    
    sub search_mirror_index_file {
        my($self, $file, $module, $version) = @_;
    
        open my $fh, '<', $file or return;
        my $found;
        while (<$fh>) {
            if (m!^\Q$module\E\s+([\w\.]+)\s+(\S*)!m) {
                $found = $self->cpan_module($module, $2, $1);
                last;
            }
        }
    
        return $found unless $self->{cascade_search};
    
        if ($found) {
            if ($self->satisfy_version($module, $found->{module_version}, $version)) {
                return $found;
            } else {
                $self->chat("Found $module $found->{module_version} which doesn't satisfy $version.\n");
            }
        }
    
        return;
    }
    
    sub with_version_range {
        my($self, $version) = @_;
        defined($version) && $version =~ /(?:<|!=|==)/;
    }
    
    sub encode_json {
        my($self, $data) = @_;
        require JSON::PP;
    
        my $json = JSON::PP::encode_json($data);
        $json =~ s/([^a-zA-Z0-9_\-.])/uc sprintf("%%%02x",ord($1))/eg;
        $json;
    }
    
    # TODO extract this as a module?
    sub version_to_query {
        my($self, $module, $version) = @_;
    
        require CPAN::Meta::Requirements;
    
        my $requirements = CPAN::Meta::Requirements->new;
        $requirements->add_string_requirement($module, $version || '0');
    
        my $req = $requirements->requirements_for_module($module);
    
        if ($req =~ s/^==\s*//) {
            return {
                term => { 'module.version' => $req },
            };
        } elsif ($req !~ /\s/) {
            return {
                range => { 'module.version_numified' => { 'gte' => $self->numify_ver_metacpan($req) } },
            };
        } else {
            my %ops = qw(< lt <= lte > gt >= gte);
            my(%range, @exclusion);
            my @requirements = split /,\s*/, $req;
            for my $r (@requirements) {
                if ($r =~ s/^([<>]=?)\s*//) {
                    $range{$ops{$1}} = $self->numify_ver_metacpan($r);
                } elsif ($r =~ s/\!=\s*//) {
                    push @exclusion, $self->numify_ver_metacpan($r);
                }
            }
    
            my @filters= (
                { range => { 'module.version_numified' => \%range } },
            );
    
            if (@exclusion) {
                push @filters, {
                    not => { or => [ map { +{ term => { 'module.version_numified' => $self->numify_ver_metacpan($_) } } } @exclusion ] },
                };
            }
    
            return @filters;
        }
    }
    
    # Apparently MetaCPAN numifies devel releases by stripping _ first
    sub numify_ver_metacpan {
        my($self, $ver) = @_;
        $ver =~ s/_//g;
        version->new($ver)->numify;
    }
    
    # version->new("1.00_00")->numify => "1.00_00" :/
    sub numify_ver {
        my($self, $ver) = @_;
        eval version->new($ver)->numify;
    }
    
    sub maturity_filter {
        my($self, $module, $version) = @_;
    
        if ($version =~ /==/) {
            # specific version: allow dev release
            return;
        } elsif ($self->{dev_release}) {
            # backpan'ed dev releases are considered cancelled
            return +{ not => { term => { status => 'backpan' } } };
        } else {
            return (
                { not => { term => { status => 'backpan' } } },
                { term => { maturity => 'released' } },
            );
        }
    }
    
    sub by_version {
        my %s = qw( latest 3  cpan 2  backpan 1 );
        $b->{_score} <=> $a->{_score} ||                             # version: higher version that satisfies the query
        $s{ $b->{fields}{status} } <=> $s{ $a->{fields}{status} };   # prefer non-BackPAN dist
    }
    
    sub by_first_come {
        $a->{fields}{date} cmp $b->{fields}{date};                   # first one wins, if all are in BackPAN/CPAN
    }
    
    sub by_date {
        $b->{fields}{date} cmp $a->{fields}{date};                   # prefer new uploads, when searching for dev
    }
    
    sub find_best_match {
        my($self, $match, $version) = @_;
        return unless $match && @{$match->{hits}{hits} || []};
        my @hits = $self->{dev_release}
            ? sort { by_version || by_date } @{$match->{hits}{hits}}
            : sort { by_version || by_first_come } @{$match->{hits}{hits}};
        $hits[0]->{fields};
    }
    
    sub search_metacpan {
        my($self, $module, $version) = @_;
    
        require JSON::PP;
    
        $self->chat("Searching $module ($version) on metacpan ...\n");
    
        my $metacpan_uri = 'http://api.metacpan.org/v0';
    
        my @filter = $self->maturity_filter($module, $version);
    
        my $query = { filtered => {
            (@filter ? (filter => { and => \@filter }) : ()),
            query => { nested => {
                score_mode => 'max',
                path => 'module',
                query => { custom_score => {
                    metacpan_script => "score_version_numified",
                    query => { constant_score => {
                        filter => { and => [
                            { term => { 'module.authorized' => JSON::PP::true() } },
                            { term => { 'module.indexed' => JSON::PP::true() } },
                            { term => { 'module.name' => $module } },
                            $self->version_to_query($module, $version),
                        ] }
                    } },
                } },
            } },
        } };
    
        my $module_uri = "$metacpan_uri/file/_search?source=";
        $module_uri .= $self->encode_json({
            query => $query,
            fields => [ 'date', 'release', 'author', 'module', 'status' ],
        });
    
        my($release, $author, $module_version);
    
        my $module_json = $self->get($module_uri);
        my $module_meta = eval { JSON::PP::decode_json($module_json) };
        my $match = $self->find_best_match($module_meta);
        if ($match) {
            $release = $match->{release};
            $author = $match->{author};
            my $module_matched = (grep { $_->{name} eq $module } @{$match->{module}})[0];
            $module_version = $module_matched->{version};
        }
    
        unless ($release) {
            $self->chat("! Could not find a release matching $module ($version) on MetaCPAN.\n");
            return;
        }
    
        my $dist_uri = "$metacpan_uri/release/_search?source=";
        $dist_uri .= $self->encode_json({
            filter => { and => [
                { term => { 'release.name' => $release } },
                { term => { 'release.author' => $author } },
            ]},
            fields => [ 'download_url', 'stat', 'status' ],
        });
    
        my $dist_json = $self->get($dist_uri);
        my $dist_meta = eval { JSON::PP::decode_json($dist_json) };
    
        if ($dist_meta) {
            $dist_meta = $dist_meta->{hits}{hits}[0]{fields};
        }
        if ($dist_meta && $dist_meta->{download_url}) {
            (my $distfile = $dist_meta->{download_url}) =~ s!.+/authors/id/!!;
            local $self->{mirrors} = $self->{mirrors};
            if ($dist_meta->{status} eq 'backpan') {
                $self->{mirrors} = [ 'http://backpan.perl.org' ];
            } elsif ($dist_meta->{stat}{mtime} > time()-24*60*60) {
                $self->{mirrors} = [ 'http://cpan.metacpan.org' ];
            }
            return $self->cpan_module($module, $distfile, $module_version);
        }
    
        $self->diag_fail("Finding $module on metacpan failed.");
        return;
    }
    
    sub search_database {
        my($self, $module, $version) = @_;
    
        my $found;
    
        if ($self->{dev_release} or $self->{metacpan}) {
            $found = $self->search_metacpan($module, $version)   and return $found;
            $found = $self->search_cpanmetadb($module, $version) and return $found;
        } else {
            $found = $self->search_cpanmetadb($module, $version) and return $found;
            $found = $self->search_metacpan($module, $version)   and return $found;
        }
    }
    
    sub search_cpanmetadb {
        my($self, $module, $version) = @_;
    
    
        $self->chat("Searching $module ($version) on cpanmetadb ...\n");
    
        if ($self->with_version_range($version)) {
            return $self->search_cpanmetadb_history($module, $version);
        } else {
            return $self->search_cpanmetadb_package($module, $version);
        }
    }
    
    sub search_cpanmetadb_package {
        my($self, $module, $version) = @_;
    
        require CPAN::Meta::YAML;
    
        (my $uri = $self->{cpanmetadb}) =~ s{/?$}{/package/$module};
        my $yaml = $self->get($uri);
        my $meta = eval { CPAN::Meta::YAML::Load($yaml) };
        if ($meta && $meta->{distfile}) {
            return $self->cpan_module($module, $meta->{distfile}, $meta->{version});
        }
    
        $self->diag_fail("Finding $module on cpanmetadb failed.");
        return;
    }
    
    sub search_cpanmetadb_history {
        my($self, $module, $version) = @_;
    
        (my $uri = $self->{cpanmetadb}) =~ s{/?$}{/history/$module};
        my $content = $self->get($uri) or return;
    
        my @found;
        for my $line (split /\r?\n/, $content) {
            if ($line =~ /^$module\s+(\S+)\s+(\S+)$/) {
                push @found, {
                    version => $1,
                    version_obj => version::->parse($1),
                    distfile => $2,
                };
            }
        }
    
        return unless @found;
    
        $found[-1]->{latest} = 1;
    
        my $match;
        for my $try (sort { $b->{version_obj} cmp $a->{version_obj} } @found) {
            if ($self->satisfy_version($module, $try->{version_obj}, $version)) {
                local $self->{mirrors} = $self->{mirrors};
                unshift @{$self->{mirrors}}, 'http://backpan.perl.org'
                  unless $try->{latest};
                return $self->cpan_module($module, $try->{distfile}, $try->{version});
            }
        }
    
        $self->diag_fail("Finding $module ($version) on cpanmetadb failed.");
        return;
    }
    
    
    sub search_module {
        my($self, $module, $version) = @_;
    
        if ($self->{mirror_index}) {
            $self->mask_output( chat => "Searching $module on mirror index $self->{mirror_index} ...\n" );
            my $pkg = $self->search_mirror_index_file($self->{mirror_index}, $module, $version);
            return $pkg if $pkg;
    
            unless ($self->{cascade_search}) {
               $self->mask_output( diag_fail => "Finding $module ($version) on mirror index $self->{mirror_index} failed." );
               return;
            }
        }
    
        unless ($self->{mirror_only}) {
            my $found = $self->search_database($module, $version);
            return $found if $found;
        }
    
        MIRROR: for my $mirror (@{ $self->{mirrors} }) {
            $self->mask_output( chat => "Searching $module on mirror $mirror ...\n" );
            my $name = '02packages.details.txt.gz';
            my $uri  = "$mirror/modules/$name";
            my $gz_file = $self->package_index_for($mirror) . '.gz';
    
            unless ($self->{pkgs}{$uri}) {
                $self->mask_output( chat => "Downloading index file $uri ...\n" );
                $self->mirror($uri, $gz_file);
                $self->generate_mirror_index($mirror) or next MIRROR;
                $self->{pkgs}{$uri} = "!!retrieved!!";
            }
    
            my $pkg = $self->search_mirror_index($mirror, $module, $version);
            return $pkg if $pkg;
    
            $self->mask_output( diag_fail => "Finding $module ($version) on mirror $mirror failed." );
        }
    
        return;
    }
    
    sub source_for {
        my($self, $mirror) = @_;
        $mirror =~ s/[^\w\.\-]+/%/g;
    
        my $dir = "$self->{home}/sources/$mirror";
        File::Path::mkpath([ $dir ], 0, 0777);
    
        return $dir;
    }
    
    sub load_argv_from_fh {
        my($self, $fh) = @_;
    
        my @argv;
        while(defined(my $line = <$fh>)){
            chomp $line;
            $line =~ s/#.+$//; # comment
            $line =~ s/^\s+//; # trim spaces
            $line =~ s/\s+$//; # trim spaces
    
            push @argv, split ' ', $line if $line;
        }
        return @argv;
    }
    
    sub show_version {
        my $self = shift;
    
        print "cpanm (App::cpanminus) version $VERSION ($0)\n";
        print "perl version $] ($^X)\n\n";
    
        print "  \%Config:\n";
        for my $key (qw( archname installsitelib installsitebin installman1dir installman3dir
                         sitearchexp sitelibexp vendorarch vendorlibexp archlibexp privlibexp )) {
            print "    $key=$Config{$key}\n" if $Config{$key};
        }
    
        print "  \%ENV:\n";
        for my $key (grep /^PERL/, sort keys %ENV) {
            print "    $key=$ENV{$key}\n";
        }
    
        print "  \@INC:\n";
        for my $inc (@INC) {
            print "    $inc\n" unless ref($inc) eq 'CODE';
        }
    
        return 1;
    }
    
    sub show_help {
        my $self = shift;
    
        if ($_[0]) {
            print <<USAGE;
    Usage: cpanm [options] Module [...]
    
    Try `cpanm --help` or `man cpanm` for more options.
    USAGE
            return;
        }
    
        print <<HELP;
    Usage: cpanm [options] Module [...]
    
    Options:
      -v,--verbose              Turns on chatty output
      -q,--quiet                Turns off the most output
      --interactive             Turns on interactive configure (required for Task:: modules)
      -f,--force                force install
      -n,--notest               Do not run unit tests
      --test-only               Run tests only, do not install
      -S,--sudo                 sudo to run install commands
      --installdeps             Only install dependencies
      --showdeps                Only display direct dependencies
      --reinstall               Reinstall the distribution even if you already have the latest version installed
      --mirror                  Specify the base URL for the mirror (e.g. http://cpan.cpantesters.org/)
      --mirror-only             Use the mirror's index file instead of the CPAN Meta DB
      -M,--from                 Use only this mirror base URL and its index file
      --prompt                  Prompt when configure/build/test fails
      -l,--local-lib            Specify the install base to install modules
      -L,--local-lib-contained  Specify the install base to install all non-core modules
      --self-contained          Install all non-core modules, even if they're already installed.
      --auto-cleanup            Number of days that cpanm's work directories expire in. Defaults to 7
    
    Commands:
      --self-upgrade            upgrades itself
      --info                    Displays distribution info on CPAN
      --look                    Opens the distribution with your SHELL
      -U,--uninstall            Uninstalls the modules (EXPERIMENTAL)
      -V,--version              Displays software version
    
    Examples:
    
      cpanm Test::More                                          # install Test::More
      cpanm MIYAGAWA/Plack-0.99_05.tar.gz                       # full distribution path
      cpanm http://example.org/LDS/CGI.pm-3.20.tar.gz           # install from URL
      cpanm ~/dists/MyCompany-Enterprise-1.00.tar.gz            # install from a local file
      cpanm --interactive Task::Kensho                          # Configure interactively
      cpanm .                                                   # install from local directory
      cpanm --installdeps .                                     # install all the deps for the current directory
      cpanm -L extlib Plack                                     # install Plack and all non-core deps into extlib
      cpanm --mirror http://cpan.cpantesters.org/ DBI           # use the fast-syncing mirror
      cpanm -M https://cpan.metacpan.org App::perlbrew          # use only this secure mirror and its index
    
    You can also specify the default options in PERL_CPANM_OPT environment variable in the shell rc:
    
      export PERL_CPANM_OPT="--prompt --reinstall -l ~/perl --mirror http://cpan.cpantesters.org"
    
    Type `man cpanm` or `perldoc cpanm` for the more detailed explanation of the options.
    
    HELP
    
        return 1;
    }
    
    sub _writable {
        my $dir = shift;
        my @dir = File::Spec->splitdir($dir);
        while (@dir) {
            $dir = File::Spec->catdir(@dir);
            if (-e $dir) {
                return -w _;
            }
            pop @dir;
        }
    
        return;
    }
    
    sub maybe_abs {
        my($self, $lib) = @_;
        if ($lib eq '_' or $lib =~ /^~/ or File::Spec->file_name_is_absolute($lib)) {
            return $lib;
        } else {
            return File::Spec->canonpath(File::Spec->catdir(Cwd::cwd(), $lib));
        }
    }
    
    sub local_lib_target {
        my($self, $root) = @_;
        # local::lib 1.008025 changed the order of PERL_LOCAL_LIB_ROOT
        (grep { $_ ne '' } split /\Q$Config{path_sep}/, $root)[0];
    }
    
    sub bootstrap_local_lib {
        my $self = shift;
    
        # If -l is specified, use that.
        if ($self->{local_lib}) {
            return $self->setup_local_lib($self->{local_lib});
        }
    
        # PERL_LOCAL_LIB_ROOT is defined. Run as local::lib mode without overwriting ENV
        if ($ENV{PERL_LOCAL_LIB_ROOT} && $ENV{PERL_MM_OPT}) {
            return $self->setup_local_lib($self->local_lib_target($ENV{PERL_LOCAL_LIB_ROOT}), 1);
        }
    
        # root, locally-installed perl or --sudo: don't care about install_base
        return if $self->{sudo} or (_writable($Config{installsitelib}) and _writable($Config{installsitebin}));
    
        # local::lib is configured in the shell -- yay
        if ($ENV{PERL_MM_OPT} and ($ENV{MODULEBUILDRC} or $ENV{PERL_MB_OPT})) {
            return;
        }
    
        $self->setup_local_lib;
    
        $self->diag(<<DIAG, 1);
    !
    ! Can't write to $Config{installsitelib} and $Config{installsitebin}: Installing modules to $ENV{HOME}/perl5
    ! To turn off this warning, you have to do one of the following:
    !   - run me as a root or with --sudo option (to install to $Config{installsitelib} and $Config{installsitebin})
    !   - Configure local::lib in your existing shell to set PERL_MM_OPT etc.
    !   - Install local::lib by running the following commands
    !
    !         cpanm --local-lib=~/perl5 local::lib && eval \$(perl -I ~/perl5/lib/perl5/ -Mlocal::lib)
    !
    DIAG
        sleep 2;
    }
    
    sub upgrade_toolchain {
        my($self, $config_deps) = @_;
    
        my %deps = map { $_->module => $_ } @$config_deps;
    
        # M::B 0.38 and EUMM 6.58 for MYMETA
        # EU::Install 1.46 for local::lib
        my $reqs = CPAN::Meta::Requirements->from_string_hash({
            'Module::Build' => '0.38',
            'ExtUtils::MakeMaker' => '6.58',
            'ExtUtils::Install' => '1.46',
        });
    
        if ($deps{"ExtUtils::MakeMaker"}) {
            $deps{"ExtUtils::MakeMaker"}->merge_with($reqs);
        } elsif ($deps{"Module::Build"}) {
            $deps{"Module::Build"}->merge_with($reqs);
            $deps{"ExtUtils::Install"} ||= App::cpanminus::Dependency->new("ExtUtils::Install", 0, 'configure');
            $deps{"ExtUtils::Install"}->merge_with($reqs);
        }
    
        @$config_deps = values %deps;
    }
    
    sub _core_only_inc {
        my($self, $base) = @_;
        require local::lib;
        (
            local::lib->resolve_path(local::lib->install_base_arch_path($base)),
            local::lib->resolve_path(local::lib->install_base_perl_path($base)),
            (!$self->{exclude_vendor} ? grep {$_} @Config{qw(vendorarch vendorlibexp)} : ()),
            @Config{qw(archlibexp privlibexp)},
        );
    }
    
    sub _diff {
        my($self, $old, $new) = @_;
    
        my @diff;
        my %old = map { $_ => 1 } @$old;
        for my $n (@$new) {
            push @diff, $n unless exists $old{$n};
        }
    
        @diff;
    }
    
    sub _setup_local_lib_env {
        my($self, $base) = @_;
    
        $self->diag(<<WARN, 1) if $base =~ /\s/;
    WARNING: Your lib directory name ($base) contains a space in it. It's known to cause issues with perl builder tools such as local::lib and MakeMaker. You're recommended to rename your directory.
    WARN
    
        local $SIG{__WARN__} = sub { }; # catch 'Attempting to write ...'
        local::lib->setup_env_hash_for($base, 0);
    }
    
    sub setup_local_lib {
        my($self, $base, $no_env) = @_;
        $base = undef if $base eq '_';
    
        require local::lib;
        {
            local $0 = 'cpanm'; # so curl/wget | perl works
            $base ||= "~/perl5";
            $base = local::lib->resolve_path($base);
            if ($self->{self_contained}) {
                my @inc = $self->_core_only_inc($base);
                $self->{search_inc} = [ @inc ];
            } else {
                $self->{search_inc} = [
                    local::lib->install_base_arch_path($base),
                    local::lib->install_base_perl_path($base),
                    @INC,
                ];
            }
            $self->_setup_local_lib_env($base) unless $no_env;
            $self->{local_lib} = $base;
        }
    }
    
    sub prompt_bool {
        my($self, $mess, $def) = @_;
    
        my $val = $self->prompt($mess, $def);
        return lc $val eq 'y';
    }
    
    sub prompt {
        my($self, $mess, $def) = @_;
    
        my $isa_tty = -t STDIN && (-t STDOUT || !(-f STDOUT || -c STDOUT)) ;
        my $dispdef = defined $def ? "[$def] " : " ";
        $def = defined $def ? $def : "";
    
        if (!$self->{prompt} || (!$isa_tty && eof STDIN)) {
            return $def;
        }
    
        local $|=1;
        local $\;
        my $ans;
        eval {
            local $SIG{ALRM} = sub { undef $ans; die "alarm\n" };
            print STDOUT "$mess $dispdef";
            alarm $self->{prompt_timeout} if $self->{prompt_timeout};
            $ans = <STDIN>;
            alarm 0;
        };
        if ( defined $ans ) {
            chomp $ans;
        } else { # user hit ctrl-D or alarm timeout
            print STDOUT "\n";
        }
    
        return (!defined $ans || $ans eq '') ? $def : $ans;
    }
    
    sub diag_ok {
        my($self, $msg) = @_;
        chomp $msg;
        $msg ||= "OK";
        if ($self->{in_progress}) {
            $self->_diag("$msg\n");
            $self->{in_progress} = 0;
        }
        $self->log("-> $msg\n");
    }
    
    sub diag_fail {
        my($self, $msg, $always) = @_;
        chomp $msg;
        if ($self->{in_progress}) {
            $self->_diag("FAIL\n");
            $self->{in_progress} = 0;
        }
    
        if ($msg) {
            $self->_diag("! $msg\n", $always, 1);
            $self->log("-> FAIL $msg\n");
        }
    }
    
    sub diag_progress {
        my($self, $msg) = @_;
        chomp $msg;
        $self->{in_progress} = 1;
        $self->_diag("$msg ... ");
        $self->log("$msg\n");
    }
    
    sub _diag {
        my($self, $msg, $always, $error) = @_;
        my $fh = $error ? *STDERR : *STDOUT;
        print {$fh} $msg if $always or $self->{verbose} or !$self->{quiet};
    }
    
    sub diag {
        my($self, $msg, $always) = @_;
        $self->_diag($msg, $always);
        $self->log($msg);
    }
    
    sub chat {
        my $self = shift;
        print STDERR @_ if $self->{verbose};
        $self->log(@_);
    }
    
    sub mask_output {
        my $self = shift;
        my $method = shift;
        $self->$method( $self->mask_uri_passwords(@_) );
    }
    
    sub log {
        my $self = shift;
        open my $out, ">>$self->{log}";
        print $out @_;
    }
    
    sub run {
        my($self, $cmd) = @_;
    
        if (WIN32) {
            $cmd = $self->shell_quote(@$cmd) if ref $cmd eq 'ARRAY';
            unless ($self->{verbose}) {
                $cmd .= " >> " . $self->shell_quote($self->{log}) . " 2>&1";
            }
            !system $cmd;
        } else {
            my $pid = fork;
            if ($pid) {
                waitpid $pid, 0;
                return !$?;
            } else {
                $self->run_exec($cmd);
            }
        }
    }
    
    sub run_exec {
        my($self, $cmd) = @_;
    
        if (ref $cmd eq 'ARRAY') {
            unless ($self->{verbose}) {
                open my $logfh, ">>", $self->{log};
                open STDERR, '>&', $logfh;
                open STDOUT, '>&', $logfh;
                close $logfh;
            }
            exec @$cmd;
        } else {
            unless ($self->{verbose}) {
                $cmd .= " >> " . $self->shell_quote($self->{log}) . " 2>&1";
            }
            exec $cmd;
        }
    }
    
    sub run_timeout {
        my($self, $cmd, $timeout) = @_;
        return $self->run($cmd) if WIN32 || $self->{verbose} || !$timeout;
    
        my $pid = fork;
        if ($pid) {
            eval {
                local $SIG{ALRM} = sub { die "alarm\n" };
                alarm $timeout;
                waitpid $pid, 0;
                alarm 0;
            };
            if ($@ && $@ eq "alarm\n") {
                $self->diag_fail("Timed out (> ${timeout}s). Use --verbose to retry.");
                local $SIG{TERM} = 'IGNORE';
                kill TERM => 0;
                waitpid $pid, 0;
                return;
            }
            return !$?;
        } elsif ($pid == 0) {
            $self->run_exec($cmd);
        } else {
            $self->chat("! fork failed: falling back to system()\n");
            $self->run($cmd);
        }
    }
    
    sub append_args {
        my($self, $cmd, $phase) = @_;
    
        if (my $args = $self->{build_args}{$phase}) {
            $cmd = join ' ', $self->shell_quote(@$cmd), $args;
        }
    
        $cmd;
    }
    
    sub configure {
        my($self, $cmd, $depth) = @_;
    
        # trick AutoInstall
        local $ENV{PERL5_CPAN_IS_RUNNING} = local $ENV{PERL5_CPANPLUS_IS_RUNNING} = $$;
    
        # e.g. skip CPAN configuration on local::lib
        local $ENV{PERL5_CPANM_IS_RUNNING} = $$;
    
        my $use_default = !$self->{interactive};
        local $ENV{PERL_MM_USE_DEFAULT} = $use_default;
    
        local $ENV{PERL_MM_OPT} = $ENV{PERL_MM_OPT};
        local $ENV{PERL_MB_OPT} = $ENV{PERL_MB_OPT};
    
        # skip man page generation
        unless ($self->{pod2man}) {
            $ENV{PERL_MM_OPT} .= " INSTALLMAN1DIR=none INSTALLMAN3DIR=none";
            $ENV{PERL_MB_OPT} .= " --config installman1dir= --config installsiteman1dir= --config installman3dir= --config installsiteman3dir=";
        }
    
        # Lancaster Consensus
        if ($self->{pure_perl}) {
            $ENV{PERL_MM_OPT} .= " PUREPERL_ONLY=1";
            $ENV{PERL_MB_OPT} .= " --pureperl-only";
        }
    
        $cmd = $self->append_args($cmd, 'configure') if $depth == 0;
    
        local $self->{verbose} = $self->{verbose} || $self->{interactive};
        $self->run_timeout($cmd, $self->{configure_timeout});
    }
    
    sub build {
        my($self, $cmd, $distname, $depth) = @_;
    
        local $ENV{PERL_MM_USE_DEFAULT} = !$self->{interactive};
    
        $cmd = $self->append_args($cmd, 'build') if $depth == 0;
    
        return 1 if $self->run_timeout($cmd, $self->{build_timeout});
        while (1) {
            my $ans = lc $self->prompt("Building $distname failed.\nYou can s)kip, r)etry, e)xamine build log, or l)ook ?", "s");
            return                                       if $ans eq 's';
            return $self->build($cmd, $distname, $depth) if $ans eq 'r';
            $self->show_build_log                        if $ans eq 'e';
            $self->look                                  if $ans eq 'l';
        }
    }
    
    sub test {
        my($self, $cmd, $distname, $depth) = @_;
        return 1 if $self->{notest};
    
        # https://rt.cpan.org/Ticket/Display.html?id=48965#txn-1013385
        local $ENV{PERL_MM_USE_DEFAULT} = !$self->{interactive};
    
        # https://github.com/Perl-Toolchain-Gang/toolchain-site/blob/master/lancaster-consensus.md
        local $ENV{NONINTERACTIVE_TESTING} = !$self->{interactive};
    
        $cmd = $self->append_args($cmd, 'test') if $depth == 0;
    
        return 1 if $self->run_timeout($cmd, $self->{test_timeout});
        if ($self->{force}) {
            $self->diag_fail("Testing $distname failed but installing it anyway.");
            return 1;
        } else {
            $self->diag_fail;
            while (1) {
                my $ans = lc $self->prompt("Testing $distname failed.\nYou can s)kip, r)etry, f)orce install, e)xamine build log, or l)ook ?", "s");
                return                                      if $ans eq 's';
                return $self->test($cmd, $distname, $depth) if $ans eq 'r';
                return 1                                    if $ans eq 'f';
                $self->show_build_log                       if $ans eq 'e';
                $self->look                                 if $ans eq 'l';
            }
        }
    }
    
    sub install {
        my($self, $cmd, $uninst_opts, $depth) = @_;
    
        if ($depth == 0 && $self->{test_only}) {
            return 1;
        }
    
        if ($self->{sudo}) {
            unshift @$cmd, "sudo";
        }
    
        if ($self->{uninstall_shadows} && !$ENV{PERL_MM_OPT}) {
            push @$cmd, @$uninst_opts;
        }
    
        $cmd = $self->append_args($cmd, 'install') if $depth == 0;
    
        $self->run($cmd);
    }
    
    sub look {
        my $self = shift;
    
        my $shell = $ENV{SHELL};
        $shell  ||= $ENV{COMSPEC} if WIN32;
        if ($shell) {
            my $cwd = Cwd::cwd;
            $self->diag("Entering $cwd with $shell\n");
            system $shell;
        } else {
            $self->diag_fail("You don't seem to have a SHELL :/");
        }
    }
    
    sub show_build_log {
        my $self = shift;
    
        my @pagers = (
            $ENV{PAGER},
            (WIN32 ? () : ('less')),
            'more'
        );
        my $pager;
        while (@pagers) {
            $pager = shift @pagers;
            next unless $pager;
            $pager = $self->which($pager);
            next unless $pager;
            last;
        }
    
        if ($pager) {
            # win32 'more' doesn't allow "more build.log", the < is required
            system("$pager < $self->{log}");
        }
        else {
            $self->diag_fail("You don't seem to have a PAGER :/");
        }
    }
    
    sub chdir {
        my $self = shift;
        Cwd::chdir(File::Spec->canonpath($_[0])) or die "$_[0]: $!";
    }
    
    sub configure_mirrors {
        my $self = shift;
        unless (@{$self->{mirrors}}) {
            $self->{mirrors} = [ 'http://www.cpan.org' ];
        }
        for (@{$self->{mirrors}}) {
            s!^/!file:///!;
            s!/$!!;
        }
    }
    
    sub self_upgrade {
        my $self = shift;
        $self->check_upgrade;
        $self->{argv} = [ 'App::cpanminus' ];
        return; # continue
    }
    
    sub install_module {
        my($self, $module, $depth, $version) = @_;
    
        $self->check_libs;
    
        if ($self->{seen}{$module}++) {
            # TODO: circular dependencies
            $self->chat("Already tried $module. Skipping.\n");
            return 1;
        }
    
        if ($self->{skip_satisfied}) {
            my($ok, $local) = $self->check_module($module, $version || 0);
            if ($ok) {
                $self->diag("You have $module ($local)\n", 1);
                return 1;
            }
        }
    
        my $dist = $self->resolve_name($module, $version);
        unless ($dist) {
            my $what = $module . ($version ? " ($version)" : "");
            $self->diag_fail("Couldn't find module or a distribution $what", 1);
            return;
        }
    
        if ($dist->{distvname} && $self->{seen}{$dist->{distvname}}++) {
            $self->chat("Already tried $dist->{distvname}. Skipping.\n");
            return 1;
        }
    
        if ($self->{cmd} eq 'info') {
            print $self->format_dist($dist), "\n";
            return 1;
        }
    
        $dist->{depth} = $depth; # ugly hack
    
        if ($dist->{module}) {
            unless ($self->satisfy_version($dist->{module}, $dist->{module_version}, $version)) {
                $self->diag("Found $dist->{module} $dist->{module_version} which doesn't satisfy $version.\n", 1);
                return;
            }
    
            # If a version is requested, it has to be the exact same version, otherwise, check as if
            # it is the minimum version you need.
            my $cmp = $version ? "==" : "";
            my $requirement = $dist->{module_version} ? "$cmp$dist->{module_version}" : 0;
            my($ok, $local) = $self->check_module($dist->{module}, $requirement);
            if ($self->{skip_installed} && $ok) {
                $self->diag("$dist->{module} is up to date. ($local)\n", 1);
                return 1;
            }
        }
    
        if ($dist->{dist} eq 'perl'){
            $self->diag("skipping $dist->{pathname}\n");
            return 1;
        }
    
        $self->diag("--> Working on $module\n");
    
        $dist->{dir} ||= $self->fetch_module($dist);
    
        unless ($dist->{dir}) {
            $self->diag_fail("Failed to fetch distribution $dist->{distvname}", 1);
            return;
        }
    
        $self->chat("Entering $dist->{dir}\n");
        $self->chdir($self->{base});
        $self->chdir($dist->{dir});
    
        if ($self->{cmd} eq 'look') {
            $self->look;
            return 1;
        }
    
        return $self->build_stuff($module, $dist, $depth);
    }
    
    sub uninstall_search_path {
        my $self = shift;
    
        $self->{local_lib}
            ? (local::lib->install_base_arch_path($self->{local_lib}),
               local::lib->install_base_perl_path($self->{local_lib}))
            : @Config{qw(installsitearch installsitelib)};
    }
    
    sub uninstall_module {
        my ($self, $module) = @_;
    
        $self->check_libs;
    
        my @inc = $self->uninstall_search_path;
    
        my($metadata, $packlist) = $self->packlists_containing($module, \@inc);
        unless ($packlist) {
            $self->diag_fail(<<DIAG, 1);
    $module is not found in the following directories and can't be uninstalled.
    
    @{[ join("  \n", map "  $_", @inc) ]}
    
    DIAG
            return;
        }
    
        my @uninst_files = $self->uninstall_target($metadata, $packlist);
    
        $self->ask_permission($module, \@uninst_files) or return;
        $self->uninstall_files(@uninst_files, $packlist);
    
        $self->diag("Successfully uninstalled $module\n", 1);
    
        return 1;
    }
    
    sub packlists_containing {
        my($self, $module, $inc) = @_;
    
        require Module::Metadata;
        my $metadata = Module::Metadata->new_from_module($module, inc => $inc)
            or return;
    
        my $packlist;
        my $wanted = sub {
            return unless $_ eq '.packlist' && -f $_;
            for my $file ($self->unpack_packlist($File::Find::name)) {
                $packlist ||= $File::Find::name if $file eq $metadata->filename;
            }
        };
    
        {
            require File::pushd;
            my $pushd = File::pushd::pushd();
            my @search = grep -d $_, map File::Spec->catdir($_, 'auto'), @$inc;
            File::Find::find($wanted, @search);
        }
    
        return $metadata, $packlist;
    }
    
    sub uninstall_target {
        my($self, $metadata, $packlist) = @_;
    
        # If the module has a shadow install, or uses local::lib, then you can't just remove
        # all files in .packlist since it might have shadows in there
        if ($self->has_shadow_install($metadata) or $self->{local_lib}) {
            grep $self->should_unlink($_), $self->unpack_packlist($packlist);
        } else {
            $self->unpack_packlist($packlist);
        }
    }
    
    sub has_shadow_install {
        my($self, $metadata) = @_;
    
        # check if you have the module in site_perl *and* perl
        my @shadow = grep defined, map Module::Metadata->new_from_module($metadata->name, inc => [$_]), @INC;
        @shadow >= 2;
    }
    
    sub should_unlink {
        my($self, $file) = @_;
    
        # If local::lib is used, everything under the directory can be safely removed
        # Otherwise, bin and man files might be shared with the shadows i.e. site_perl vs perl
        # This is not 100% safe to keep the script there hoping to work with older version of .pm
        # files in the shadow, but there's nothing you can do about it.
        if ($self->{local_lib}) {
            $file =~ /^\Q$self->{local_lib}\E/;
        } else {
            !(grep $file =~ /^\Q$_\E/, @Config{qw(installbin installscript installman1dir installman3dir)});
        }
    }
    
    sub ask_permission {
        my ($self, $module, $files) = @_;
    
        $self->diag("$module contains the following files:\n\n");
        for my $file (@$files) {
            $self->diag("  $file\n");
        }
        $self->diag("\n");
    
        return 'force uninstall' if $self->{force};
        local $self->{prompt} = 1;
        return $self->prompt_bool("Are you sure you want to uninstall $module?", 'y');
    }
    
    sub unpack_packlist {
        my ($self, $packlist) = @_;
        open my $fh, '<', $packlist or die "$packlist: $!";
        map { chomp; $_ } <$fh>;
    }
    
    sub uninstall_files {
        my ($self, @files) = @_;
    
        $self->diag("\n");
    
        for my $file (@files) {
            $self->diag("Unlink: $file\n");
            unlink $file or $self->diag_fail("$!: $file");
        }
    
        $self->diag("\n");
    
        return 1;
    }
    
    sub format_dist {
        my($self, $dist) = @_;
    
        # TODO support --dist-format?
        return "$dist->{cpanid}/$dist->{filename}";
    }
    
    sub trim {
        local $_ = shift;
        tr/\n/ /d;
        s/^\s*|\s*$//g;
        $_;
    }
    
    sub fetch_module {
        my($self, $dist) = @_;
    
        $self->chdir($self->{base});
    
        for my $uri (@{$dist->{uris}}) {
            $self->mask_output( diag_progress => "Fetching $uri" );
    
            # Ugh, $dist->{filename} can contain sub directory
            my $filename = $dist->{filename} || $uri;
            my $name = File::Basename::basename($filename);
    
            my $cancelled;
            my $fetch = sub {
                my $file;
                eval {
                    local $SIG{INT} = sub { $cancelled = 1; die "SIGINT\n" };
                    $self->mirror($uri, $name);
                    $file = $name if -e $name;
                };
                $self->diag("ERROR: " . trim("$@") . "\n", 1) if $@ && $@ ne "SIGINT\n";
                return $file;
            };
    
            my($try, $file);
            while ($try++ < 3) {
                $file = $fetch->();
                last if $cancelled or $file;
                $self->mask_output( diag_fail => "Download $uri failed. Retrying ... ");
            }
    
            if ($cancelled) {
                $self->diag_fail("Download cancelled.");
                return;
            }
    
            unless ($file) {
                $self->mask_output( diag_fail => "Failed to download $uri");
                next;
            }
    
            $self->diag_ok;
            $dist->{local_path} = File::Spec->rel2abs($name);
    
            my $dir = $self->unpack($file, $uri, $dist);
            next unless $dir; # unpack failed
    
            if (my $save = $self->{save_dists}) {
                # Only distros retrieved from CPAN have a pathname set
                my $path = $dist->{pathname} ? "$save/authors/id/$dist->{pathname}"
                                             : "$save/vendor/$file";
                $self->chat("Copying $name to $path\n");
                File::Path::mkpath([ File::Basename::dirname($path) ], 0, 0777);
                File::Copy::copy($file, $path) or warn $!;
            }
    
            return $dist, $dir;
        }
    }
    
    sub unpack {
        my($self, $file, $uri, $dist) = @_;
    
        if ($self->{verify}) {
            $self->verify_archive($file, $uri, $dist) or return;
        }
    
        $self->chat("Unpacking $file\n");
        my $dir = $file =~ /\.zip/i ? $self->unzip($file) : $self->untar($file);
        unless ($dir) {
            $self->diag_fail("Failed to unpack $file: no directory");
        }
        return $dir;
    }
    
    sub verify_checksums_signature {
        my($self, $chk_file) = @_;
    
        require Module::Signature; # no fatpack
    
        $self->chat("Verifying the signature of CHECKSUMS\n");
    
        my $rv = eval {
            local $SIG{__WARN__} = sub {}; # suppress warnings
            my $v = Module::Signature::_verify($chk_file);
            $v == Module::Signature::SIGNATURE_OK();
        };
        if ($rv) {
            $self->chat("Verified OK!\n");
        } else {
            $self->diag_fail("Verifying CHECKSUMS signature failed: $rv\n");
            return;
        }
    
        return 1;
    }
    
    sub verify_archive {
        my($self, $file, $uri, $dist) = @_;
    
        unless ($dist->{cpanid}) {
            $self->chat("Archive '$file' does not seem to be from PAUSE. Skip verification.\n");
            return 1;
        }
    
        (my $mirror = $uri) =~ s!/authors/id.*$!!;
    
        (my $chksum_uri = $uri) =~ s!/[^/]*$!/CHECKSUMS!;
        my $chk_file = $self->source_for($mirror) . "/$dist->{cpanid}.CHECKSUMS";
        $self->mask_output( diag_progress => "Fetching $chksum_uri" );
        $self->mirror($chksum_uri, $chk_file);
    
        unless (-e $chk_file) {
            $self->diag_fail("Fetching $chksum_uri failed.\n");
            return;
        }
    
        $self->diag_ok;
        $self->verify_checksums_signature($chk_file) or return;
        $self->verify_checksum($file, $chk_file);
    }
    
    sub verify_checksum {
        my($self, $file, $chk_file) = @_;
    
        $self->chat("Verifying the SHA1 for $file\n");
    
        open my $fh, "<$chk_file" or die "$chk_file: $!";
        my $data = join '', <$fh>;
        $data =~ s/\015?\012/\n/g;
    
        require Safe; # no fatpack
        my $chksum = Safe->new->reval($data);
    
        if (!ref $chksum or ref $chksum ne 'HASH') {
            $self->diag_fail("! Checksum file downloaded from $chk_file is broken.\n");
            return;
        }
    
        if (my $sha = $chksum->{$file}{sha256}) {
            my $hex = $self->sha1_for($file);
            if ($hex eq $sha) {
                $self->chat("Checksum for $file: Verified!\n");
            } else {
                $self->diag_fail("Checksum mismatch for $file\n");
                return;
            }
        } else {
            $self->chat("Checksum for $file not found in CHECKSUMS.\n");
            return;
        }
    }
    
    sub sha1_for {
        my($self, $file) = @_;
    
        require Digest::SHA; # no fatpack
    
        open my $fh, "<", $file or die "$file: $!";
        my $dg = Digest::SHA->new(256);
        my($data);
        while (read($fh, $data, 4096)) {
            $dg->add($data);
        }
    
        return $dg->hexdigest;
    }
    
    sub verify_signature {
        my($self, $dist) = @_;
    
        $self->diag_progress("Verifying the SIGNATURE file");
        my $out = `$self->{cpansign} -v --skip 2>&1`;
        $self->log($out);
    
        if ($out =~ /Signature verified OK/) {
            $self->diag_ok("Verified OK");
            return 1;
        } else {
            $self->diag_fail("SIGNATURE verificaion for $dist->{filename} failed\n");
            return;
        }
    }
    
    sub resolve_name {
        my($self, $module, $version) = @_;
    
        # Git
        if ($module =~ /(?:^git:|\.git(?:@.+)?$)/) {
            return $self->git_uri($module);
        }
    
        # URL
        if ($module =~ /^(ftp|https?|file):/) {
            if ($module =~ m!authors/id/(.*)!) {
                return $self->cpan_dist($1, $module);
            } else {
                return { uris => [ $module ] };
            }
        }
    
        # Directory
        if ($module =~ m!^[\./]! && -d $module) {
            return {
                source => 'local',
                dir => Cwd::abs_path($module),
            };
        }
    
        # File
        if (-f $module) {
            return {
                source => 'local',
                uris => [ "file://" . Cwd::abs_path($module) ],
            };
        }
    
        # cpan URI
        if ($module =~ s!^cpan:///distfile/!!) {
            return $self->cpan_dist($module);
        }
    
        # PAUSEID/foo
        # P/PA/PAUSEID/foo
        if ($module =~ m!^(?:[A-Z]/[A-Z]{2}/)?([A-Z]{2}[\-A-Z0-9]*/.*)$!) {
            return $self->cpan_dist($1);
        }
    
        # Module name
        return $self->search_module($module, $version);
    }
    
    sub cpan_module {
        my($self, $module, $dist, $version) = @_;
    
        my $dist = $self->cpan_dist($dist);
        $dist->{module} = $module;
        $dist->{module_version} = $version if $version && $version ne 'undef';
    
        return $dist;
    }
    
    sub cpan_dist {
        my($self, $dist, $url) = @_;
    
        $dist =~ s!^([A-Z]{2})!substr($1,0,1)."/".substr($1,0,2)."/".$1!e;
    
        require CPAN::DistnameInfo;
        my $d = CPAN::DistnameInfo->new($dist);
    
        if ($url) {
            $url = [ $url ] unless ref $url eq 'ARRAY';
        } else {
            my $id = $d->cpanid;
            my $fn = substr($id, 0, 1) . "/" . substr($id, 0, 2) . "/" . $id . "/" . $d->filename;
    
            my @mirrors = @{$self->{mirrors}};
            my @urls    = map "$_/authors/id/$fn", @mirrors;
    
            $url = \@urls,
        }
    
        return {
            $d->properties,
            source  => 'cpan',
            uris    => $url,
        };
    }
    
    sub git_uri {
        my ($self, $uri) = @_;
    
        # similar to http://www.pip-installer.org/en/latest/logic.html#vcs-support
        # git URL has to end with .git when you need to use pin @ commit/tag/branch
    
        ($uri, my $commitish) = split /(?<=\.git)@/i, $uri, 2;
    
        my $dir = File::Temp::tempdir(CLEANUP => 1);
    
        $self->mask_output( diag_progress => "Cloning $uri" );
        $self->run([ 'git', 'clone', $uri, $dir ]);
    
        unless (-e "$dir/.git") {
            $self->diag_fail("Failed cloning git repository $uri", 1);
            return;
        }
    
        if ($commitish) {
            require File::pushd;
            my $dir = File::pushd::pushd($dir);
    
            unless ($self->run([ 'git', 'checkout', $commitish ])) {
                $self->diag_fail("Failed to checkout '$commitish' in git repository $uri\n");
                return;
            }
        }
    
        $self->diag_ok;
    
        return {
            source => 'local',
            dir    => $dir,
        };
    }
    
    sub setup_module_build_patch {
        my $self = shift;
    
        open my $out, ">$self->{base}/ModuleBuildSkipMan.pm" or die $!;
        print $out <<EOF;
    package ModuleBuildSkipMan;
    CHECK {
      if (%Module::Build::) {
        no warnings 'redefine';
        *Module::Build::Base::ACTION_manpages = sub {};
        *Module::Build::Base::ACTION_docs     = sub {};
      }
    }
    1;
    EOF
    }
    
    sub core_version_for {
        my($self, $module) = @_;
    
        require Module::CoreList; # no fatpack
        unless (exists $Module::CoreList::version{$]+0}) {
            die sprintf("Module::CoreList %s (loaded from %s) doesn't seem to have entries for perl $]. " .
                        "You're strongly recommended to upgrade Module::CoreList from CPAN.\n",
                        $Module::CoreList::VERSION, $INC{"Module/CoreList.pm"});
        }
    
        unless (exists $Module::CoreList::version{$]+0}{$module}) {
            return -1;
        }
    
        return $Module::CoreList::version{$]+0}{$module};
    }
    
    sub search_inc {
        my $self = shift;
        $self->{search_inc} ||= do {
            # strip lib/ and fatlib/ from search path when booted from dev
            if (defined $::Bin) {
                [grep !/^\Q$::Bin\E\/..\/(?:fat)?lib$/, @INC]
            } else {
                [@INC]
            }
        };
    }
    
    sub check_module {
        my($self, $mod, $want_ver) = @_;
    
        require Module::Metadata;
        my $meta = Module::Metadata->new_from_module($mod, inc => $self->search_inc)
            or return 0, undef;
    
        my $version = $meta->version;
    
        # When -L is in use, the version loaded from 'perl' library path
        # might be newer than (or actually wasn't core at) the version
        # that is shipped with the current perl
        if ($self->{self_contained} && $self->loaded_from_perl_lib($meta)) {
            $version = $self->core_version_for($mod);
            return 0, undef if $version && $version == -1;
        }
    
        $self->{local_versions}{$mod} = $version;
    
        if ($self->is_deprecated($meta)){
            return 0, $version;
        } elsif ($self->satisfy_version($mod, $version, $want_ver)) {
            return 1, ($version || 'undef');
        } else {
            return 0, $version;
        }
    }
    
    sub satisfy_version {
        my($self, $mod, $version, $want_ver) = @_;
    
        $want_ver = '0' unless defined($want_ver) && length($want_ver);
    
        require CPAN::Meta::Requirements;
        my $requirements = CPAN::Meta::Requirements->new;
        $requirements->add_string_requirement($mod, $want_ver);
        $requirements->accepts_module($mod, $version);
    }
    
    sub unsatisfy_how {
        my($self, $ver, $want_ver) = @_;
    
        if ($want_ver =~ /^[v0-9\.\_]+$/) {
            return "$ver < $want_ver";
        } else {
            return "$ver doesn't satisfy $want_ver";
        }
    }
    
    sub is_deprecated {
        my($self, $meta) = @_;
    
        my $deprecated = eval {
            require Module::CoreList; # no fatpack
            Module::CoreList::is_deprecated($meta->{module});
        };
    
        return $deprecated && $self->loaded_from_perl_lib($meta);
    }
    
    sub loaded_from_perl_lib {
        my($self, $meta) = @_;
    
        require Config;
        my @dirs = qw(archlibexp privlibexp);
        if ($self->{self_contained} && ! $self->{exclude_vendor} && $Config{vendorarch}) {
            unshift @dirs, qw(vendorarch vendorlibexp);
        }
        for my $dir (@dirs) {
            my $confdir = $Config{$dir};
            if ($confdir eq substr($meta->filename, 0, length($confdir))) {
                return 1;
            }
        }
    
        return;
    }
    
    sub should_install {
        my($self, $mod, $ver) = @_;
    
        $self->chat("Checking if you have $mod $ver ... ");
        my($ok, $local) = $self->check_module($mod, $ver);
    
        if ($ok)       { $self->chat("Yes ($local)\n") }
        elsif ($local) { $self->chat("No (" . $self->unsatisfy_how($local, $ver) . ")\n") }
        else           { $self->chat("No\n") }
    
        return $mod unless $ok;
        return;
    }
    
    sub check_perl_version {
        my($self, $version) = @_;
        require CPAN::Meta::Requirements;
        my $req = CPAN::Meta::Requirements->from_string_hash({ perl => $version });
        $req->accepts_module(perl => $]);
    }
    
    sub install_deps {
        my($self, $dir, $depth, @deps) = @_;
    
        my(@install, %seen, @fail);
        for my $dep (@deps) {
            next if $seen{$dep->module};
            if ($dep->module eq 'perl') {
                if ($dep->is_requirement && !$self->check_perl_version($dep->version)) {
                    $self->diag("Needs perl @{[$dep->version]}, you have $]\n");
                    push @fail, 'perl';
                }
            } elsif ($self->should_install($dep->module, $dep->version)) {
                push @install, $dep;
                $seen{$dep->module} = 1;
            }
        }
    
        if (@install) {
            $self->diag("==> Found dependencies: " . join(", ",  map $_->module, @install) . "\n");
        }
    
        for my $dep (@install) {
            $self->install_module($dep->module, $depth + 1, $dep->version);
        }
    
        $self->chdir($self->{base});
        $self->chdir($dir) if $dir;
    
        if ($self->{scandeps}) {
            return 1; # Don't check if dependencies are installed, since with --scandeps they aren't
        }
        my @not_ok = $self->unsatisfied_deps(@deps);
        if (@not_ok) {
            return 0, \@not_ok;
        } else {
            return 1;
        }
    }
    
    sub unsatisfied_deps {
        my($self, @deps) = @_;
    
        require CPAN::Meta::Check;
        require CPAN::Meta::Requirements;
    
        my $reqs = CPAN::Meta::Requirements->new;
        for my $dep (grep $_->is_requirement, @deps) {
            $reqs->add_string_requirement($dep->module => $dep->requires_version || '0');
        }
    
        my $ret = CPAN::Meta::Check::check_requirements($reqs, 'requires', $self->{search_inc});
        grep defined, values %$ret;
    }
    
    sub install_deps_bailout {
        my($self, $target, $dir, $depth, @deps) = @_;
    
        my($ok, $fail) = $self->install_deps($dir, $depth, @deps);
        if (!$ok) {
            $self->diag_fail("Installing the dependencies failed: " . join(", ", @$fail), 1);
            unless ($self->prompt_bool("Do you want to continue building $target anyway?", "n")) {
                $self->diag_fail("Bailing out the installation for $target.", 1);
                return;
            }
        }
    
        return 1;
    }
    
    sub build_stuff {
        my($self, $stuff, $dist, $depth) = @_;
    
        if ($self->{verify} && -e 'SIGNATURE') {
            $self->verify_signature($dist) or return;
        }
    
        require CPAN::Meta;
    
        my($meta_file) = grep -f, qw(META.json META.yml);
        if ($meta_file) {
            $self->chat("Checking configure dependencies from $meta_file\n");
            $dist->{cpanmeta} = eval { CPAN::Meta->load_file($meta_file) };
        } elsif ($dist->{dist} && $dist->{version}) {
            $self->chat("META.yml/json not found. Creating skeleton for it.\n");
            $dist->{cpanmeta} = CPAN::Meta->new({ name => $dist->{dist}, version => $dist->{version} });
        }
    
        $dist->{meta} = $dist->{cpanmeta} ? $dist->{cpanmeta}->as_struct : {};
    
        my @config_deps;
        if ($dist->{cpanmeta}) {
            push @config_deps, App::cpanminus::Dependency->from_prereqs(
                $dist->{cpanmeta}->effective_prereqs, ['configure'], $self->{install_types},
            );
        }
    
        if (-e 'Build.PL' && !$self->should_use_mm($dist->{dist}) && !@config_deps) {
            push @config_deps, App::cpanminus::Dependency->from_versions(
                { 'Module::Build' => '0.38' }, 'configure',
            );
        }
    
        $self->upgrade_toolchain(\@config_deps);
    
        my $target = $dist->{meta}{name} ? "$dist->{meta}{name}-$dist->{meta}{version}" : $dist->{dir};
        {
            $self->install_deps_bailout($target, $dist->{dir}, $depth, @config_deps)
              or return;
        }
    
        $self->diag_progress("Configuring $target");
    
        my $configure_state = $self->configure_this($dist, $depth);
        $self->diag_ok($configure_state->{configured_ok} ? "OK" : "N/A");
    
        if ($dist->{cpanmeta} && $dist->{source} eq 'cpan') {
            $dist->{provides} = $dist->{cpanmeta}{provides} || $self->extract_packages($dist->{cpanmeta}, ".");
        }
    
        # install direct 'test' dependencies for --installdeps, even with --notest
        my $root_target = (($self->{installdeps} or $self->{showdeps}) and $depth == 0);
        $dist->{want_phases} = $self->{notest} && !$root_target
                             ? [qw( build runtime )] : [qw( build test runtime )];
    
        push @{$dist->{want_phases}}, 'develop' if $self->{with_develop} && $depth == 0;
    
        my @deps = $self->find_prereqs($dist);
        my $module_name = $self->find_module_name($configure_state) || $dist->{meta}{name};
        $module_name =~ s/-/::/g;
    
        if ($self->{showdeps}) {
            for my $dep (@config_deps, @deps) {
                print $dep->module, ($dep->version ? ("~".$dep->version) : ""), "\n";
            }
            return 1;
        }
    
        my $distname = $dist->{meta}{name} ? "$dist->{meta}{name}-$dist->{meta}{version}" : $stuff;
    
        my $walkup;
        if ($self->{scandeps}) {
            $walkup = $self->scandeps_append_child($dist);
        }
    
        $self->install_deps_bailout($distname, $dist->{dir}, $depth, @deps)
            or return;
    
        if ($self->{scandeps}) {
            unless ($configure_state->{configured_ok}) {
                my $diag = <<DIAG;
    ! Configuring $distname failed. See $self->{log} for details.
    ! You might have to install the following modules first to get --scandeps working correctly.
    DIAG
                if (@config_deps) {
                    my @tree = @{$self->{scandeps_tree}};
                    $diag .= "!\n" . join("", map "! * $_->[0]{module}\n", @tree[0..$#tree-1]) if @tree;
                }
                $self->diag("!\n$diag!\n", 1);
            }
            $walkup->();
            return 1;
        }
    
        if ($self->{installdeps} && $depth == 0) {
            if ($configure_state->{configured_ok}) {
                $self->diag("<== Installed dependencies for $stuff. Finishing.\n");
                return 1;
            } else {
                $self->diag("! Configuring $distname failed. See $self->{log} for details.\n", 1);
                return;
            }
        }
    
        my $installed;
        if ($configure_state->{use_module_build} && -e 'Build' && -f _) {
            $self->diag_progress("Building " . ($self->{notest} ? "" : "and testing ") . $distname);
            $self->build([ $self->{perl}, "./Build" ], $distname, $depth) &&
            $self->test([ $self->{perl}, "./Build", "test" ], $distname, $depth) &&
            $self->install([ $self->{perl}, "./Build", "install" ], [ "--uninst", 1 ], $depth) &&
            $installed++;
        } elsif ($self->{make} && -e 'Makefile') {
            $self->diag_progress("Building " . ($self->{notest} ? "" : "and testing ") . $distname);
            $self->build([ $self->{make} ], $distname, $depth) &&
            $self->test([ $self->{make}, "test" ], $distname, $depth) &&
            $self->install([ $self->{make}, "install" ], [ "UNINST=1" ], $depth) &&
            $installed++;
        } else {
            my $why;
            my $configure_failed = $configure_state->{configured} && !$configure_state->{configured_ok};
            if ($configure_failed) { $why = "Configure failed for $distname." }
            elsif ($self->{make})  { $why = "The distribution doesn't have a proper Makefile.PL/Build.PL" }
            else                   { $why = "Can't configure the distribution. You probably need to have 'make'." }
    
            $self->diag_fail("$why See $self->{log} for details.", 1);
            return;
        }
    
        if ($installed && $self->{test_only}) {
            $self->diag_ok;
            $self->diag("Successfully tested $distname\n", 1);
        } elsif ($installed) {
            my $local   = $self->{local_versions}{$dist->{module} || ''};
            my $version = $dist->{module_version} || $dist->{meta}{version} || $dist->{version};
            my $reinstall = $local && ($local eq $version);
            my $action  = $local && !$reinstall
                        ? $self->numify_ver($version) < $self->numify_ver($local)
                            ? "downgraded"
                            : "upgraded"
                        : undef;
    
            my $how = $reinstall ? "reinstalled $distname"
                    : $local     ? "installed $distname ($action from $local)"
                                 : "installed $distname" ;
            my $msg = "Successfully $how";
            $self->diag_ok;
            $self->diag("$msg\n", 1);
            $self->{installed_dists}++;
            $self->save_meta($stuff, $dist, $module_name, \@config_deps, \@deps);
            return 1;
        } else {
            my $what = $self->{test_only} ? "Testing" : "Installing";
            $self->diag_fail("$what $stuff failed. See $self->{log} for details. Retry with --force to force install it.", 1);
            return;
        }
    }
    
    sub perl_requirements {
        my($self, @requires) = @_;
    
        my @perl;
        for my $requires (grep defined, @requires) {
            if (exists $requires->{perl}) {
                push @perl, App::cpanminus::Dependency->new(perl => $requires->{perl});
            }
        }
    
        return @perl;
    }
    
    sub should_use_mm {
        my($self, $dist) = @_;
    
        # Module::Build deps should use MakeMaker because that causes circular deps and fail
        # Otherwise we should prefer Build.PL
        my %should_use_mm = map { $_ => 1 } qw( version ExtUtils-ParseXS ExtUtils-Install ExtUtils-Manifest );
    
        $should_use_mm{$dist};
    }
    
    sub configure_this {
        my($self, $dist, $depth) = @_;
    
        # Short-circuit `cpanm --installdeps .` because it doesn't need to build the current dir
        if (-e $self->{cpanfile_path} && $self->{installdeps} && $depth == 0) {
            require Module::CPANfile;
            $dist->{cpanfile} = eval { Module::CPANfile->load($self->{cpanfile_path}) };
            $self->diag_fail($@, 1) if $@;
            return {
                configured       => 1,
                configured_ok    => !!$dist->{cpanfile},
                use_module_build => 0,
            };
        }
    
        if ($self->{skip_configure}) {
            my $eumm = -e 'Makefile';
            my $mb   = -e 'Build' && -f _;
            return {
                configured => 1,
                configured_ok => $eumm || $mb,
                use_module_build => $mb,
            };
        }
    
        my $state = {};
    
        my $try_eumm = sub {
            if (-e 'Makefile.PL') {
                $self->chat("Running Makefile.PL\n");
    
                # NOTE: according to Devel::CheckLib, most XS modules exit
                # with 0 even if header files are missing, to avoid receiving
                # tons of FAIL reports in such cases. So exit code can't be
                # trusted if it went well.
                if ($self->configure([ $self->{perl}, "Makefile.PL" ], $depth)) {
                    $state->{configured_ok} = -e 'Makefile';
                }
                $state->{configured}++;
            }
        };
    
        my $try_mb = sub {
            if (-e 'Build.PL') {
                $self->chat("Running Build.PL\n");
                if ($self->configure([ $self->{perl}, "Build.PL" ], $depth)) {
                    $state->{configured_ok} = -e 'Build' && -f _;
                }
                $state->{use_module_build}++;
                $state->{configured}++;
            }
        };
    
        my @try;
        if ($dist->{dist} && $self->should_use_mm($dist->{dist})) {
            @try = ($try_eumm, $try_mb);
        } else {
            @try = ($try_mb, $try_eumm);
        }
    
        for my $try (@try) {
            $try->();
            last if $state->{configured_ok};
        }
    
        unless ($state->{configured_ok}) {
            while (1) {
                my $ans = lc $self->prompt("Configuring $dist->{dist} failed.\nYou can s)kip, r)etry, e)xamine build log, or l)ook ?", "s");
                last                                        if $ans eq 's';
                return $self->configure_this($dist, $depth) if $ans eq 'r';
                $self->show_build_log                       if $ans eq 'e';
                $self->look                                 if $ans eq 'l';
            }
        }
    
        return $state;
    }
    
    sub find_module_name {
        my($self, $state) = @_;
    
        return unless $state->{configured_ok};
    
        if ($state->{use_module_build} &&
            -e "_build/build_params") {
            my $params = do { open my $in, "_build/build_params"; $self->safe_eval(join "", <$in>) };
            return eval { $params->[2]{module_name} } || undef;
        } elsif (-e "Makefile") {
            open my $mf, "Makefile";
            while (<$mf>) {
                if (/^\#\s+NAME\s+=>\s+(.*)/) {
                    return $self->safe_eval($1);
                }
            }
        }
    
        return;
    }
    
    sub list_files {
        my $self = shift;
    
        if (-e 'MANIFEST') {
            require ExtUtils::Manifest;
            my $manifest = eval { ExtUtils::Manifest::manifind() } || {};
            return sort { lc $a cmp lc $b } keys %$manifest;
        } else {
            require File::Find;
            my @files;
            my $finder = sub {
                my $name = $File::Find::name;
                $name =~ s!\.[/\\]!!;
                push @files, $name;
            };
            File::Find::find($finder, ".");
            return sort { lc $a cmp lc $b } @files;
        }
    }
    
    sub extract_packages {
        my($self, $meta, $dir) = @_;
    
        my $try = sub {
            my $file = shift;
            return 0 if $file =~ m!^(?:x?t|inc|local|perl5|fatlib|_build)/!;
            return 1 unless $meta->{no_index};
            return 0 if grep { $file =~ m!^$_/! } @{$meta->{no_index}{directory} || []};
            return 0 if grep { $file eq $_ } @{$meta->{no_index}{file} || []};
            return 1;
        };
    
        require Parse::PMFile;
    
        my @files = grep { /\.pm(?:\.PL)?$/ && $try->($_) } $self->list_files;
    
        my $provides = { };
    
        for my $file (@files) {
            my $parser = Parse::PMFile->new($meta, { UNSAFE => 1, ALLOW_DEV_VERSION => 1 });
            my $packages = $parser->parse($file);
    
            while (my($package, $meta) = each %$packages) {
                $provides->{$package} ||= {
                    file => $meta->{infile},
                    ($meta->{version} eq 'undef') ? () : (version => $meta->{version}),
                };
            }
        }
    
        return $provides;
    }
    
    sub save_meta {
        my($self, $module, $dist, $module_name, $config_deps, $build_deps) = @_;
    
        return unless $dist->{distvname} && $dist->{source} eq 'cpan';
    
        my $base = ($ENV{PERL_MM_OPT} || '') =~ /INSTALL_BASE=/
            ? ($self->install_base($ENV{PERL_MM_OPT}) . "/lib/perl5") : $Config{sitelibexp};
    
        my $provides = $dist->{provides};
    
        File::Path::mkpath("blib/meta", 0, 0777);
    
        my $local = {
            name => $module_name,
            target => $module,
            version => exists $provides->{$module_name}
                ? ($provides->{$module_name}{version} || $dist->{version}) : $dist->{version},
            dist => $dist->{distvname},
            pathname => $dist->{pathname},
            provides => $provides,
        };
    
        require JSON::PP;
        open my $fh, ">", "blib/meta/install.json" or die $!;
        print $fh JSON::PP::encode_json($local);
    
        # Existence of MYMETA.* Depends on EUMM/M::B versions and CPAN::Meta
        if (-e "MYMETA.json") {
            File::Copy::copy("MYMETA.json", "blib/meta/MYMETA.json");
        }
    
        my @cmd = (
            ($self->{sudo} ? 'sudo' : ()),
            $^X,
            '-MExtUtils::Install=install',
            '-e',
            qq[install({ 'blib/meta' => '$base/$Config{archname}/.meta/$dist->{distvname}' })],
        );
        $self->run(\@cmd);
    }
    
    sub _merge_hashref {
        my($self, @hashrefs) = @_;
    
        my %hash;
        for my $h (@hashrefs) {
            %hash = (%hash, %$h);
        }
    
        return \%hash;
    }
    
    sub install_base {
        my($self, $mm_opt) = @_;
        $mm_opt =~ /INSTALL_BASE=(\S+)/ and return $1;
        die "Your PERL_MM_OPT doesn't contain INSTALL_BASE";
    }
    
    sub safe_eval {
        my($self, $code) = @_;
        eval $code;
    }
    
    sub configure_features {
        my($self, $dist, @features) = @_;
        map $_->identifier, grep { $self->effective_feature($dist, $_) } @features;
    }
    
    sub effective_feature {
        my($self, $dist, $feature) = @_;
    
        if ($dist->{depth} == 0) {
            my $value = $self->{features}{$feature->identifier};
            return $value if defined $value;
            return 1 if $self->{features}{__all};
        }
    
        if ($self->{interactive}) {
            require CPAN::Meta::Requirements;
    
            $self->diag("[@{[ $feature->description ]}]\n", 1);
    
            my $req = CPAN::Meta::Requirements->new;
            for my $phase (@{$dist->{want_phases}}) {
                for my $type (@{$self->{install_types}}) {
                    $req->add_requirements($feature->prereqs->requirements_for($phase, $type));
                }
            }
    
            my $reqs = $req->as_string_hash;
            my @missing;
            for my $module (keys %$reqs) {
                if ($self->should_install($module, $req->{$module})) {
                    push @missing, $module;
                }
            }
    
            if (@missing) {
                my $howmany = @missing;
                $self->diag("==> Found missing dependencies: " . join(", ", @missing) . "\n", 1);
                local $self->{prompt} = 1;
                return $self->prompt_bool("Install the $howmany optional module(s)?", "y");
            }
        }
    
        return;
    }
    
    sub find_prereqs {
        my($self, $dist) = @_;
    
        my @deps = $self->extract_meta_prereqs($dist);
    
        if ($dist->{module} =~ /^Bundle::/i) {
            push @deps, $self->bundle_deps($dist);
        }
    
        if ($self->{cpanfile_requirements} && !$dist->{cpanfile}) {
            for my $dep (@deps) {
                $dep->merge_with($self->{cpanfile_requirements});
            }
        }
    
        return @deps;
    }
    
    sub extract_meta_prereqs {
        my($self, $dist) = @_;
    
        if ($dist->{cpanfile}) {
            my @features = $self->configure_features($dist, $dist->{cpanfile}->features);
            my $prereqs = $dist->{cpanfile}->prereqs_with(@features);
            # TODO: creating requirements is useful even without cpanfile to detect conflicting prereqs
            $self->{cpanfile_requirements} = $prereqs->merged_requirements($dist->{want_phases}, ['requires']);
            return App::cpanminus::Dependency->from_prereqs($prereqs, $dist->{want_phases}, $self->{install_types});
        }
    
        require CPAN::Meta;
    
        my @deps;
        my($meta_file) = grep -f, qw(MYMETA.json MYMETA.yml);
        if ($meta_file) {
            $self->chat("Checking dependencies from $meta_file ...\n");
            my $mymeta = eval { CPAN::Meta->load_file($meta_file, { lazy_validation => 1 }) };
            if ($mymeta) {
                $dist->{meta}{name}    = $mymeta->name;
                $dist->{meta}{version} = $mymeta->version;
                return $self->extract_prereqs($mymeta, $dist);
            }
        }
    
        if (-e '_build/prereqs') {
            $self->chat("Checking dependencies from _build/prereqs ...\n");
            my $prereqs = do { open my $in, "_build/prereqs"; $self->safe_eval(join "", <$in>) };
            my $meta = CPAN::Meta->new(
                { name => $dist->{meta}{name}, version => $dist->{meta}{version}, %$prereqs },
                { lazy_validation => 1 },
            );
            @deps = $self->extract_prereqs($meta, $dist);
        } elsif (-e 'Makefile') {
            $self->chat("Finding PREREQ from Makefile ...\n");
            open my $mf, "Makefile";
            while (<$mf>) {
                if (/^\#\s+PREREQ_PM => \{\s*(.*?)\s*\}/) {
                    my @all;
                    my @pairs = split ', ', $1;
                    for (@pairs) {
                        my ($pkg, $v) = split '=>', $_;
                        push @all, [ $pkg, $v ];
                    }
                    my $list = join ", ", map { "'$_->[0]' => $_->[1]" } @all;
                    my $prereq = $self->safe_eval("no strict; +{ $list }");
                    push @deps, App::cpanminus::Dependency->from_versions($prereq) if $prereq;
                    last;
                }
            }
        }
    
        return @deps;
    }
    
    sub bundle_deps {
        my($self, $dist) = @_;
    
        my @files;
        File::Find::find({
            wanted => sub { push @files, File::Spec->rel2abs($_) if /\.pm/i },
            no_chdir => 1,
        }, '.');
    
        my @deps;
    
        for my $file (@files) {
            open my $pod, "<", $file or next;
            my $in_contents;
            while (<$pod>) {
                if (/^=head\d\s+CONTENTS/) {
                    $in_contents = 1;
                } elsif (/^=/) {
                    $in_contents = 0;
                } elsif ($in_contents) {
                    /^(\S+)\s*(\S+)?/
                        and push @deps, App::cpanminus::Dependency->new($1, $self->maybe_version($2));
                }
            }
        }
    
        return @deps;
    }
    
    sub maybe_version {
        my($self, $string) = @_;
        return $string && $string =~ /^\.?\d/ ? $string : undef;
    }
    
    sub extract_prereqs {
        my($self, $meta, $dist) = @_;
    
        my @features = $self->configure_features($dist, $meta->features);
        my $prereqs  = $self->soften_makemaker_prereqs($meta->effective_prereqs(\@features)->clone);
    
        return App::cpanminus::Dependency->from_prereqs($prereqs, $dist->{want_phases}, $self->{install_types});
    }
    
    # Workaround for Module::Install 1.04 creating a bogus (higher) MakeMaker requirement that it needs in build_requires
    # Assuming MakeMaker requirement is already satisfied in configure_requires, there's no need to have higher version of
    # MakeMaker in build/test anyway. https://github.com/miyagawa/cpanminus/issues/463
    sub soften_makemaker_prereqs {
        my($self, $prereqs) = @_;
    
        return $prereqs unless -e "inc/Module/Install.pm";
    
        for my $phase (qw( build test runtime )) {
            my $reqs = $prereqs->requirements_for($phase, 'requires');
            if ($reqs->requirements_for_module('ExtUtils::MakeMaker')) {
                $reqs->clear_requirement('ExtUtils::MakeMaker');
                $reqs->add_minimum('ExtUtils::MakeMaker' => 0);
            }
        }
    
        $prereqs;
    }
    
    sub cleanup_workdirs {
        my $self = shift;
    
        my $expire = time - 24 * 60 * 60 * $self->{auto_cleanup};
        my @targets;
    
        opendir my $dh, "$self->{home}/work";
        while (my $e = readdir $dh) {
            next if $e !~ /^(\d+)\.\d+$/; # {UNIX time}.{PID}
            my $time = $1;
            if ($time < $expire) {
                push @targets, "$self->{home}/work/$e";
            }
        }
    
        if (@targets) {
            if (@targets >= 64) {
                $self->diag("Expiring " . scalar(@targets) . " work directories. This might take a while...\n");
            } else {
                $self->chat("Expiring " . scalar(@targets) . " work directories.\n");
            }
            File::Path::rmtree(\@targets, 0, 0); # safe = 0, since blib usually doesn't have write bits
        }
    }
    
    sub scandeps_append_child {
        my($self, $dist) = @_;
    
        my $new_node = [ $dist, [] ];
    
        my $curr_node = $self->{scandeps_current} || [ undef, $self->{scandeps_tree} ];
        push @{$curr_node->[1]}, $new_node;
    
        $self->{scandeps_current} = $new_node;
    
        return sub { $self->{scandeps_current} = $curr_node };
    }
    
    sub dump_scandeps {
        my $self = shift;
    
        if ($self->{format} eq 'tree') {
            $self->walk_down(sub {
                my($dist, $depth) = @_;
                if ($depth == 0) {
                    print "$dist->{distvname}\n";
                } else {
                    print " " x ($depth - 1);
                    print "\\_ $dist->{distvname}\n";
                }
            }, 1);
        } elsif ($self->{format} =~ /^dists?$/) {
            $self->walk_down(sub {
                my($dist, $depth) = @_;
                print $self->format_dist($dist), "\n";
            }, 0);
        } elsif ($self->{format} eq 'json') {
            require JSON::PP;
            print JSON::PP::encode_json($self->{scandeps_tree});
        } elsif ($self->{format} eq 'yaml') {
            require YAML; # no fatpack
            print YAML::Dump($self->{scandeps_tree});
        } else {
            $self->diag("Unknown format: $self->{format}\n");
        }
    }
    
    sub walk_down {
        my($self, $cb, $pre) = @_;
        $self->_do_walk_down($self->{scandeps_tree}, $cb, 0, $pre);
    }
    
    sub _do_walk_down {
        my($self, $children, $cb, $depth, $pre) = @_;
    
        # DFS - $pre determines when we call the callback
        for my $node (@$children) {
            $cb->($node->[0], $depth) if $pre;
            $self->_do_walk_down($node->[1], $cb, $depth + 1, $pre);
            $cb->($node->[0], $depth) unless $pre;
        }
    }
    
    sub DESTROY {
        my $self = shift;
        $self->{at_exit}->($self) if $self->{at_exit};
    }
    
    # Utils
    
    sub shell_quote {
        my($self, @stuff) = @_;
        if (WIN32) {
            join ' ', map { /^${quote}.+${quote}$/ ? $_ : ($quote . $_ . $quote) } @stuff;
        } else {
            String::ShellQuote::shell_quote_best_effort(@stuff);
        }
    }
    
    sub which {
        my($self, $name) = @_;
        if (File::Spec->file_name_is_absolute($name)) {
            if (-x $name && !-d _) {
                return $name;
            }
        }
        my $exe_ext = $Config{_exe};
        for my $dir (File::Spec->path) {
            my $fullpath = File::Spec->catfile($dir, $name);
            if ((-x $fullpath || -x ($fullpath .= $exe_ext)) && !-d _) {
                if ($fullpath =~ /\s/) {
                    $fullpath = $self->shell_quote($fullpath);
                }
                return $fullpath;
            }
        }
        return;
    }
    
    sub get {
        my($self, $uri) = @_;
        if ($uri =~ /^file:/) {
            $self->file_get($uri);
        } else {
            $self->{_backends}{get}->(@_);
        }
    }
    
    sub mirror {
        my($self, $uri, $local) = @_;
        if ($uri =~ /^file:/) {
            $self->file_mirror($uri, $local);
        } else {
            $self->{_backends}{mirror}->(@_);
        }
    }
    
    sub untar    { $_[0]->{_backends}{untar}->(@_) };
    sub unzip    { $_[0]->{_backends}{unzip}->(@_) };
    
    sub uri_to_file {
        my($self, $uri) = @_;
    
        # file:///path/to/file -> /path/to/file
        # file://C:/path       -> C:/path
        if ($uri =~ s!file:/+!!) {
            $uri = "/$uri" unless $uri =~ m![a-zA-Z]:!;
        }
    
        return $uri;
    }
    
    sub file_get {
        my($self, $uri) = @_;
        my $file = $self->uri_to_file($uri);
        open my $fh, "<$file" or return;
        join '', <$fh>;
    }
    
    sub file_mirror {
        my($self, $uri, $path) = @_;
        my $file = $self->uri_to_file($uri);
        File::Copy::copy($file, $path);
    }
    
    sub has_working_lwp {
        my($self, $mirrors) = @_;
        my $https = grep /^https:/, @$mirrors;
        eval {
            require LWP::UserAgent; # no fatpack
            LWP::UserAgent->VERSION(5.802);
            require LWP::Protocol::https if $https; # no fatpack
            1;
        };
    }
    
    sub init_tools {
        my $self = shift;
    
        return if $self->{initialized}++;
    
        if ($self->{make} = $self->which($Config{make})) {
            $self->chat("You have make $self->{make}\n");
        }
    
        # use --no-lwp if they have a broken LWP, to upgrade LWP
        if ($self->{try_lwp} && $self->has_working_lwp($self->{mirrors})) {
            $self->chat("You have LWP $LWP::VERSION\n");
            my $ua = sub {
                LWP::UserAgent->new(
                    parse_head => 0,
                    env_proxy => 1,
                    agent => $self->agent,
                    timeout => 30,
                    @_,
                );
            };
            $self->{_backends}{get} = sub {
                my $self = shift;
                my $res = $ua->()->request(HTTP::Request->new(GET => $_[0]));
                return unless $res->is_success;
                return $res->decoded_content;
            };
            $self->{_backends}{mirror} = sub {
                my $self = shift;
                my $res = $ua->()->mirror(@_);
                die $res->content if $res->code == 501;
                $res->code;
            };
        } elsif ($self->{try_wget} and my $wget = $self->which('wget')) {
            $self->chat("You have $wget\n");
            my @common = (
                '--user-agent', $self->agent,
                '--retry-connrefused',
                ($self->{verbose} ? () : ('-q')),
            );
            $self->{_backends}{get} = sub {
                my($self, $uri) = @_;
                $self->safeexec( my $fh, $wget, $uri, @common, '-O', '-' ) or die "wget $uri: $!";
                local $/;
                <$fh>;
            };
            $self->{_backends}{mirror} = sub {
                my($self, $uri, $path) = @_;
                $self->safeexec( my $fh, $wget, $uri, @common, '-O', $path ) or die "wget $uri: $!";
                local $/;
                <$fh>;
            };
        } elsif ($self->{try_curl} and my $curl = $self->which('curl')) {
            $self->chat("You have $curl\n");
            my @common = (
                '--location',
                '--user-agent', $self->agent,
                ($self->{verbose} ? () : '-s'),
            );
            $self->{_backends}{get} = sub {
                my($self, $uri) = @_;
                $self->safeexec( my $fh, $curl, @common, $uri ) or die "curl $uri: $!";
                local $/;
                <$fh>;
            };
            $self->{_backends}{mirror} = sub {
                my($self, $uri, $path) = @_;
                $self->safeexec( my $fh, $curl, @common, $uri, '-#', '-o', $path ) or die "curl $uri: $!";
                local $/;
                <$fh>;
            };
        } else {
            require HTTP::Tiny;
            $self->chat("Falling back to HTTP::Tiny $HTTP::Tiny::VERSION\n");
            my %common = (
                agent => $self->agent,
            );
            $self->{_backends}{get} = sub {
                my $self = shift;
                my $res = HTTP::Tiny->new(%common)->get($_[0]);
                return unless $res->{success};
                return $res->{content};
            };
            $self->{_backends}{mirror} = sub {
                my $self = shift;
                my $res = HTTP::Tiny->new(%common)->mirror(@_);
                return $res->{status};
            };
        }
    
        my $tar = $self->which('tar');
        my $tar_ver;
        my $maybe_bad_tar = sub { WIN32 || BAD_TAR || (($tar_ver = `$tar --version 2>/dev/null`) =~ /GNU.*1\.13/i) };
    
        if ($tar && !$maybe_bad_tar->()) {
            chomp $tar_ver;
            $self->chat("You have $tar: $tar_ver\n");
            $self->{_backends}{untar} = sub {
                my($self, $tarfile) = @_;
    
                my $xf = ($self->{verbose} ? 'v' : '')."xf";
                my $ar = $tarfile =~ /bz2$/ ? 'j' : 'z';
    
                my($root, @others) = `$tar ${ar}tf $tarfile`
                    or return undef;
    
                FILE: {
                    chomp $root;
                    $root =~ s!^\./!!;
                    $root =~ s{^(.+?)/.*$}{$1};
    
                    if (!length($root)) {
                        # archive had ./ as the first entry, so try again
                        $root = shift(@others);
                        redo FILE if $root;
                    }
                }
    
                system "$tar $ar$xf $tarfile";
                return $root if -d $root;
    
                $self->diag_fail("Bad archive: $tarfile");
                return undef;
            }
        } elsif (    $tar
                 and my $gzip = $self->which('gzip')
                 and my $bzip2 = $self->which('bzip2')) {
            $self->chat("You have $tar, $gzip and $bzip2\n");
            $self->{_backends}{untar} = sub {
                my($self, $tarfile) = @_;
    
                my $x  = "x" . ($self->{verbose} ? 'v' : '') . "f -";
                my $ar = $tarfile =~ /bz2$/ ? $bzip2 : $gzip;
    
                my($root, @others) = `$ar -dc $tarfile | $tar tf -`
                    or return undef;
    
                FILE: {
                    chomp $root;
                    $root =~ s!^\./!!;
                    $root =~ s{^(.+?)/.*$}{$1};
    
                    if (!length($root)) {
                        # archive had ./ as the first entry, so try again
                        $root = shift(@others);
                        redo FILE if $root;
                    }
                }
    
                system "$ar -dc $tarfile | $tar $x";
                return $root if -d $root;
    
                $self->diag_fail("Bad archive: $tarfile");
                return undef;
            }
        } elsif (eval { require Archive::Tar }) { # uses too much memory!
            $self->chat("Falling back to Archive::Tar $Archive::Tar::VERSION\n");
            $self->{_backends}{untar} = sub {
                my $self = shift;
                my $t = Archive::Tar->new($_[0]);
                my($root, @others) = $t->list_files;
                FILE: {
                    $root =~ s!^\./!!;
                    $root =~ s{^(.+?)/.*$}{$1};
    
                    if (!length($root)) {
                        # archive had ./ as the first entry, so try again
                        $root = shift(@others);
                        redo FILE if $root;
                    }
                }
                $t->extract;
                return -d $root ? $root : undef;
            };
        } else {
            $self->{_backends}{untar} = sub {
                die "Failed to extract $_[1] - You need to have tar or Archive::Tar installed.\n";
            };
        }
    
        if (my $unzip = $self->which('unzip')) {
            $self->chat("You have $unzip\n");
            $self->{_backends}{unzip} = sub {
                my($self, $zipfile) = @_;
    
                my $opt = $self->{verbose} ? '' : '-q';
                my(undef, $root, @others) = `$unzip -t $zipfile`
                    or return undef;
    
                chomp $root;
                $root =~ s{^\s+testing:\s+([^/]+)/.*?\s+OK$}{$1};
    
                system "$unzip $opt $zipfile";
                return $root if -d $root;
    
                $self->diag_fail("Bad archive: [$root] $zipfile");
                return undef;
            }
        } else {
            $self->{_backends}{unzip} = sub {
                eval { require Archive::Zip }
                    or  die "Failed to extract $_[1] - You need to have unzip or Archive::Zip installed.\n";
                my($self, $file) = @_;
                my $zip = Archive::Zip->new();
                my $status;
                $status = $zip->read($file);
                $self->diag_fail("Read of file[$file] failed")
                    if $status != Archive::Zip::AZ_OK();
                my @members = $zip->members();
                for my $member ( @members ) {
                    my $af = $member->fileName();
                    next if ($af =~ m!^(/|\.\./)!);
                    $status = $member->extractToFileNamed( $af );
                    $self->diag_fail("Extracting of file[$af] from zipfile[$file failed")
                        if $status != Archive::Zip::AZ_OK();
                }
    
                my ($root) = $zip->membersMatching( qr<^[^/]+/$> );
                $root &&= $root->fileName;
                return -d $root ? $root : undef;
            };
        }
    }
    
    sub safeexec {
        my $self = shift;
        my $rdr = $_[0] ||= Symbol::gensym();
    
        if (WIN32) {
            my $cmd = $self->shell_quote(@_[1..$#_]);
            return open( $rdr, "$cmd |" );
        }
    
        if ( my $pid = open( $rdr, '-|' ) ) {
            return $pid;
        }
        elsif ( defined $pid ) {
            exec( @_[ 1 .. $#_ ] );
            exit 1;
        }
        else {
            return;
        }
    }
    
    sub mask_uri_passwords {
        my($self, @strings) = @_;
        s{ (https?://) ([^:/]+) : [^@/]+ @ }{$1$2:********@}gx for @strings;
        return @strings;
    }
    
    1;
  APP_CPANMINUS_SCRIPT
  
  $fatpacked{"CPAN/DistnameInfo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_DISTNAMEINFO';
    
    package CPAN::DistnameInfo;
    
    $VERSION = "0.12";
    use strict;
    
    sub distname_info {
      my $file = shift or return;
    
      my ($dist, $version) = $file =~ /^
        ((?:[-+.]*(?:[A-Za-z0-9]+|(?<=\D)_|_(?=\D))*
         (?:
    	[A-Za-z](?=[^A-Za-z]|$)
    	|
    	\d(?=-)
         )(?<![._-][vV])
        )+)(.*)
      $/xs or return ($file,undef,undef);
    
      if ($dist =~ /-undef\z/ and ! length $version) {
        $dist =~ s/-undef\z//;
      }
    
      # Remove potential -withoutworldwriteables suffix
      $version =~ s/-withoutworldwriteables$//;
    
      if ($version =~ /^(-[Vv].*)-(\d.*)/) {
       
        # Catch names like Unicode-Collate-Standard-V3_1_1-0.1
        # where the V3_1_1 is part of the distname
        $dist .= $1;
        $version = $2;
      }
    
      if ($version =~ /(.+_.*)-(\d.*)/) {
          # Catch names like Task-Deprecations5_14-1.00.tar.gz where the 5_14 is
          # part of the distname. However, names like libao-perl_0.03-1.tar.gz
          # should still have 0.03-1 as their version.
          $dist .= $1;
          $version = $2;
      }
    
      # Normalize the Dist.pm-1.23 convention which CGI.pm and
      # a few others use.
      $dist =~ s{\.pm$}{};
    
      $version = $1
        if !length $version and $dist =~ s/-(\d+\w)$//;
    
      $version = $1 . $version
        if $version =~ /^\d+$/ and $dist =~ s/-(\w+)$//;
    
      if ($version =~ /\d\.\d/) {
        $version =~ s/^[-_.]+//;
      }
      else {
        $version =~ s/^[-_]+//;
      }
    
      my $dev;
      if (length $version) {
        if ($file =~ /^perl-?\d+\.(\d+)(?:\D(\d+))?(-(?:TRIAL|RC)\d+)?$/) {
          $dev = 1 if (($1 > 6 and $1 & 1) or ($2 and $2 >= 50)) or $3;
        }
        elsif ($version =~ /\d\D\d+_\d/ or $version =~ /-TRIAL/) {
          $dev = 1;
        }
      }
      else {
        $version = undef;
      }
    
      ($dist, $version, $dev);
    }
    
    sub new {
      my $class = shift;
      my $distfile = shift;
    
      $distfile =~ s,//+,/,g;
    
      my %info = ( pathname => $distfile );
    
      ($info{filename} = $distfile) =~ s,^(((.*?/)?authors/)?id/)?([A-Z])/(\4[A-Z])/(\5[-A-Z0-9]*)/,,
        and $info{cpanid} = $6;
    
      if ($distfile =~ m,([^/]+)\.(tar\.(?:g?z|bz2)|zip|tgz)$,i) { # support more ?
        $info{distvname} = $1;
        $info{extension} = $2;
      }
    
      @info{qw(dist version beta)} = distname_info($info{distvname});
      $info{maturity} = delete $info{beta} ? 'developer' : 'released';
    
      return bless \%info, $class;
    }
    
    sub dist      { shift->{dist} }
    sub version   { shift->{version} }
    sub maturity  { shift->{maturity} }
    sub filename  { shift->{filename} }
    sub cpanid    { shift->{cpanid} }
    sub distvname { shift->{distvname} }
    sub extension { shift->{extension} }
    sub pathname  { shift->{pathname} }
    
    sub properties { %{ $_[0] } }
    
    1;
    
    __END__
    
    =head1 NAME
    
    CPAN::DistnameInfo - Extract distribution name and version from a distribution filename
    
    =head1 SYNOPSIS
    
      my $pathname = "authors/id/G/GB/GBARR/CPAN-DistnameInfo-0.02.tar.gz";
    
      my $d = CPAN::DistnameInfo->new($pathname);
    
      my $dist      = $d->dist;      # "CPAN-DistnameInfo"
      my $version   = $d->version;   # "0.02"
      my $maturity  = $d->maturity;  # "released"
      my $filename  = $d->filename;  # "CPAN-DistnameInfo-0.02.tar.gz"
      my $cpanid    = $d->cpanid;    # "GBARR"
      my $distvname = $d->distvname; # "CPAN-DistnameInfo-0.02"
      my $extension = $d->extension; # "tar.gz"
      my $pathname  = $d->pathname;  # "authors/id/G/GB/GBARR/..."
    
      my %prop = $d->properties;
    
    =head1 DESCRIPTION
    
    Many online services that are centered around CPAN attempt to
    associate multiple uploads by extracting a distribution name from
    the filename of the upload. For most distributions this is easy as
    they have used ExtUtils::MakeMaker or Module::Build to create the
    distribution, which results in a uniform name. But sadly not all
    uploads are created in this way.
    
    C<CPAN::DistnameInfo> uses heuristics that have been learnt by
    L<http://search.cpan.org/> to extract the distribution name and
    version from filenames and also report if the version is to be
    treated as a developer release
    
    The constructor takes a single pathname, returning an object with the following methods
    
    =over
    
    =item cpanid
    
    If the path given looked like a CPAN authors directory path, then this will be the
    the CPAN id of the author.
    
    =item dist
    
    The name of the distribution
    
    =item distvname
    
    The file name with any suffix and leading directory names removed
    
    =item filename
    
    If the path given looked like a CPAN authors directory path, then this will be the
    path to the file relative to the detected CPAN author directory. Otherwise it is the path
    that was passed in.
    
    =item maturity
    
    The maturity of the distribution. This will be either C<released> or C<developer>
    
    =item extension
    
    The extension of the distribution, often used to denote the archive type (e.g. 'tar.gz')
    
    =item pathname
    
    The pathname that was passed to the constructor when creating the object.
    
    =item properties
    
    This will return a list of key-value pairs, suitable for assigning to a hash,
    for the known properties.
    
    =item version
    
    The extracted version
    
    =back
    
    =head1 AUTHOR
    
    Graham Barr <gbarr@pobox.com>
    
    =head1 COPYRIGHT 
    
    Copyright (c) 2003 Graham Barr. All rights reserved. This program is
    free software; you can redistribute it and/or modify it under the same
    terms as Perl itself.
    
    =cut
    
  CPAN_DISTNAMEINFO
  
  $fatpacked{"CPAN/Meta.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META';
    use 5.006;
    use strict;
    use warnings;
    package CPAN::Meta;
    
    our $VERSION = '2.150005';
    
    #pod =head1 SYNOPSIS
    #pod
    #pod     use v5.10;
    #pod     use strict;
    #pod     use warnings;
    #pod     use CPAN::Meta;
    #pod     use Module::Load;
    #pod
    #pod     my $meta = CPAN::Meta->load_file('META.json');
    #pod
    #pod     printf "testing requirements for %s version %s\n",
    #pod     $meta->name,
    #pod     $meta->version;
    #pod
    #pod     my $prereqs = $meta->effective_prereqs;
    #pod
    #pod     for my $phase ( qw/configure runtime build test/ ) {
    #pod         say "Requirements for $phase:";
    #pod         my $reqs = $prereqs->requirements_for($phase, "requires");
    #pod         for my $module ( sort $reqs->required_modules ) {
    #pod             my $status;
    #pod             if ( eval { load $module unless $module eq 'perl'; 1 } ) {
    #pod                 my $version = $module eq 'perl' ? $] : $module->VERSION;
    #pod                 $status = $reqs->accepts_module($module, $version)
    #pod                         ? "$version ok" : "$version not ok";
    #pod             } else {
    #pod                 $status = "missing"
    #pod             };
    #pod             say "  $module ($status)";
    #pod         }
    #pod     }
    #pod
    #pod =head1 DESCRIPTION
    #pod
    #pod Software distributions released to the CPAN include a F<META.json> or, for
    #pod older distributions, F<META.yml>, which describes the distribution, its
    #pod contents, and the requirements for building and installing the distribution.
    #pod The data structure stored in the F<META.json> file is described in
    #pod L<CPAN::Meta::Spec>.
    #pod
    #pod CPAN::Meta provides a simple class to represent this distribution metadata (or
    #pod I<distmeta>), along with some helpful methods for interrogating that data.
    #pod
    #pod The documentation below is only for the methods of the CPAN::Meta object.  For
    #pod information on the meaning of individual fields, consult the spec.
    #pod
    #pod =cut
    
    use Carp qw(carp croak);
    use CPAN::Meta::Feature;
    use CPAN::Meta::Prereqs;
    use CPAN::Meta::Converter;
    use CPAN::Meta::Validator;
    use Parse::CPAN::Meta 1.4414 ();
    
    BEGIN { *_dclone = \&CPAN::Meta::Converter::_dclone }
    
    #pod =head1 STRING DATA
    #pod
    #pod The following methods return a single value, which is the value for the
    #pod corresponding entry in the distmeta structure.  Values should be either undef
    #pod or strings.
    #pod
    #pod =for :list
    #pod * abstract
    #pod * description
    #pod * dynamic_config
    #pod * generated_by
    #pod * name
    #pod * release_status
    #pod * version
    #pod
    #pod =cut
    
    BEGIN {
      my @STRING_READERS = qw(
        abstract
        description
        dynamic_config
        generated_by
        name
        release_status
        version
      );
    
      no strict 'refs';
      for my $attr (@STRING_READERS) {
        *$attr = sub { $_[0]{ $attr } };
      }
    }
    
    #pod =head1 LIST DATA
    #pod
    #pod These methods return lists of string values, which might be represented in the
    #pod distmeta structure as arrayrefs or scalars:
    #pod
    #pod =for :list
    #pod * authors
    #pod * keywords
    #pod * licenses
    #pod
    #pod The C<authors> and C<licenses> methods may also be called as C<author> and
    #pod C<license>, respectively, to match the field name in the distmeta structure.
    #pod
    #pod =cut
    
    BEGIN {
      my @LIST_READERS = qw(
        author
        keywords
        license
      );
    
      no strict 'refs';
      for my $attr (@LIST_READERS) {
        *$attr = sub {
          my $value = $_[0]{ $attr };
          croak "$attr must be called in list context"
            unless wantarray;
          return @{ _dclone($value) } if ref $value;
          return $value;
        };
      }
    }
    
    sub authors  { $_[0]->author }
    sub licenses { $_[0]->license }
    
    #pod =head1 MAP DATA
    #pod
    #pod These readers return hashrefs of arbitrary unblessed data structures, each
    #pod described more fully in the specification:
    #pod
    #pod =for :list
    #pod * meta_spec
    #pod * resources
    #pod * provides
    #pod * no_index
    #pod * prereqs
    #pod * optional_features
    #pod
    #pod =cut
    
    BEGIN {
      my @MAP_READERS = qw(
        meta-spec
        resources
        provides
        no_index
    
        prereqs
        optional_features
      );
    
      no strict 'refs';
      for my $attr (@MAP_READERS) {
        (my $subname = $attr) =~ s/-/_/;
        *$subname = sub {
          my $value = $_[0]{ $attr };
          return _dclone($value) if $value;
          return {};
        };
      }
    }
    
    #pod =head1 CUSTOM DATA
    #pod
    #pod A list of custom keys are available from the C<custom_keys> method and
    #pod particular keys may be retrieved with the C<custom> method.
    #pod
    #pod   say $meta->custom($_) for $meta->custom_keys;
    #pod
    #pod If a custom key refers to a data structure, a deep clone is returned.
    #pod
    #pod =cut
    
    sub custom_keys {
      return grep { /^x_/i } keys %{$_[0]};
    }
    
    sub custom {
      my ($self, $attr) = @_;
      my $value = $self->{$attr};
      return _dclone($value) if ref $value;
      return $value;
    }
    
    #pod =method new
    #pod
    #pod   my $meta = CPAN::Meta->new($distmeta_struct, \%options);
    #pod
    #pod Returns a valid CPAN::Meta object or dies if the supplied metadata hash
    #pod reference fails to validate.  Older-format metadata will be up-converted to
    #pod version 2 if they validate against the original stated specification.
    #pod
    #pod It takes an optional hashref of options. Valid options include:
    #pod
    #pod =over
    #pod
    #pod =item *
    #pod
    #pod lazy_validation -- if true, new will attempt to convert the given metadata
    #pod to version 2 before attempting to validate it.  This means than any
    #pod fixable errors will be handled by CPAN::Meta::Converter before validation.
    #pod (Note that this might result in invalid optional data being silently
    #pod dropped.)  The default is false.
    #pod
    #pod =back
    #pod
    #pod =cut
    
    sub _new {
      my ($class, $struct, $options) = @_;
      my $self;
    
      if ( $options->{lazy_validation} ) {
        # try to convert to a valid structure; if succeeds, then return it
        my $cmc = CPAN::Meta::Converter->new( $struct );
        $self = $cmc->convert( version => 2 ); # valid or dies
        return bless $self, $class;
      }
      else {
        # validate original struct
        my $cmv = CPAN::Meta::Validator->new( $struct );
        unless ( $cmv->is_valid) {
          die "Invalid metadata structure. Errors: "
            . join(", ", $cmv->errors) . "\n";
        }
      }
    
      # up-convert older spec versions
      my $version = $struct->{'meta-spec'}{version} || '1.0';
      if ( $version == 2 ) {
        $self = $struct;
      }
      else {
        my $cmc = CPAN::Meta::Converter->new( $struct );
        $self = $cmc->convert( version => 2 );
      }
    
      return bless $self, $class;
    }
    
    sub new {
      my ($class, $struct, $options) = @_;
      my $self = eval { $class->_new($struct, $options) };
      croak($@) if $@;
      return $self;
    }
    
    #pod =method create
    #pod
    #pod   my $meta = CPAN::Meta->create($distmeta_struct, \%options);
    #pod
    #pod This is same as C<new()>, except that C<generated_by> and C<meta-spec> fields
    #pod will be generated if not provided.  This means the metadata structure is
    #pod assumed to otherwise follow the latest L<CPAN::Meta::Spec>.
    #pod
    #pod =cut
    
    sub create {
      my ($class, $struct, $options) = @_;
      my $version = __PACKAGE__->VERSION || 2;
      $struct->{generated_by} ||= __PACKAGE__ . " version $version" ;
      $struct->{'meta-spec'}{version} ||= int($version);
      my $self = eval { $class->_new($struct, $options) };
      croak ($@) if $@;
      return $self;
    }
    
    #pod =method load_file
    #pod
    #pod   my $meta = CPAN::Meta->load_file($distmeta_file, \%options);
    #pod
    #pod Given a pathname to a file containing metadata, this deserializes the file
    #pod according to its file suffix and constructs a new C<CPAN::Meta> object, just
    #pod like C<new()>.  It will die if the deserialized version fails to validate
    #pod against its stated specification version.
    #pod
    #pod It takes the same options as C<new()> but C<lazy_validation> defaults to
    #pod true.
    #pod
    #pod =cut
    
    sub load_file {
      my ($class, $file, $options) = @_;
      $options->{lazy_validation} = 1 unless exists $options->{lazy_validation};
    
      croak "load_file() requires a valid, readable filename"
        unless -r $file;
    
      my $self;
      eval {
        my $struct = Parse::CPAN::Meta->load_file( $file );
        $self = $class->_new($struct, $options);
      };
      croak($@) if $@;
      return $self;
    }
    
    #pod =method load_yaml_string
    #pod
    #pod   my $meta = CPAN::Meta->load_yaml_string($yaml, \%options);
    #pod
    #pod This method returns a new CPAN::Meta object using the first document in the
    #pod given YAML string.  In other respects it is identical to C<load_file()>.
    #pod
    #pod =cut
    
    sub load_yaml_string {
      my ($class, $yaml, $options) = @_;
      $options->{lazy_validation} = 1 unless exists $options->{lazy_validation};
    
      my $self;
      eval {
        my ($struct) = Parse::CPAN::Meta->load_yaml_string( $yaml );
        $self = $class->_new($struct, $options);
      };
      croak($@) if $@;
      return $self;
    }
    
    #pod =method load_json_string
    #pod
    #pod   my $meta = CPAN::Meta->load_json_string($json, \%options);
    #pod
    #pod This method returns a new CPAN::Meta object using the structure represented by
    #pod the given JSON string.  In other respects it is identical to C<load_file()>.
    #pod
    #pod =cut
    
    sub load_json_string {
      my ($class, $json, $options) = @_;
      $options->{lazy_validation} = 1 unless exists $options->{lazy_validation};
    
      my $self;
      eval {
        my $struct = Parse::CPAN::Meta->load_json_string( $json );
        $self = $class->_new($struct, $options);
      };
      croak($@) if $@;
      return $self;
    }
    
    #pod =method load_string
    #pod
    #pod   my $meta = CPAN::Meta->load_string($string, \%options);
    #pod
    #pod If you don't know if a string contains YAML or JSON, this method will use
    #pod L<Parse::CPAN::Meta> to guess.  In other respects it is identical to
    #pod C<load_file()>.
    #pod
    #pod =cut
    
    sub load_string {
      my ($class, $string, $options) = @_;
      $options->{lazy_validation} = 1 unless exists $options->{lazy_validation};
    
      my $self;
      eval {
        my $struct = Parse::CPAN::Meta->load_string( $string );
        $self = $class->_new($struct, $options);
      };
      croak($@) if $@;
      return $self;
    }
    
    #pod =method save
    #pod
    #pod   $meta->save($distmeta_file, \%options);
    #pod
    #pod Serializes the object as JSON and writes it to the given file.  The only valid
    #pod option is C<version>, which defaults to '2'. On Perl 5.8.1 or later, the file
    #pod is saved with UTF-8 encoding.
    #pod
    #pod For C<version> 2 (or higher), the filename should end in '.json'.  L<JSON::PP>
    #pod is the default JSON backend. Using another JSON backend requires L<JSON> 2.5 or
    #pod later and you must set the C<$ENV{PERL_JSON_BACKEND}> to a supported alternate
    #pod backend like L<JSON::XS>.
    #pod
    #pod For C<version> less than 2, the filename should end in '.yml'.
    #pod L<CPAN::Meta::Converter> is used to generate an older metadata structure, which
    #pod is serialized to YAML.  CPAN::Meta::YAML is the default YAML backend.  You may
    #pod set the C<$ENV{PERL_YAML_BACKEND}> to a supported alternative backend, though
    #pod this is not recommended due to subtle incompatibilities between YAML parsers on
    #pod CPAN.
    #pod
    #pod =cut
    
    sub save {
      my ($self, $file, $options) = @_;
    
      my $version = $options->{version} || '2';
      my $layer = $] ge '5.008001' ? ':utf8' : '';
    
      if ( $version ge '2' ) {
        carp "'$file' should end in '.json'"
          unless $file =~ m{\.json$};
      }
      else {
        carp "'$file' should end in '.yml'"
          unless $file =~ m{\.yml$};
      }
    
      my $data = $self->as_string( $options );
      open my $fh, ">$layer", $file
        or die "Error opening '$file' for writing: $!\n";
    
      print {$fh} $data;
      close $fh
        or die "Error closing '$file': $!\n";
    
      return 1;
    }
    
    #pod =method meta_spec_version
    #pod
    #pod This method returns the version part of the C<meta_spec> entry in the distmeta
    #pod structure.  It is equivalent to:
    #pod
    #pod   $meta->meta_spec->{version};
    #pod
    #pod =cut
    
    sub meta_spec_version {
      my ($self) = @_;
      return $self->meta_spec->{version};
    }
    
    #pod =method effective_prereqs
    #pod
    #pod   my $prereqs = $meta->effective_prereqs;
    #pod
    #pod   my $prereqs = $meta->effective_prereqs( \@feature_identifiers );
    #pod
    #pod This method returns a L<CPAN::Meta::Prereqs> object describing all the
    #pod prereqs for the distribution.  If an arrayref of feature identifiers is given,
    #pod the prereqs for the identified features are merged together with the
    #pod distribution's core prereqs before the CPAN::Meta::Prereqs object is returned.
    #pod
    #pod =cut
    
    sub effective_prereqs {
      my ($self, $features) = @_;
      $features ||= [];
    
      my $prereq = CPAN::Meta::Prereqs->new($self->prereqs);
    
      return $prereq unless @$features;
    
      my @other = map {; $self->feature($_)->prereqs } @$features;
    
      return $prereq->with_merged_prereqs(\@other);
    }
    
    #pod =method should_index_file
    #pod
    #pod   ... if $meta->should_index_file( $filename );
    #pod
    #pod This method returns true if the given file should be indexed.  It decides this
    #pod by checking the C<file> and C<directory> keys in the C<no_index> property of
    #pod the distmeta structure. Note that neither the version format nor
    #pod C<release_status> are considered.
    #pod
    #pod C<$filename> should be given in unix format.
    #pod
    #pod =cut
    
    sub should_index_file {
      my ($self, $filename) = @_;
    
      for my $no_index_file (@{ $self->no_index->{file} || [] }) {
        return if $filename eq $no_index_file;
      }
    
      for my $no_index_dir (@{ $self->no_index->{directory} }) {
        $no_index_dir =~ s{$}{/} unless $no_index_dir =~ m{/\z};
        return if index($filename, $no_index_dir) == 0;
      }
    
      return 1;
    }
    
    #pod =method should_index_package
    #pod
    #pod   ... if $meta->should_index_package( $package );
    #pod
    #pod This method returns true if the given package should be indexed.  It decides
    #pod this by checking the C<package> and C<namespace> keys in the C<no_index>
    #pod property of the distmeta structure. Note that neither the version format nor
    #pod C<release_status> are considered.
    #pod
    #pod =cut
    
    sub should_index_package {
      my ($self, $package) = @_;
    
      for my $no_index_pkg (@{ $self->no_index->{package} || [] }) {
        return if $package eq $no_index_pkg;
      }
    
      for my $no_index_ns (@{ $self->no_index->{namespace} }) {
        return if index($package, "${no_index_ns}::") == 0;
      }
    
      return 1;
    }
    
    #pod =method features
    #pod
    #pod   my @feature_objects = $meta->features;
    #pod
    #pod This method returns a list of L<CPAN::Meta::Feature> objects, one for each
    #pod optional feature described by the distribution's metadata.
    #pod
    #pod =cut
    
    sub features {
      my ($self) = @_;
    
      my $opt_f = $self->optional_features;
      my @features = map {; CPAN::Meta::Feature->new($_ => $opt_f->{ $_ }) }
                     keys %$opt_f;
    
      return @features;
    }
    
    #pod =method feature
    #pod
    #pod   my $feature_object = $meta->feature( $identifier );
    #pod
    #pod This method returns a L<CPAN::Meta::Feature> object for the optional feature
    #pod with the given identifier.  If no feature with that identifier exists, an
    #pod exception will be raised.
    #pod
    #pod =cut
    
    sub feature {
      my ($self, $ident) = @_;
    
      croak "no feature named $ident"
        unless my $f = $self->optional_features->{ $ident };
    
      return CPAN::Meta::Feature->new($ident, $f);
    }
    
    #pod =method as_struct
    #pod
    #pod   my $copy = $meta->as_struct( \%options );
    #pod
    #pod This method returns a deep copy of the object's metadata as an unblessed hash
    #pod reference.  It takes an optional hashref of options.  If the hashref contains
    #pod a C<version> argument, the copied metadata will be converted to the version
    #pod of the specification and returned.  For example:
    #pod
    #pod   my $old_spec = $meta->as_struct( {version => "1.4"} );
    #pod
    #pod =cut
    
    sub as_struct {
      my ($self, $options) = @_;
      my $struct = _dclone($self);
      if ( $options->{version} ) {
        my $cmc = CPAN::Meta::Converter->new( $struct );
        $struct = $cmc->convert( version => $options->{version} );
      }
      return $struct;
    }
    
    #pod =method as_string
    #pod
    #pod   my $string = $meta->as_string( \%options );
    #pod
    #pod This method returns a serialized copy of the object's metadata as a character
    #pod string.  (The strings are B<not> UTF-8 encoded.)  It takes an optional hashref
    #pod of options.  If the hashref contains a C<version> argument, the copied metadata
    #pod will be converted to the version of the specification and returned.  For
    #pod example:
    #pod
    #pod   my $string = $meta->as_string( {version => "1.4"} );
    #pod
    #pod For C<version> greater than or equal to 2, the string will be serialized as
    #pod JSON.  For C<version> less than 2, the string will be serialized as YAML.  In
    #pod both cases, the same rules are followed as in the C<save()> method for choosing
    #pod a serialization backend.
    #pod
    #pod The serialized structure will include a C<x_serialization_backend> entry giving
    #pod the package and version used to serialize.  Any existing key in the given
    #pod C<$meta> object will be clobbered.
    #pod
    #pod =cut
    
    sub as_string {
      my ($self, $options) = @_;
    
      my $version = $options->{version} || '2';
    
      my $struct;
      if ( $self->meta_spec_version ne $version ) {
        my $cmc = CPAN::Meta::Converter->new( $self->as_struct );
        $struct = $cmc->convert( version => $version );
      }
      else {
        $struct = $self->as_struct;
      }
    
      my ($data, $backend);
      if ( $version ge '2' ) {
        $backend = Parse::CPAN::Meta->json_backend();
        local $struct->{x_serialization_backend} = sprintf '%s version %s',
          $backend, $backend->VERSION;
        $data = $backend->new->pretty->canonical->encode($struct);
      }
      else {
        $backend = Parse::CPAN::Meta->yaml_backend();
        local $struct->{x_serialization_backend} = sprintf '%s version %s',
          $backend, $backend->VERSION;
        $data = eval { no strict 'refs'; &{"$backend\::Dump"}($struct) };
        if ( $@ ) {
          croak $backend->can('errstr') ? $backend->errstr : $@
        }
      }
    
      return $data;
    }
    
    # Used by JSON::PP, etc. for "convert_blessed"
    sub TO_JSON {
      return { %{ $_[0] } };
    }
    
    1;
    
    # ABSTRACT: the distribution metadata for a CPAN dist
    
    =pod
    
    =encoding UTF-8
    
    =head1 NAME
    
    CPAN::Meta - the distribution metadata for a CPAN dist
    
    =head1 VERSION
    
    version 2.150005
    
    =head1 SYNOPSIS
    
        use v5.10;
        use strict;
        use warnings;
        use CPAN::Meta;
        use Module::Load;
    
        my $meta = CPAN::Meta->load_file('META.json');
    
        printf "testing requirements for %s version %s\n",
        $meta->name,
        $meta->version;
    
        my $prereqs = $meta->effective_prereqs;
    
        for my $phase ( qw/configure runtime build test/ ) {
            say "Requirements for $phase:";
            my $reqs = $prereqs->requirements_for($phase, "requires");
            for my $module ( sort $reqs->required_modules ) {
                my $status;
                if ( eval { load $module unless $module eq 'perl'; 1 } ) {
                    my $version = $module eq 'perl' ? $] : $module->VERSION;
                    $status = $reqs->accepts_module($module, $version)
                            ? "$version ok" : "$version not ok";
                } else {
                    $status = "missing"
                };
                say "  $module ($status)";
            }
        }
    
    =head1 DESCRIPTION
    
    Software distributions released to the CPAN include a F<META.json> or, for
    older distributions, F<META.yml>, which describes the distribution, its
    contents, and the requirements for building and installing the distribution.
    The data structure stored in the F<META.json> file is described in
    L<CPAN::Meta::Spec>.
    
    CPAN::Meta provides a simple class to represent this distribution metadata (or
    I<distmeta>), along with some helpful methods for interrogating that data.
    
    The documentation below is only for the methods of the CPAN::Meta object.  For
    information on the meaning of individual fields, consult the spec.
    
    =head1 METHODS
    
    =head2 new
    
      my $meta = CPAN::Meta->new($distmeta_struct, \%options);
    
    Returns a valid CPAN::Meta object or dies if the supplied metadata hash
    reference fails to validate.  Older-format metadata will be up-converted to
    version 2 if they validate against the original stated specification.
    
    It takes an optional hashref of options. Valid options include:
    
    =over
    
    =item *
    
    lazy_validation -- if true, new will attempt to convert the given metadata
    to version 2 before attempting to validate it.  This means than any
    fixable errors will be handled by CPAN::Meta::Converter before validation.
    (Note that this might result in invalid optional data being silently
    dropped.)  The default is false.
    
    =back
    
    =head2 create
    
      my $meta = CPAN::Meta->create($distmeta_struct, \%options);
    
    This is same as C<new()>, except that C<generated_by> and C<meta-spec> fields
    will be generated if not provided.  This means the metadata structure is
    assumed to otherwise follow the latest L<CPAN::Meta::Spec>.
    
    =head2 load_file
    
      my $meta = CPAN::Meta->load_file($distmeta_file, \%options);
    
    Given a pathname to a file containing metadata, this deserializes the file
    according to its file suffix and constructs a new C<CPAN::Meta> object, just
    like C<new()>.  It will die if the deserialized version fails to validate
    against its stated specification version.
    
    It takes the same options as C<new()> but C<lazy_validation> defaults to
    true.
    
    =head2 load_yaml_string
    
      my $meta = CPAN::Meta->load_yaml_string($yaml, \%options);
    
    This method returns a new CPAN::Meta object using the first document in the
    given YAML string.  In other respects it is identical to C<load_file()>.
    
    =head2 load_json_string
    
      my $meta = CPAN::Meta->load_json_string($json, \%options);
    
    This method returns a new CPAN::Meta object using the structure represented by
    the given JSON string.  In other respects it is identical to C<load_file()>.
    
    =head2 load_string
    
      my $meta = CPAN::Meta->load_string($string, \%options);
    
    If you don't know if a string contains YAML or JSON, this method will use
    L<Parse::CPAN::Meta> to guess.  In other respects it is identical to
    C<load_file()>.
    
    =head2 save
    
      $meta->save($distmeta_file, \%options);
    
    Serializes the object as JSON and writes it to the given file.  The only valid
    option is C<version>, which defaults to '2'. On Perl 5.8.1 or later, the file
    is saved with UTF-8 encoding.
    
    For C<version> 2 (or higher), the filename should end in '.json'.  L<JSON::PP>
    is the default JSON backend. Using another JSON backend requires L<JSON> 2.5 or
    later and you must set the C<$ENV{PERL_JSON_BACKEND}> to a supported alternate
    backend like L<JSON::XS>.
    
    For C<version> less than 2, the filename should end in '.yml'.
    L<CPAN::Meta::Converter> is used to generate an older metadata structure, which
    is serialized to YAML.  CPAN::Meta::YAML is the default YAML backend.  You may
    set the C<$ENV{PERL_YAML_BACKEND}> to a supported alternative backend, though
    this is not recommended due to subtle incompatibilities between YAML parsers on
    CPAN.
    
    =head2 meta_spec_version
    
    This method returns the version part of the C<meta_spec> entry in the distmeta
    structure.  It is equivalent to:
    
      $meta->meta_spec->{version};
    
    =head2 effective_prereqs
    
      my $prereqs = $meta->effective_prereqs;
    
      my $prereqs = $meta->effective_prereqs( \@feature_identifiers );
    
    This method returns a L<CPAN::Meta::Prereqs> object describing all the
    prereqs for the distribution.  If an arrayref of feature identifiers is given,
    the prereqs for the identified features are merged together with the
    distribution's core prereqs before the CPAN::Meta::Prereqs object is returned.
    
    =head2 should_index_file
    
      ... if $meta->should_index_file( $filename );
    
    This method returns true if the given file should be indexed.  It decides this
    by checking the C<file> and C<directory> keys in the C<no_index> property of
    the distmeta structure. Note that neither the version format nor
    C<release_status> are considered.
    
    C<$filename> should be given in unix format.
    
    =head2 should_index_package
    
      ... if $meta->should_index_package( $package );
    
    This method returns true if the given package should be indexed.  It decides
    this by checking the C<package> and C<namespace> keys in the C<no_index>
    property of the distmeta structure. Note that neither the version format nor
    C<release_status> are considered.
    
    =head2 features
    
      my @feature_objects = $meta->features;
    
    This method returns a list of L<CPAN::Meta::Feature> objects, one for each
    optional feature described by the distribution's metadata.
    
    =head2 feature
    
      my $feature_object = $meta->feature( $identifier );
    
    This method returns a L<CPAN::Meta::Feature> object for the optional feature
    with the given identifier.  If no feature with that identifier exists, an
    exception will be raised.
    
    =head2 as_struct
    
      my $copy = $meta->as_struct( \%options );
    
    This method returns a deep copy of the object's metadata as an unblessed hash
    reference.  It takes an optional hashref of options.  If the hashref contains
    a C<version> argument, the copied metadata will be converted to the version
    of the specification and returned.  For example:
    
      my $old_spec = $meta->as_struct( {version => "1.4"} );
    
    =head2 as_string
    
      my $string = $meta->as_string( \%options );
    
    This method returns a serialized copy of the object's metadata as a character
    string.  (The strings are B<not> UTF-8 encoded.)  It takes an optional hashref
    of options.  If the hashref contains a C<version> argument, the copied metadata
    will be converted to the version of the specification and returned.  For
    example:
    
      my $string = $meta->as_string( {version => "1.4"} );
    
    For C<version> greater than or equal to 2, the string will be serialized as
    JSON.  For C<version> less than 2, the string will be serialized as YAML.  In
    both cases, the same rules are followed as in the C<save()> method for choosing
    a serialization backend.
    
    The serialized structure will include a C<x_serialization_backend> entry giving
    the package and version used to serialize.  Any existing key in the given
    C<$meta> object will be clobbered.
    
    =head1 STRING DATA
    
    The following methods return a single value, which is the value for the
    corresponding entry in the distmeta structure.  Values should be either undef
    or strings.
    
    =over 4
    
    =item *
    
    abstract
    
    =item *
    
    description
    
    =item *
    
    dynamic_config
    
    =item *
    
    generated_by
    
    =item *
    
    name
    
    =item *
    
    release_status
    
    =item *
    
    version
    
    =back
    
    =head1 LIST DATA
    
    These methods return lists of string values, which might be represented in the
    distmeta structure as arrayrefs or scalars:
    
    =over 4
    
    =item *
    
    authors
    
    =item *
    
    keywords
    
    =item *
    
    licenses
    
    =back
    
    The C<authors> and C<licenses> methods may also be called as C<author> and
    C<license>, respectively, to match the field name in the distmeta structure.
    
    =head1 MAP DATA
    
    These readers return hashrefs of arbitrary unblessed data structures, each
    described more fully in the specification:
    
    =over 4
    
    =item *
    
    meta_spec
    
    =item *
    
    resources
    
    =item *
    
    provides
    
    =item *
    
    no_index
    
    =item *
    
    prereqs
    
    =item *
    
    optional_features
    
    =back
    
    =head1 CUSTOM DATA
    
    A list of custom keys are available from the C<custom_keys> method and
    particular keys may be retrieved with the C<custom> method.
    
      say $meta->custom($_) for $meta->custom_keys;
    
    If a custom key refers to a data structure, a deep clone is returned.
    
    =for Pod::Coverage TO_JSON abstract author authors custom custom_keys description dynamic_config
    generated_by keywords license licenses meta_spec name no_index
    optional_features prereqs provides release_status resources version
    
    =head1 BUGS
    
    Please report any bugs or feature using the CPAN Request Tracker.
    Bugs can be submitted through the web interface at
    L<http://rt.cpan.org/Dist/Display.html?Queue=CPAN-Meta>
    
    When submitting a bug or request, please include a test-file or a patch to an
    existing test-file that illustrates the bug or desired feature.
    
    =head1 SEE ALSO
    
    =over 4
    
    =item *
    
    L<CPAN::Meta::Converter>
    
    =item *
    
    L<CPAN::Meta::Validator>
    
    =back
    
    =for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
    
    =head1 SUPPORT
    
    =head2 Bugs / Feature Requests
    
    Please report any bugs or feature requests through the issue tracker
    at L<https://github.com/Perl-Toolchain-Gang/CPAN-Meta/issues>.
    You will be notified automatically of any progress on your issue.
    
    =head2 Source Code
    
    This is open source software.  The code repository is available for
    public review and contribution under the terms of the license.
    
    L<https://github.com/Perl-Toolchain-Gang/CPAN-Meta>
    
      git clone https://github.com/Perl-Toolchain-Gang/CPAN-Meta.git
    
    =head1 AUTHORS
    
    =over 4
    
    =item *
    
    David Golden <dagolden@cpan.org>
    
    =item *
    
    Ricardo Signes <rjbs@cpan.org>
    
    =back
    
    =head1 CONTRIBUTORS
    
    =for stopwords Ansgar Burchardt Avar Arnfjord Bjarmason Christopher J. Madsen Chuck Adams Cory G Watson Damyan Ivanov Eric Wilhelm Graham Knop Gregor Hermann Karen Etheridge Kenichi Ishigaki Ken Williams Lars Dieckow Leon Timmermans majensen Mark Fowler Matt S Trout Michael G. Schwern mohawk2 moznion Niko Tyni Olaf Alders Olivier Mengué Randy Sims Tomohiro Hosaka
    
    =over 4
    
    =item *
    
    Ansgar Burchardt <ansgar@cpan.org>
    
    =item *
    
    Avar Arnfjord Bjarmason <avar@cpan.org>
    
    =item *
    
    Christopher J. Madsen <cjm@cpan.org>
    
    =item *
    
    Chuck Adams <cja987@gmail.com>
    
    =item *
    
    Cory G Watson <gphat@cpan.org>
    
    =item *
    
    Damyan Ivanov <dam@cpan.org>
    
    =item *
    
    Eric Wilhelm <ewilhelm@cpan.org>
    
    =item *
    
    Graham Knop <haarg@haarg.org>
    
    =item *
    
    Gregor Hermann <gregoa@debian.org>
    
    =item *
    
    Karen Etheridge <ether@cpan.org>
    
    =item *
    
    Kenichi Ishigaki <ishigaki@cpan.org>
    
    =item *
    
    Ken Williams <kwilliams@cpan.org>
    
    =item *
    
    Lars Dieckow <daxim@cpan.org>
    
    =item *
    
    Leon Timmermans <leont@cpan.org>
    
    =item *
    
    majensen <maj@fortinbras.us>
    
    =item *
    
    Mark Fowler <markf@cpan.org>
    
    =item *
    
    Matt S Trout <mst@shadowcat.co.uk>
    
    =item *
    
    Michael G. Schwern <mschwern@cpan.org>
    
    =item *
    
    mohawk2 <mohawk2@users.noreply.github.com>
    
    =item *
    
    moznion <moznion@gmail.com>
    
    =item *
    
    Niko Tyni <ntyni@debian.org>
    
    =item *
    
    Olaf Alders <olaf@wundersolutions.com>
    
    =item *
    
    Olivier Mengué <dolmen@cpan.org>
    
    =item *
    
    Randy Sims <randys@thepierianspring.org>
    
    =item *
    
    Tomohiro Hosaka <bokutin@bokut.in>
    
    =back
    
    =head1 COPYRIGHT AND LICENSE
    
    This software is copyright (c) 2010 by David Golden and Ricardo Signes.
    
    This is free software; you can redistribute it and/or modify it under
    the same terms as the Perl 5 programming language system itself.
    
    =cut
    
    __END__
    
    
    # vim: ts=2 sts=2 sw=2 et :
  CPAN_META
  
  $fatpacked{"CPAN/Meta/Check.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_CHECK';
    package CPAN::Meta::Check;
    $CPAN::Meta::Check::VERSION = '0.012';
    use strict;
    use warnings;
    
    use base 'Exporter';
    our @EXPORT = qw//;
    our @EXPORT_OK = qw/check_requirements requirements_for verify_dependencies/;
    our %EXPORT_TAGS = (all => [ @EXPORT, @EXPORT_OK ] );
    
    use CPAN::Meta::Prereqs '2.132830';
    use CPAN::Meta::Requirements 2.121;
    use Module::Metadata 1.000023;
    
    sub _check_dep {
    	my ($reqs, $module, $dirs) = @_;
    
    	$module eq 'perl' and return ($reqs->accepts_module($module, $]) ? () : sprintf "Your Perl (%s) is not in the range '%s'", $], $reqs->requirements_for_module($module));
    
    	my $metadata = Module::Metadata->new_from_module($module, inc => $dirs);
    	return "Module '$module' is not installed" if not defined $metadata;
    	my $version = eval { $metadata->version };
    	return "Missing version info for module '$module'" if $reqs->requirements_for_module($module) and not $version;
    	return sprintf 'Installed version (%s) of %s is not in range \'%s\'', $version, $module, $reqs->requirements_for_module($module) if not $reqs->accepts_module($module, $version || 0);
    	return;
    }
    
    sub _check_conflict {
    	my ($reqs, $module, $dirs) = @_;
    	my $metadata = Module::Metadata->new_from_module($module, inc => $dirs);
    	return if not defined $metadata;
    	my $version = eval { $metadata->version };
    	return "Missing version info for module '$module'" if not $version;
    	return sprintf 'Installed version (%s) of %s is in range \'%s\'', $version, $module, $reqs->requirements_for_module($module) if $reqs->accepts_module($module, $version);
    	return;
    }
    
    sub requirements_for {
    	my ($meta, $phases, $type) = @_;
    	my $prereqs = ref($meta) eq 'CPAN::Meta' ? $meta->effective_prereqs : $meta;
    	return $prereqs->merged_requirements(ref($phases) ? $phases : [ $phases ], [ $type ]);
    }
    
    sub check_requirements {
    	my ($reqs, $type, $dirs) = @_;
    
    	return +{
    		map {
    			$_ => $type ne 'conflicts'
    				? scalar _check_dep($reqs, $_, $dirs)
    				: scalar _check_conflict($reqs, $_, $dirs)
    		} $reqs->required_modules
    	};
    }
    
    sub verify_dependencies {
    	my ($meta, $phases, $type, $dirs) = @_;
    	my $reqs = requirements_for($meta, $phases, $type);
    	my $issues = check_requirements($reqs, $type, $dirs);
    	return grep { defined } values %{ $issues };
    }
    
    1;
    
    #ABSTRACT: Verify requirements in a CPAN::Meta object
    
    __END__
    
    =pod
    
    =encoding UTF-8
    
    =head1 NAME
    
    CPAN::Meta::Check - Verify requirements in a CPAN::Meta object
    
    =head1 VERSION
    
    version 0.012
    
    =head1 SYNOPSIS
    
     warn "$_\n" for verify_dependencies($meta, [qw/runtime build test/], 'requires');
    
    =head1 DESCRIPTION
    
    This module verifies if requirements described in a CPAN::Meta object are present.
    
    =head1 FUNCTIONS
    
    =head2 check_requirements($reqs, $type, $incdirs)
    
    This function checks if all dependencies in C<$reqs> (a L<CPAN::Meta::Requirements|CPAN::Meta::Requirements> object) are met, taking into account that 'conflicts' dependencies have to be checked in reverse. It returns a hash with the modules as keys and any problems as values; the value for a successfully found module will be undef. Modules are searched for in C<@$incdirs>, defaulting to C<@INC>.
    
    =head2 verify_dependencies($meta, $phases, $types, $incdirs)
    
    Check all requirements in C<$meta> for phases C<$phases> and type C<$type>. Modules are searched for in C<@$incdirs>, defaulting to C<@INC>. C<$meta> should be a L<CPAN::Meta::Prereqs> or L<CPAN::Meta> object.
    
    =head2 requirements_for($meta, $phases, $types)
    
    B<< This function is deprecated and may be removed at some point in the future, please use CPAN::Meta::Prereqs->merged_requirements instead. >>
    
    This function returns a unified L<CPAN::Meta::Requirements|CPAN::Meta::Requirements> object for all C<$type> requirements for C<$phases>. C<$phases> may be either one (scalar) value or an arrayref of valid values as defined by the L<CPAN::Meta spec|CPAN::Meta::Spec>. C<$type> must be a relationship as defined by the same spec. C<$meta> should be a L<CPAN::Meta::Prereqs> or L<CPAN::Meta> object.
    
    =head1 SEE ALSO
    
    =over 4
    
    =item * L<Test::CheckDeps|Test::CheckDeps>
    
    =item * L<CPAN::Meta|CPAN::Meta>
    
    =for comment # vi:noet:sts=2:sw=2:ts=2
    
    =back
    
    =head1 AUTHOR
    
    Leon Timmermans <leont@cpan.org>
    
    =head1 COPYRIGHT AND LICENSE
    
    This software is copyright (c) 2012 by Leon Timmermans.
    
    This is free software; you can redistribute it and/or modify it under
    the same terms as the Perl 5 programming language system itself.
    
    =cut
  CPAN_META_CHECK
  
  $fatpacked{"CPAN/Meta/Converter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_CONVERTER';
    use 5.006;
    use strict;
    use warnings;
    package CPAN::Meta::Converter;
    
    our $VERSION = '2.150005';
    
    #pod =head1 SYNOPSIS
    #pod
    #pod   my $struct = decode_json_file('META.json');
    #pod
    #pod   my $cmc = CPAN::Meta::Converter->new( $struct );
    #pod
    #pod   my $new_struct = $cmc->convert( version => "2" );
    #pod
    #pod =head1 DESCRIPTION
    #pod
    #pod This module converts CPAN Meta structures from one form to another.  The
    #pod primary use is to convert older structures to the most modern version of
    #pod the specification, but other transformations may be implemented in the
    #pod future as needed.  (E.g. stripping all custom fields or stripping all
    #pod optional fields.)
    #pod
    #pod =cut
    
    use CPAN::Meta::Validator;
    use CPAN::Meta::Requirements;
    use Parse::CPAN::Meta 1.4400 ();
    
    # To help ExtUtils::MakeMaker bootstrap CPAN::Meta::Requirements on perls
    # before 5.10, we fall back to the EUMM bundled compatibility version module if
    # that's the only thing available.  This shouldn't ever happen in a normal CPAN
    # install of CPAN::Meta::Requirements, as version.pm will be picked up from
    # prereqs and be available at runtime.
    
    BEGIN {
      eval "use version ()"; ## no critic
      if ( my $err = $@ ) {
        eval "use ExtUtils::MakeMaker::version" or die $err; ## no critic
      }
    }
    
    # Perl 5.10.0 didn't have "is_qv" in version.pm
    *_is_qv = version->can('is_qv') ? sub { $_[0]->is_qv } : sub { exists $_[0]->{qv} };
    
    sub _dclone {
      my $ref = shift;
    
      # if an object is in the data structure and doesn't specify how to
      # turn itself into JSON, we just stringify the object.  That does the
      # right thing for typical things that might be there, like version objects,
      # Path::Class objects, etc.
      no warnings 'once';
      no warnings 'redefine';
      local *UNIVERSAL::TO_JSON = sub { "$_[0]" };
    
      my $json = Parse::CPAN::Meta->json_backend()->new
          ->utf8
          ->allow_blessed
          ->convert_blessed;
      $json->decode($json->encode($ref))
    }
    
    my %known_specs = (
        '2'   => 'http://search.cpan.org/perldoc?CPAN::Meta::Spec',
        '1.4' => 'http://module-build.sourceforge.net/META-spec-v1.4.html',
        '1.3' => 'http://module-build.sourceforge.net/META-spec-v1.3.html',
        '1.2' => 'http://module-build.sourceforge.net/META-spec-v1.2.html',
        '1.1' => 'http://module-build.sourceforge.net/META-spec-v1.1.html',
        '1.0' => 'http://module-build.sourceforge.net/META-spec-v1.0.html'
    );
    
    my @spec_list = sort { $a <=> $b } keys %known_specs;
    my ($LOWEST, $HIGHEST) = @spec_list[0,-1];
    
    #--------------------------------------------------------------------------#
    # converters
    #
    # called as $converter->($element, $field_name, $full_meta, $to_version)
    #
    # defined return value used for field
    # undef return value means field is skipped
    #--------------------------------------------------------------------------#
    
    sub _keep { $_[0] }
    
    sub _keep_or_one { defined($_[0]) ? $_[0] : 1 }
    
    sub _keep_or_zero { defined($_[0]) ? $_[0] : 0 }
    
    sub _keep_or_unknown { defined($_[0]) && length($_[0]) ? $_[0] : "unknown" }
    
    sub _generated_by {
      my $gen = shift;
      my $sig = __PACKAGE__ . " version " . (__PACKAGE__->VERSION || "<dev>");
    
      return $sig unless defined $gen and length $gen;
      return $gen if $gen =~ /\Q$sig/;
      return "$gen, $sig";
    }
    
    sub _listify { ! defined $_[0] ? undef : ref $_[0] eq 'ARRAY' ? $_[0] : [$_[0]] }
    
    sub _prefix_custom {
      my $key = shift;
      $key =~ s/^(?!x_)   # Unless it already starts with x_
                 (?:x-?)? # Remove leading x- or x (if present)
               /x_/ix;    # and prepend x_
      return $key;
    }
    
    sub _ucfirst_custom {
      my $key = shift;
      $key = ucfirst $key unless $key =~ /[A-Z]/;
      return $key;
    }
    
    sub _no_prefix_ucfirst_custom {
      my $key = shift;
      $key =~ s/^x_//;
      return _ucfirst_custom($key);
    }
    
    sub _change_meta_spec {
      my ($element, undef, undef, $version) = @_;
      return {
        version => $version,
        url => $known_specs{$version},
      };
    }
    
    my @open_source = (
      'perl',
      'gpl',
      'apache',
      'artistic',
      'artistic_2',
      'lgpl',
      'bsd',
      'gpl',
      'mit',
      'mozilla',
      'open_source',
    );
    
    my %is_open_source = map {; $_ => 1 } @open_source;
    
    my @valid_licenses_1 = (
      @open_source,
      'unrestricted',
      'restrictive',
      'unknown',
    );
    
    my %license_map_1 = (
      ( map { $_ => $_ } @valid_licenses_1 ),
      artistic2 => 'artistic_2',
    );
    
    sub _license_1 {
      my ($element) = @_;
      return 'unknown' unless defined $element;
      if ( $license_map_1{lc $element} ) {
        return $license_map_1{lc $element};
      }
      else {
        return 'unknown';
      }
    }
    
    my @valid_licenses_2 = qw(
      agpl_3
      apache_1_1
      apache_2_0
      artistic_1
      artistic_2
      bsd
      freebsd
      gfdl_1_2
      gfdl_1_3
      gpl_1
      gpl_2
      gpl_3
      lgpl_2_1
      lgpl_3_0
      mit
      mozilla_1_0
      mozilla_1_1
      openssl
      perl_5
      qpl_1_0
      ssleay
      sun
      zlib
      open_source
      restricted
      unrestricted
      unknown
    );
    
    # The "old" values were defined by Module::Build, and were often vague.  I have
    # made the decisions below based on reading Module::Build::API and how clearly
    # it specifies the version of the license.
    my %license_map_2 = (
      (map { $_ => $_ } @valid_licenses_2),
      apache      => 'apache_2_0',  # clearly stated as 2.0
      artistic    => 'artistic_1',  # clearly stated as 1
      artistic2   => 'artistic_2',  # clearly stated as 2
      gpl         => 'open_source', # we don't know which GPL; punt
      lgpl        => 'open_source', # we don't know which LGPL; punt
      mozilla     => 'open_source', # we don't know which MPL; punt
      perl        => 'perl_5',      # clearly Perl 5
      restrictive => 'restricted',
    );
    
    sub _license_2 {
      my ($element) = @_;
      return [ 'unknown' ] unless defined $element;
      $element = [ $element ] unless ref $element eq 'ARRAY';
      my @new_list;
      for my $lic ( @$element ) {
        next unless defined $lic;
        if ( my $new = $license_map_2{lc $lic} ) {
          push @new_list, $new;
        }
      }
      return @new_list ? \@new_list : [ 'unknown' ];
    }
    
    my %license_downgrade_map = qw(
      agpl_3            open_source
      apache_1_1        apache
      apache_2_0        apache
      artistic_1        artistic
      artistic_2        artistic_2
      bsd               bsd
      freebsd           open_source
      gfdl_1_2          open_source
      gfdl_1_3          open_source
      gpl_1             gpl
      gpl_2             gpl
      gpl_3             gpl
      lgpl_2_1          lgpl
      lgpl_3_0          lgpl
      mit               mit
      mozilla_1_0       mozilla
      mozilla_1_1       mozilla
      openssl           open_source
      perl_5            perl
      qpl_1_0           open_source
      ssleay            open_source
      sun               open_source
      zlib              open_source
      open_source       open_source
      restricted        restrictive
      unrestricted      unrestricted
      unknown           unknown
    );
    
    sub _downgrade_license {
      my ($element) = @_;
      if ( ! defined $element ) {
        return "unknown";
      }
      elsif( ref $element eq 'ARRAY' ) {
        if ( @$element > 1) {
          if (grep { !$is_open_source{ $license_downgrade_map{lc $_} || 'unknown' } } @$element) {
            return 'unknown';
          }
          else {
            return 'open_source';
          }
        }
        elsif ( @$element == 1 ) {
          return $license_downgrade_map{lc $element->[0]} || "unknown";
        }
      }
      elsif ( ! ref $element ) {
        return $license_downgrade_map{lc $element} || "unknown";
      }
      return "unknown";
    }
    
    my $no_index_spec_1_2 = {
      'file' => \&_listify,
      'dir' => \&_listify,
      'package' => \&_listify,
      'namespace' => \&_listify,
    };
    
    my $no_index_spec_1_3 = {
      'file' => \&_listify,
      'directory' => \&_listify,
      'package' => \&_listify,
      'namespace' => \&_listify,
    };
    
    my $no_index_spec_2 = {
      'file' => \&_listify,
      'directory' => \&_listify,
      'package' => \&_listify,
      'namespace' => \&_listify,
      ':custom'  => \&_prefix_custom,
    };
    
    sub _no_index_1_2 {
      my (undef, undef, $meta) = @_;
      my $no_index = $meta->{no_index} || $meta->{private};
      return unless $no_index;
    
      # cleanup wrong format
      if ( ! ref $no_index ) {
        my $item = $no_index;
        $no_index = { dir => [ $item ], file => [ $item ] };
      }
      elsif ( ref $no_index eq 'ARRAY' ) {
        my $list = $no_index;
        $no_index = { dir => [ @$list ], file => [ @$list ] };
      }
    
      # common mistake: files -> file
      if ( exists $no_index->{files} ) {
        $no_index->{file} = delete $no_index->{files};
      }
      # common mistake: modules -> module
      if ( exists $no_index->{modules} ) {
        $no_index->{module} = delete $no_index->{modules};
      }
      return _convert($no_index, $no_index_spec_1_2);
    }
    
    sub _no_index_directory {
      my ($element, $key, $meta, $version) = @_;
      return unless $element;
    
      # cleanup wrong format
      if ( ! ref $element ) {
        my $item = $element;
        $element = { directory => [ $item ], file => [ $item ] };
      }
      elsif ( ref $element eq 'ARRAY' ) {
        my $list = $element;
        $element = { directory => [ @$list ], file => [ @$list ] };
      }
    
      if ( exists $element->{dir} ) {
        $element->{directory} = delete $element->{dir};
      }
      # common mistake: files -> file
      if ( exists $element->{files} ) {
        $element->{file} = delete $element->{files};
      }
      # common mistake: modules -> module
      if ( exists $element->{modules} ) {
        $element->{module} = delete $element->{modules};
      }
      my $spec = $version == 2 ? $no_index_spec_2 : $no_index_spec_1_3;
      return _convert($element, $spec);
    }
    
    sub _is_module_name {
      my $mod = shift;
      return unless defined $mod && length $mod;
      return $mod =~ m{^[A-Za-z][A-Za-z0-9_]*(?:::[A-Za-z0-9_]+)*$};
    }
    
    sub _clean_version {
      my ($element) = @_;
      return 0 if ! defined $element;
    
      $element =~ s{^\s*}{};
      $element =~ s{\s*$}{};
      $element =~ s{^\.}{0.};
    
      return 0 if ! length $element;
      return 0 if ( $element eq 'undef' || $element eq '<undef>' );
    
      my $v = eval { version->new($element) };
      # XXX check defined $v and not just $v because version objects leak memory
      # in boolean context -- dagolden, 2012-02-03
      if ( defined $v ) {
        return _is_qv($v) ? $v->normal : $element;
      }
      else {
        return 0;
      }
    }
    
    sub _bad_version_hook {
      my ($v) = @_;
      $v =~ s{^\s*}{};
      $v =~ s{\s*$}{};
      $v =~ s{[a-z]+$}{}; # strip trailing alphabetics
      my $vobj = eval { version->new($v) };
      return defined($vobj) ? $vobj : version->new(0); # or give up
    }
    
    sub _version_map {
      my ($element) = @_;
      return unless defined $element;
      if ( ref $element eq 'HASH' ) {
        # XXX turn this into CPAN::Meta::Requirements with bad version hook
        # and then turn it back into a hash
        my $new_map = CPAN::Meta::Requirements->new(
          { bad_version_hook => \&_bad_version_hook } # punt
        );
        while ( my ($k,$v) = each %$element ) {
          next unless _is_module_name($k);
          if ( !defined($v) || !length($v) || $v eq 'undef' || $v eq '<undef>'  ) {
            $v = 0;
          }
          # some weird, old META have bad yml with module => module
          # so check if value is like a module name and not like a version
          if ( _is_module_name($v) && ! version::is_lax($v) ) {
            $new_map->add_minimum($k => 0);
            $new_map->add_minimum($v => 0);
          }
          $new_map->add_string_requirement($k => $v);
        }
        return $new_map->as_string_hash;
      }
      elsif ( ref $element eq 'ARRAY' ) {
        my $hashref = { map { $_ => 0 } @$element };
        return _version_map($hashref); # cleanup any weird stuff
      }
      elsif ( ref $element eq '' && length $element ) {
        return { $element => 0 }
      }
      return;
    }
    
    sub _prereqs_from_1 {
      my (undef, undef, $meta) = @_;
      my $prereqs = {};
      for my $phase ( qw/build configure/ ) {
        my $key = "${phase}_requires";
        $prereqs->{$phase}{requires} = _version_map($meta->{$key})
          if $meta->{$key};
      }
      for my $rel ( qw/requires recommends conflicts/ ) {
        $prereqs->{runtime}{$rel} = _version_map($meta->{$rel})
          if $meta->{$rel};
      }
      return $prereqs;
    }
    
    my $prereqs_spec = {
      configure => \&_prereqs_rel,
      build     => \&_prereqs_rel,
      test      => \&_prereqs_rel,
      runtime   => \&_prereqs_rel,
      develop   => \&_prereqs_rel,
      ':custom'  => \&_prefix_custom,
    };
    
    my $relation_spec = {
      requires   => \&_version_map,
      recommends => \&_version_map,
      suggests   => \&_version_map,
      conflicts  => \&_version_map,
      ':custom'  => \&_prefix_custom,
    };
    
    sub _cleanup_prereqs {
      my ($prereqs, $key, $meta, $to_version) = @_;
      return unless $prereqs && ref $prereqs eq 'HASH';
      return _convert( $prereqs, $prereqs_spec, $to_version );
    }
    
    sub _prereqs_rel {
      my ($relation, $key, $meta, $to_version) = @_;
      return unless $relation && ref $relation eq 'HASH';
      return _convert( $relation, $relation_spec, $to_version );
    }
    
    
    BEGIN {
      my @old_prereqs = qw(
        requires
        configure_requires
        recommends
        conflicts
      );
    
      for ( @old_prereqs ) {
        my $sub = "_get_$_";
        my ($phase,$type) = split qr/_/, $_;
        if ( ! defined $type ) {
          $type = $phase;
          $phase = 'runtime';
        }
        no strict 'refs';
        *{$sub} = sub { _extract_prereqs($_[2]->{prereqs},$phase,$type) };
      }
    }
    
    sub _get_build_requires {
      my ($data, $key, $meta) = @_;
    
      my $test_h  = _extract_prereqs($_[2]->{prereqs}, qw(test  requires)) || {};
      my $build_h = _extract_prereqs($_[2]->{prereqs}, qw(build requires)) || {};
    
      my $test_req  = CPAN::Meta::Requirements->from_string_hash($test_h);
      my $build_req = CPAN::Meta::Requirements->from_string_hash($build_h);
    
      $test_req->add_requirements($build_req)->as_string_hash;
    }
    
    sub _extract_prereqs {
      my ($prereqs, $phase, $type) = @_;
      return unless ref $prereqs eq 'HASH';
      return scalar _version_map($prereqs->{$phase}{$type});
    }
    
    sub _downgrade_optional_features {
      my (undef, undef, $meta) = @_;
      return unless exists $meta->{optional_features};
      my $origin = $meta->{optional_features};
      my $features = {};
      for my $name ( keys %$origin ) {
        $features->{$name} = {
          description => $origin->{$name}{description},
          requires => _extract_prereqs($origin->{$name}{prereqs},'runtime','requires'),
          configure_requires => _extract_prereqs($origin->{$name}{prereqs},'runtime','configure_requires'),
          build_requires => _extract_prereqs($origin->{$name}{prereqs},'runtime','build_requires'),
          recommends => _extract_prereqs($origin->{$name}{prereqs},'runtime','recommends'),
          conflicts => _extract_prereqs($origin->{$name}{prereqs},'runtime','conflicts'),
        };
        for my $k (keys %{$features->{$name}} ) {
          delete $features->{$name}{$k} unless defined $features->{$name}{$k};
        }
      }
      return $features;
    }
    
    sub _upgrade_optional_features {
      my (undef, undef, $meta) = @_;
      return unless exists $meta->{optional_features};
      my $origin = $meta->{optional_features};
      my $features = {};
      for my $name ( keys %$origin ) {
        $features->{$name} = {
          description => $origin->{$name}{description},
          prereqs => _prereqs_from_1(undef, undef, $origin->{$name}),
        };
        delete $features->{$name}{prereqs}{configure};
      }
      return $features;
    }
    
    my $optional_features_2_spec = {
      description => \&_keep,
      prereqs => \&_cleanup_prereqs,
      ':custom'  => \&_prefix_custom,
    };
    
    sub _feature_2 {
      my ($element, $key, $meta, $to_version) = @_;
      return unless $element && ref $element eq 'HASH';
      _convert( $element, $optional_features_2_spec, $to_version );
    }
    
    sub _cleanup_optional_features_2 {
      my ($element, $key, $meta, $to_version) = @_;
      return unless $element && ref $element eq 'HASH';
      my $new_data = {};
      for my $k ( keys %$element ) {
        $new_data->{$k} = _feature_2( $element->{$k}, $k, $meta, $to_version );
      }
      return unless keys %$new_data;
      return $new_data;
    }
    
    sub _optional_features_1_4 {
      my ($element) = @_;
      return unless $element;
      $element = _optional_features_as_map($element);
      for my $name ( keys %$element ) {
        for my $drop ( qw/requires_packages requires_os excluded_os/ ) {
          delete $element->{$name}{$drop};
        }
      }
      return $element;
    }
    
    sub _optional_features_as_map {
      my ($element) = @_;
      return unless $element;
      if ( ref $element eq 'ARRAY' ) {
        my %map;
        for my $feature ( @$element ) {
          my (@parts) = %$feature;
          $map{$parts[0]} = $parts[1];
        }
        $element = \%map;
      }
      return $element;
    }
    
    sub _is_urlish { defined $_[0] && $_[0] =~ m{\A[-+.a-z0-9]+:.+}i }
    
    sub _url_or_drop {
      my ($element) = @_;
      return $element if _is_urlish($element);
      return;
    }
    
    sub _url_list {
      my ($element) = @_;
      return unless $element;
      $element = _listify( $element );
      $element = [ grep { _is_urlish($_) } @$element ];
      return unless @$element;
      return $element;
    }
    
    sub _author_list {
      my ($element) = @_;
      return [ 'unknown' ] unless $element;
      $element = _listify( $element );
      $element = [ map { defined $_ && length $_ ? $_ : 'unknown' } @$element ];
      return [ 'unknown' ] unless @$element;
      return $element;
    }
    
    my $resource2_upgrade = {
      license    => sub { return _is_urlish($_[0]) ? _listify( $_[0] ) : undef },
      homepage   => \&_url_or_drop,
      bugtracker => sub {
        my ($item) = @_;
        return unless $item;
        if ( $item =~ m{^mailto:(.*)$} ) { return { mailto => $1 } }
        elsif( _is_urlish($item) ) { return { web => $item } }
        else { return }
      },
      repository => sub { return _is_urlish($_[0]) ? { url => $_[0] } : undef },
      ':custom'  => \&_prefix_custom,
    };
    
    sub _upgrade_resources_2 {
      my (undef, undef, $meta, $version) = @_;
      return unless exists $meta->{resources};
      return _convert($meta->{resources}, $resource2_upgrade);
    }
    
    my $bugtracker2_spec = {
      web => \&_url_or_drop,
      mailto => \&_keep,
      ':custom'  => \&_prefix_custom,
    };
    
    sub _repo_type {
      my ($element, $key, $meta, $to_version) = @_;
      return $element if defined $element;
      return unless exists $meta->{url};
      my $repo_url = $meta->{url};
      for my $type ( qw/git svn/ ) {
        return $type if $repo_url =~ m{\A$type};
      }
      return;
    }
    
    my $repository2_spec = {
      web => \&_url_or_drop,
      url => \&_url_or_drop,
      type => \&_repo_type,
      ':custom'  => \&_prefix_custom,
    };
    
    my $resources2_cleanup = {
      license    => \&_url_list,
      homepage   => \&_url_or_drop,
      bugtracker => sub { ref $_[0] ? _convert( $_[0], $bugtracker2_spec ) : undef },
      repository => sub { my $data = shift; ref $data ? _convert( $data, $repository2_spec ) : undef },
      ':custom'  => \&_prefix_custom,
    };
    
    sub _cleanup_resources_2 {
      my ($resources, $key, $meta, $to_version) = @_;
      return unless $resources && ref $resources eq 'HASH';
      return _convert($resources, $resources2_cleanup, $to_version);
    }
    
    my $resource1_spec = {
      license    => \&_url_or_drop,
      homepage   => \&_url_or_drop,
      bugtracker => \&_url_or_drop,
      repository => \&_url_or_drop,
      ':custom'  => \&_keep,
    };
    
    sub _resources_1_3 {
      my (undef, undef, $meta, $version) = @_;
      return unless exists $meta->{resources};
      return _convert($meta->{resources}, $resource1_spec);
    }
    
    *_resources_1_4 = *_resources_1_3;
    
    sub _resources_1_2 {
      my (undef, undef, $meta) = @_;
      my $resources = $meta->{resources} || {};
      if ( $meta->{license_url} && ! $resources->{license} ) {
        $resources->{license} = $meta->{license_url}
          if _is_urlish($meta->{license_url});
      }
      return unless keys %$resources;
      return _convert($resources, $resource1_spec);
    }
    
    my $resource_downgrade_spec = {
      license    => sub { return ref $_[0] ? $_[0]->[0] : $_[0] },
      homepage   => \&_url_or_drop,
      bugtracker => sub { return $_[0]->{web} },
      repository => sub { return $_[0]->{url} || $_[0]->{web} },
      ':custom'  => \&_no_prefix_ucfirst_custom,
    };
    
    sub _downgrade_resources {
      my (undef, undef, $meta, $version) = @_;
      return unless exists $meta->{resources};
      return _convert($meta->{resources}, $resource_downgrade_spec);
    }
    
    sub _release_status {
      my ($element, undef, $meta) = @_;
      return $element if $element && $element =~ m{\A(?:stable|testing|unstable)\z};
      return _release_status_from_version(undef, undef, $meta);
    }
    
    sub _release_status_from_version {
      my (undef, undef, $meta) = @_;
      my $version = $meta->{version} || '';
      return ( $version =~ /_/ ) ? 'testing' : 'stable';
    }
    
    my $provides_spec = {
      file => \&_keep,
      version => \&_keep,
    };
    
    my $provides_spec_2 = {
      file => \&_keep,
      version => \&_keep,
      ':custom'  => \&_prefix_custom,
    };
    
    sub _provides {
      my ($element, $key, $meta, $to_version) = @_;
      return unless defined $element && ref $element eq 'HASH';
      my $spec = $to_version == 2 ? $provides_spec_2 : $provides_spec;
      my $new_data = {};
      for my $k ( keys %$element ) {
        $new_data->{$k} = _convert($element->{$k}, $spec, $to_version);
        $new_data->{$k}{version} = _clean_version($element->{$k}{version})
          if exists $element->{$k}{version};
      }
      return $new_data;
    }
    
    sub _convert {
      my ($data, $spec, $to_version, $is_fragment) = @_;
    
      my $new_data = {};
      for my $key ( keys %$spec ) {
        next if $key eq ':custom' || $key eq ':drop';
        next unless my $fcn = $spec->{$key};
        if ( $is_fragment && $key eq 'generated_by' ) {
          $fcn = \&_keep;
        }
        die "spec for '$key' is not a coderef"
          unless ref $fcn && ref $fcn eq 'CODE';
        my $new_value = $fcn->($data->{$key}, $key, $data, $to_version);
        $new_data->{$key} = $new_value if defined $new_value;
      }
    
      my $drop_list   = $spec->{':drop'};
      my $customizer  = $spec->{':custom'} || \&_keep;
    
      for my $key ( keys %$data ) {
        next if $drop_list && grep { $key eq $_ } @$drop_list;
        next if exists $spec->{$key}; # we handled it
        $new_data->{ $customizer->($key) } = $data->{$key};
      }
    
      return $new_data;
    }
    
    #--------------------------------------------------------------------------#
    # define converters for each conversion
    #--------------------------------------------------------------------------#
    
    # each converts from prior version
    # special ":custom" field is used for keys not recognized in spec
    my %up_convert = (
      '2-from-1.4' => {
        # PRIOR MANDATORY
        'abstract'            => \&_keep_or_unknown,
        'author'              => \&_author_list,
        'generated_by'        => \&_generated_by,
        'license'             => \&_license_2,
        'meta-spec'           => \&_change_meta_spec,
        'name'                => \&_keep,
        'version'             => \&_keep,
        # CHANGED TO MANDATORY
        'dynamic_config'      => \&_keep_or_one,
        # ADDED MANDATORY
        'release_status'      => \&_release_status,
        # PRIOR OPTIONAL
        'keywords'            => \&_keep,
        'no_index'            => \&_no_index_directory,
        'optional_features'   => \&_upgrade_optional_features,
        'provides'            => \&_provides,
        'resources'           => \&_upgrade_resources_2,
        # ADDED OPTIONAL
        'description'         => \&_keep,
        'prereqs'             => \&_prereqs_from_1,
    
        # drop these deprecated fields, but only after we convert
        ':drop' => [ qw(
            build_requires
            configure_requires
            conflicts
            distribution_type
            license_url
            private
            recommends
            requires
        ) ],
    
        # other random keys need x_ prefixing
        ':custom'              => \&_prefix_custom,
      },
      '1.4-from-1.3' => {
        # PRIOR MANDATORY
        'abstract'            => \&_keep_or_unknown,
        'author'              => \&_author_list,
        'generated_by'        => \&_generated_by,
        'license'             => \&_license_1,
        'meta-spec'           => \&_change_meta_spec,
        'name'                => \&_keep,
        'version'             => \&_keep,
        # PRIOR OPTIONAL
        'build_requires'      => \&_version_map,
        'conflicts'           => \&_version_map,
        'distribution_type'   => \&_keep,
        'dynamic_config'      => \&_keep_or_one,
        'keywords'            => \&_keep,
        'no_index'            => \&_no_index_directory,
        'optional_features'   => \&_optional_features_1_4,
        'provides'            => \&_provides,
        'recommends'          => \&_version_map,
        'requires'            => \&_version_map,
        'resources'           => \&_resources_1_4,
        # ADDED OPTIONAL
        'configure_requires'  => \&_keep,
    
        # drop these deprecated fields, but only after we convert
        ':drop' => [ qw(
          license_url
          private
        )],
    
        # other random keys are OK if already valid
        ':custom'              => \&_keep
      },
      '1.3-from-1.2' => {
        # PRIOR MANDATORY
        'abstract'            => \&_keep_or_unknown,
        'author'              => \&_author_list,
        'generated_by'        => \&_generated_by,
        'license'             => \&_license_1,
        'meta-spec'           => \&_change_meta_spec,
        'name'                => \&_keep,
        'version'             => \&_keep,
        # PRIOR OPTIONAL
        'build_requires'      => \&_version_map,
        'conflicts'           => \&_version_map,
        'distribution_type'   => \&_keep,
        'dynamic_config'      => \&_keep_or_one,
        'keywords'            => \&_keep,
        'no_index'            => \&_no_index_directory,
        'optional_features'   => \&_optional_features_as_map,
        'provides'            => \&_provides,
        'recommends'          => \&_version_map,
        'requires'            => \&_version_map,
        'resources'           => \&_resources_1_3,
    
        # drop these deprecated fields, but only after we convert
        ':drop' => [ qw(
          license_url
          private
        )],
    
        # other random keys are OK if already valid
        ':custom'              => \&_keep
      },
      '1.2-from-1.1' => {
        # PRIOR MANDATORY
        'version'             => \&_keep,
        # CHANGED TO MANDATORY
        'license'             => \&_license_1,
        'name'                => \&_keep,
        'generated_by'        => \&_generated_by,
        # ADDED MANDATORY
        'abstract'            => \&_keep_or_unknown,
        'author'              => \&_author_list,
        'meta-spec'           => \&_change_meta_spec,
        # PRIOR OPTIONAL
        'build_requires'      => \&_version_map,
        'conflicts'           => \&_version_map,
        'distribution_type'   => \&_keep,
        'dynamic_config'      => \&_keep_or_one,
        'recommends'          => \&_version_map,
        'requires'            => \&_version_map,
        # ADDED OPTIONAL
        'keywords'            => \&_keep,
        'no_index'            => \&_no_index_1_2,
        'optional_features'   => \&_optional_features_as_map,
        'provides'            => \&_provides,
        'resources'           => \&_resources_1_2,
    
        # drop these deprecated fields, but only after we convert
        ':drop' => [ qw(
          license_url
          private
        )],
    
        # other random keys are OK if already valid
        ':custom'              => \&_keep
      },
      '1.1-from-1.0' => {
        # CHANGED TO MANDATORY
        'version'             => \&_keep,
        # IMPLIED MANDATORY
        'name'                => \&_keep,
        # PRIOR OPTIONAL
        'build_requires'      => \&_version_map,
        'conflicts'           => \&_version_map,
        'distribution_type'   => \&_keep,
        'dynamic_config'      => \&_keep_or_one,
        'generated_by'        => \&_generated_by,
        'license'             => \&_license_1,
        'recommends'          => \&_version_map,
        'requires'            => \&_version_map,
        # ADDED OPTIONAL
        'license_url'         => \&_url_or_drop,
        'private'             => \&_keep,
    
        # other random keys are OK if already valid
        ':custom'              => \&_keep
      },
    );
    
    my %down_convert = (
      '1.4-from-2' => {
        # MANDATORY
        'abstract'            => \&_keep_or_unknown,
        'author'              => \&_author_list,
        'generated_by'        => \&_generated_by,
        'license'             => \&_downgrade_license,
        'meta-spec'           => \&_change_meta_spec,
        'name'                => \&_keep,
        'version'             => \&_keep,
        # OPTIONAL
        'build_requires'      => \&_get_build_requires,
        'configure_requires'  => \&_get_configure_requires,
        'conflicts'           => \&_get_conflicts,
        'distribution_type'   => \&_keep,
        'dynamic_config'      => \&_keep_or_one,
        'keywords'            => \&_keep,
        'no_index'            => \&_no_index_directory,
        'optional_features'   => \&_downgrade_optional_features,
        'provides'            => \&_provides,
        'recommends'          => \&_get_recommends,
        'requires'            => \&_get_requires,
        'resources'           => \&_downgrade_resources,
    
        # drop these unsupported fields (after conversion)
        ':drop' => [ qw(
          description
          prereqs
          release_status
        )],
    
        # custom keys will be left unchanged
        ':custom'              => \&_keep
      },
      '1.3-from-1.4' => {
        # MANDATORY
        'abstract'            => \&_keep_or_unknown,
        'author'              => \&_author_list,
        'generated_by'        => \&_generated_by,
        'license'             => \&_license_1,
        'meta-spec'           => \&_change_meta_spec,
        'name'                => \&_keep,
        'version'             => \&_keep,
        # OPTIONAL
        'build_requires'      => \&_version_map,
        'conflicts'           => \&_version_map,
        'distribution_type'   => \&_keep,
        'dynamic_config'      => \&_keep_or_one,
        'keywords'            => \&_keep,
        'no_index'            => \&_no_index_directory,
        'optional_features'   => \&_optional_features_as_map,
        'provides'            => \&_provides,
        'recommends'          => \&_version_map,
        'requires'            => \&_version_map,
        'resources'           => \&_resources_1_3,
    
        # drop these unsupported fields, but only after we convert
        ':drop' => [ qw(
          configure_requires
        )],
    
        # other random keys are OK if already valid
        ':custom'              => \&_keep,
      },
      '1.2-from-1.3' => {
        # MANDATORY
        'abstract'            => \&_keep_or_unknown,
        'author'              => \&_author_list,
        'generated_by'        => \&_generated_by,
        'license'             => \&_license_1,
        'meta-spec'           => \&_change_meta_spec,
        'name'                => \&_keep,
        'version'             => \&_keep,
        # OPTIONAL
        'build_requires'      => \&_version_map,
        'conflicts'           => \&_version_map,
        'distribution_type'   => \&_keep,
        'dynamic_config'      => \&_keep_or_one,
        'keywords'            => \&_keep,
        'no_index'            => \&_no_index_1_2,
        'optional_features'   => \&_optional_features_as_map,
        'provides'            => \&_provides,
        'recommends'          => \&_version_map,
        'requires'            => \&_version_map,
        'resources'           => \&_resources_1_3,
    
        # other random keys are OK if already valid
        ':custom'              => \&_keep,
      },
      '1.1-from-1.2' => {
        # MANDATORY
        'version'             => \&_keep,
        # IMPLIED MANDATORY
        'name'                => \&_keep,
        'meta-spec'           => \&_change_meta_spec,
        # OPTIONAL
        'build_requires'      => \&_version_map,
        'conflicts'           => \&_version_map,
        'distribution_type'   => \&_keep,
        'dynamic_config'      => \&_keep_or_one,
        'generated_by'        => \&_generated_by,
        'license'             => \&_license_1,
        'private'             => \&_keep,
        'recommends'          => \&_version_map,
        'requires'            => \&_version_map,
    
        # drop unsupported fields
        ':drop' => [ qw(
          abstract
          author
          provides
          no_index
          keywords
          resources
        )],
    
        # other random keys are OK if already valid
        ':custom'              => \&_keep,
      },
      '1.0-from-1.1' => {
        # IMPLIED MANDATORY
        'name'                => \&_keep,
        'meta-spec'           => \&_change_meta_spec,
        'version'             => \&_keep,
        # PRIOR OPTIONAL
        'build_requires'      => \&_version_map,
        'conflicts'           => \&_version_map,
        'distribution_type'   => \&_keep,
        'dynamic_config'      => \&_keep_or_one,
        'generated_by'        => \&_generated_by,
        'license'             => \&_license_1,
        'recommends'          => \&_version_map,
        'requires'            => \&_version_map,
    
        # other random keys are OK if already valid
        ':custom'              => \&_keep,
      },
    );
    
    my %cleanup = (
      '2' => {
        # PRIOR MANDATORY
        'abstract'            => \&_keep_or_unknown,
        'author'              => \&_author_list,
        'generated_by'        => \&_generated_by,
        'license'             => \&_license_2,
        'meta-spec'           => \&_change_meta_spec,
        'name'                => \&_keep,
        'version'             => \&_keep,
        # CHANGED TO MANDATORY
        'dynamic_config'      => \&_keep_or_one,
        # ADDED MANDATORY
        'release_status'      => \&_release_status,
        # PRIOR OPTIONAL
        'keywords'            => \&_keep,
        'no_index'            => \&_no_index_directory,
        'optional_features'   => \&_cleanup_optional_features_2,
        'provides'            => \&_provides,
        'resources'           => \&_cleanup_resources_2,
        # ADDED OPTIONAL
        'description'         => \&_keep,
        'prereqs'             => \&_cleanup_prereqs,
    
        # drop these deprecated fields, but only after we convert
        ':drop' => [ qw(
            build_requires
            configure_requires
            conflicts
            distribution_type
            license_url
            private
            recommends
            requires
        ) ],
    
        # other random keys need x_ prefixing
        ':custom'              => \&_prefix_custom,
      },
      '1.4' => {
        # PRIOR MANDATORY
        'abstract'            => \&_keep_or_unknown,
        'author'              => \&_author_list,
        'generated_by'        => \&_generated_by,
        'license'             => \&_license_1,
        'meta-spec'           => \&_change_meta_spec,
        'name'                => \&_keep,
        'version'             => \&_keep,
        # PRIOR OPTIONAL
        'build_requires'      => \&_version_map,
        'conflicts'           => \&_version_map,
        'distribution_type'   => \&_keep,
        'dynamic_config'      => \&_keep_or_one,
        'keywords'            => \&_keep,
        'no_index'            => \&_no_index_directory,
        'optional_features'   => \&_optional_features_1_4,
        'provides'            => \&_provides,
        'recommends'          => \&_version_map,
        'requires'            => \&_version_map,
        'resources'           => \&_resources_1_4,
        # ADDED OPTIONAL
        'configure_requires'  => \&_keep,
    
        # other random keys are OK if already valid
        ':custom'             => \&_keep
      },
      '1.3' => {
        # PRIOR MANDATORY
        'abstract'            => \&_keep_or_unknown,
        'author'              => \&_author_list,
        'generated_by'        => \&_generated_by,
        'license'             => \&_license_1,
        'meta-spec'           => \&_change_meta_spec,
        'name'                => \&_keep,
        'version'             => \&_keep,
        # PRIOR OPTIONAL
        'build_requires'      => \&_version_map,
        'conflicts'           => \&_version_map,
        'distribution_type'   => \&_keep,
        'dynamic_config'      => \&_keep_or_one,
        'keywords'            => \&_keep,
        'no_index'            => \&_no_index_directory,
        'optional_features'   => \&_optional_features_as_map,
        'provides'            => \&_provides,
        'recommends'          => \&_version_map,
        'requires'            => \&_version_map,
        'resources'           => \&_resources_1_3,
    
        # other random keys are OK if already valid
        ':custom'             => \&_keep
      },
      '1.2' => {
        # PRIOR MANDATORY
        'version'             => \&_keep,
        # CHANGED TO MANDATORY
        'license'             => \&_license_1,
        'name'                => \&_keep,
        'generated_by'        => \&_generated_by,
        # ADDED MANDATORY
        'abstract'            => \&_keep_or_unknown,
        'author'              => \&_author_list,
        'meta-spec'           => \&_change_meta_spec,
        # PRIOR OPTIONAL
        'build_requires'      => \&_version_map,
        'conflicts'           => \&_version_map,
        'distribution_type'   => \&_keep,
        'dynamic_config'      => \&_keep_or_one,
        'recommends'          => \&_version_map,
        'requires'            => \&_version_map,
        # ADDED OPTIONAL
        'keywords'            => \&_keep,
        'no_index'            => \&_no_index_1_2,
        'optional_features'   => \&_optional_features_as_map,
        'provides'            => \&_provides,
        'resources'           => \&_resources_1_2,
    
        # other random keys are OK if already valid
        ':custom'             => \&_keep
      },
      '1.1' => {
        # CHANGED TO MANDATORY
        'version'             => \&_keep,
        # IMPLIED MANDATORY
        'name'                => \&_keep,
        'meta-spec'           => \&_change_meta_spec,
        # PRIOR OPTIONAL
        'build_requires'      => \&_version_map,
        'conflicts'           => \&_version_map,
        'distribution_type'   => \&_keep,
        'dynamic_config'      => \&_keep_or_one,
        'generated_by'        => \&_generated_by,
        'license'             => \&_license_1,
        'recommends'          => \&_version_map,
        'requires'            => \&_version_map,
        # ADDED OPTIONAL
        'license_url'         => \&_url_or_drop,
        'private'             => \&_keep,
    
        # other random keys are OK if already valid
        ':custom'             => \&_keep
      },
      '1.0' => {
        # IMPLIED MANDATORY
        'name'                => \&_keep,
        'meta-spec'           => \&_change_meta_spec,
        'version'             => \&_keep,
        # IMPLIED OPTIONAL
        'build_requires'      => \&_version_map,
        'conflicts'           => \&_version_map,
        'distribution_type'   => \&_keep,
        'dynamic_config'      => \&_keep_or_one,
        'generated_by'        => \&_generated_by,
        'license'             => \&_license_1,
        'recommends'          => \&_version_map,
        'requires'            => \&_version_map,
    
        # other random keys are OK if already valid
        ':custom'             => \&_keep,
      },
    );
    
    # for a given field in a spec version, what fields will it feed
    # into in the *latest* spec (i.e. v2); meta-spec omitted because
    # we always expect a meta-spec to be generated
    my %fragments_generate = (
      '2' => {
        'abstract'            =>   'abstract',
        'author'              =>   'author',
        'generated_by'        =>   'generated_by',
        'license'             =>   'license',
        'name'                =>   'name',
        'version'             =>   'version',
        'dynamic_config'      =>   'dynamic_config',
        'release_status'      =>   'release_status',
        'keywords'            =>   'keywords',
        'no_index'            =>   'no_index',
        'optional_features'   =>   'optional_features',
        'provides'            =>   'provides',
        'resources'           =>   'resources',
        'description'         =>   'description',
        'prereqs'             =>   'prereqs',
      },
      '1.4' => {
        'abstract'            => 'abstract',
        'author'              => 'author',
        'generated_by'        => 'generated_by',
        'license'             => 'license',
        'name'                => 'name',
        'version'             => 'version',
        'build_requires'      => 'prereqs',
        'conflicts'           => 'prereqs',
        'distribution_type'   => 'distribution_type',
        'dynamic_config'      => 'dynamic_config',
        'keywords'            => 'keywords',
        'no_index'            => 'no_index',
        'optional_features'   => 'optional_features',
        'provides'            => 'provides',
        'recommends'          => 'prereqs',
        'requires'            => 'prereqs',
        'resources'           => 'resources',
        'configure_requires'  => 'prereqs',
      },
    );
    # this is not quite true but will work well enough
    # as 1.4 is a superset of earlier ones
    $fragments_generate{$_} = $fragments_generate{'1.4'} for qw/1.3 1.2 1.1 1.0/;
    
    #--------------------------------------------------------------------------#
    # Code
    #--------------------------------------------------------------------------#
    
    #pod =method new
    #pod
    #pod   my $cmc = CPAN::Meta::Converter->new( $struct );
    #pod
    #pod The constructor should be passed a valid metadata structure but invalid
    #pod structures are accepted.  If no meta-spec version is provided, version 1.0 will
    #pod be assumed.
    #pod
    #pod Optionally, you can provide a C<default_version> argument after C<$struct>:
    #pod
    #pod   my $cmc = CPAN::Meta::Converter->new( $struct, default_version => "1.4" );
    #pod
    #pod This is only needed when converting a metadata fragment that does not include a
    #pod C<meta-spec> field.
    #pod
    #pod =cut
    
    sub new {
      my ($class,$data,%args) = @_;
    
      # create an attributes hash
      my $self = {
        'data'    => $data,
        'spec'    => _extract_spec_version($data, $args{default_version}),
      };
    
      # create the object
      return bless $self, $class;
    }
    
    sub _extract_spec_version {
        my ($data, $default) = @_;
        my $spec = $data->{'meta-spec'};
    
        # is meta-spec there and valid?
        return( $default || "1.0" ) unless defined $spec && ref $spec eq 'HASH'; # before meta-spec?
    
        # does the version key look like a valid version?
        my $v = $spec->{version};
        if ( defined $v && $v =~ /^\d+(?:\.\d+)?$/ ) {
            return $v if defined $v && grep { $v eq $_ } keys %known_specs; # known spec
            return $v+0 if defined $v && grep { $v == $_ } keys %known_specs; # 2.0 => 2
        }
    
        # otherwise, use heuristics: look for 1.x vs 2.0 fields
        return "2" if exists $data->{prereqs};
        return "1.4" if exists $data->{configure_requires};
        return( $default || "1.2" ); # when meta-spec was first defined
    }
    
    #pod =method convert
    #pod
    #pod   my $new_struct = $cmc->convert( version => "2" );
    #pod
    #pod Returns a new hash reference with the metadata converted to a different form.
    #pod C<convert> will die if any conversion/standardization still results in an
    #pod invalid structure.
    #pod
    #pod Valid parameters include:
    #pod
    #pod =over
    #pod
    #pod =item *
    #pod
    #pod C<version> -- Indicates the desired specification version (e.g. "1.0", "1.1" ... "1.4", "2").
    #pod Defaults to the latest version of the CPAN Meta Spec.
    #pod
    #pod =back
    #pod
    #pod Conversion proceeds through each version in turn.  For example, a version 1.2
    #pod structure might be converted to 1.3 then 1.4 then finally to version 2. The
    #pod conversion process attempts to clean-up simple errors and standardize data.
    #pod For example, if C<author> is given as a scalar, it will converted to an array
    #pod reference containing the item. (Converting a structure to its own version will
    #pod also clean-up and standardize.)
    #pod
    #pod When data are cleaned and standardized, missing or invalid fields will be
    #pod replaced with sensible defaults when possible.  This may be lossy or imprecise.
    #pod For example, some badly structured META.yml files on CPAN have prerequisite
    #pod modules listed as both keys and values:
    #pod
    #pod   requires => { 'Foo::Bar' => 'Bam::Baz' }
    #pod
    #pod These would be split and each converted to a prerequisite with a minimum
    #pod version of zero.
    #pod
    #pod When some mandatory fields are missing or invalid, the conversion will attempt
    #pod to provide a sensible default or will fill them with a value of 'unknown'.  For
    #pod example a missing or unrecognized C<license> field will result in a C<license>
    #pod field of 'unknown'.  Fields that may get an 'unknown' include:
    #pod
    #pod =for :list
    #pod * abstract
    #pod * author
    #pod * license
    #pod
    #pod =cut
    
    sub convert {
      my ($self, %args) = @_;
      my $args = { %args };
    
      my $new_version = $args->{version} || $HIGHEST;
      my $is_fragment = $args->{is_fragment};
    
      my ($old_version) = $self->{spec};
      my $converted = _dclone($self->{data});
    
      if ( $old_version == $new_version ) {
        $converted = _convert( $converted, $cleanup{$old_version}, $old_version, $is_fragment );
        unless ( $args->{is_fragment} ) {
          my $cmv = CPAN::Meta::Validator->new( $converted );
          unless ( $cmv->is_valid ) {
            my $errs = join("\n", $cmv->errors);
            die "Failed to clean-up $old_version metadata. Errors:\n$errs\n";
          }
        }
        return $converted;
      }
      elsif ( $old_version > $new_version )  {
        my @vers = sort { $b <=> $a } keys %known_specs;
        for my $i ( 0 .. $#vers-1 ) {
          next if $vers[$i] > $old_version;
          last if $vers[$i+1] < $new_version;
          my $spec_string = "$vers[$i+1]-from-$vers[$i]";
          $converted = _convert( $converted, $down_convert{$spec_string}, $vers[$i+1], $is_fragment );
          unless ( $args->{is_fragment} ) {
            my $cmv = CPAN::Meta::Validator->new( $converted );
            unless ( $cmv->is_valid ) {
              my $errs = join("\n", $cmv->errors);
              die "Failed to downconvert metadata to $vers[$i+1]. Errors:\n$errs\n";
            }
          }
        }
        return $converted;
      }
      else {
        my @vers = sort { $a <=> $b } keys %known_specs;
        for my $i ( 0 .. $#vers-1 ) {
          next if $vers[$i] < $old_version;
          last if $vers[$i+1] > $new_version;
          my $spec_string = "$vers[$i+1]-from-$vers[$i]";
          $converted = _convert( $converted, $up_convert{$spec_string}, $vers[$i+1], $is_fragment );
          unless ( $args->{is_fragment} ) {
            my $cmv = CPAN::Meta::Validator->new( $converted );
            unless ( $cmv->is_valid ) {
              my $errs = join("\n", $cmv->errors);
              die "Failed to upconvert metadata to $vers[$i+1]. Errors:\n$errs\n";
            }
          }
        }
        return $converted;
      }
    }
    
    #pod =method upgrade_fragment
    #pod
    #pod   my $new_struct = $cmc->upgrade_fragment;
    #pod
    #pod Returns a new hash reference with the metadata converted to the latest version
    #pod of the CPAN Meta Spec.  No validation is done on the result -- you must
    #pod validate after merging fragments into a complete metadata document.
    #pod
    #pod Available since version 2.141170.
    #pod
    #pod =cut
    
    sub upgrade_fragment {
      my ($self) = @_;
      my ($old_version) = $self->{spec};
      my %expected =
        map {; $_ => 1 }
        grep { defined }
        map { $fragments_generate{$old_version}{$_} }
        keys %{ $self->{data} };
      my $converted = $self->convert( version => $HIGHEST, is_fragment => 1 );
      for my $key ( keys %$converted ) {
        next if $key =~ /^x_/i || $key eq 'meta-spec';
        delete $converted->{$key} unless $expected{$key};
      }
      return $converted;
    }
    
    1;
    
    # ABSTRACT: Convert CPAN distribution metadata structures
    
    =pod
    
    =encoding UTF-8
    
    =head1 NAME
    
    CPAN::Meta::Converter - Convert CPAN distribution metadata structures
    
    =head1 VERSION
    
    version 2.150005
    
    =head1 SYNOPSIS
    
      my $struct = decode_json_file('META.json');
    
      my $cmc = CPAN::Meta::Converter->new( $struct );
    
      my $new_struct = $cmc->convert( version => "2" );
    
    =head1 DESCRIPTION
    
    This module converts CPAN Meta structures from one form to another.  The
    primary use is to convert older structures to the most modern version of
    the specification, but other transformations may be implemented in the
    future as needed.  (E.g. stripping all custom fields or stripping all
    optional fields.)
    
    =head1 METHODS
    
    =head2 new
    
      my $cmc = CPAN::Meta::Converter->new( $struct );
    
    The constructor should be passed a valid metadata structure but invalid
    structures are accepted.  If no meta-spec version is provided, version 1.0 will
    be assumed.
    
    Optionally, you can provide a C<default_version> argument after C<$struct>:
    
      my $cmc = CPAN::Meta::Converter->new( $struct, default_version => "1.4" );
    
    This is only needed when converting a metadata fragment that does not include a
    C<meta-spec> field.
    
    =head2 convert
    
      my $new_struct = $cmc->convert( version => "2" );
    
    Returns a new hash reference with the metadata converted to a different form.
    C<convert> will die if any conversion/standardization still results in an
    invalid structure.
    
    Valid parameters include:
    
    =over
    
    =item *
    
    C<version> -- Indicates the desired specification version (e.g. "1.0", "1.1" ... "1.4", "2").
    Defaults to the latest version of the CPAN Meta Spec.
    
    =back
    
    Conversion proceeds through each version in turn.  For example, a version 1.2
    structure might be converted to 1.3 then 1.4 then finally to version 2. The
    conversion process attempts to clean-up simple errors and standardize data.
    For example, if C<author> is given as a scalar, it will converted to an array
    reference containing the item. (Converting a structure to its own version will
    also clean-up and standardize.)
    
    When data are cleaned and standardized, missing or invalid fields will be
    replaced with sensible defaults when possible.  This may be lossy or imprecise.
    For example, some badly structured META.yml files on CPAN have prerequisite
    modules listed as both keys and values:
    
      requires => { 'Foo::Bar' => 'Bam::Baz' }
    
    These would be split and each converted to a prerequisite with a minimum
    version of zero.
    
    When some mandatory fields are missing or invalid, the conversion will attempt
    to provide a sensible default or will fill them with a value of 'unknown'.  For
    example a missing or unrecognized C<license> field will result in a C<license>
    field of 'unknown'.  Fields that may get an 'unknown' include:
    
    =over 4
    
    =item *
    
    abstract
    
    =item *
    
    author
    
    =item *
    
    license
    
    =back
    
    =head2 upgrade_fragment
    
      my $new_struct = $cmc->upgrade_fragment;
    
    Returns a new hash reference with the metadata converted to the latest version
    of the CPAN Meta Spec.  No validation is done on the result -- you must
    validate after merging fragments into a complete metadata document.
    
    Available since version 2.141170.
    
    =head1 BUGS
    
    Please report any bugs or feature using the CPAN Request Tracker.
    Bugs can be submitted through the web interface at
    L<http://rt.cpan.org/Dist/Display.html?Queue=CPAN-Meta>
    
    When submitting a bug or request, please include a test-file or a patch to an
    existing test-file that illustrates the bug or desired feature.
    
    =head1 AUTHORS
    
    =over 4
    
    =item *
    
    David Golden <dagolden@cpan.org>
    
    =item *
    
    Ricardo Signes <rjbs@cpan.org>
    
    =back
    
    =head1 COPYRIGHT AND LICENSE
    
    This software is copyright (c) 2010 by David Golden and Ricardo Signes.
    
    This is free software; you can redistribute it and/or modify it under
    the same terms as the Perl 5 programming language system itself.
    
    =cut
    
    __END__
    
    
    # vim: ts=2 sts=2 sw=2 et :
  CPAN_META_CONVERTER
  
  $fatpacked{"CPAN/Meta/Feature.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_FEATURE';
    use 5.006;
    use strict;
    use warnings;
    package CPAN::Meta::Feature;
    
    our $VERSION = '2.150005';
    
    use CPAN::Meta::Prereqs;
    
    #pod =head1 DESCRIPTION
    #pod
    #pod A CPAN::Meta::Feature object describes an optional feature offered by a CPAN
    #pod distribution and specified in the distribution's F<META.json> (or F<META.yml>)
    #pod file.
    #pod
    #pod For the most part, this class will only be used when operating on the result of
    #pod the C<feature> or C<features> methods on a L<CPAN::Meta> object.
    #pod
    #pod =method new
    #pod
    #pod   my $feature = CPAN::Meta::Feature->new( $identifier => \%spec );
    #pod
    #pod This returns a new Feature object.  The C<%spec> argument to the constructor
    #pod should be the same as the value of the C<optional_feature> entry in the
    #pod distmeta.  It must contain entries for C<description> and C<prereqs>.
    #pod
    #pod =cut
    
    sub new {
      my ($class, $identifier, $spec) = @_;
    
      my %guts = (
        identifier  => $identifier,
        description => $spec->{description},
        prereqs     => CPAN::Meta::Prereqs->new($spec->{prereqs}),
      );
    
      bless \%guts => $class;
    }
    
    #pod =method identifier
    #pod
    #pod This method returns the feature's identifier.
    #pod
    #pod =cut
    
    sub identifier  { $_[0]{identifier}  }
    
    #pod =method description
    #pod
    #pod This method returns the feature's long description.
    #pod
    #pod =cut
    
    sub description { $_[0]{description} }
    
    #pod =method prereqs
    #pod
    #pod This method returns the feature's prerequisites as a L<CPAN::Meta::Prereqs>
    #pod object.
    #pod
    #pod =cut
    
    sub prereqs     { $_[0]{prereqs} }
    
    1;
    
    # ABSTRACT: an optional feature provided by a CPAN distribution
    
    =pod
    
    =encoding UTF-8
    
    =head1 NAME
    
    CPAN::Meta::Feature - an optional feature provided by a CPAN distribution
    
    =head1 VERSION
    
    version 2.150005
    
    =head1 DESCRIPTION
    
    A CPAN::Meta::Feature object describes an optional feature offered by a CPAN
    distribution and specified in the distribution's F<META.json> (or F<META.yml>)
    file.
    
    For the most part, this class will only be used when operating on the result of
    the C<feature> or C<features> methods on a L<CPAN::Meta> object.
    
    =head1 METHODS
    
    =head2 new
    
      my $feature = CPAN::Meta::Feature->new( $identifier => \%spec );
    
    This returns a new Feature object.  The C<%spec> argument to the constructor
    should be the same as the value of the C<optional_feature> entry in the
    distmeta.  It must contain entries for C<description> and C<prereqs>.
    
    =head2 identifier
    
    This method returns the feature's identifier.
    
    =head2 description
    
    This method returns the feature's long description.
    
    =head2 prereqs
    
    This method returns the feature's prerequisites as a L<CPAN::Meta::Prereqs>
    object.
    
    =head1 BUGS
    
    Please report any bugs or feature using the CPAN Request Tracker.
    Bugs can be submitted through the web interface at
    L<http://rt.cpan.org/Dist/Display.html?Queue=CPAN-Meta>
    
    When submitting a bug or request, please include a test-file or a patch to an
    existing test-file that illustrates the bug or desired feature.
    
    =head1 AUTHORS
    
    =over 4
    
    =item *
    
    David Golden <dagolden@cpan.org>
    
    =item *
    
    Ricardo Signes <rjbs@cpan.org>
    
    =back
    
    =head1 COPYRIGHT AND LICENSE
    
    This software is copyright (c) 2010 by David Golden and Ricardo Signes.
    
    This is free software; you can redistribute it and/or modify it under
    the same terms as the Perl 5 programming language system itself.
    
    =cut
    
    __END__
    
    
    # vim: ts=2 sts=2 sw=2 et :
  CPAN_META_FEATURE
  
  $fatpacked{"CPAN/Meta/History.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_HISTORY';
    # vi:tw=72
    use 5.006;
    use strict;
    use warnings;
    package CPAN::Meta::History;
    
    our $VERSION = '2.150005';
    
    1;
    
    # ABSTRACT: history of CPAN Meta Spec changes
    
    __END__
    
    =pod
    
    =encoding UTF-8
    
    =head1 NAME
    
    CPAN::Meta::History - history of CPAN Meta Spec changes
    
    =head1 VERSION
    
    version 2.150005
    
    =head1 DESCRIPTION
    
    The CPAN Meta Spec has gone through several iterations.  It was
    originally written in HTML and later revised into POD (though published
    in HTML generated from the POD).  Fields were added, removed or changed,
    sometimes by design and sometimes to reflect real-world usage after the
    fact.
    
    This document reconstructs the history of the CPAN Meta Spec based on
    change logs, repository commit messages and the published HTML files.
    In some cases, particularly prior to version 1.2, the exact version
    when certain fields were introduced or changed is inconsistent between
    sources.  When in doubt, the published HTML files for versions 1.0 to
    1.4 as they existed when version 2 was developed are used as the
    definitive source.
    
    Starting with version 2, the specification document is part of the
    CPAN-Meta distribution and will be published on CPAN as
    L<CPAN::Meta::Spec>.
    
    Going forward, specification version numbers will be integers and
    decimal portions will correspond to a release date for the CPAN::Meta
    library.
    
    =head1 HISTORY
    
    =head2 Version 2
    
    April 2010
    
    =over
    
    =item *
    
    Revised spec examples as perl data structures rather than YAML
    
    =item *
    
    Switched to JSON serialization from YAML
    
    =item *
    
    Specified allowed version number formats
    
    =item *
    
    Replaced 'requires', 'build_requires', 'configure_requires',
    'recommends' and 'conflicts' with new 'prereqs' data structure divided
    by I<phase> (configure, build, test, runtime, etc.) and I<relationship>
    (requires, recommends, suggests, conflicts)
    
    =item *
    
    Added support for 'develop' phase for requirements for maintaining
    a list of authoring tools
    
    =item *
    
    Changed 'license' to a list and revised the set of valid licenses
    
    =item *
    
    Made 'dynamic_config' mandatory to reduce confusion
    
    =item *
    
    Changed 'resources' subkey 'repository' to a hash that clarifies
    repository type, url for browsing and url for checkout
    
    =item *
    
    Changed 'resources' subkey 'bugtracker' to a hash for either web
    or mailto resource
    
    =item *
    
    Changed specification of 'optional_features':
    
    =over
    
    =item *
    
    Added formal specification and usage guide instead of just example
    
    =item *
    
    Changed to use new prereqs data structure instead of individual keys
    
    =back
    
    =item *
    
    Clarified intended use of 'author' as generalized contact list
    
    =item *
    
    Added 'release_status' field to indicate stable, testing or unstable
    status to provide hints to indexers
    
    =item *
    
    Added 'description' field for a longer description of the distribution
    
    =item *
    
    Formalized use of "x_" or "X_" for all custom keys not listed in the
    official spec
    
    =back
    
    =head2 Version 1.4
    
    June 2008
    
    =over
    
    =item *
    
    Noted explicit support for 'perl' in prerequisites
    
    =item *
    
    Added 'configure_requires' prerequisite type
    
    =item *
    
    Changed 'optional_features'
    
    =over
    
    =item *
    
    Example corrected to show map of maps instead of list of maps
    (though descriptive text said 'map' even in v1.3)
    
    =item *
    
    Removed 'requires_packages', 'requires_os' and 'excluded_os'
    as valid subkeys
    
    =back
    
    =back
    
    =head2 Version 1.3
    
    November 2006
    
    =over
    
    =item *
    
    Added 'no_index' subkey 'directory' and removed 'dir' to match actual
    usage in the wild
    
    =item *
    
    Added a 'repository' subkey to 'resources'
    
    =back
    
    =head2 Version 1.2
    
    August 2005
    
    =over
    
    =item *
    
    Re-wrote and restructured spec in POD syntax
    
    =item *
    
    Changed 'name' to be mandatory
    
    =item *
    
    Changed 'generated_by' to be mandatory
    
    =item *
    
    Changed 'license' to be mandatory
    
    =item *
    
    Added version range specifications for prerequisites
    
    =item *
    
    Added required 'abstract' field
    
    =item *
    
    Added required 'author' field
    
    =item *
    
    Added required 'meta-spec' field to define 'version' (and 'url') of the
    CPAN Meta Spec used for metadata
    
    =item *
    
    Added 'provides' field
    
    =item *
    
    Added 'no_index' field and deprecated 'private' field.  'no_index'
    subkeys include 'file', 'dir', 'package' and 'namespace'
    
    =item *
    
    Added 'keywords' field
    
    =item *
    
    Added 'resources' field with subkeys 'homepage', 'license', and
    'bugtracker'
    
    =item *
    
    Added 'optional_features' field as an alternate under 'recommends'.
    Includes 'description', 'requires', 'build_requires', 'conflicts',
    'requires_packages', 'requires_os' and 'excluded_os' as valid subkeys
    
    =item *
    
    Removed 'license_uri' field
    
    =back
    
    =head2 Version 1.1
    
    May 2003
    
    =over
    
    =item *
    
    Changed 'version' to be mandatory
    
    =item *
    
    Added 'private' field
    
    =item *
    
    Added 'license_uri' field
    
    =back
    
    =head2 Version 1.0
    
    March 2003
    
    =over
    
    =item *
    
    Original release (in HTML format only)
    
    =item *
    
    Included 'name', 'version', 'license', 'distribution_type', 'requires',
    'recommends', 'build_requires', 'conflicts', 'dynamic_config',
    'generated_by'
    
    =back
    
    =head1 AUTHORS
    
    =over 4
    
    =item *
    
    David Golden <dagolden@cpan.org>
    
    =item *
    
    Ricardo Signes <rjbs@cpan.org>
    
    =back
    
    =head1 COPYRIGHT AND LICENSE
    
    This software is copyright (c) 2010 by David Golden and Ricardo Signes.
    
    This is free software; you can redistribute it and/or modify it under
    the same terms as the Perl 5 programming language system itself.
    
    =cut
  CPAN_META_HISTORY
  
  $fatpacked{"CPAN/Meta/Merge.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_MERGE';
    use strict;
    use warnings;
    
    package CPAN::Meta::Merge;
    
    our $VERSION = '2.150005';
    
    use Carp qw/croak/;
    use Scalar::Util qw/blessed/;
    use CPAN::Meta::Converter 2.141170;
    
    sub _is_identical {
      my ($left, $right) = @_;
      return
        (not defined $left and not defined $right)
        # if either of these are references, we compare the serialized value
        || (defined $left and defined $right and $left eq $right);
    }
    
    sub _identical {
      my ($left, $right, $path) = @_;
      croak sprintf "Can't merge attribute %s: '%s' does not equal '%s'", join('.', @{$path}), $left, $right
        unless _is_identical($left, $right);
      return $left;
    }
    
    sub _merge {
      my ($current, $next, $mergers, $path) = @_;
      for my $key (keys %{$next}) {
        if (not exists $current->{$key}) {
          $current->{$key} = $next->{$key};
        }
        elsif (my $merger = $mergers->{$key}) {
          $current->{$key} = $merger->($current->{$key}, $next->{$key}, [ @{$path}, $key ]);
        }
        elsif ($merger = $mergers->{':default'}) {
          $current->{$key} = $merger->($current->{$key}, $next->{$key}, [ @{$path}, $key ]);
        }
        else {
          croak sprintf "Can't merge unknown attribute '%s'", join '.', @{$path}, $key;
        }
      }
      return $current;
    }
    
    sub _uniq {
      my %seen = ();
      return grep { not $seen{$_}++ } @_;
    }
    
    sub _set_addition {
      my ($left, $right) = @_;
      return [ +_uniq(@{$left}, @{$right}) ];
    }
    
    sub _uniq_map {
      my ($left, $right, $path) = @_;
      for my $key (keys %{$right}) {
        if (not exists $left->{$key}) {
          $left->{$key} = $right->{$key};
        }
        # identical strings or references are merged identically
        elsif (_is_identical($left->{$key}, $right->{$key})) {
          1; # do nothing - keep left
        }
        elsif (ref $left->{$key} eq 'HASH' and ref $right->{$key} eq 'HASH') {
          $left->{$key} = _uniq_map($left->{$key}, $right->{$key}, [ @{$path}, $key ]);
        }
        else {
          croak 'Duplication of element ' . join '.', @{$path}, $key;
        }
      }
      return $left;
    }
    
    sub _improvize {
      my ($left, $right, $path) = @_;
      my ($name) = reverse @{$path};
      if ($name =~ /^x_/) {
        if (ref($left) eq 'ARRAY') {
          return _set_addition($left, $right, $path);
        }
        elsif (ref($left) eq 'HASH') {
          return _uniq_map($left, $right, $path);
        }
        else {
          return _identical($left, $right, $path);
        }
      }
      croak sprintf "Can't merge '%s'", join '.', @{$path};
    }
    
    sub _optional_features {
      my ($left, $right, $path) = @_;
    
      for my $key (keys %{$right}) {
        if (not exists $left->{$key}) {
          $left->{$key} = $right->{$key};
        }
        else {
          for my $subkey (keys %{ $right->{$key} }) {
            next if $subkey eq 'prereqs';
            if (not exists $left->{$key}{$subkey}) {
              $left->{$key}{$subkey} = $right->{$key}{$subkey};
            }
            else {
              Carp::croak "Cannot merge two optional_features named '$key' with different '$subkey' values"
                if do { no warnings 'uninitialized'; $left->{$key}{$subkey} ne $right->{$key}{$subkey} };
            }
          }
    
          require CPAN::Meta::Prereqs;
          $left->{$key}{prereqs} =
            CPAN::Meta::Prereqs->new($left->{$key}{prereqs})
              ->with_merged_prereqs(CPAN::Meta::Prereqs->new($right->{$key}{prereqs}))
              ->as_string_hash;
        }
      }
      return $left;
    }
    
    
    my %default = (
      abstract       => \&_identical,
      author         => \&_set_addition,
      dynamic_config => sub {
        my ($left, $right) = @_;
        return $left || $right;
      },
      generated_by => sub {
        my ($left, $right) = @_;
        return join ', ', _uniq(split(/, /, $left), split(/, /, $right));
      },
      license     => \&_set_addition,
      'meta-spec' => {
        version => \&_identical,
        url     => \&_identical
      },
      name              => \&_identical,
      release_status    => \&_identical,
      version           => \&_identical,
      description       => \&_identical,
      keywords          => \&_set_addition,
      no_index          => { map { ($_ => \&_set_addition) } qw/file directory package namespace/ },
      optional_features => \&_optional_features,
      prereqs           => sub {
        require CPAN::Meta::Prereqs;
        my ($left, $right) = map { CPAN::Meta::Prereqs->new($_) } @_[0,1];
        return $left->with_merged_prereqs($right)->as_string_hash;
      },
      provides  => \&_uniq_map,
      resources => {
        license    => \&_set_addition,
        homepage   => \&_identical,
        bugtracker => \&_uniq_map,
        repository => \&_uniq_map,
        ':default' => \&_improvize,
      },
      ':default' => \&_improvize,
    );
    
    sub new {
      my ($class, %arguments) = @_;
      croak 'default version required' if not exists $arguments{default_version};
      my %mapping = %default;
      my %extra = %{ $arguments{extra_mappings} || {} };
      for my $key (keys %extra) {
        if (ref($mapping{$key}) eq 'HASH') {
          $mapping{$key} = { %{ $mapping{$key} }, %{ $extra{$key} } };
        }
        else {
          $mapping{$key} = $extra{$key};
        }
      }
      return bless {
        default_version => $arguments{default_version},
        mapping => _coerce_mapping(\%mapping, []),
      }, $class;
    }
    
    my %coderef_for = (
      set_addition => \&_set_addition,
      uniq_map     => \&_uniq_map,
      identical    => \&_identical,
      improvize    => \&_improvize,
    );
    
    sub _coerce_mapping {
      my ($orig, $map_path) = @_;
      my %ret;
      for my $key (keys %{$orig}) {
        my $value = $orig->{$key};
        if (ref($orig->{$key}) eq 'CODE') {
          $ret{$key} = $value;
        }
        elsif (ref($value) eq 'HASH') {
          my $mapping = _coerce_mapping($value, [ @{$map_path}, $key ]);
          $ret{$key} = sub {
            my ($left, $right, $path) = @_;
            return _merge($left, $right, $mapping, [ @{$path} ]);
          };
        }
        elsif ($coderef_for{$value}) {
          $ret{$key} = $coderef_for{$value};
        }
        else {
          croak "Don't know what to do with " . join '.', @{$map_path}, $key;
        }
      }
      return \%ret;
    }
    
    sub merge {
      my ($self, @items) = @_;
      my $current = {};
      for my $next (@items) {
        if ( blessed($next) && $next->isa('CPAN::Meta') ) {
          $next = $next->as_struct;
        }
        elsif ( ref($next) eq 'HASH' ) {
          my $cmc = CPAN::Meta::Converter->new(
            $next, default_version => $self->{default_version}
          );
          $next = $cmc->upgrade_fragment;
        }
        else {
          croak "Don't know how to merge '$next'";
        }
        $current = _merge($current, $next, $self->{mapping}, []);
      }
      return $current;
    }
    
    1;
    
    # ABSTRACT: Merging CPAN Meta fragments
    
    
    # vim: ts=2 sts=2 sw=2 et :
    
    __END__
    
    =pod
    
    =encoding UTF-8
    
    =head1 NAME
    
    CPAN::Meta::Merge - Merging CPAN Meta fragments
    
    =head1 VERSION
    
    version 2.150005
    
    =head1 SYNOPSIS
    
     my $merger = CPAN::Meta::Merge->new(default_version => "2");
     my $meta = $merger->merge($base, @additional);
    
    =head1 DESCRIPTION
    
    =head1 METHODS
    
    =head2 new
    
    This creates a CPAN::Meta::Merge object. It takes one mandatory named
    argument, C<version>, declaring the version of the meta-spec that must be
    used for the merge. It can optionally take an C<extra_mappings> argument
    that allows one to add additional merging functions for specific elements.
    
    =head2 merge(@fragments)
    
    Merge all C<@fragments> together. It will accept both CPAN::Meta objects and
    (possibly incomplete) hashrefs of metadata.
    
    =head1 AUTHORS
    
    =over 4
    
    =item *
    
    David Golden <dagolden@cpan.org>
    
    =item *
    
    Ricardo Signes <rjbs@cpan.org>
    
    =back
    
    =head1 COPYRIGHT AND LICENSE
    
    This software is copyright (c) 2010 by David Golden and Ricardo Signes.
    
    This is free software; you can redistribute it and/or modify it under
    the same terms as the Perl 5 programming language system itself.
    
    =cut
  CPAN_META_MERGE
  
  $fatpacked{"CPAN/Meta/Prereqs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_PREREQS';
    use 5.006;
    use strict;
    use warnings;
    package CPAN::Meta::Prereqs;
    
    our $VERSION = '2.150005';
    
    #pod =head1 DESCRIPTION
    #pod
    #pod A CPAN::Meta::Prereqs object represents the prerequisites for a CPAN
    #pod distribution or one of its optional features.  Each set of prereqs is
    #pod organized by phase and type, as described in L<CPAN::Meta::Prereqs>.
    #pod
    #pod =cut
    
    use Carp qw(confess);
    use Scalar::Util qw(blessed);
    use CPAN::Meta::Requirements 2.121;
    
    #pod =method new
    #pod
    #pod   my $prereq = CPAN::Meta::Prereqs->new( \%prereq_spec );
    #pod
    #pod This method returns a new set of Prereqs.  The input should look like the
    #pod contents of the C<prereqs> field described in L<CPAN::Meta::Spec>, meaning
    #pod something more or less like this:
    #pod
    #pod   my $prereq = CPAN::Meta::Prereqs->new({
    #pod     runtime => {
    #pod       requires => {
    #pod         'Some::Module' => '1.234',
    #pod         ...,
    #pod       },
    #pod       ...,
    #pod     },
    #pod     ...,
    #pod   });
    #pod
    #pod You can also construct an empty set of prereqs with:
    #pod
    #pod   my $prereqs = CPAN::Meta::Prereqs->new;
    #pod
    #pod This empty set of prereqs is useful for accumulating new prereqs before finally
    #pod dumping the whole set into a structure or string.
    #pod
    #pod =cut
    
    sub __legal_phases { qw(configure build test runtime develop)   }
    sub __legal_types  { qw(requires recommends suggests conflicts) }
    
    # expect a prereq spec from META.json -- rjbs, 2010-04-11
    sub new {
      my ($class, $prereq_spec) = @_;
      $prereq_spec ||= {};
    
      my %is_legal_phase = map {; $_ => 1 } $class->__legal_phases;
      my %is_legal_type  = map {; $_ => 1 } $class->__legal_types;
    
      my %guts;
      PHASE: for my $phase (keys %$prereq_spec) {
        next PHASE unless $phase =~ /\Ax_/i or $is_legal_phase{$phase};
    
        my $phase_spec = $prereq_spec->{ $phase };
        next PHASE unless keys %$phase_spec;
    
        TYPE: for my $type (keys %$phase_spec) {
          next TYPE unless $type =~ /\Ax_/i or $is_legal_type{$type};
    
          my $spec = $phase_spec->{ $type };
    
          next TYPE unless keys %$spec;
    
          $guts{prereqs}{$phase}{$type} = CPAN::Meta::Requirements->from_string_hash(
            $spec
          );
        }
      }
    
      return bless \%guts => $class;
    }
    
    #pod =method requirements_for
    #pod
    #pod   my $requirements = $prereqs->requirements_for( $phase, $type );
    #pod
    #pod This method returns a L<CPAN::Meta::Requirements> object for the given
    #pod phase/type combination.  If no prerequisites are registered for that
    #pod combination, a new CPAN::Meta::Requirements object will be returned, and it may
    #pod be added to as needed.
    #pod
    #pod If C<$phase> or C<$type> are undefined or otherwise invalid, an exception will
    #pod be raised.
    #pod
    #pod =cut
    
    sub requirements_for {
      my ($self, $phase, $type) = @_;
    
      confess "requirements_for called without phase" unless defined $phase;
      confess "requirements_for called without type"  unless defined $type;
    
      unless ($phase =~ /\Ax_/i or grep { $phase eq $_ } $self->__legal_phases) {
        confess "requested requirements for unknown phase: $phase";
      }
    
      unless ($type =~ /\Ax_/i or grep { $type eq $_ } $self->__legal_types) {
        confess "requested requirements for unknown type: $type";
      }
    
      my $req = ($self->{prereqs}{$phase}{$type} ||= CPAN::Meta::Requirements->new);
    
      $req->finalize if $self->is_finalized;
    
      return $req;
    }
    
    #pod =method with_merged_prereqs
    #pod
    #pod   my $new_prereqs = $prereqs->with_merged_prereqs( $other_prereqs );
    #pod
    #pod   my $new_prereqs = $prereqs->with_merged_prereqs( \@other_prereqs );
    #pod
    #pod This method returns a new CPAN::Meta::Prereqs objects in which all the
    #pod other prerequisites given are merged into the current set.  This is primarily
    #pod provided for combining a distribution's core prereqs with the prereqs of one of
    #pod its optional features.
    #pod
    #pod The new prereqs object has no ties to the originals, and altering it further
    #pod will not alter them.
    #pod
    #pod =cut
    
    sub with_merged_prereqs {
      my ($self, $other) = @_;
    
      my @other = blessed($other) ? $other : @$other;
    
      my @prereq_objs = ($self, @other);
    
      my %new_arg;
    
      for my $phase ($self->__legal_phases) {
        for my $type ($self->__legal_types) {
          my $req = CPAN::Meta::Requirements->new;
    
          for my $prereq (@prereq_objs) {
            my $this_req = $prereq->requirements_for($phase, $type);
            next unless $this_req->required_modules;
    
            $req->add_requirements($this_req);
          }
    
          next unless $req->required_modules;
    
          $new_arg{ $phase }{ $type } = $req->as_string_hash;
        }
      }
    
      return (ref $self)->new(\%new_arg);
    }
    
    #pod =method merged_requirements
    #pod
    #pod     my $new_reqs = $prereqs->merged_requirements( \@phases, \@types );
    #pod     my $new_reqs = $prereqs->merged_requirements( \@phases );
    #pod     my $new_reqs = $prereqs->merged_requirements();
    #pod
    #pod This method joins together all requirements across a number of phases
    #pod and types into a new L<CPAN::Meta::Requirements> object.  If arguments
    #pod are omitted, it defaults to "runtime", "build" and "test" for phases
    #pod and "requires" and "recommends" for types.
    #pod
    #pod =cut
    
    sub merged_requirements {
      my ($self, $phases, $types) = @_;
      $phases = [qw/runtime build test/] unless defined $phases;
      $types = [qw/requires recommends/] unless defined $types;
    
      confess "merged_requirements phases argument must be an arrayref"
        unless ref $phases eq 'ARRAY';
      confess "merged_requirements types argument must be an arrayref"
        unless ref $types eq 'ARRAY';
    
      my $req = CPAN::Meta::Requirements->new;
    
      for my $phase ( @$phases ) {
        unless ($phase =~ /\Ax_/i or grep { $phase eq $_ } $self->__legal_phases) {
            confess "requested requirements for unknown phase: $phase";
        }
        for my $type ( @$types ) {
          unless ($type =~ /\Ax_/i or grep { $type eq $_ } $self->__legal_types) {
              confess "requested requirements for unknown type: $type";
          }
          $req->add_requirements( $self->requirements_for($phase, $type) );
        }
      }
    
      $req->finalize if $self->is_finalized;
    
      return $req;
    }
    
    
    #pod =method as_string_hash
    #pod
    #pod This method returns a hashref containing structures suitable for dumping into a
    #pod distmeta data structure.  It is made up of hashes and strings, only; there will
    #pod be no Prereqs, CPAN::Meta::Requirements, or C<version> objects inside it.
    #pod
    #pod =cut
    
    sub as_string_hash {
      my ($self) = @_;
    
      my %hash;
    
      for my $phase ($self->__legal_phases) {
        for my $type ($self->__legal_types) {
          my $req = $self->requirements_for($phase, $type);
          next unless $req->required_modules;
    
          $hash{ $phase }{ $type } = $req->as_string_hash;
        }
      }
    
      return \%hash;
    }
    
    #pod =method is_finalized
    #pod
    #pod This method returns true if the set of prereqs has been marked "finalized," and
    #pod cannot be altered.
    #pod
    #pod =cut
    
    sub is_finalized { $_[0]{finalized} }
    
    #pod =method finalize
    #pod
    #pod Calling C<finalize> on a Prereqs object will close it for further modification.
    #pod Attempting to make any changes that would actually alter the prereqs will
    #pod result in an exception being thrown.
    #pod
    #pod =cut
    
    sub finalize {
      my ($self) = @_;
    
      $self->{finalized} = 1;
    
      for my $phase (keys %{ $self->{prereqs} }) {
        $_->finalize for values %{ $self->{prereqs}{$phase} };
      }
    }
    
    #pod =method clone
    #pod
    #pod   my $cloned_prereqs = $prereqs->clone;
    #pod
    #pod This method returns a Prereqs object that is identical to the original object,
    #pod but can be altered without affecting the original object.  Finalization does
    #pod not survive cloning, meaning that you may clone a finalized set of prereqs and
    #pod then modify the clone.
    #pod
    #pod =cut
    
    sub clone {
      my ($self) = @_;
    
      my $clone = (ref $self)->new( $self->as_string_hash );
    }
    
    1;
    
    # ABSTRACT: a set of distribution prerequisites by phase and type
    
    =pod
    
    =encoding UTF-8
    
    =head1 NAME
    
    CPAN::Meta::Prereqs - a set of distribution prerequisites by phase and type
    
    =head1 VERSION
    
    version 2.150005
    
    =head1 DESCRIPTION
    
    A CPAN::Meta::Prereqs object represents the prerequisites for a CPAN
    distribution or one of its optional features.  Each set of prereqs is
    organized by phase and type, as described in L<CPAN::Meta::Prereqs>.
    
    =head1 METHODS
    
    =head2 new
    
      my $prereq = CPAN::Meta::Prereqs->new( \%prereq_spec );
    
    This method returns a new set of Prereqs.  The input should look like the
    contents of the C<prereqs> field described in L<CPAN::Meta::Spec>, meaning
    something more or less like this:
    
      my $prereq = CPAN::Meta::Prereqs->new({
        runtime => {
          requires => {
            'Some::Module' => '1.234',
            ...,
          },
          ...,
        },
        ...,
      });
    
    You can also construct an empty set of prereqs with:
    
      my $prereqs = CPAN::Meta::Prereqs->new;
    
    This empty set of prereqs is useful for accumulating new prereqs before finally
    dumping the whole set into a structure or string.
    
    =head2 requirements_for
    
      my $requirements = $prereqs->requirements_for( $phase, $type );
    
    This method returns a L<CPAN::Meta::Requirements> object for the given
    phase/type combination.  If no prerequisites are registered for that
    combination, a new CPAN::Meta::Requirements object will be returned, and it may
    be added to as needed.
    
    If C<$phase> or C<$type> are undefined or otherwise invalid, an exception will
    be raised.
    
    =head2 with_merged_prereqs
    
      my $new_prereqs = $prereqs->with_merged_prereqs( $other_prereqs );
    
      my $new_prereqs = $prereqs->with_merged_prereqs( \@other_prereqs );
    
    This method returns a new CPAN::Meta::Prereqs objects in which all the
    other prerequisites given are merged into the current set.  This is primarily
    provided for combining a distribution's core prereqs with the prereqs of one of
    its optional features.
    
    The new prereqs object has no ties to the originals, and altering it further
    will not alter them.
    
    =head2 merged_requirements
    
        my $new_reqs = $prereqs->merged_requirements( \@phases, \@types );
        my $new_reqs = $prereqs->merged_requirements( \@phases );
        my $new_reqs = $prereqs->merged_requirements();
    
    This method joins together all requirements across a number of phases
    and types into a new L<CPAN::Meta::Requirements> object.  If arguments
    are omitted, it defaults to "runtime", "build" and "test" for phases
    and "requires" and "recommends" for types.
    
    =head2 as_string_hash
    
    This method returns a hashref containing structures suitable for dumping into a
    distmeta data structure.  It is made up of hashes and strings, only; there will
    be no Prereqs, CPAN::Meta::Requirements, or C<version> objects inside it.
    
    =head2 is_finalized
    
    This method returns true if the set of prereqs has been marked "finalized," and
    cannot be altered.
    
    =head2 finalize
    
    Calling C<finalize> on a Prereqs object will close it for further modification.
    Attempting to make any changes that would actually alter the prereqs will
    result in an exception being thrown.
    
    =head2 clone
    
      my $cloned_prereqs = $prereqs->clone;
    
    This method returns a Prereqs object that is identical to the original object,
    but can be altered without affecting the original object.  Finalization does
    not survive cloning, meaning that you may clone a finalized set of prereqs and
    then modify the clone.
    
    =head1 BUGS
    
    Please report any bugs or feature using the CPAN Request Tracker.
    Bugs can be submitted through the web interface at
    L<http://rt.cpan.org/Dist/Display.html?Queue=CPAN-Meta>
    
    When submitting a bug or request, please include a test-file or a patch to an
    existing test-file that illustrates the bug or desired feature.
    
    =head1 AUTHORS
    
    =over 4
    
    =item *
    
    David Golden <dagolden@cpan.org>
    
    =item *
    
    Ricardo Signes <rjbs@cpan.org>
    
    =back
    
    =head1 COPYRIGHT AND LICENSE
    
    This software is copyright (c) 2010 by David Golden and Ricardo Signes.
    
    This is free software; you can redistribute it and/or modify it under
    the same terms as the Perl 5 programming language system itself.
    
    =cut
    
    __END__
    
    
    # vim: ts=2 sts=2 sw=2 et :
  CPAN_META_PREREQS
  
  $fatpacked{"CPAN/Meta/Requirements.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_REQUIREMENTS';
    use strict;
    use warnings;
    package CPAN::Meta::Requirements;
    # ABSTRACT: a set of version requirements for a CPAN dist
    
    our $VERSION = '2.133';
    
    #pod =head1 SYNOPSIS
    #pod
    #pod   use CPAN::Meta::Requirements;
    #pod
    #pod   my $build_requires = CPAN::Meta::Requirements->new;
    #pod
    #pod   $build_requires->add_minimum('Library::Foo' => 1.208);
    #pod
    #pod   $build_requires->add_minimum('Library::Foo' => 2.602);
    #pod
    #pod   $build_requires->add_minimum('Module::Bar'  => 'v1.2.3');
    #pod
    #pod   $METAyml->{build_requires} = $build_requires->as_string_hash;
    #pod
    #pod =head1 DESCRIPTION
    #pod
    #pod A CPAN::Meta::Requirements object models a set of version constraints like
    #pod those specified in the F<META.yml> or F<META.json> files in CPAN distributions,
    #pod and as defined by L<CPAN::Meta::Spec>;
    #pod It can be built up by adding more and more constraints, and it will reduce them
    #pod to the simplest representation.
    #pod
    #pod Logically impossible constraints will be identified immediately by thrown
    #pod exceptions.
    #pod
    #pod =cut
    
    use Carp ();
    
    # To help ExtUtils::MakeMaker bootstrap CPAN::Meta::Requirements on perls
    # before 5.10, we fall back to the EUMM bundled compatibility version module if
    # that's the only thing available.  This shouldn't ever happen in a normal CPAN
    # install of CPAN::Meta::Requirements, as version.pm will be picked up from
    # prereqs and be available at runtime.
    
    BEGIN {
      eval "use version ()"; ## no critic
      if ( my $err = $@ ) {
        eval "use ExtUtils::MakeMaker::version" or die $err; ## no critic
      }
    }
    
    # Perl 5.10.0 didn't have "is_qv" in version.pm
    *_is_qv = version->can('is_qv') ? sub { $_[0]->is_qv } : sub { exists $_[0]->{qv} };
    
    # construct once, reuse many times
    my $V0 = version->new(0);
    
    #pod =method new
    #pod
    #pod   my $req = CPAN::Meta::Requirements->new;
    #pod
    #pod This returns a new CPAN::Meta::Requirements object.  It takes an optional
    #pod hash reference argument.  Currently, only one key is supported:
    #pod
    #pod =for :list
    #pod * C<bad_version_hook> -- if provided, when a version cannot be parsed into
    #pod   a version object, this code reference will be called with the invalid
    #pod   version string as first argument, and the module name as second
    #pod   argument.  It must return a valid version object.
    #pod
    #pod All other keys are ignored.
    #pod
    #pod =cut
    
    my @valid_options = qw( bad_version_hook );
    
    sub new {
      my ($class, $options) = @_;
      $options ||= {};
      Carp::croak "Argument to $class\->new() must be a hash reference"
        unless ref $options eq 'HASH';
      my %self = map {; $_ => $options->{$_}} @valid_options;
    
      return bless \%self => $class;
    }
    
    # from version::vpp
    sub _find_magic_vstring {
      my $value = shift;
      my $tvalue = '';
      require B;
      my $sv = B::svref_2object(\$value);
      my $magic = ref($sv) eq 'B::PVMG' ? $sv->MAGIC : undef;
      while ( $magic ) {
        if ( $magic->TYPE eq 'V' ) {
          $tvalue = $magic->PTR;
          $tvalue =~ s/^v?(.+)$/v$1/;
          last;
        }
        else {
          $magic = $magic->MOREMAGIC;
        }
      }
      return $tvalue;
    }
    
    # safe if given an unblessed reference
    sub _isa_version {
      UNIVERSAL::isa( $_[0], 'UNIVERSAL' ) && $_[0]->isa('version')
    }
    
    sub _version_object {
      my ($self, $module, $version) = @_;
    
      my ($vobj, $err);
    
      if (not defined $version or (!ref($version) && $version eq '0')) {
        return $V0;
      }
      elsif ( ref($version) eq 'version' || _isa_version($version) ) {
        $vobj = $version;
      }
      else {
        # hack around version::vpp not handling <3 character vstring literals
        if ( $INC{'version/vpp.pm'} || $INC{'ExtUtils/MakeMaker/version/vpp.pm'} ) {
          my $magic = _find_magic_vstring( $version );
          $version = $magic if length $magic;
        }
        eval {
          local $SIG{__WARN__} = sub { die "Invalid version: $_[0]" };
          $vobj = version->new($version);
        };
        if ( my $err = $@ ) {
          my $hook = $self->{bad_version_hook};
          $vobj = eval { $hook->($version, $module) }
            if ref $hook eq 'CODE';
          unless (eval { $vobj->isa("version") }) {
            $err =~ s{ at .* line \d+.*$}{};
            die "Can't convert '$version': $err";
          }
        }
      }
    
      # ensure no leading '.'
      if ( $vobj =~ m{\A\.} ) {
        $vobj = version->new("0$vobj");
      }
    
      # ensure normal v-string form
      if ( _is_qv($vobj) ) {
        $vobj = version->new($vobj->normal);
      }
    
      return $vobj;
    }
    
    #pod =method add_minimum
    #pod
    #pod   $req->add_minimum( $module => $version );
    #pod
    #pod This adds a new minimum version requirement.  If the new requirement is
    #pod redundant to the existing specification, this has no effect.
    #pod
    #pod Minimum requirements are inclusive.  C<$version> is required, along with any
    #pod greater version number.
    #pod
    #pod This method returns the requirements object.
    #pod
    #pod =method add_maximum
    #pod
    #pod   $req->add_maximum( $module => $version );
    #pod
    #pod This adds a new maximum version requirement.  If the new requirement is
    #pod redundant to the existing specification, this has no effect.
    #pod
    #pod Maximum requirements are inclusive.  No version strictly greater than the given
    #pod version is allowed.
    #pod
    #pod This method returns the requirements object.
    #pod
    #pod =method add_exclusion
    #pod
    #pod   $req->add_exclusion( $module => $version );
    #pod
    #pod This adds a new excluded version.  For example, you might use these three
    #pod method calls:
    #pod
    #pod   $req->add_minimum( $module => '1.00' );
    #pod   $req->add_maximum( $module => '1.82' );
    #pod
    #pod   $req->add_exclusion( $module => '1.75' );
    #pod
    #pod Any version between 1.00 and 1.82 inclusive would be acceptable, except for
    #pod 1.75.
    #pod
    #pod This method returns the requirements object.
    #pod
    #pod =method exact_version
    #pod
    #pod   $req->exact_version( $module => $version );
    #pod
    #pod This sets the version required for the given module to I<exactly> the given
    #pod version.  No other version would be considered acceptable.
    #pod
    #pod This method returns the requirements object.
    #pod
    #pod =cut
    
    BEGIN {
      for my $type (qw(maximum exclusion exact_version)) {
        my $method = "with_$type";
        my $to_add = $type eq 'exact_version' ? $type : "add_$type";
    
        my $code = sub {
          my ($self, $name, $version) = @_;
    
          $version = $self->_version_object( $name, $version );
    
          $self->__modify_entry_for($name, $method, $version);
    
          return $self;
        };
        
        no strict 'refs';
        *$to_add = $code;
      }
    }
    
    # add_minimum is optimized compared to generated subs above because
    # it is called frequently and with "0" or equivalent input
    sub add_minimum {
      my ($self, $name, $version) = @_;
    
      # stringify $version so that version->new("0.00")->stringify ne "0"
      # which preserves the user's choice of "0.00" as the requirement
      if (not defined $version or "$version" eq '0') {
        return $self if $self->__entry_for($name);
        Carp::confess("can't add new requirements to finalized requirements")
          if $self->is_finalized;
    
        $self->{requirements}{ $name } =
          CPAN::Meta::Requirements::_Range::Range->with_minimum($V0);
      }
      else {
        $version = $self->_version_object( $name, $version );
    
        $self->__modify_entry_for($name, 'with_minimum', $version);
      }
      return $self;
    }
    
    #pod =method add_requirements
    #pod
    #pod   $req->add_requirements( $another_req_object );
    #pod
    #pod This method adds all the requirements in the given CPAN::Meta::Requirements object
    #pod to the requirements object on which it was called.  If there are any conflicts,
    #pod an exception is thrown.
    #pod
    #pod This method returns the requirements object.
    #pod
    #pod =cut
    
    sub add_requirements {
      my ($self, $req) = @_;
    
      for my $module ($req->required_modules) {
        my $modifiers = $req->__entry_for($module)->as_modifiers;
        for my $modifier (@$modifiers) {
          my ($method, @args) = @$modifier;
          $self->$method($module => @args);
        };
      }
    
      return $self;
    }
    
    #pod =method accepts_module
    #pod
    #pod   my $bool = $req->accepts_module($module => $version);
    #pod
    #pod Given an module and version, this method returns true if the version
    #pod specification for the module accepts the provided version.  In other words,
    #pod given:
    #pod
    #pod   Module => '>= 1.00, < 2.00'
    #pod
    #pod We will accept 1.00 and 1.75 but not 0.50 or 2.00.
    #pod
    #pod For modules that do not appear in the requirements, this method will return
    #pod true.
    #pod
    #pod =cut
    
    sub accepts_module {
      my ($self, $module, $version) = @_;
    
      $version = $self->_version_object( $module, $version );
    
      return 1 unless my $range = $self->__entry_for($module);
      return $range->_accepts($version);
    }
    
    #pod =method clear_requirement
    #pod
    #pod   $req->clear_requirement( $module );
    #pod
    #pod This removes the requirement for a given module from the object.
    #pod
    #pod This method returns the requirements object.
    #pod
    #pod =cut
    
    sub clear_requirement {
      my ($self, $module) = @_;
    
      return $self unless $self->__entry_for($module);
    
      Carp::confess("can't clear requirements on finalized requirements")
        if $self->is_finalized;
    
      delete $self->{requirements}{ $module };
    
      return $self;
    }
    
    #pod =method requirements_for_module
    #pod
    #pod   $req->requirements_for_module( $module );
    #pod
    #pod This returns a string containing the version requirements for a given module in
    #pod the format described in L<CPAN::Meta::Spec> or undef if the given module has no
    #pod requirements. This should only be used for informational purposes such as error
    #pod messages and should not be interpreted or used for comparison (see
    #pod L</accepts_module> instead.)
    #pod
    #pod =cut
    
    sub requirements_for_module {
      my ($self, $module) = @_;
      my $entry = $self->__entry_for($module);
      return unless $entry;
      return $entry->as_string;
    }
    
    #pod =method required_modules
    #pod
    #pod This method returns a list of all the modules for which requirements have been
    #pod specified.
    #pod
    #pod =cut
    
    sub required_modules { keys %{ $_[0]{requirements} } }
    
    #pod =method clone
    #pod
    #pod   $req->clone;
    #pod
    #pod This method returns a clone of the invocant.  The clone and the original object
    #pod can then be changed independent of one another.
    #pod
    #pod =cut
    
    sub clone {
      my ($self) = @_;
      my $new = (ref $self)->new;
    
      return $new->add_requirements($self);
    }
    
    sub __entry_for     { $_[0]{requirements}{ $_[1] } }
    
    sub __modify_entry_for {
      my ($self, $name, $method, $version) = @_;
    
      my $fin = $self->is_finalized;
      my $old = $self->__entry_for($name);
    
      Carp::confess("can't add new requirements to finalized requirements")
        if $fin and not $old;
    
      my $new = ($old || 'CPAN::Meta::Requirements::_Range::Range')
              ->$method($version);
    
      Carp::confess("can't modify finalized requirements")
        if $fin and $old->as_string ne $new->as_string;
    
      $self->{requirements}{ $name } = $new;
    }
    
    #pod =method is_simple
    #pod
    #pod This method returns true if and only if all requirements are inclusive minimums
    #pod -- that is, if their string expression is just the version number.
    #pod
    #pod =cut
    
    sub is_simple {
      my ($self) = @_;
      for my $module ($self->required_modules) {
        # XXX: This is a complete hack, but also entirely correct.
        return if $self->__entry_for($module)->as_string =~ /\s/;
      }
    
      return 1;
    }
    
    #pod =method is_finalized
    #pod
    #pod This method returns true if the requirements have been finalized by having the
    #pod C<finalize> method called on them.
    #pod
    #pod =cut
    
    sub is_finalized { $_[0]{finalized} }
    
    #pod =method finalize
    #pod
    #pod This method marks the requirements finalized.  Subsequent attempts to change
    #pod the requirements will be fatal, I<if> they would result in a change.  If they
    #pod would not alter the requirements, they have no effect.
    #pod
    #pod If a finalized set of requirements is cloned, the cloned requirements are not
    #pod also finalized.
    #pod
    #pod =cut
    
    sub finalize { $_[0]{finalized} = 1 }
    
    #pod =method as_string_hash
    #pod
    #pod This returns a reference to a hash describing the requirements using the
    #pod strings in the L<CPAN::Meta::Spec> specification.
    #pod
    #pod For example after the following program:
    #pod
    #pod   my $req = CPAN::Meta::Requirements->new;
    #pod
    #pod   $req->add_minimum('CPAN::Meta::Requirements' => 0.102);
    #pod
    #pod   $req->add_minimum('Library::Foo' => 1.208);
    #pod
    #pod   $req->add_maximum('Library::Foo' => 2.602);
    #pod
    #pod   $req->add_minimum('Module::Bar'  => 'v1.2.3');
    #pod
    #pod   $req->add_exclusion('Module::Bar'  => 'v1.2.8');
    #pod
    #pod   $req->exact_version('Xyzzy'  => '6.01');
    #pod
    #pod   my $hashref = $req->as_string_hash;
    #pod
    #pod C<$hashref> would contain:
    #pod
    #pod   {
    #pod     'CPAN::Meta::Requirements' => '0.102',
    #pod     'Library::Foo' => '>= 1.208, <= 2.206',
    #pod     'Module::Bar'  => '>= v1.2.3, != v1.2.8',
    #pod     'Xyzzy'        => '== 6.01',
    #pod   }
    #pod
    #pod =cut
    
    sub as_string_hash {
      my ($self) = @_;
    
      my %hash = map {; $_ => $self->{requirements}{$_}->as_string }
                 $self->required_modules;
    
      return \%hash;
    }
    
    #pod =method add_string_requirement
    #pod
    #pod   $req->add_string_requirement('Library::Foo' => '>= 1.208, <= 2.206');
    #pod   $req->add_string_requirement('Library::Foo' => v1.208);
    #pod
    #pod This method parses the passed in string and adds the appropriate requirement
    #pod for the given module.  A version can be a Perl "v-string".  It understands
    #pod version ranges as described in the L<CPAN::Meta::Spec/Version Ranges>. For
    #pod example:
    #pod
    #pod =over 4
    #pod
    #pod =item 1.3
    #pod
    #pod =item >= 1.3
    #pod
    #pod =item <= 1.3
    #pod
    #pod =item == 1.3
    #pod
    #pod =item != 1.3
    #pod
    #pod =item > 1.3
    #pod
    #pod =item < 1.3
    #pod
    #pod =item >= 1.3, != 1.5, <= 2.0
    #pod
    #pod A version number without an operator is equivalent to specifying a minimum
    #pod (C<E<gt>=>).  Extra whitespace is allowed.
    #pod
    #pod =back
    #pod
    #pod =cut
    
    my %methods_for_op = (
      '==' => [ qw(exact_version) ],
      '!=' => [ qw(add_exclusion) ],
      '>=' => [ qw(add_minimum)   ],
      '<=' => [ qw(add_maximum)   ],
      '>'  => [ qw(add_minimum add_exclusion) ],
      '<'  => [ qw(add_maximum add_exclusion) ],
    );
    
    sub add_string_requirement {
      my ($self, $module, $req) = @_;
    
      unless ( defined $req && length $req ) {
        $req = 0;
        $self->_blank_carp($module);
      }
    
      my $magic = _find_magic_vstring( $req );
      if (length $magic) {
        $self->add_minimum($module => $magic);
        return;
      }
    
      my @parts = split qr{\s*,\s*}, $req;
    
      for my $part (@parts) {
        my ($op, $ver) = $part =~ m{\A\s*(==|>=|>|<=|<|!=)\s*(.*)\z};
    
        if (! defined $op) {
          $self->add_minimum($module => $part);
        } else {
          Carp::confess("illegal requirement string: $req")
            unless my $methods = $methods_for_op{ $op };
    
          $self->$_($module => $ver) for @$methods;
        }
      }
    }
    
    #pod =method from_string_hash
    #pod
    #pod   my $req = CPAN::Meta::Requirements->from_string_hash( \%hash );
    #pod   my $req = CPAN::Meta::Requirements->from_string_hash( \%hash, \%opts );
    #pod
    #pod This is an alternate constructor for a CPAN::Meta::Requirements
    #pod object. It takes a hash of module names and version requirement
    #pod strings and returns a new CPAN::Meta::Requirements object. As with
    #pod add_string_requirement, a version can be a Perl "v-string". Optionally,
    #pod you can supply a hash-reference of options, exactly as with the L</new>
    #pod method.
    #pod
    #pod =cut
    
    sub _blank_carp {
      my ($self, $module) = @_;
      Carp::carp("Undefined requirement for $module treated as '0'");
    }
    
    sub from_string_hash {
      my ($class, $hash, $options) = @_;
    
      my $self = $class->new($options);
    
      for my $module (keys %$hash) {
        my $req = $hash->{$module};
        unless ( defined $req && length $req ) {
          $req = 0;
          $class->_blank_carp($module);
        }
        $self->add_string_requirement($module, $req);
      }
    
      return $self;
    }
    
    ##############################################################
    
    {
      package
        CPAN::Meta::Requirements::_Range::Exact;
      sub _new     { bless { version => $_[1] } => $_[0] }
    
      sub _accepts { return $_[0]{version} == $_[1] }
    
      sub as_string { return "== $_[0]{version}" }
    
      sub as_modifiers { return [ [ exact_version => $_[0]{version} ] ] }
    
      sub _clone {
        (ref $_[0])->_new( version->new( $_[0]{version} ) )
      }
    
      sub with_exact_version {
        my ($self, $version) = @_;
    
        return $self->_clone if $self->_accepts($version);
    
        Carp::confess("illegal requirements: unequal exact version specified");
      }
    
      sub with_minimum {
        my ($self, $minimum) = @_;
        return $self->_clone if $self->{version} >= $minimum;
        Carp::confess("illegal requirements: minimum above exact specification");
      }
    
      sub with_maximum {
        my ($self, $maximum) = @_;
        return $self->_clone if $self->{version} <= $maximum;
        Carp::confess("illegal requirements: maximum below exact specification");
      }
    
      sub with_exclusion {
        my ($self, $exclusion) = @_;
        return $self->_clone unless $exclusion == $self->{version};
        Carp::confess("illegal requirements: excluded exact specification");
      }
    }
    
    ##############################################################
    
    {
      package
        CPAN::Meta::Requirements::_Range::Range;
    
      sub _self { ref($_[0]) ? $_[0] : (bless { } => $_[0]) }
    
      sub _clone {
        return (bless { } => $_[0]) unless ref $_[0];
    
        my ($s) = @_;
        my %guts = (
          (exists $s->{minimum} ? (minimum => version->new($s->{minimum})) : ()),
          (exists $s->{maximum} ? (maximum => version->new($s->{maximum})) : ()),
    
          (exists $s->{exclusions}
            ? (exclusions => [ map { version->new($_) } @{ $s->{exclusions} } ])
            : ()),
        );
    
        bless \%guts => ref($s);
      }
    
      sub as_modifiers {
        my ($self) = @_;
        my @mods;
        push @mods, [ add_minimum => $self->{minimum} ] if exists $self->{minimum};
        push @mods, [ add_maximum => $self->{maximum} ] if exists $self->{maximum};
        push @mods, map {; [ add_exclusion => $_ ] } @{$self->{exclusions} || []};
        return \@mods;
      }
    
      sub as_string {
        my ($self) = @_;
    
        return 0 if ! keys %$self;
    
        return "$self->{minimum}" if (keys %$self) == 1 and exists $self->{minimum};
    
        my @exclusions = @{ $self->{exclusions} || [] };
    
        my @parts;
    
        for my $pair (
          [ qw( >= > minimum ) ],
          [ qw( <= < maximum ) ],
        ) {
          my ($op, $e_op, $k) = @$pair;
          if (exists $self->{$k}) {
            my @new_exclusions = grep { $_ != $self->{ $k } } @exclusions;
            if (@new_exclusions == @exclusions) {
              push @parts, "$op $self->{ $k }";
            } else {
              push @parts, "$e_op $self->{ $k }";
              @exclusions = @new_exclusions;
            }
          }
        }
    
        push @parts, map {; "!= $_" } @exclusions;
    
        return join q{, }, @parts;
      }
    
      sub with_exact_version {
        my ($self, $version) = @_;
        $self = $self->_clone;
    
        Carp::confess("illegal requirements: exact specification outside of range")
          unless $self->_accepts($version);
    
        return CPAN::Meta::Requirements::_Range::Exact->_new($version);
      }
    
      sub _simplify {
        my ($self) = @_;
    
        if (defined $self->{minimum} and defined $self->{maximum}) {
          if ($self->{minimum} == $self->{maximum}) {
            Carp::confess("illegal requirements: excluded all values")
              if grep { $_ == $self->{minimum} } @{ $self->{exclusions} || [] };
    
            return CPAN::Meta::Requirements::_Range::Exact->_new($self->{minimum})
          }
    
          Carp::confess("illegal requirements: minimum exceeds maximum")
            if $self->{minimum} > $self->{maximum};
        }
    
        # eliminate irrelevant exclusions
        if ($self->{exclusions}) {
          my %seen;
          @{ $self->{exclusions} } = grep {
            (! defined $self->{minimum} or $_ >= $self->{minimum})
            and
            (! defined $self->{maximum} or $_ <= $self->{maximum})
            and
            ! $seen{$_}++
          } @{ $self->{exclusions} };
        }
    
        return $self;
      }
    
      sub with_minimum {
        my ($self, $minimum) = @_;
        $self = $self->_clone;
    
        if (defined (my $old_min = $self->{minimum})) {
          $self->{minimum} = (sort { $b cmp $a } ($minimum, $old_min))[0];
        } else {
          $self->{minimum} = $minimum;
        }
    
        return $self->_simplify;
      }
    
      sub with_maximum {
        my ($self, $maximum) = @_;
        $self = $self->_clone;
    
        if (defined (my $old_max = $self->{maximum})) {
          $self->{maximum} = (sort { $a cmp $b } ($maximum, $old_max))[0];
        } else {
          $self->{maximum} = $maximum;
        }
    
        return $self->_simplify;
      }
    
      sub with_exclusion {
        my ($self, $exclusion) = @_;
        $self = $self->_clone;
    
        push @{ $self->{exclusions} ||= [] }, $exclusion;
    
        return $self->_simplify;
      }
    
      sub _accepts {
        my ($self, $version) = @_;
    
        return if defined $self->{minimum} and $version < $self->{minimum};
        return if defined $self->{maximum} and $version > $self->{maximum};
        return if defined $self->{exclusions}
              and grep { $version == $_ } @{ $self->{exclusions} };
    
        return 1;
      }
    }
    
    1;
    # vim: ts=2 sts=2 sw=2 et:
    
    __END__
    
    =pod
    
    =encoding UTF-8
    
    =head1 NAME
    
    CPAN::Meta::Requirements - a set of version requirements for a CPAN dist
    
    =head1 VERSION
    
    version 2.133
    
    =head1 SYNOPSIS
    
      use CPAN::Meta::Requirements;
    
      my $build_requires = CPAN::Meta::Requirements->new;
    
      $build_requires->add_minimum('Library::Foo' => 1.208);
    
      $build_requires->add_minimum('Library::Foo' => 2.602);
    
      $build_requires->add_minimum('Module::Bar'  => 'v1.2.3');
    
      $METAyml->{build_requires} = $build_requires->as_string_hash;
    
    =head1 DESCRIPTION
    
    A CPAN::Meta::Requirements object models a set of version constraints like
    those specified in the F<META.yml> or F<META.json> files in CPAN distributions,
    and as defined by L<CPAN::Meta::Spec>;
    It can be built up by adding more and more constraints, and it will reduce them
    to the simplest representation.
    
    Logically impossible constraints will be identified immediately by thrown
    exceptions.
    
    =head1 METHODS
    
    =head2 new
    
      my $req = CPAN::Meta::Requirements->new;
    
    This returns a new CPAN::Meta::Requirements object.  It takes an optional
    hash reference argument.  Currently, only one key is supported:
    
    =over 4
    
    =item *
    
    C<bad_version_hook> -- if provided, when a version cannot be parsed into a version object, this code reference will be called with the invalid version string as first argument, and the module name as second argument.  It must return a valid version object.
    
    =back
    
    All other keys are ignored.
    
    =head2 add_minimum
    
      $req->add_minimum( $module => $version );
    
    This adds a new minimum version requirement.  If the new requirement is
    redundant to the existing specification, this has no effect.
    
    Minimum requirements are inclusive.  C<$version> is required, along with any
    greater version number.
    
    This method returns the requirements object.
    
    =head2 add_maximum
    
      $req->add_maximum( $module => $version );
    
    This adds a new maximum version requirement.  If the new requirement is
    redundant to the existing specification, this has no effect.
    
    Maximum requirements are inclusive.  No version strictly greater than the given
    version is allowed.
    
    This method returns the requirements object.
    
    =head2 add_exclusion
    
      $req->add_exclusion( $module => $version );
    
    This adds a new excluded version.  For example, you might use these three
    method calls:
    
      $req->add_minimum( $module => '1.00' );
      $req->add_maximum( $module => '1.82' );
    
      $req->add_exclusion( $module => '1.75' );
    
    Any version between 1.00 and 1.82 inclusive would be acceptable, except for
    1.75.
    
    This method returns the requirements object.
    
    =head2 exact_version
    
      $req->exact_version( $module => $version );
    
    This sets the version required for the given module to I<exactly> the given
    version.  No other version would be considered acceptable.
    
    This method returns the requirements object.
    
    =head2 add_requirements
    
      $req->add_requirements( $another_req_object );
    
    This method adds all the requirements in the given CPAN::Meta::Requirements object
    to the requirements object on which it was called.  If there are any conflicts,
    an exception is thrown.
    
    This method returns the requirements object.
    
    =head2 accepts_module
    
      my $bool = $req->accepts_module($module => $version);
    
    Given an module and version, this method returns true if the version
    specification for the module accepts the provided version.  In other words,
    given:
    
      Module => '>= 1.00, < 2.00'
    
    We will accept 1.00 and 1.75 but not 0.50 or 2.00.
    
    For modules that do not appear in the requirements, this method will return
    true.
    
    =head2 clear_requirement
    
      $req->clear_requirement( $module );
    
    This removes the requirement for a given module from the object.
    
    This method returns the requirements object.
    
    =head2 requirements_for_module
    
      $req->requirements_for_module( $module );
    
    This returns a string containing the version requirements for a given module in
    the format described in L<CPAN::Meta::Spec> or undef if the given module has no
    requirements. This should only be used for informational purposes such as error
    messages and should not be interpreted or used for comparison (see
    L</accepts_module> instead.)
    
    =head2 required_modules
    
    This method returns a list of all the modules for which requirements have been
    specified.
    
    =head2 clone
    
      $req->clone;
    
    This method returns a clone of the invocant.  The clone and the original object
    can then be changed independent of one another.
    
    =head2 is_simple
    
    This method returns true if and only if all requirements are inclusive minimums
    -- that is, if their string expression is just the version number.
    
    =head2 is_finalized
    
    This method returns true if the requirements have been finalized by having the
    C<finalize> method called on them.
    
    =head2 finalize
    
    This method marks the requirements finalized.  Subsequent attempts to change
    the requirements will be fatal, I<if> they would result in a change.  If they
    would not alter the requirements, they have no effect.
    
    If a finalized set of requirements is cloned, the cloned requirements are not
    also finalized.
    
    =head2 as_string_hash
    
    This returns a reference to a hash describing the requirements using the
    strings in the L<CPAN::Meta::Spec> specification.
    
    For example after the following program:
    
      my $req = CPAN::Meta::Requirements->new;
    
      $req->add_minimum('CPAN::Meta::Requirements' => 0.102);
    
      $req->add_minimum('Library::Foo' => 1.208);
    
      $req->add_maximum('Library::Foo' => 2.602);
    
      $req->add_minimum('Module::Bar'  => 'v1.2.3');
    
      $req->add_exclusion('Module::Bar'  => 'v1.2.8');
    
      $req->exact_version('Xyzzy'  => '6.01');
    
      my $hashref = $req->as_string_hash;
    
    C<$hashref> would contain:
    
      {
        'CPAN::Meta::Requirements' => '0.102',
        'Library::Foo' => '>= 1.208, <= 2.206',
        'Module::Bar'  => '>= v1.2.3, != v1.2.8',
        'Xyzzy'        => '== 6.01',
      }
    
    =head2 add_string_requirement
    
      $req->add_string_requirement('Library::Foo' => '>= 1.208, <= 2.206');
      $req->add_string_requirement('Library::Foo' => v1.208);
    
    This method parses the passed in string and adds the appropriate requirement
    for the given module.  A version can be a Perl "v-string".  It understands
    version ranges as described in the L<CPAN::Meta::Spec/Version Ranges>. For
    example:
    
    =over 4
    
    =item 1.3
    
    =item >= 1.3
    
    =item <= 1.3
    
    =item == 1.3
    
    =item != 1.3
    
    =item > 1.3
    
    =item < 1.3
    
    =item >= 1.3, != 1.5, <= 2.0
    
    A version number without an operator is equivalent to specifying a minimum
    (C<E<gt>=>).  Extra whitespace is allowed.
    
    =back
    
    =head2 from_string_hash
    
      my $req = CPAN::Meta::Requirements->from_string_hash( \%hash );
      my $req = CPAN::Meta::Requirements->from_string_hash( \%hash, \%opts );
    
    This is an alternate constructor for a CPAN::Meta::Requirements
    object. It takes a hash of module names and version requirement
    strings and returns a new CPAN::Meta::Requirements object. As with
    add_string_requirement, a version can be a Perl "v-string". Optionally,
    you can supply a hash-reference of options, exactly as with the L</new>
    method.
    
    =for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
    
    =head1 SUPPORT
    
    =head2 Bugs / Feature Requests
    
    Please report any bugs or feature requests through the issue tracker
    at L<https://github.com/dagolden/CPAN-Meta-Requirements/issues>.
    You will be notified automatically of any progress on your issue.
    
    =head2 Source Code
    
    This is open source software.  The code repository is available for
    public review and contribution under the terms of the license.
    
    L<https://github.com/dagolden/CPAN-Meta-Requirements>
    
      git clone https://github.com/dagolden/CPAN-Meta-Requirements.git
    
    =head1 AUTHORS
    
    =over 4
    
    =item *
    
    David Golden <dagolden@cpan.org>
    
    =item *
    
    Ricardo Signes <rjbs@cpan.org>
    
    =back
    
    =head1 CONTRIBUTORS
    
    =for stopwords Ed J Karen Etheridge Leon Timmermans robario
    
    =over 4
    
    =item *
    
    Ed J <mohawk2@users.noreply.github.com>
    
    =item *
    
    Karen Etheridge <ether@cpan.org>
    
    =item *
    
    Leon Timmermans <fawaka@gmail.com>
    
    =item *
    
    robario <webmaster@robario.com>
    
    =back
    
    =head1 COPYRIGHT AND LICENSE
    
    This software is copyright (c) 2010 by David Golden and Ricardo Signes.
    
    This is free software; you can redistribute it and/or modify it under
    the same terms as the Perl 5 programming language system itself.
    
    =cut
  CPAN_META_REQUIREMENTS
  
  $fatpacked{"CPAN/Meta/Spec.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_SPEC';
    # XXX RULES FOR PATCHING THIS FILE XXX
    # Patches that fix typos or formatting are acceptable.  Patches
    # that change semantics are not acceptable without prior approval
    # by David Golden or Ricardo Signes.
    
    use 5.006;
    use strict;
    use warnings;
    package CPAN::Meta::Spec;
    
    our $VERSION = '2.150005';
    
    1;
    
    # ABSTRACT: specification for CPAN distribution metadata
    
    
    # vi:tw=72
    
    __END__
    
    =pod
    
    =encoding UTF-8
    
    =head1 NAME
    
    CPAN::Meta::Spec - specification for CPAN distribution metadata
    
    =head1 VERSION
    
    version 2.150005
    
    =head1 SYNOPSIS
    
      my $distmeta = {
        name => 'Module-Build',
        abstract => 'Build and install Perl modules',
        description =>  "Module::Build is a system for "
          . "building, testing, and installing Perl modules. "
          . "It is meant to ... blah blah blah ...",
        version  => '0.36',
        release_status => 'stable',
        author   => [
          'Ken Williams <kwilliams@cpan.org>',
          'Module-Build List <module-build@perl.org>', # additional contact
        ],
        license  => [ 'perl_5' ],
        prereqs => {
          runtime => {
            requires => {
              'perl'   => '5.006',
              'ExtUtils::Install' => '0',
              'File::Basename' => '0',
              'File::Compare'  => '0',
              'IO::File'   => '0',
            },
            recommends => {
              'Archive::Tar' => '1.00',
              'ExtUtils::Install' => '0.3',
              'ExtUtils::ParseXS' => '2.02',
            },
          },
          build => {
            requires => {
              'Test::More' => '0',
            },
          }
        },
        resources => {
          license => ['http://dev.perl.org/licenses/'],
        },
        optional_features => {
          domination => {
            description => 'Take over the world',
            prereqs     => {
              develop => { requires => { 'Genius::Evil'     => '1.234' } },
              runtime => { requires => { 'Machine::Weather' => '2.0'   } },
            },
          },
        },
        dynamic_config => 1,
        keywords => [ qw/ toolchain cpan dual-life / ],
        'meta-spec' => {
          version => '2',
          url     => 'https://metacpan.org/pod/CPAN::Meta::Spec',
        },
        generated_by => 'Module::Build version 0.36',
      };
    
    =head1 DESCRIPTION
    
    This document describes version 2 of the CPAN distribution metadata
    specification, also known as the "CPAN Meta Spec".
    
    Revisions of this specification for typo corrections and prose
    clarifications may be issued as CPAN::Meta::Spec 2.I<x>.  These
    revisions will never change semantics or add or remove specified
    behavior.
    
    Distribution metadata describe important properties of Perl
    distributions. Distribution building tools like Module::Build,
    Module::Install, ExtUtils::MakeMaker or Dist::Zilla should create a
    metadata file in accordance with this specification and include it with
    the distribution for use by automated tools that index, examine, package
    or install Perl distributions.
    
    =head1 TERMINOLOGY
    
    =over 4
    
    =item distribution
    
    This is the primary object described by the metadata. In the context of
    this document it usually refers to a collection of modules, scripts,
    and/or documents that are distributed together for other developers to
    use.  Examples of distributions are C<Class-Container>, C<libwww-perl>,
    or C<DBI>.
    
    =item module
    
    This refers to a reusable library of code contained in a single file.
    Modules usually contain one or more packages and are often referred
    to by the name of a primary package that can be mapped to the file
    name. For example, one might refer to C<File::Spec> instead of
    F<File/Spec.pm>
    
    =item package
    
    This refers to a namespace declared with the Perl C<package> statement.
    In Perl, packages often have a version number property given by the
    C<$VERSION> variable in the namespace.
    
    =item consumer
    
    This refers to code that reads a metadata file, deserializes it into a
    data structure in memory, or interprets a data structure of metadata
    elements.
    
    =item producer
    
    This refers to code that constructs a metadata data structure,
    serializes into a bytestream and/or writes it to disk.
    
    =item must, should, may, etc.
    
    These terms are interpreted as described in IETF RFC 2119.
    
    =back
    
    =head1 DATA TYPES
    
    Fields in the L</STRUCTURE> section describe data elements, each of
    which has an associated data type as described herein.  There are four
    primitive types: Boolean, String, List and Map.  Other types are
    subtypes of primitives and define compound data structures or define
    constraints on the values of a data element.
    
    =head2 Boolean
    
    A I<Boolean> is used to provide a true or false value.  It B<must> be
    represented as a defined value.
    
    =head2 String
    
    A I<String> is data element containing a non-zero length sequence of
    Unicode characters, such as an ordinary Perl scalar that is not a
    reference.
    
    =head2 List
    
    A I<List> is an ordered collection of zero or more data elements.
    Elements of a List may be of mixed types.
    
    Producers B<must> represent List elements using a data structure which
    unambiguously indicates that multiple values are possible, such as a
    reference to a Perl array (an "arrayref").
    
    Consumers expecting a List B<must> consider a String as equivalent to a
    List of length 1.
    
    =head2 Map
    
    A I<Map> is an unordered collection of zero or more data elements
    ("values"), indexed by associated String elements ("keys").  The Map's
    value elements may be of mixed types.
    
    =head2 License String
    
    A I<License String> is a subtype of String with a restricted set of
    values.  Valid values are described in detail in the description of
    the L</license> field.
    
    =head2 URL
    
    I<URL> is a subtype of String containing a Uniform Resource Locator or
    Identifier.  [ This type is called URL and not URI for historical reasons. ]
    
    =head2 Version
    
    A I<Version> is a subtype of String containing a value that describes
    the version number of packages or distributions.  Restrictions on format
    are described in detail in the L</Version Formats> section.
    
    =head2 Version Range
    
    The I<Version Range> type is a subtype of String.  It describes a range
    of Versions that may be present or installed to fulfill prerequisites.
    It is specified in detail in the L</Version Ranges> section.
    
    =head1 STRUCTURE
    
    The metadata structure is a data element of type Map.  This section
    describes valid keys within the Map.
    
    Any keys not described in this specification document (whether top-level
    or within compound data structures described herein) are considered
    I<custom keys> and B<must> begin with an "x" or "X" and be followed by an
    underscore; i.e. they must match the pattern: C<< qr{\Ax_}i >>.  If a
    custom key refers to a compound data structure, subkeys within it do not
    need an "x_" or "X_" prefix.
    
    Consumers of metadata may ignore any or all custom keys.  All other keys
    not described herein are invalid and should be ignored by consumers.
    Producers must not generate or output invalid keys.
    
    For each key, an example is provided followed by a description.  The
    description begins with the version of spec in which the key was added
    or in which the definition was modified, whether the key is I<required>
    or I<optional> and the data type of the corresponding data element.
    These items are in parentheses, brackets and braces, respectively.
    
    If a data type is a Map or Map subtype, valid subkeys will be described
    as well.
    
    Some fields are marked I<Deprecated>.  These are shown for historical
    context and must not be produced in or consumed from any metadata structure
    of version 2 or higher.
    
    =head2 REQUIRED FIELDS
    
    =head3 abstract
    
    Example:
    
      abstract => 'Build and install Perl modules'
    
    (Spec 1.2) [required] {String}
    
    This is a short description of the purpose of the distribution.
    
    =head3 author
    
    Example:
    
      author => [ 'Ken Williams <kwilliams@cpan.org>' ]
    
    (Spec 1.2) [required] {List of one or more Strings}
    
    This List indicates the person(s) to contact concerning the
    distribution. The preferred form of the contact string is:
    
      contact-name <email-address>
    
    This field provides a general contact list independent of other
    structured fields provided within the L</resources> field, such as
    C<bugtracker>.  The addressee(s) can be contacted for any purpose
    including but not limited to (security) problems with the distribution,
    questions about the distribution or bugs in the distribution.
    
    A distribution's original author is usually the contact listed within
    this field.  Co-maintainers, successor maintainers or mailing lists
    devoted to the distribution may also be listed in addition to or instead
    of the original author.
    
    =head3 dynamic_config
    
    Example:
    
      dynamic_config => 1
    
    (Spec 2) [required] {Boolean}
    
    A boolean flag indicating whether a F<Build.PL> or F<Makefile.PL> (or
    similar) must be executed to determine prerequisites.
    
    This field should be set to a true value if the distribution performs
    some dynamic configuration (asking questions, sensing the environment,
    etc.) as part of its configuration.  This field should be set to a false
    value to indicate that prerequisites included in metadata may be
    considered final and valid for static analysis.
    
    Note: when this field is true, post-configuration prerequisites are not
    guaranteed to bear any relation whatsoever to those stated in the metadata,
    and relying on them doing so is an error. See also
    L</Prerequisites for dynamically configured distributions> in the implementors'
    notes.
    
    This field explicitly B<does not> indicate whether installation may be
    safely performed without using a Makefile or Build file, as there may be
    special files to install or custom installation targets (e.g. for
    dual-life modules that exist on CPAN as well as in the Perl core).  This
    field only defines whether or not prerequisites are exactly as given in the
    metadata.
    
    =head3 generated_by
    
    Example:
    
      generated_by => 'Module::Build version 0.36'
    
    (Spec 1.0) [required] {String}
    
    This field indicates the tool that was used to create this metadata.
    There are no defined semantics for this field, but it is traditional to
    use a string in the form "Generating::Package version 1.23" or the
    author's name, if the file was generated by hand.
    
    =head3 license
    
    Example:
    
      license => [ 'perl_5' ]
    
      license => [ 'apache_2_0', 'mozilla_1_0' ]
    
    (Spec 2) [required] {List of one or more License Strings}
    
    One or more licenses that apply to some or all of the files in the
    distribution.  If multiple licenses are listed, the distribution
    documentation should be consulted to clarify the interpretation of
    multiple licenses.
    
    The following list of license strings are valid:
    
     string          description
     -------------   -----------------------------------------------
     agpl_3          GNU Affero General Public License, Version 3
     apache_1_1      Apache Software License, Version 1.1
     apache_2_0      Apache License, Version 2.0
     artistic_1      Artistic License, (Version 1)
     artistic_2      Artistic License, Version 2.0
     bsd             BSD License (three-clause)
     freebsd         FreeBSD License (two-clause)
     gfdl_1_2        GNU Free Documentation License, Version 1.2
     gfdl_1_3        GNU Free Documentation License, Version 1.3
     gpl_1           GNU General Public License, Version 1
     gpl_2           GNU General Public License, Version 2
     gpl_3           GNU General Public License, Version 3
     lgpl_2_1        GNU Lesser General Public License, Version 2.1
     lgpl_3_0        GNU Lesser General Public License, Version 3.0
     mit             MIT (aka X11) License
     mozilla_1_0     Mozilla Public License, Version 1.0
     mozilla_1_1     Mozilla Public License, Version 1.1
     openssl         OpenSSL License
     perl_5          The Perl 5 License (Artistic 1 & GPL 1 or later)
     qpl_1_0         Q Public License, Version 1.0
     ssleay          Original SSLeay License
     sun             Sun Internet Standards Source License (SISSL)
     zlib            zlib License
    
    The following license strings are also valid and indicate other
    licensing not described above:
    
     string          description
     -------------   -----------------------------------------------
     open_source     Other Open Source Initiative (OSI) approved license
     restricted      Requires special permission from copyright holder
     unrestricted    Not an OSI approved license, but not restricted
     unknown         License not provided in metadata
    
    All other strings are invalid in the license field.
    
    =head3 meta-spec
    
    Example:
    
      'meta-spec' => {
        version => '2',
        url     => 'http://search.cpan.org/perldoc?CPAN::Meta::Spec',
      }
    
    (Spec 1.2) [required] {Map}
    
    This field indicates the version of the CPAN Meta Spec that should be
    used to interpret the metadata.  Consumers must check this key as soon
    as possible and abort further metadata processing if the meta-spec
    version is not supported by the consumer.
    
    The following keys are valid, but only C<version> is required.
    
    =over
    
    =item version
    
    This subkey gives the integer I<Version> of the CPAN Meta Spec against
    which the document was generated.
    
    =item url
    
    This is a I<URL> of the metadata specification document corresponding to
    the given version.  This is strictly for human-consumption and should
    not impact the interpretation of the document.
    
    For the version 2 spec, either of these are recommended:
    
    =over 4
    
    =item *
    
    C<https://metacpan.org/pod/CPAN::Meta::Spec>
    
    =item *
    
    C<http://search.cpan.org/perldoc?CPAN::Meta::Spec>
    
    =back
    
    =back
    
    =head3 name
    
    Example:
    
      name => 'Module-Build'
    
    (Spec 1.0) [required] {String}
    
    This field is the name of the distribution.  This is often created by
    taking the "main package" in the distribution and changing C<::> to
    C<->, but the name may be completely unrelated to the packages within
    the distribution.  For example, L<LWP::UserAgent> is distributed as part
    of the distribution name "libwww-perl".
    
    =head3 release_status
    
    Example:
    
      release_status => 'stable'
    
    (Spec 2) [required] {String}
    
    This field provides the  release status of this distribution.  If the
    C<version> field contains an underscore character, then
    C<release_status> B<must not> be "stable."
    
    The C<release_status> field B<must> have one of the following values:
    
    =over
    
    =item stable
    
    This indicates an ordinary, "final" release that should be indexed by PAUSE
    or other indexers.
    
    =item testing
    
    This indicates a "beta" release that is substantially complete, but has an
    elevated risk of bugs and requires additional testing.  The distribution
    should not be installed over a stable release without an explicit request
    or other confirmation from a user.  This release status may also be used
    for "release candidate" versions of a distribution.
    
    =item unstable
    
    This indicates an "alpha" release that is under active development, but has
    been released for early feedback or testing and may be missing features or
    may have serious bugs.  The distribution should not be installed over a
    stable release without an explicit request or other confirmation from a
    user.
    
    =back
    
    Consumers B<may> use this field to determine how to index the
    distribution for CPAN or other repositories in addition to or in
    replacement of heuristics based on version number or file name.
    
    =head3 version
    
    Example:
    
      version => '0.36'
    
    (Spec 1.0) [required] {Version}
    
    This field gives the version of the distribution to which the metadata
    structure refers.
    
    =head2 OPTIONAL FIELDS
    
    =head3 description
    
    Example:
    
        description =>  "Module::Build is a system for "
          . "building, testing, and installing Perl modules. "
          . "It is meant to ... blah blah blah ...",
    
    (Spec 2) [optional] {String}
    
    A longer, more complete description of the purpose or intended use of
    the distribution than the one provided by the C<abstract> key.
    
    =head3 keywords
    
    Example:
    
      keywords => [ qw/ toolchain cpan dual-life / ]
    
    (Spec 1.1) [optional] {List of zero or more Strings}
    
    A List of keywords that describe this distribution.  Keywords
    B<must not> include whitespace.
    
    =head3 no_index
    
    Example:
    
      no_index => {
        file      => [ 'My/Module.pm' ],
        directory => [ 'My/Private' ],
        package   => [ 'My::Module::Secret' ],
        namespace => [ 'My::Module::Sample' ],
      }
    
    (Spec 1.2) [optional] {Map}
    
    This Map describes any files, directories, packages, and namespaces that
    are private to the packaging or implementation of the distribution and
    should be ignored by indexing or search tools. Note that this is a list of
    exclusions, and the spec does not define what to I<include> - see
    L</Indexing distributions a la PAUSE> in the implementors notes for more
    information.
    
    Valid subkeys are as follows:
    
    =over
    
    =item file
    
    A I<List> of relative paths to files.  Paths B<must be> specified with
    unix conventions.
    
    =item directory
    
    A I<List> of relative paths to directories.  Paths B<must be> specified
    with unix conventions.
    
    [ Note: previous editions of the spec had C<dir> instead of C<directory> ]
    
    =item package
    
    A I<List> of package names.
    
    =item namespace
    
    A I<List> of package namespaces, where anything below the namespace
    must be ignored, but I<not> the namespace itself.
    
    In the example above for C<no_index>, C<My::Module::Sample::Foo> would
    be ignored, but C<My::Module::Sample> would not.
    
    =back
    
    =head3 optional_features
    
    Example:
    
      optional_features => {
        sqlite => {
          description => 'Provides SQLite support',
          prereqs => {
            runtime => {
              requires => {
                'DBD::SQLite' => '1.25'
              }
            }
          }
        }
      }
    
    (Spec 2) [optional] {Map}
    
    This Map describes optional features with incremental prerequisites.
    Each key of the C<optional_features> Map is a String used to identify
    the feature and each value is a Map with additional information about
    the feature.  Valid subkeys include:
    
    =over
    
    =item description
    
    This is a String describing the feature.  Every optional feature
    should provide a description
    
    =item prereqs
    
    This entry is required and has the same structure as that of the
    C<L</prereqs>> key.  It provides a list of package requirements
    that must be satisfied for the feature to be supported or enabled.
    
    There is one crucial restriction:  the prereqs of an optional feature
    B<must not> include C<configure> phase prereqs.
    
    =back
    
    Consumers B<must not> include optional features as prerequisites without
    explicit instruction from users (whether via interactive prompting,
    a function parameter or a configuration value, etc. ).
    
    If an optional feature is used by a consumer to add additional
    prerequisites, the consumer should merge the optional feature
    prerequisites into those given by the C<prereqs> key using the same
    semantics.  See L</Merging and Resolving Prerequisites> for details on
    merging prerequisites.
    
    I<Suggestion for disuse:> Because there is currently no way for a
    distribution to specify a dependency on an optional feature of another
    dependency, the use of C<optional_feature> is discouraged.  Instead,
    create a separate, installable distribution that ensures the desired
    feature is available.  For example, if C<Foo::Bar> has a C<Baz> feature,
    release a separate C<Foo-Bar-Baz> distribution that satisfies
    requirements for the feature.
    
    =head3 prereqs
    
    Example:
    
      prereqs => {
        runtime => {
          requires => {
            'perl'          => '5.006',
            'File::Spec'    => '0.86',
            'JSON'          => '2.16',
          },
          recommends => {
            'JSON::XS'      => '2.26',
          },
          suggests => {
            'Archive::Tar'  => '0',
          },
        },
        build => {
          requires => {
            'Alien::SDL'    => '1.00',
          },
        },
        test => {
          recommends => {
            'Test::Deep'    => '0.10',
          },
        }
      }
    
    (Spec 2) [optional] {Map}
    
    This is a Map that describes all the prerequisites of the distribution.
    The keys are phases of activity, such as C<configure>, C<build>, C<test>
    or C<runtime>.  Values are Maps in which the keys name the type of
    prerequisite relationship such as C<requires>, C<recommends>, or
    C<suggests> and the value provides a set of prerequisite relations.  The
    set of relations B<must> be specified as a Map of package names to
    version ranges.
    
    The full definition for this field is given in the L</Prereq Spec>
    section.
    
    =head3 provides
    
    Example:
    
      provides => {
        'Foo::Bar' => {
          file    => 'lib/Foo/Bar.pm',
          version => '0.27_02',
        },
        'Foo::Bar::Blah' => {
          file    => 'lib/Foo/Bar/Blah.pm',
        },
        'Foo::Bar::Baz' => {
          file    => 'lib/Foo/Bar/Baz.pm',
          version => '0.3',
        },
      }
    
    (Spec 1.2) [optional] {Map}
    
    This describes all packages provided by this distribution.  This
    information is used by distribution and automation mechanisms like
    PAUSE, CPAN, metacpan.org and search.cpan.org to build indexes saying in
    which distribution various packages can be found.
    
    The keys of C<provides> are package names that can be found within
    the distribution.  If a package name key is provided, it must
    have a Map with the following valid subkeys:
    
    =over
    
    =item file
    
    This field is required.  It must contain a Unix-style relative file path
    from the root of the distribution directory to a file that contains or
    generates the package.  It may be given as C<META.yml> or C<META.json>
    to claim a package for indexing without needing a C<*.pm>.
    
    =item version
    
    If it exists, this field must contains a I<Version> String for the
    package.  If the package does not have a C<$VERSION>, this field must
    be omitted.
    
    =back
    
    =head3 resources
    
    Example:
    
      resources => {
        license     => [ 'http://dev.perl.org/licenses/' ],
        homepage    => 'http://sourceforge.net/projects/module-build',
        bugtracker  => {
          web    => 'http://rt.cpan.org/Public/Dist/Display.html?Name=CPAN-Meta',
          mailto => 'meta-bugs@example.com',
        },
        repository  => {
          url  => 'git://github.com/dagolden/cpan-meta.git',
          web  => 'http://github.com/dagolden/cpan-meta',
          type => 'git',
        },
        x_twitter   => 'http://twitter.com/cpan_linked/',
      }
    
    (Spec 2) [optional] {Map}
    
    This field describes resources related to this distribution.
    
    Valid subkeys include:
    
    =over
    
    =item homepage
    
    The official home of this project on the web.
    
    =item license
    
    A List of I<URL>'s that relate to this distribution's license.  As with the
    top-level C<license> field, distribution documentation should be consulted
    to clarify the interpretation of multiple licenses provided here.
    
    =item bugtracker
    
    This entry describes the bug tracking system for this distribution.  It
    is a Map with the following valid keys:
    
      web    - a URL pointing to a web front-end for the bug tracker
      mailto - an email address to which bugs can be sent
    
    =item repository
    
    This entry describes the source control repository for this distribution.  It
    is a Map with the following valid keys:
    
      url  - a URL pointing to the repository itself
      web  - a URL pointing to a web front-end for the repository
      type - a lowercase string indicating the VCS used
    
    Because a url like C<http://myrepo.example.com/> is ambiguous as to
    type, producers should provide a C<type> whenever a C<url> key is given.
    The C<type> field should be the name of the most common program used
    to work with the repository, e.g. C<git>, C<svn>, C<cvs>, C<darcs>,
    C<bzr> or C<hg>.
    
    =back
    
    =head2 DEPRECATED FIELDS
    
    =head3 build_requires
    
    I<(Deprecated in Spec 2)> [optional] {String}
    
    Replaced by C<prereqs>
    
    =head3 configure_requires
    
    I<(Deprecated in Spec 2)> [optional] {String}
    
    Replaced by C<prereqs>
    
    =head3 conflicts
    
    I<(Deprecated in Spec 2)> [optional] {String}
    
    Replaced by C<prereqs>
    
    =head3 distribution_type
    
    I<(Deprecated in Spec 2)> [optional] {String}
    
    This field indicated 'module' or 'script' but was considered
    meaningless, since many distributions are hybrids of several kinds of
    things.
    
    =head3 license_uri
    
    I<(Deprecated in Spec 1.2)> [optional] {URL}
    
    Replaced by C<license> in C<resources>
    
    =head3 private
    
    I<(Deprecated in Spec 1.2)> [optional] {Map}
    
    This field has been renamed to L</"no_index">.
    
    =head3 recommends
    
    I<(Deprecated in Spec 2)> [optional] {String}
    
    Replaced by C<prereqs>
    
    =head3 requires
    
    I<(Deprecated in Spec 2)> [optional] {String}
    
    Replaced by C<prereqs>
    
    =head1 VERSION NUMBERS
    
    =head2 Version Formats
    
    This section defines the Version type, used by several fields in the
    CPAN Meta Spec.
    
    Version numbers must be treated as strings, not numbers.  For
    example, C<1.200> B<must not> be serialized as C<1.2>.  Version
    comparison should be delegated to the Perl L<version> module, version
    0.80 or newer.
    
    Unless otherwise specified, version numbers B<must> appear in one of two
    formats:
    
    =over
    
    =item Decimal versions
    
    Decimal versions are regular "decimal numbers", with some limitations.
    They B<must> be non-negative and B<must> begin and end with a digit.  A
    single underscore B<may> be included, but B<must> be between two digits.
    They B<must not> use exponential notation ("1.23e-2").
    
       version => '1.234'       # OK
       version => '1.23_04'     # OK
    
       version => '1.23_04_05'  # Illegal
       version => '1.'          # Illegal
       version => '.1'          # Illegal
    
    =item Dotted-integer versions
    
    Dotted-integer (also known as dotted-decimal) versions consist of
    positive integers separated by full stop characters (i.e. "dots",
    "periods" or "decimal points").  This are equivalent in format to Perl
    "v-strings", with some additional restrictions on form.  They must be
    given in "normal" form, which has a leading "v" character and at least
    three integer components.  To retain a one-to-one mapping with decimal
    versions, all components after the first B<should> be restricted to the
    range 0 to 999.  The final component B<may> be separated by an
    underscore character instead of a period.
    
       version => 'v1.2.3'      # OK
       version => 'v1.2_3'      # OK
       version => 'v1.2.3.4'    # OK
       version => 'v1.2.3_4'    # OK
       version => 'v2009.10.31' # OK
    
       version => 'v1.2'          # Illegal
       version => '1.2.3'         # Illegal
       version => 'v1.2_3_4'      # Illegal
       version => 'v1.2009.10.31' # Not recommended
    
    =back
    
    =head2 Version Ranges
    
    Some fields (prereq, optional_features) indicate the particular
    version(s) of some other module that may be required as a prerequisite.
    This section details the Version Range type used to provide this
    information.
    
    The simplest format for a Version Range is just the version
    number itself, e.g. C<2.4>.  This means that B<at least> version 2.4
    must be present.  To indicate that B<any> version of a prerequisite is
    okay, even if the prerequisite doesn't define a version at all, use
    the version C<0>.
    
    Alternatively, a version range B<may> use the operators E<lt> (less than),
    E<lt>= (less than or equal), E<gt> (greater than), E<gt>= (greater than
    or equal), == (equal), and != (not equal).  For example, the
    specification C<E<lt> 2.0> means that any version of the prerequisite
    less than 2.0 is suitable.
    
    For more complicated situations, version specifications B<may> be AND-ed
    together using commas.  The specification C<E<gt>= 1.2, != 1.5, E<lt>
    2.0> indicates a version that must be B<at least> 1.2, B<less than> 2.0,
    and B<not equal to> 1.5.
    
    =head1 PREREQUISITES
    
    =head2 Prereq Spec
    
    The C<prereqs> key in the top-level metadata and within
    C<optional_features> define the relationship between a distribution and
    other packages.  The prereq spec structure is a hierarchical data
    structure which divides prerequisites into I<Phases> of activity in the
    installation process and I<Relationships> that indicate how
    prerequisites should be resolved.
    
    For example, to specify that C<Data::Dumper> is C<required> during the
    C<test> phase, this entry would appear in the distribution metadata:
    
      prereqs => {
        test => {
          requires => {
            'Data::Dumper' => '2.00'
          }
        }
      }
    
    =head3 Phases
    
    Requirements for regular use must be listed in the C<runtime> phase.
    Other requirements should be listed in the earliest stage in which they
    are required and consumers must accumulate and satisfy requirements
    across phases before executing the activity. For example, C<build>
    requirements must also be available during the C<test> phase.
    
      before action       requirements that must be met
      ----------------    --------------------------------
      perl Build.PL       configure
      perl Makefile.PL
    
      make                configure, runtime, build
      Build
    
      make test           configure, runtime, build, test
      Build test
    
    Consumers that install the distribution must ensure that
    I<runtime> requirements are also installed and may install
    dependencies from other phases.
    
      after action        requirements that must be met
      ----------------    --------------------------------
      make install        runtime
      Build install
    
    =over
    
    =item configure
    
    The configure phase occurs before any dynamic configuration has been
    attempted.  Libraries required by the configure phase B<must> be
    available for use before the distribution building tool has been
    executed.
    
    =item build
    
    The build phase is when the distribution's source code is compiled (if
    necessary) and otherwise made ready for installation.
    
    =item test
    
    The test phase is when the distribution's automated test suite is run.
    Any library that is needed only for testing and not for subsequent use
    should be listed here.
    
    =item runtime
    
    The runtime phase refers not only to when the distribution's contents
    are installed, but also to its continued use.  Any library that is a
    prerequisite for regular use of this distribution should be indicated
    here.
    
    =item develop
    
    The develop phase's prereqs are libraries needed to work on the
    distribution's source code as its author does.  These tools might be
    needed to build a release tarball, to run author-only tests, or to
    perform other tasks related to developing new versions of the
    distribution.
    
    =back
    
    =head3 Relationships
    
    =over
    
    =item requires
    
    These dependencies B<must> be installed for proper completion of the
    phase.
    
    =item recommends
    
    Recommended dependencies are I<strongly> encouraged and should be
    satisfied except in resource constrained environments.
    
    =item suggests
    
    These dependencies are optional, but are suggested for enhanced operation
    of the described distribution.
    
    =item conflicts
    
    These libraries cannot be installed when the phase is in operation.
    This is a very rare situation, and the C<conflicts> relationship should
    be used with great caution, or not at all.
    
    =back
    
    =head2 Merging and Resolving Prerequisites
    
    Whenever metadata consumers merge prerequisites, either from different
    phases or from C<optional_features>, they should merged in a way which
    preserves the intended semantics of the prerequisite structure.  Generally,
    this means concatenating the version specifications using commas, as
    described in the L<Version Ranges> section.
    
    Another subtle error that can occur in resolving prerequisites comes from
    the way that modules in prerequisites are indexed to distribution files on
    CPAN.  When a module is deleted from a distribution, prerequisites calling
    for that module could indicate an older distribution should be installed,
    potentially overwriting files from a newer distribution.
    
    For example, as of Oct 31, 2009, the CPAN index file contained these
    module-distribution mappings:
    
      Class::MOP                   0.94  D/DR/DROLSKY/Class-MOP-0.94.tar.gz
      Class::MOP::Class            0.94  D/DR/DROLSKY/Class-MOP-0.94.tar.gz
      Class::MOP::Class::Immutable 0.04  S/ST/STEVAN/Class-MOP-0.36.tar.gz
    
    Consider the case where "Class::MOP" 0.94 is installed.  If a
    distribution specified "Class::MOP::Class::Immutable" as a prerequisite,
    it could result in Class-MOP-0.36.tar.gz being installed, overwriting
    any files from Class-MOP-0.94.tar.gz.
    
    Consumers of metadata B<should> test whether prerequisites would result
    in installed module files being "downgraded" to an older version and
    B<may> warn users or ignore the prerequisite that would cause such a
    result.
    
    =head1 SERIALIZATION
    
    Distribution metadata should be serialized (as a hashref) as
    JSON-encoded data and packaged with distributions as the file
    F<META.json>.
    
    In the past, the distribution metadata structure had been packed with
    distributions as F<META.yml>, a file in the YAML Tiny format (for which,
    see L<YAML::Tiny>).  Tools that consume distribution metadata from disk
    should be capable of loading F<META.yml>, but should prefer F<META.json>
    if both are found.
    
    =head1 NOTES FOR IMPLEMENTORS
    
    =head2 Extracting Version Numbers from Perl Modules
    
    To get the version number from a Perl module, consumers should use the
    C<< MM->parse_version($file) >> method provided by
    L<ExtUtils::MakeMaker> or L<Module::Metadata>.  For example, for the
    module given by C<$mod>, the version may be retrieved in one of the
    following ways:
    
      # via ExtUtils::MakeMaker
      my $file = MM->_installed_file_for_module($mod);
      my $version = MM->parse_version($file)
    
    The private C<_installed_file_for_module> method may be replaced with
    other methods for locating a module in C<@INC>.
    
      # via Module::Metadata
      my $info = Module::Metadata->new_from_module($mod);
      my $version = $info->version;
    
    If only a filename is available, the following approach may be used:
    
      # via Module::Build
      my $info = Module::Metadata->new_from_file($file);
      my $version = $info->version;
    
    =head2 Comparing Version Numbers
    
    The L<version> module provides the most reliable way to compare version
    numbers in all the various ways they might be provided or might exist
    within modules.  Given two strings containing version numbers, C<$v1> and
    C<$v2>, they should be converted to C<version> objects before using
    ordinary comparison operators.  For example:
    
      use version;
      if ( version->new($v1) <=> version->new($v2) ) {
        print "Versions are not equal\n";
      }
    
    If the only comparison needed is whether an installed module is of a
    sufficiently high version, a direct test may be done using the string
    form of C<eval> and the C<use> function.  For example, for module C<$mod>
    and version prerequisite C<$prereq>:
    
      if ( eval "use $mod $prereq (); 1" ) {
        print "Module $mod version is OK.\n";
      }
    
    If the values of C<$mod> and C<$prereq> have not been scrubbed, however,
    this presents security implications.
    
    =head2 Prerequisites for dynamically configured distributions
    
    When C<dynamic_config> is true, it is an error to presume that the
    prerequisites given in distribution metadata will have any relationship
    whatsoever to the actual prerequisites of the distribution.
    
    In practice, however, one can generally expect such prerequisites to be
    one of two things:
    
    =over 4
    
    =item *
    
    The minimum prerequisites for the distribution, to which dynamic configuration will only add items
    
    =item *
    
    Whatever the distribution configured with on the releaser's machine at release time
    
    =back
    
    The second case often turns out to have identical results to the first case,
    albeit only by accident.
    
    As such, consumers may use this data for informational analysis, but
    presenting it to the user as canonical or relying on it as such is
    invariably the height of folly.
    
    =head2 Indexing distributions a la PAUSE
    
    While no_index tells you what must be ignored when indexing, this spec holds
    no opinion on how you should get your initial candidate list of things to
    possibly index. For "normal" distributions you might consider simply indexing
    the contents of lib/, but there are many fascinating oddities on CPAN and
    many dists from the days when it was normal to put the main .pm file in the
    root of the distribution archive - so PAUSE currently indexes all .pm and .PL
    files that are not either (a) specifically excluded by no_index (b) in
    C<inc>, C<xt>, or C<t> directories, or common 'mistake' directories such as
    C<perl5>.
    
    Or: If you're trying to be PAUSE-like, make sure you skip C<inc>, C<xt> and
    C<t> as well as anything marked as no_index.
    
    Also remember: If the META file contains a provides field, you shouldn't be
    indexing anything in the first place - just use that.
    
    =head1 SEE ALSO
    
    =over 4
    
    =item *
    
    CPAN, L<http://www.cpan.org/>
    
    =item *
    
    JSON, L<http://json.org/>
    
    =item *
    
    YAML, L<http://www.yaml.org/>
    
    =item *
    
    L<CPAN>
    
    =item *
    
    L<CPANPLUS>
    
    =item *
    
    L<ExtUtils::MakeMaker>
    
    =item *
    
    L<Module::Build>
    
    =item *
    
    L<Module::Install>
    
    =back
    
    =head1 HISTORY
    
    Ken Williams wrote the original CPAN Meta Spec (also known as the
    "META.yml spec") in 2003 and maintained it through several revisions
    with input from various members of the community.  In 2005, Randy
    Sims redrafted it from HTML to POD for the version 1.2 release.  Ken
    continued to maintain the spec through version 1.4.
    
    In late 2009, David Golden organized the version 2 proposal review
    process.  David and Ricardo Signes drafted the final version 2 spec
    in April 2010 based on the version 1.4 spec and patches contributed
    during the proposal process.
    
    =head1 AUTHORS
    
    =over 4
    
    =item *
    
    David Golden <dagolden@cpan.org>
    
    =item *
    
    Ricardo Signes <rjbs@cpan.org>
    
    =back
    
    =head1 COPYRIGHT AND LICENSE
    
    This software is copyright (c) 2010 by David Golden and Ricardo Signes.
    
    This is free software; you can redistribute it and/or modify it under
    the same terms as the Perl 5 programming language system itself.
    
    =cut
  CPAN_META_SPEC
  
  $fatpacked{"CPAN/Meta/Validator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_VALIDATOR';
    use 5.006;
    use strict;
    use warnings;
    package CPAN::Meta::Validator;
    
    our $VERSION = '2.150005';
    
    #pod =head1 SYNOPSIS
    #pod
    #pod   my $struct = decode_json_file('META.json');
    #pod
    #pod   my $cmv = CPAN::Meta::Validator->new( $struct );
    #pod
    #pod   unless ( $cmv->is_valid ) {
    #pod     my $msg = "Invalid META structure.  Errors found:\n";
    #pod     $msg .= join( "\n", $cmv->errors );
    #pod     die $msg;
    #pod   }
    #pod
    #pod =head1 DESCRIPTION
    #pod
    #pod This module validates a CPAN Meta structure against the version of the
    #pod the specification claimed in the C<meta-spec> field of the structure.
    #pod
    #pod =cut
    
    #--------------------------------------------------------------------------#
    # This code copied and adapted from Test::CPAN::Meta
    # by Barbie, <barbie@cpan.org> for Miss Barbell Productions,
    # L<http://www.missbarbell.co.uk>
    #--------------------------------------------------------------------------#
    
    #--------------------------------------------------------------------------#
    # Specification Definitions
    #--------------------------------------------------------------------------#
    
    my %known_specs = (
        '1.4' => 'http://module-build.sourceforge.net/META-spec-v1.4.html',
        '1.3' => 'http://module-build.sourceforge.net/META-spec-v1.3.html',
        '1.2' => 'http://module-build.sourceforge.net/META-spec-v1.2.html',
        '1.1' => 'http://module-build.sourceforge.net/META-spec-v1.1.html',
        '1.0' => 'http://module-build.sourceforge.net/META-spec-v1.0.html'
    );
    my %known_urls = map {$known_specs{$_} => $_} keys %known_specs;
    
    my $module_map1 = { 'map' => { ':key' => { name => \&module, value => \&exversion } } };
    
    my $module_map2 = { 'map' => { ':key' => { name => \&module, value => \&version   } } };
    
    my $no_index_2 = {
        'map'       => { file       => { list => { value => \&string } },
                         directory  => { list => { value => \&string } },
                         'package'  => { list => { value => \&string } },
                         namespace  => { list => { value => \&string } },
                        ':key'      => { name => \&custom_2, value => \&anything },
        }
    };
    
    my $no_index_1_3 = {
        'map'       => { file       => { list => { value => \&string } },
                         directory  => { list => { value => \&string } },
                         'package'  => { list => { value => \&string } },
                         namespace  => { list => { value => \&string } },
                         ':key'     => { name => \&string, value => \&anything },
        }
    };
    
    my $no_index_1_2 = {
        'map'       => { file       => { list => { value => \&string } },
                         dir        => { list => { value => \&string } },
                         'package'  => { list => { value => \&string } },
                         namespace  => { list => { value => \&string } },
                         ':key'     => { name => \&string, value => \&anything },
        }
    };
    
    my $no_index_1_1 = {
        'map'       => { ':key'     => { name => \&string, list => { value => \&string } },
        }
    };
    
    my $prereq_map = {
      map => {
        ':key' => {
          name => \&phase,
          'map' => {
            ':key'  => {
              name => \&relation,
              %$module_map1,
            },
          },
        }
      },
    };
    
    my %definitions = (
      '2' => {
        # REQUIRED
        'abstract'            => { mandatory => 1, value => \&string  },
        'author'              => { mandatory => 1, list => { value => \&string } },
        'dynamic_config'      => { mandatory => 1, value => \&boolean },
        'generated_by'        => { mandatory => 1, value => \&string  },
        'license'             => { mandatory => 1, list => { value => \&license } },
        'meta-spec' => {
          mandatory => 1,
          'map' => {
            version => { mandatory => 1, value => \&version},
            url     => { value => \&url },
            ':key' => { name => \&custom_2, value => \&anything },
          }
        },
        'name'                => { mandatory => 1, value => \&string  },
        'release_status'      => { mandatory => 1, value => \&release_status },
        'version'             => { mandatory => 1, value => \&version },
    
        # OPTIONAL
        'description' => { value => \&string },
        'keywords'    => { list => { value => \&string } },
        'no_index'    => $no_index_2,
        'optional_features'   => {
          'map'       => {
            ':key'  => {
              name => \&string,
              'map'   => {
                description        => { value => \&string },
                prereqs => $prereq_map,
                ':key' => { name => \&custom_2, value => \&anything },
              }
            }
          }
        },
        'prereqs' => $prereq_map,
        'provides'    => {
          'map'       => {
            ':key' => {
              name  => \&module,
              'map' => {
                file    => { mandatory => 1, value => \&file },
                version => { value => \&version },
                ':key' => { name => \&custom_2, value => \&anything },
              }
            }
          }
        },
        'resources'   => {
          'map'       => {
            license    => { list => { value => \&url } },
            homepage   => { value => \&url },
            bugtracker => {
              'map' => {
                web => { value => \&url },
                mailto => { value => \&string},
                ':key' => { name => \&custom_2, value => \&anything },
              }
            },
            repository => {
              'map' => {
                web => { value => \&url },
                url => { value => \&url },
                type => { value => \&string },
                ':key' => { name => \&custom_2, value => \&anything },
              }
            },
            ':key'     => { value => \&string, name => \&custom_2 },
          }
        },
    
        # CUSTOM -- additional user defined key/value pairs
        # note we can only validate the key name, as the structure is user defined
        ':key'        => { name => \&custom_2, value => \&anything },
      },
    
    '1.4' => {
      'meta-spec'           => {
        mandatory => 1,
        'map' => {
          version => { mandatory => 1, value => \&version},
          url     => { mandatory => 1, value => \&urlspec },
          ':key'  => { name => \&string, value => \&anything },
        },
      },
    
      'name'                => { mandatory => 1, value => \&string  },
      'version'             => { mandatory => 1, value => \&version },
      'abstract'            => { mandatory => 1, value => \&string  },
      'author'              => { mandatory => 1, list  => { value => \&string } },
      'license'             => { mandatory => 1, value => \&license },
      'generated_by'        => { mandatory => 1, value => \&string  },
    
      'distribution_type'   => { value => \&string  },
      'dynamic_config'      => { value => \&boolean },
    
      'requires'            => $module_map1,
      'recommends'          => $module_map1,
      'build_requires'      => $module_map1,
      'configure_requires'  => $module_map1,
      'conflicts'           => $module_map2,
    
      'optional_features'   => {
        'map'       => {
            ':key'  => { name => \&string,
                'map'   => { description        => { value => \&string },
                             requires           => $module_map1,
                             recommends         => $module_map1,
                             build_requires     => $module_map1,
                             conflicts          => $module_map2,
                             ':key'  => { name => \&string, value => \&anything },
                }
            }
         }
      },
    
      'provides'    => {
        'map'       => {
          ':key' => { name  => \&module,
            'map' => {
              file    => { mandatory => 1, value => \&file },
              version => { value => \&version },
              ':key'  => { name => \&string, value => \&anything },
            }
          }
        }
      },
    
      'no_index'    => $no_index_1_3,
      'private'     => $no_index_1_3,
    
      'keywords'    => { list => { value => \&string } },
    
      'resources'   => {
        'map'       => { license    => { value => \&url },
                         homepage   => { value => \&url },
                         bugtracker => { value => \&url },
                         repository => { value => \&url },
                         ':key'     => { value => \&string, name => \&custom_1 },
        }
      },
    
      # additional user defined key/value pairs
      # note we can only validate the key name, as the structure is user defined
      ':key'        => { name => \&string, value => \&anything },
    },
    
    '1.3' => {
      'meta-spec'           => {
        mandatory => 1,
        'map' => {
          version => { mandatory => 1, value => \&version},
          url     => { mandatory => 1, value => \&urlspec },
          ':key'  => { name => \&string, value => \&anything },
        },
      },
    
      'name'                => { mandatory => 1, value => \&string  },
      'version'             => { mandatory => 1, value => \&version },
      'abstract'            => { mandatory => 1, value => \&string  },
      'author'              => { mandatory => 1, list  => { value => \&string } },
      'license'             => { mandatory => 1, value => \&license },
      'generated_by'        => { mandatory => 1, value => \&string  },
    
      'distribution_type'   => { value => \&string  },
      'dynamic_config'      => { value => \&boolean },
    
      'requires'            => $module_map1,
      'recommends'          => $module_map1,
      'build_requires'      => $module_map1,
      'conflicts'           => $module_map2,
    
      'optional_features'   => {
        'map'       => {
            ':key'  => { name => \&string,
                'map'   => { description        => { value => \&string },
                             requires           => $module_map1,
                             recommends         => $module_map1,
                             build_requires     => $module_map1,
                             conflicts          => $module_map2,
                             ':key'  => { name => \&string, value => \&anything },
                }
            }
         }
      },
    
      'provides'    => {
        'map'       => {
          ':key' => { name  => \&module,
            'map' => {
              file    => { mandatory => 1, value => \&file },
              version => { value => \&version },
              ':key'  => { name => \&string, value => \&anything },
            }
          }
        }
      },
    
    
      'no_index'    => $no_index_1_3,
      'private'     => $no_index_1_3,
    
      'keywords'    => { list => { value => \&string } },
    
      'resources'   => {
        'map'       => { license    => { value => \&url },
                         homepage   => { value => \&url },
                         bugtracker => { value => \&url },
                         repository => { value => \&url },
                         ':key'     => { value => \&string, name => \&custom_1 },
        }
      },
    
      # additional user defined key/value pairs
      # note we can only validate the key name, as the structure is user defined
      ':key'        => { name => \&string, value => \&anything },
    },
    
    # v1.2 is misleading, it seems to assume that a number of fields where created
    # within v1.1, when they were created within v1.2. This may have been an
    # original mistake, and that a v1.1 was retro fitted into the timeline, when
    # v1.2 was originally slated as v1.1. But I could be wrong ;)
    '1.2' => {
      'meta-spec'           => {
        mandatory => 1,
        'map' => {
          version => { mandatory => 1, value => \&version},
          url     => { mandatory => 1, value => \&urlspec },
          ':key'  => { name => \&string, value => \&anything },
        },
      },
    
    
      'name'                => { mandatory => 1, value => \&string  },
      'version'             => { mandatory => 1, value => \&version },
      'license'             => { mandatory => 1, value => \&license },
      'generated_by'        => { mandatory => 1, value => \&string  },
      'author'              => { mandatory => 1, list => { value => \&string } },
      'abstract'            => { mandatory => 1, value => \&string  },
    
      'distribution_type'   => { value => \&string  },
      'dynamic_config'      => { value => \&boolean },
    
      'keywords'            => { list => { value => \&string } },
    
      'private'             => $no_index_1_2,
      '$no_index'           => $no_index_1_2,
    
      'requires'            => $module_map1,
      'recommends'          => $module_map1,
      'build_requires'      => $module_map1,
      'conflicts'           => $module_map2,
    
      'optional_features'   => {
        'map'       => {
            ':key'  => { name => \&string,
                'map'   => { description        => { value => \&string },
                             requires           => $module_map1,
                             recommends         => $module_map1,
                             build_requires     => $module_map1,
                             conflicts          => $module_map2,
                             ':key'  => { name => \&string, value => \&anything },
                }
            }
         }
      },
    
      'provides'    => {
        'map'       => {
          ':key' => { name  => \&module,
            'map' => {
              file    => { mandatory => 1, value => \&file },
              version => { value => \&version },
              ':key'  => { name => \&string, value => \&anything },
            }
          }
        }
      },
    
      'resources'   => {
        'map'       => { license    => { value => \&url },
                         homepage   => { value => \&url },
                         bugtracker => { value => \&url },
                         repository => { value => \&url },
                         ':key'     => { value => \&string, name => \&custom_1 },
        }
      },
    
      # additional user defined key/value pairs
      # note we can only validate the key name, as the structure is user defined
      ':key'        => { name => \&string, value => \&anything },
    },
    
    # note that the 1.1 spec only specifies 'version' as mandatory
    '1.1' => {
      'name'                => { value => \&string  },
      'version'             => { mandatory => 1, value => \&version },
      'license'             => { value => \&license },
      'generated_by'        => { value => \&string  },
    
      'license_uri'         => { value => \&url },
      'distribution_type'   => { value => \&string  },
      'dynamic_config'      => { value => \&boolean },
    
      'private'             => $no_index_1_1,
    
      'requires'            => $module_map1,
      'recommends'          => $module_map1,
      'build_requires'      => $module_map1,
      'conflicts'           => $module_map2,
    
      # additional user defined key/value pairs
      # note we can only validate the key name, as the structure is user defined
      ':key'        => { name => \&string, value => \&anything },
    },
    
    # note that the 1.0 spec doesn't specify optional or mandatory fields
    # but we will treat version as mandatory since otherwise META 1.0 is
    # completely arbitrary and pointless
    '1.0' => {
      'name'                => { value => \&string  },
      'version'             => { mandatory => 1, value => \&version },
      'license'             => { value => \&license },
      'generated_by'        => { value => \&string  },
    
      'license_uri'         => { value => \&url },
      'distribution_type'   => { value => \&string  },
      'dynamic_config'      => { value => \&boolean },
    
      'requires'            => $module_map1,
      'recommends'          => $module_map1,
      'build_requires'      => $module_map1,
      'conflicts'           => $module_map2,
    
      # additional user defined key/value pairs
      # note we can only validate the key name, as the structure is user defined
      ':key'        => { name => \&string, value => \&anything },
    },
    );
    
    #--------------------------------------------------------------------------#
    # Code
    #--------------------------------------------------------------------------#
    
    #pod =method new
    #pod
    #pod   my $cmv = CPAN::Meta::Validator->new( $struct )
    #pod
    #pod The constructor must be passed a metadata structure.
    #pod
    #pod =cut
    
    sub new {
      my ($class,$data) = @_;
    
      # create an attributes hash
      my $self = {
        'data'    => $data,
        'spec'    => eval { $data->{'meta-spec'}{'version'} } || "1.0",
        'errors'  => undef,
      };
    
      # create the object
      return bless $self, $class;
    }
    
    #pod =method is_valid
    #pod
    #pod   if ( $cmv->is_valid ) {
    #pod     ...
    #pod   }
    #pod
    #pod Returns a boolean value indicating whether the metadata provided
    #pod is valid.
    #pod
    #pod =cut
    
    sub is_valid {
        my $self = shift;
        my $data = $self->{data};
        my $spec_version = $self->{spec};
        $self->check_map($definitions{$spec_version},$data);
        return ! $self->errors;
    }
    
    #pod =method errors
    #pod
    #pod   warn( join "\n", $cmv->errors );
    #pod
    #pod Returns a list of errors seen during validation.
    #pod
    #pod =cut
    
    sub errors {
        my $self = shift;
        return ()   unless(defined $self->{errors});
        return @{$self->{errors}};
    }
    
    #pod =begin :internals
    #pod
    #pod =head2 Check Methods
    #pod
    #pod =over
    #pod
    #pod =item *
    #pod
    #pod check_map($spec,$data)
    #pod
    #pod Checks whether a map (or hash) part of the data structure conforms to the
    #pod appropriate specification definition.
    #pod
    #pod =item *
    #pod
    #pod check_list($spec,$data)
    #pod
    #pod Checks whether a list (or array) part of the data structure conforms to
    #pod the appropriate specification definition.
    #pod
    #pod =item *
    #pod
    #pod =back
    #pod
    #pod =cut
    
    my $spec_error = "Missing validation action in specification. "
      . "Must be one of 'map', 'list', or 'value'";
    
    sub check_map {
        my ($self,$spec,$data) = @_;
    
        if(ref($spec) ne 'HASH') {
            $self->_error( "Unknown META specification, cannot validate." );
            return;
        }
    
        if(ref($data) ne 'HASH') {
            $self->_error( "Expected a map structure from string or file." );
            return;
        }
    
        for my $key (keys %$spec) {
            next    unless($spec->{$key}->{mandatory});
            next    if(defined $data->{$key});
            push @{$self->{stack}}, $key;
            $self->_error( "Missing mandatory field, '$key'" );
            pop @{$self->{stack}};
        }
    
        for my $key (keys %$data) {
            push @{$self->{stack}}, $key;
            if($spec->{$key}) {
                if($spec->{$key}{value}) {
                    $spec->{$key}{value}->($self,$key,$data->{$key});
                } elsif($spec->{$key}{'map'}) {
                    $self->check_map($spec->{$key}{'map'},$data->{$key});
                } elsif($spec->{$key}{'list'}) {
                    $self->check_list($spec->{$key}{'list'},$data->{$key});
                } else {
                    $self->_error( "$spec_error for '$key'" );
                }
    
            } elsif ($spec->{':key'}) {
                $spec->{':key'}{name}->($self,$key,$key);
                if($spec->{':key'}{value}) {
                    $spec->{':key'}{value}->($self,$key,$data->{$key});
                } elsif($spec->{':key'}{'map'}) {
                    $self->check_map($spec->{':key'}{'map'},$data->{$key});
                } elsif($spec->{':key'}{'list'}) {
                    $self->check_list($spec->{':key'}{'list'},$data->{$key});
                } else {
                    $self->_error( "$spec_error for ':key'" );
                }
    
    
            } else {
                $self->_error( "Unknown key, '$key', found in map structure" );
            }
            pop @{$self->{stack}};
        }
    }
    
    sub check_list {
        my ($self,$spec,$data) = @_;
    
        if(ref($data) ne 'ARRAY') {
            $self->_error( "Expected a list structure" );
            return;
        }
    
        if(defined $spec->{mandatory}) {
            if(!defined $data->[0]) {
                $self->_error( "Missing entries from mandatory list" );
            }
        }
    
        for my $value (@$data) {
            push @{$self->{stack}}, $value || "<undef>";
            if(defined $spec->{value}) {
                $spec->{value}->($self,'list',$value);
            } elsif(defined $spec->{'map'}) {
                $self->check_map($spec->{'map'},$value);
            } elsif(defined $spec->{'list'}) {
                $self->check_list($spec->{'list'},$value);
            } elsif ($spec->{':key'}) {
                $self->check_map($spec,$value);
            } else {
              $self->_error( "$spec_error associated with '$self->{stack}[-2]'" );
            }
            pop @{$self->{stack}};
        }
    }
    
    #pod =head2 Validator Methods
    #pod
    #pod =over
    #pod
    #pod =item *
    #pod
    #pod header($self,$key,$value)
    #pod
    #pod Validates that the header is valid.
    #pod
    #pod Note: No longer used as we now read the data structure, not the file.
    #pod
    #pod =item *
    #pod
    #pod url($self,$key,$value)
    #pod
    #pod Validates that a given value is in an acceptable URL format
    #pod
    #pod =item *
    #pod
    #pod urlspec($self,$key,$value)
    #pod
    #pod Validates that the URL to a META specification is a known one.
    #pod
    #pod =item *
    #pod
    #pod string_or_undef($self,$key,$value)
    #pod
    #pod Validates that the value is either a string or an undef value. Bit of a
    #pod catchall function for parts of the data structure that are completely user
    #pod defined.
    #pod
    #pod =item *
    #pod
    #pod string($self,$key,$value)
    #pod
    #pod Validates that a string exists for the given key.
    #pod
    #pod =item *
    #pod
    #pod file($self,$key,$value)
    #pod
    #pod Validate that a file is passed for the given key. This may be made more
    #pod thorough in the future. For now it acts like \&string.
    #pod
    #pod =item *
    #pod
    #pod exversion($self,$key,$value)
    #pod
    #pod Validates a list of versions, e.g. '<= 5, >=2, ==3, !=4, >1, <6, 0'.
    #pod
    #pod =item *
    #pod
    #pod version($self,$key,$value)
    #pod
    #pod Validates a single version string. Versions of the type '5.8.8' and '0.00_00'
    #pod are both valid. A leading 'v' like 'v1.2.3' is also valid.
    #pod
    #pod =item *
    #pod
    #pod boolean($self,$key,$value)
    #pod
    #pod Validates for a boolean value. Currently these values are '1', '0', 'true',
    #pod 'false', however the latter 2 may be removed.
    #pod
    #pod =item *
    #pod
    #pod license($self,$key,$value)
    #pod
    #pod Validates that a value is given for the license. Returns 1 if an known license
    #pod type, or 2 if a value is given but the license type is not a recommended one.
    #pod
    #pod =item *
    #pod
    #pod custom_1($self,$key,$value)
    #pod
    #pod Validates that the given key is in CamelCase, to indicate a user defined
    #pod keyword and only has characters in the class [-_a-zA-Z].  In version 1.X
    #pod of the spec, this was only explicitly stated for 'resources'.
    #pod
    #pod =item *
    #pod
    #pod custom_2($self,$key,$value)
    #pod
    #pod Validates that the given key begins with 'x_' or 'X_', to indicate a user
    #pod defined keyword and only has characters in the class [-_a-zA-Z]
    #pod
    #pod =item *
    #pod
    #pod identifier($self,$key,$value)
    #pod
    #pod Validates that key is in an acceptable format for the META specification,
    #pod for an identifier, i.e. any that matches the regular expression
    #pod qr/[a-z][a-z_]/i.
    #pod
    #pod =item *
    #pod
    #pod module($self,$key,$value)
    #pod
    #pod Validates that a given key is in an acceptable module name format, e.g.
    #pod 'Test::CPAN::Meta::Version'.
    #pod
    #pod =back
    #pod
    #pod =end :internals
    #pod
    #pod =cut
    
    sub header {
        my ($self,$key,$value) = @_;
        if(defined $value) {
            return 1    if($value && $value =~ /^--- #YAML:1.0/);
        }
        $self->_error( "file does not have a valid YAML header." );
        return 0;
    }
    
    sub release_status {
      my ($self,$key,$value) = @_;
      if(defined $value) {
        my $version = $self->{data}{version} || '';
        if ( $version =~ /_/ ) {
          return 1 if ( $value =~ /\A(?:testing|unstable)\z/ );
          $self->_error( "'$value' for '$key' is invalid for version '$version'" );
        }
        else {
          return 1 if ( $value =~ /\A(?:stable|testing|unstable)\z/ );
          $self->_error( "'$value' for '$key' is invalid" );
        }
      }
      else {
        $self->_error( "'$key' is not defined" );
      }
      return 0;
    }
    
    # _uri_split taken from URI::Split by Gisle Aas, Copyright 2003
    sub _uri_split {
         return $_[0] =~ m,(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?,;
    }
    
    sub url {
        my ($self,$key,$value) = @_;
        if(defined $value) {
          my ($scheme, $auth, $path, $query, $frag) = _uri_split($value);
          unless ( defined $scheme && length $scheme ) {
            $self->_error( "'$value' for '$key' does not have a URL scheme" );
            return 0;
          }
          unless ( defined $auth && length $auth ) {
            $self->_error( "'$value' for '$key' does not have a URL authority" );
            return 0;
          }
          return 1;
        }
        $value ||= '';
        $self->_error( "'$value' for '$key' is not a valid URL." );
        return 0;
    }
    
    sub urlspec {
        my ($self,$key,$value) = @_;
        if(defined $value) {
            return 1    if($value && $known_specs{$self->{spec}} eq $value);
            if($value && $known_urls{$value}) {
                $self->_error( 'META specification URL does not match version' );
                return 0;
            }
        }
        $self->_error( 'Unknown META specification' );
        return 0;
    }
    
    sub anything { return 1 }
    
    sub string {
        my ($self,$key,$value) = @_;
        if(defined $value) {
            return 1    if($value || $value =~ /^0$/);
        }
        $self->_error( "value is an undefined string" );
        return 0;
    }
    
    sub string_or_undef {
        my ($self,$key,$value) = @_;
        return 1    unless(defined $value);
        return 1    if($value || $value =~ /^0$/);
        $self->_error( "No string defined for '$key'" );
        return 0;
    }
    
    sub file {
        my ($self,$key,$value) = @_;
        return 1    if(defined $value);
        $self->_error( "No file defined for '$key'" );
        return 0;
    }
    
    sub exversion {
        my ($self,$key,$value) = @_;
        if(defined $value && ($value || $value =~ /0/)) {
            my $pass = 1;
            for(split(",",$value)) { $self->version($key,$_) or ($pass = 0); }
            return $pass;
        }
        $value = '<undef>'  unless(defined $value);
        $self->_error( "'$value' for '$key' is not a valid version." );
        return 0;
    }
    
    sub version {
        my ($self,$key,$value) = @_;
        if(defined $value) {
            return 0    unless($value || $value =~ /0/);
            return 1    if($value =~ /^\s*((<|<=|>=|>|!=|==)\s*)?v?\d+((\.\d+((_|\.)\d+)?)?)/);
        } else {
            $value = '<undef>';
        }
        $self->_error( "'$value' for '$key' is not a valid version." );
        return 0;
    }
    
    sub boolean {
        my ($self,$key,$value) = @_;
        if(defined $value) {
            return 1    if($value =~ /^(0|1|true|false)$/);
        } else {
            $value = '<undef>';
        }
        $self->_error( "'$value' for '$key' is not a boolean value." );
        return 0;
    }
    
    my %v1_licenses = (
        'perl'         => 'http://dev.perl.org/licenses/',
        'gpl'          => 'http://www.opensource.org/licenses/gpl-license.php',
        'apache'       => 'http://apache.org/licenses/LICENSE-2.0',
        'artistic'     => 'http://opensource.org/licenses/artistic-license.php',
        'artistic_2'   => 'http://opensource.org/licenses/artistic-license-2.0.php',
        'lgpl'         => 'http://www.opensource.org/licenses/lgpl-license.php',
        'bsd'          => 'http://www.opensource.org/licenses/bsd-license.php',
        'gpl'          => 'http://www.opensource.org/licenses/gpl-license.php',
        'mit'          => 'http://opensource.org/licenses/mit-license.php',
        'mozilla'      => 'http://opensource.org/licenses/mozilla1.1.php',
        'open_source'  => undef,
        'unrestricted' => undef,
        'restrictive'  => undef,
        'unknown'      => undef,
    );
    
    my %v2_licenses = map { $_ => 1 } qw(
      agpl_3
      apache_1_1
      apache_2_0
      artistic_1
      artistic_2
      bsd
      freebsd
      gfdl_1_2
      gfdl_1_3
      gpl_1
      gpl_2
      gpl_3
      lgpl_2_1
      lgpl_3_0
      mit
      mozilla_1_0
      mozilla_1_1
      openssl
      perl_5
      qpl_1_0
      ssleay
      sun
      zlib
      open_source
      restricted
      unrestricted
      unknown
    );
    
    sub license {
        my ($self,$key,$value) = @_;
        my $licenses = $self->{spec} < 2 ? \%v1_licenses : \%v2_licenses;
        if(defined $value) {
            return 1    if($value && exists $licenses->{$value});
        } else {
            $value = '<undef>';
        }
        $self->_error( "License '$value' is invalid" );
        return 0;
    }
    
    sub custom_1 {
        my ($self,$key) = @_;
        if(defined $key) {
            # a valid user defined key should be alphabetic
            # and contain at least one capital case letter.
            return 1    if($key && $key =~ /^[_a-z]+$/i && $key =~ /[A-Z]/);
        } else {
            $key = '<undef>';
        }
        $self->_error( "Custom resource '$key' must be in CamelCase." );
        return 0;
    }
    
    sub custom_2 {
        my ($self,$key) = @_;
        if(defined $key) {
            return 1    if($key && $key =~ /^x_/i);  # user defined
        } else {
            $key = '<undef>';
        }
        $self->_error( "Custom key '$key' must begin with 'x_' or 'X_'." );
        return 0;
    }
    
    sub identifier {
        my ($self,$key) = @_;
        if(defined $key) {
            return 1    if($key && $key =~ /^([a-z][_a-z]+)$/i);    # spec 2.0 defined
        } else {
            $key = '<undef>';
        }
        $self->_error( "Key '$key' is not a legal identifier." );
        return 0;
    }
    
    sub module {
        my ($self,$key) = @_;
        if(defined $key) {
            return 1    if($key && $key =~ /^[A-Za-z0-9_]+(::[A-Za-z0-9_]+)*$/);
        } else {
            $key = '<undef>';
        }
        $self->_error( "Key '$key' is not a legal module name." );
        return 0;
    }
    
    my @valid_phases = qw/ configure build test runtime develop /;
    sub phase {
        my ($self,$key) = @_;
        if(defined $key) {
            return 1 if( length $key && grep { $key eq $_ } @valid_phases );
            return 1 if $key =~ /x_/i;
        } else {
            $key = '<undef>';
        }
        $self->_error( "Key '$key' is not a legal phase." );
        return 0;
    }
    
    my @valid_relations = qw/ requires recommends suggests conflicts /;
    sub relation {
        my ($self,$key) = @_;
        if(defined $key) {
            return 1 if( length $key && grep { $key eq $_ } @valid_relations );
            return 1 if $key =~ /x_/i;
        } else {
            $key = '<undef>';
        }
        $self->_error( "Key '$key' is not a legal prereq relationship." );
        return 0;
    }
    
    sub _error {
        my $self = shift;
        my $mess = shift;
    
        $mess .= ' ('.join(' -> ',@{$self->{stack}}).')'  if($self->{stack});
        $mess .= " [Validation: $self->{spec}]";
    
        push @{$self->{errors}}, $mess;
    }
    
    1;
    
    # ABSTRACT: validate CPAN distribution metadata structures
    
    =pod
    
    =encoding UTF-8
    
    =head1 NAME
    
    CPAN::Meta::Validator - validate CPAN distribution metadata structures
    
    =head1 VERSION
    
    version 2.150005
    
    =head1 SYNOPSIS
    
      my $struct = decode_json_file('META.json');
    
      my $cmv = CPAN::Meta::Validator->new( $struct );
    
      unless ( $cmv->is_valid ) {
        my $msg = "Invalid META structure.  Errors found:\n";
        $msg .= join( "\n", $cmv->errors );
        die $msg;
      }
    
    =head1 DESCRIPTION
    
    This module validates a CPAN Meta structure against the version of the
    the specification claimed in the C<meta-spec> field of the structure.
    
    =head1 METHODS
    
    =head2 new
    
      my $cmv = CPAN::Meta::Validator->new( $struct )
    
    The constructor must be passed a metadata structure.
    
    =head2 is_valid
    
      if ( $cmv->is_valid ) {
        ...
      }
    
    Returns a boolean value indicating whether the metadata provided
    is valid.
    
    =head2 errors
    
      warn( join "\n", $cmv->errors );
    
    Returns a list of errors seen during validation.
    
    =begin :internals
    
    =head2 Check Methods
    
    =over
    
    =item *
    
    check_map($spec,$data)
    
    Checks whether a map (or hash) part of the data structure conforms to the
    appropriate specification definition.
    
    =item *
    
    check_list($spec,$data)
    
    Checks whether a list (or array) part of the data structure conforms to
    the appropriate specification definition.
    
    =item *
    
    =back
    
    =head2 Validator Methods
    
    =over
    
    =item *
    
    header($self,$key,$value)
    
    Validates that the header is valid.
    
    Note: No longer used as we now read the data structure, not the file.
    
    =item *
    
    url($self,$key,$value)
    
    Validates that a given value is in an acceptable URL format
    
    =item *
    
    urlspec($self,$key,$value)
    
    Validates that the URL to a META specification is a known one.
    
    =item *
    
    string_or_undef($self,$key,$value)
    
    Validates that the value is either a string or an undef value. Bit of a
    catchall function for parts of the data structure that are completely user
    defined.
    
    =item *
    
    string($self,$key,$value)
    
    Validates that a string exists for the given key.
    
    =item *
    
    file($self,$key,$value)
    
    Validate that a file is passed for the given key. This may be made more
    thorough in the future. For now it acts like \&string.
    
    =item *
    
    exversion($self,$key,$value)
    
    Validates a list of versions, e.g. '<= 5, >=2, ==3, !=4, >1, <6, 0'.
    
    =item *
    
    version($self,$key,$value)
    
    Validates a single version string. Versions of the type '5.8.8' and '0.00_00'
    are both valid. A leading 'v' like 'v1.2.3' is also valid.
    
    =item *
    
    boolean($self,$key,$value)
    
    Validates for a boolean value. Currently these values are '1', '0', 'true',
    'false', however the latter 2 may be removed.
    
    =item *
    
    license($self,$key,$value)
    
    Validates that a value is given for the license. Returns 1 if an known license
    type, or 2 if a value is given but the license type is not a recommended one.
    
    =item *
    
    custom_1($self,$key,$value)
    
    Validates that the given key is in CamelCase, to indicate a user defined
    keyword and only has characters in the class [-_a-zA-Z].  In version 1.X
    of the spec, this was only explicitly stated for 'resources'.
    
    =item *
    
    custom_2($self,$key,$value)
    
    Validates that the given key begins with 'x_' or 'X_', to indicate a user
    defined keyword and only has characters in the class [-_a-zA-Z]
    
    =item *
    
    identifier($self,$key,$value)
    
    Validates that key is in an acceptable format for the META specification,
    for an identifier, i.e. any that matches the regular expression
    qr/[a-z][a-z_]/i.
    
    =item *
    
    module($self,$key,$value)
    
    Validates that a given key is in an acceptable module name format, e.g.
    'Test::CPAN::Meta::Version'.
    
    =back
    
    =end :internals
    
    =for Pod::Coverage anything boolean check_list custom_1 custom_2 exversion file
    identifier license module phase relation release_status string string_or_undef
    url urlspec version header check_map
    
    =head1 BUGS
    
    Please report any bugs or feature using the CPAN Request Tracker.
    Bugs can be submitted through the web interface at
    L<http://rt.cpan.org/Dist/Display.html?Queue=CPAN-Meta>
    
    When submitting a bug or request, please include a test-file or a patch to an
    existing test-file that illustrates the bug or desired feature.
    
    =head1 AUTHORS
    
    =over 4
    
    =item *
    
    David Golden <dagolden@cpan.org>
    
    =item *
    
    Ricardo Signes <rjbs@cpan.org>
    
    =back
    
    =head1 COPYRIGHT AND LICENSE
    
    This software is copyright (c) 2010 by David Golden and Ricardo Signes.
    
    This is free software; you can redistribute it and/or modify it under
    the same terms as the Perl 5 programming language system itself.
    
    =cut
    
    __END__
    
    
    # vim: ts=2 sts=2 sw=2 et :
  CPAN_META_VALIDATOR
  
  $fatpacked{"CPAN/Meta/YAML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_YAML';
    use 5.008001; # sane UTF-8 support
    use strict;
    use warnings;
    package CPAN::Meta::YAML; # git description: v1.66-5-ge09e1ae
    # XXX-INGY is 5.8.1 too old/broken for utf8?
    # XXX-XDG Lancaster consensus was that it was sufficient until
    # proven otherwise
    $CPAN::Meta::YAML::VERSION = '0.016';
    ; # original $VERSION removed by Doppelgaenger
    
    #####################################################################
    # The CPAN::Meta::YAML API.
    #
    # These are the currently documented API functions/methods and
    # exports:
    
    use Exporter;
    our @ISA       = qw{ Exporter  };
    our @EXPORT    = qw{ Load Dump };
    our @EXPORT_OK = qw{ LoadFile DumpFile freeze thaw };
    
    ###
    # Functional/Export API:
    
    sub Dump {
        return CPAN::Meta::YAML->new(@_)->_dump_string;
    }
    
    # XXX-INGY Returning last document seems a bad behavior.
    # XXX-XDG I think first would seem more natural, but I don't know
    # that it's worth changing now
    sub Load {
        my $self = CPAN::Meta::YAML->_load_string(@_);
        if ( wantarray ) {
            return @$self;
        } else {
            # To match YAML.pm, return the last document
            return $self->[-1];
        }
    }
    
    # XXX-INGY Do we really need freeze and thaw?
    # XXX-XDG I don't think so.  I'd support deprecating them.
    BEGIN {
        *freeze = \&Dump;
        *thaw   = \&Load;
    }
    
    sub DumpFile {
        my $file = shift;
        return CPAN::Meta::YAML->new(@_)->_dump_file($file);
    }
    
    sub LoadFile {
        my $file = shift;
        my $self = CPAN::Meta::YAML->_load_file($file);
        if ( wantarray ) {
            return @$self;
        } else {
            # Return only the last document to match YAML.pm,
            return $self->[-1];
        }
    }
    
    
    ###
    # Object Oriented API:
    
    # Create an empty CPAN::Meta::YAML object
    # XXX-INGY Why do we use ARRAY object?
    # NOTE: I get it now, but I think it's confusing and not needed.
    # Will change it on a branch later, for review.
    #
    # XXX-XDG I don't support changing it yet.  It's a very well-documented
    # "API" of CPAN::Meta::YAML.  I'd support deprecating it, but Adam suggested
    # we not change it until YAML.pm's own OO API is established so that
    # users only have one API change to digest, not two
    sub new {
        my $class = shift;
        bless [ @_ ], $class;
    }
    
    # XXX-INGY It probably doesn't matter, and it's probably too late to
    # change, but 'read/write' are the wrong names. Read and Write
    # are actions that take data from storage to memory
    # characters/strings. These take the data to/from storage to native
    # Perl objects, which the terms dump and load are meant. As long as
    # this is a legacy quirk to CPAN::Meta::YAML it's ok, but I'd prefer not
    # to add new {read,write}_* methods to this API.
    
    sub read_string {
        my $self = shift;
        $self->_load_string(@_);
    }
    
    sub write_string {
        my $self = shift;
        $self->_dump_string(@_);
    }
    
    sub read {
        my $self = shift;
        $self->_load_file(@_);
    }
    
    sub write {
        my $self = shift;
        $self->_dump_file(@_);
    }
    
    
    
    
    #####################################################################
    # Constants
    
    # Printed form of the unprintable characters in the lowest range
    # of ASCII characters, listed by ASCII ordinal position.
    my @UNPRINTABLE = qw(
        0    x01  x02  x03  x04  x05  x06  a
        b    t    n    v    f    r    x0E  x0F
        x10  x11  x12  x13  x14  x15  x16  x17
        x18  x19  x1A  e    x1C  x1D  x1E  x1F
    );
    
    # Printable characters for escapes
    my %UNESCAPES = (
        0 => "\x00", z => "\x00", N    => "\x85",
        a => "\x07", b => "\x08", t    => "\x09",
        n => "\x0a", v => "\x0b", f    => "\x0c",
        r => "\x0d", e => "\x1b", '\\' => '\\',
    );
    
    # XXX-INGY
    # I(ngy) need to decide if these values should be quoted in
    # CPAN::Meta::YAML or not. Probably yes.
    
    # These 3 values have special meaning when unquoted and using the
    # default YAML schema. They need quotes if they are strings.
    my %QUOTE = map { $_ => 1 } qw{
        null true false
    };
    
    # The commented out form is simpler, but overloaded the Perl regex
    # engine due to recursion and backtracking problems on strings
    # larger than 32,000ish characters. Keep it for reference purposes.
    # qr/\"((?:\\.|[^\"])*)\"/
    my $re_capture_double_quoted = qr/\"([^\\"]*(?:\\.[^\\"]*)*)\"/;
    my $re_capture_single_quoted = qr/\'([^\']*(?:\'\'[^\']*)*)\'/;
    # unquoted re gets trailing space that needs to be stripped
    my $re_capture_unquoted_key  = qr/([^:]+(?::+\S(?:[^:]*|.*?(?=:)))*)(?=\s*\:(?:\s+|$))/;
    my $re_trailing_comment      = qr/(?:\s+\#.*)?/;
    my $re_key_value_separator   = qr/\s*:(?:\s+(?:\#.*)?|$)/;
    
    
    
    
    
    #####################################################################
    # CPAN::Meta::YAML Implementation.
    #
    # These are the private methods that do all the work. They may change
    # at any time.
    
    
    ###
    # Loader functions:
    
    # Create an object from a file
    sub _load_file {
        my $class = ref $_[0] ? ref shift : shift;
    
        # Check the file
        my $file = shift or $class->_error( 'You did not specify a file name' );
        $class->_error( "File '$file' does not exist" )
            unless -e $file;
        $class->_error( "'$file' is a directory, not a file" )
            unless -f _;
        $class->_error( "Insufficient permissions to read '$file'" )
            unless -r _;
    
        # Open unbuffered with strict UTF-8 decoding and no translation layers
        open( my $fh, "<:unix:encoding(UTF-8)", $file );
        unless ( $fh ) {
            $class->_error("Failed to open file '$file': $!");
        }
    
        # flock if available (or warn if not possible for OS-specific reasons)
        if ( _can_flock() ) {
            flock( $fh, Fcntl::LOCK_SH() )
                or warn "Couldn't lock '$file' for reading: $!";
        }
    
        # slurp the contents
        my $contents = eval {
            use warnings FATAL => 'utf8';
            local $/;
            <$fh>
        };
        if ( my $err = $@ ) {
            $class->_error("Error reading from file '$file': $err");
        }
    
        # close the file (release the lock)
        unless ( close $fh ) {
            $class->_error("Failed to close file '$file': $!");
        }
    
        $class->_load_string( $contents );
    }
    
    # Create an object from a string
    sub _load_string {
        my $class  = ref $_[0] ? ref shift : shift;
        my $self   = bless [], $class;
        my $string = $_[0];
        eval {
            unless ( defined $string ) {
                die \"Did not provide a string to load";
            }
    
            # Check if Perl has it marked as characters, but it's internally
            # inconsistent.  E.g. maybe latin1 got read on a :utf8 layer
            if ( utf8::is_utf8($string) && ! utf8::valid($string) ) {
                die \<<'...';
    Read an invalid UTF-8 string (maybe mixed UTF-8 and 8-bit character set).
    Did you decode with lax ":utf8" instead of strict ":encoding(UTF-8)"?
    ...
            }
    
            # Ensure Unicode character semantics, even for 0x80-0xff
            utf8::upgrade($string);
    
            # Check for and strip any leading UTF-8 BOM
            $string =~ s/^\x{FEFF}//;
    
            # Check for some special cases
            return $self unless length $string;
    
            # Split the file into lines
            my @lines = grep { ! /^\s*(?:\#.*)?\z/ }
                    split /(?:\015{1,2}\012|\015|\012)/, $string;
    
            # Strip the initial YAML header
            @lines and $lines[0] =~ /^\%YAML[: ][\d\.]+.*\z/ and shift @lines;
    
            # A nibbling parser
            my $in_document = 0;
            while ( @lines ) {
                # Do we have a document header?
                if ( $lines[0] =~ /^---\s*(?:(.+)\s*)?\z/ ) {
                    # Handle scalar documents
                    shift @lines;
                    if ( defined $1 and $1 !~ /^(?:\#.+|\%YAML[: ][\d\.]+)\z/ ) {
                        push @$self,
                            $self->_load_scalar( "$1", [ undef ], \@lines );
                        next;
                    }
                    $in_document = 1;
                }
    
                if ( ! @lines or $lines[0] =~ /^(?:---|\.\.\.)/ ) {
                    # A naked document
                    push @$self, undef;
                    while ( @lines and $lines[0] !~ /^---/ ) {
                        shift @lines;
                    }
                    $in_document = 0;
    
                # XXX The final '-+$' is to look for -- which ends up being an
                # error later.
                } elsif ( ! $in_document && @$self ) {
                    # only the first document can be explicit
                    die \"CPAN::Meta::YAML failed to classify the line '$lines[0]'";
                } elsif ( $lines[0] =~ /^\s*\-(?:\s|$|-+$)/ ) {
                    # An array at the root
                    my $document = [ ];
                    push @$self, $document;
                    $self->_load_array( $document, [ 0 ], \@lines );
    
                } elsif ( $lines[0] =~ /^(\s*)\S/ ) {
                    # A hash at the root
                    my $document = { };
                    push @$self, $document;
                    $self->_load_hash( $document, [ length($1) ], \@lines );
    
                } else {
                    # Shouldn't get here.  @lines have whitespace-only lines
                    # stripped, and previous match is a line with any
                    # non-whitespace.  So this clause should only be reachable via
                    # a perlbug where \s is not symmetric with \S
    
                    # uncoverable statement
                    die \"CPAN::Meta::YAML failed to classify the line '$lines[0]'";
                }
            }
        };
        my $err = $@;
        if ( ref $err eq 'SCALAR' ) {
            $self->_error(${$err});
        } elsif ( $err ) {
            $self->_error($err);
        }
    
        return $self;
    }
    
    sub _unquote_single {
        my ($self, $string) = @_;
        return '' unless length $string;
        $string =~ s/\'\'/\'/g;
        return $string;
    }
    
    sub _unquote_double {
        my ($self, $string) = @_;
        return '' unless length $string;
        $string =~ s/\\"/"/g;
        $string =~
            s{\\([Nnever\\fartz0b]|x([0-9a-fA-F]{2}))}
             {(length($1)>1)?pack("H2",$2):$UNESCAPES{$1}}gex;
        return $string;
    }
    
    # Load a YAML scalar string to the actual Perl scalar
    sub _load_scalar {
        my ($self, $string, $indent, $lines) = @_;
    
        # Trim trailing whitespace
        $string =~ s/\s*\z//;
    
        # Explitic null/undef
        return undef if $string eq '~';
    
        # Single quote
        if ( $string =~ /^$re_capture_single_quoted$re_trailing_comment\z/ ) {
            return $self->_unquote_single($1);
        }
    
        # Double quote.
        if ( $string =~ /^$re_capture_double_quoted$re_trailing_comment\z/ ) {
            return $self->_unquote_double($1);
        }
    
        # Special cases
        if ( $string =~ /^[\'\"!&]/ ) {
            die \"CPAN::Meta::YAML does not support a feature in line '$string'";
        }
        return {} if $string =~ /^{}(?:\s+\#.*)?\z/;
        return [] if $string =~ /^\[\](?:\s+\#.*)?\z/;
    
        # Regular unquoted string
        if ( $string !~ /^[>|]/ ) {
            die \"CPAN::Meta::YAML found illegal characters in plain scalar: '$string'"
                if $string =~ /^(?:-(?:\s|$)|[\@\%\`])/ or
                    $string =~ /:(?:\s|$)/;
            $string =~ s/\s+#.*\z//;
            return $string;
        }
    
        # Error
        die \"CPAN::Meta::YAML failed to find multi-line scalar content" unless @$lines;
    
        # Check the indent depth
        $lines->[0]   =~ /^(\s*)/;
        $indent->[-1] = length("$1");
        if ( defined $indent->[-2] and $indent->[-1] <= $indent->[-2] ) {
            die \"CPAN::Meta::YAML found bad indenting in line '$lines->[0]'";
        }
    
        # Pull the lines
        my @multiline = ();
        while ( @$lines ) {
            $lines->[0] =~ /^(\s*)/;
            last unless length($1) >= $indent->[-1];
            push @multiline, substr(shift(@$lines), length($1));
        }
    
        my $j = (substr($string, 0, 1) eq '>') ? ' ' : "\n";
        my $t = (substr($string, 1, 1) eq '-') ? ''  : "\n";
        return join( $j, @multiline ) . $t;
    }
    
    # Load an array
    sub _load_array {
        my ($self, $array, $indent, $lines) = @_;
    
        while ( @$lines ) {
            # Check for a new document
            if ( $lines->[0] =~ /^(?:---|\.\.\.)/ ) {
                while ( @$lines and $lines->[0] !~ /^---/ ) {
                    shift @$lines;
                }
                return 1;
            }
    
            # Check the indent level
            $lines->[0] =~ /^(\s*)/;
            if ( length($1) < $indent->[-1] ) {
                return 1;
            } elsif ( length($1) > $indent->[-1] ) {
                die \"CPAN::Meta::YAML found bad indenting in line '$lines->[0]'";
            }
    
            if ( $lines->[0] =~ /^(\s*\-\s+)[^\'\"]\S*\s*:(?:\s+|$)/ ) {
                # Inline nested hash
                my $indent2 = length("$1");
                $lines->[0] =~ s/-/ /;
                push @$array, { };
                $self->_load_hash( $array->[-1], [ @$indent, $indent2 ], $lines );
    
            } elsif ( $lines->[0] =~ /^\s*\-\s*\z/ ) {
                shift @$lines;
                unless ( @$lines ) {
                    push @$array, undef;
                    return 1;
                }
                if ( $lines->[0] =~ /^(\s*)\-/ ) {
                    my $indent2 = length("$1");
                    if ( $indent->[-1] == $indent2 ) {
                        # Null array entry
                        push @$array, undef;
                    } else {
                        # Naked indenter
                        push @$array, [ ];
                        $self->_load_array(
                            $array->[-1], [ @$indent, $indent2 ], $lines
                        );
                    }
    
                } elsif ( $lines->[0] =~ /^(\s*)\S/ ) {
                    push @$array, { };
                    $self->_load_hash(
                        $array->[-1], [ @$indent, length("$1") ], $lines
                    );
    
                } else {
                    die \"CPAN::Meta::YAML failed to classify line '$lines->[0]'";
                }
    
            } elsif ( $lines->[0] =~ /^\s*\-(\s*)(.+?)\s*\z/ ) {
                # Array entry with a value
                shift @$lines;
                push @$array, $self->_load_scalar(
                    "$2", [ @$indent, undef ], $lines
                );
    
            } elsif ( defined $indent->[-2] and $indent->[-1] == $indent->[-2] ) {
                # This is probably a structure like the following...
                # ---
                # foo:
                # - list
                # bar: value
                #
                # ... so lets return and let the hash parser handle it
                return 1;
    
            } else {
                die \"CPAN::Meta::YAML failed to classify line '$lines->[0]'";
            }
        }
    
        return 1;
    }
    
    # Load a hash
    sub _load_hash {
        my ($self, $hash, $indent, $lines) = @_;
    
        while ( @$lines ) {
            # Check for a new document
            if ( $lines->[0] =~ /^(?:---|\.\.\.)/ ) {
                while ( @$lines and $lines->[0] !~ /^---/ ) {
                    shift @$lines;
                }
                return 1;
            }
    
            # Check the indent level
            $lines->[0] =~ /^(\s*)/;
            if ( length($1) < $indent->[-1] ) {
                return 1;
            } elsif ( length($1) > $indent->[-1] ) {
                die \"CPAN::Meta::YAML found bad indenting in line '$lines->[0]'";
            }
    
            # Find the key
            my $key;
    
            # Quoted keys
            if ( $lines->[0] =~
                s/^\s*$re_capture_single_quoted$re_key_value_separator//
            ) {
                $key = $self->_unquote_single($1);
            }
            elsif ( $lines->[0] =~
                s/^\s*$re_capture_double_quoted$re_key_value_separator//
            ) {
                $key = $self->_unquote_double($1);
            }
            elsif ( $lines->[0] =~
                s/^\s*$re_capture_unquoted_key$re_key_value_separator//
            ) {
                $key = $1;
                $key =~ s/\s+$//;
            }
            elsif ( $lines->[0] =~ /^\s*\?/ ) {
                die \"CPAN::Meta::YAML does not support a feature in line '$lines->[0]'";
            }
            else {
                die \"CPAN::Meta::YAML failed to classify line '$lines->[0]'";
            }
    
            if ( exists $hash->{$key} ) {
                warn "CPAN::Meta::YAML found a duplicate key '$key' in line '$lines->[0]'";
            }
    
            # Do we have a value?
            if ( length $lines->[0] ) {
                # Yes
                $hash->{$key} = $self->_load_scalar(
                    shift(@$lines), [ @$indent, undef ], $lines
                );
            } else {
                # An indent
                shift @$lines;
                unless ( @$lines ) {
                    $hash->{$key} = undef;
                    return 1;
                }
                if ( $lines->[0] =~ /^(\s*)-/ ) {
                    $hash->{$key} = [];
                    $self->_load_array(
                        $hash->{$key}, [ @$indent, length($1) ], $lines
                    );
                } elsif ( $lines->[0] =~ /^(\s*)./ ) {
                    my $indent2 = length("$1");
                    if ( $indent->[-1] >= $indent2 ) {
                        # Null hash entry
                        $hash->{$key} = undef;
                    } else {
                        $hash->{$key} = {};
                        $self->_load_hash(
                            $hash->{$key}, [ @$indent, length($1) ], $lines
                        );
                    }
                }
            }
        }
    
        return 1;
    }
    
    
    ###
    # Dumper functions:
    
    # Save an object to a file
    sub _dump_file {
        my $self = shift;
    
        require Fcntl;
    
        # Check the file
        my $file = shift or $self->_error( 'You did not specify a file name' );
    
        my $fh;
        # flock if available (or warn if not possible for OS-specific reasons)
        if ( _can_flock() ) {
            # Open without truncation (truncate comes after lock)
            my $flags = Fcntl::O_WRONLY()|Fcntl::O_CREAT();
            sysopen( $fh, $file, $flags );
            unless ( $fh ) {
                $self->_error("Failed to open file '$file' for writing: $!");
            }
    
            # Use no translation and strict UTF-8
            binmode( $fh, ":raw:encoding(UTF-8)");
    
            flock( $fh, Fcntl::LOCK_EX() )
                or warn "Couldn't lock '$file' for reading: $!";
    
            # truncate and spew contents
            truncate $fh, 0;
            seek $fh, 0, 0;
        }
        else {
            open $fh, ">:unix:encoding(UTF-8)", $file;
        }
    
        # serialize and spew to the handle
        print {$fh} $self->_dump_string;
    
        # close the file (release the lock)
        unless ( close $fh ) {
            $self->_error("Failed to close file '$file': $!");
        }
    
        return 1;
    }
    
    # Save an object to a string
    sub _dump_string {
        my $self = shift;
        return '' unless ref $self && @$self;
    
        # Iterate over the documents
        my $indent = 0;
        my @lines  = ();
    
        eval {
            foreach my $cursor ( @$self ) {
                push @lines, '---';
    
                # An empty document
                if ( ! defined $cursor ) {
                    # Do nothing
    
                # A scalar document
                } elsif ( ! ref $cursor ) {
                    $lines[-1] .= ' ' . $self->_dump_scalar( $cursor );
    
                # A list at the root
                } elsif ( ref $cursor eq 'ARRAY' ) {
                    unless ( @$cursor ) {
                        $lines[-1] .= ' []';
                        next;
                    }
                    push @lines, $self->_dump_array( $cursor, $indent, {} );
    
                # A hash at the root
                } elsif ( ref $cursor eq 'HASH' ) {
                    unless ( %$cursor ) {
                        $lines[-1] .= ' {}';
                        next;
                    }
                    push @lines, $self->_dump_hash( $cursor, $indent, {} );
    
                } else {
                    die \("Cannot serialize " . ref($cursor));
                }
            }
        };
        if ( ref $@ eq 'SCALAR' ) {
            $self->_error(${$@});
        } elsif ( $@ ) {
            $self->_error($@);
        }
    
        join '', map { "$_\n" } @lines;
    }
    
    sub _has_internal_string_value {
        my $value = shift;
        my $b_obj = B::svref_2object(\$value);  # for round trip problem
        return $b_obj->FLAGS & B::SVf_POK();
    }
    
    sub _dump_scalar {
        my $string = $_[1];
        my $is_key = $_[2];
        # Check this before checking length or it winds up looking like a string!
        my $has_string_flag = _has_internal_string_value($string);
        return '~'  unless defined $string;
        return "''" unless length  $string;
        if (Scalar::Util::looks_like_number($string)) {
            # keys and values that have been used as strings get quoted
            if ( $is_key || $has_string_flag ) {
                return qq['$string'];
            }
            else {
                return $string;
            }
        }
        if ( $string =~ /[\x00-\x09\x0b-\x0d\x0e-\x1f\x7f-\x9f\'\n]/ ) {
            $string =~ s/\\/\\\\/g;
            $string =~ s/"/\\"/g;
            $string =~ s/\n/\\n/g;
            $string =~ s/[\x85]/\\N/g;
            $string =~ s/([\x00-\x1f])/\\$UNPRINTABLE[ord($1)]/g;
            $string =~ s/([\x7f-\x9f])/'\x' . sprintf("%X",ord($1))/ge;
            return qq|"$string"|;
        }
        if ( $string =~ /(?:^[~!@#%&*|>?:,'"`{}\[\]]|^-+$|\s|:\z)/ or
            $QUOTE{$string}
        ) {
            return "'$string'";
        }
        return $string;
    }
    
    sub _dump_array {
        my ($self, $array, $indent, $seen) = @_;
        if ( $seen->{refaddr($array)}++ ) {
            die \"CPAN::Meta::YAML does not support circular references";
        }
        my @lines  = ();
        foreach my $el ( @$array ) {
            my $line = ('  ' x $indent) . '-';
            my $type = ref $el;
            if ( ! $type ) {
                $line .= ' ' . $self->_dump_scalar( $el );
                push @lines, $line;
    
            } elsif ( $type eq 'ARRAY' ) {
                if ( @$el ) {
                    push @lines, $line;
                    push @lines, $self->_dump_array( $el, $indent + 1, $seen );
                } else {
                    $line .= ' []';
                    push @lines, $line;
                }
    
            } elsif ( $type eq 'HASH' ) {
                if ( keys %$el ) {
                    push @lines, $line;
                    push @lines, $self->_dump_hash( $el, $indent + 1, $seen );
                } else {
                    $line .= ' {}';
                    push @lines, $line;
                }
    
            } else {
                die \"CPAN::Meta::YAML does not support $type references";
            }
        }
    
        @lines;
    }
    
    sub _dump_hash {
        my ($self, $hash, $indent, $seen) = @_;
        if ( $seen->{refaddr($hash)}++ ) {
            die \"CPAN::Meta::YAML does not support circular references";
        }
        my @lines  = ();
        foreach my $name ( sort keys %$hash ) {
            my $el   = $hash->{$name};
            my $line = ('  ' x $indent) . $self->_dump_scalar($name, 1) . ":";
            my $type = ref $el;
            if ( ! $type ) {
                $line .= ' ' . $self->_dump_scalar( $el );
                push @lines, $line;
    
            } elsif ( $type eq 'ARRAY' ) {
                if ( @$el ) {
                    push @lines, $line;
                    push @lines, $self->_dump_array( $el, $indent + 1, $seen );
                } else {
                    $line .= ' []';
                    push @lines, $line;
                }
    
            } elsif ( $type eq 'HASH' ) {
                if ( keys %$el ) {
                    push @lines, $line;
                    push @lines, $self->_dump_hash( $el, $indent + 1, $seen );
                } else {
                    $line .= ' {}';
                    push @lines, $line;
                }
    
            } else {
                die \"CPAN::Meta::YAML does not support $type references";
            }
        }
    
        @lines;
    }
    
    
    
    #####################################################################
    # DEPRECATED API methods:
    
    # Error storage (DEPRECATED as of 1.57)
    our $errstr    = '';
    
    # Set error
    sub _error {
        require Carp;
        $errstr = $_[1];
        $errstr =~ s/ at \S+ line \d+.*//;
        Carp::croak( $errstr );
    }
    
    # Retrieve error
    my $errstr_warned;
    sub errstr {
        require Carp;
        Carp::carp( "CPAN::Meta::YAML->errstr and \$CPAN::Meta::YAML::errstr is deprecated" )
            unless $errstr_warned++;
        $errstr;
    }
    
    
    
    
    #####################################################################
    # Helper functions. Possibly not needed.
    
    
    # Use to detect nv or iv
    use B;
    
    # XXX-INGY Is flock CPAN::Meta::YAML's responsibility?
    # Some platforms can't flock :-(
    # XXX-XDG I think it is.  When reading and writing files, we ought
    # to be locking whenever possible.  People (foolishly) use YAML
    # files for things like session storage, which has race issues.
    my $HAS_FLOCK;
    sub _can_flock {
        if ( defined $HAS_FLOCK ) {
            return $HAS_FLOCK;
        }
        else {
            require Config;
            my $c = \%Config::Config;
            $HAS_FLOCK = grep { $c->{$_} } qw/d_flock d_fcntl_can_lock d_lockf/;
            require Fcntl if $HAS_FLOCK;
            return $HAS_FLOCK;
        }
    }
    
    
    # XXX-INGY Is this core in 5.8.1? Can we remove this?
    # XXX-XDG Scalar::Util 1.18 didn't land until 5.8.8, so we need this
    #####################################################################
    # Use Scalar::Util if possible, otherwise emulate it
    
    use Scalar::Util ();
    BEGIN {
        local $@;
        if ( eval { Scalar::Util->VERSION(1.18); } ) {
            *refaddr = *Scalar::Util::refaddr;
        }
        else {
            eval <<'END_PERL';
    # Scalar::Util failed to load or too old
    sub refaddr {
        my $pkg = ref($_[0]) or return undef;
        if ( !! UNIVERSAL::can($_[0], 'can') ) {
            bless $_[0], 'Scalar::Util::Fake';
        } else {
            $pkg = undef;
        }
        "$_[0]" =~ /0x(\w+)/;
        my $i = do { no warnings 'portable'; hex $1 };
        bless $_[0], $pkg if defined $pkg;
        $i;
    }
    END_PERL
        }
    }
    
    delete $CPAN::Meta::YAML::{refaddr};
    
    1;
    
    # XXX-INGY Doc notes I'm putting up here. Changing the doc when it's wrong
    # but leaving grey area stuff up here.
    #
    # I would like to change Read/Write to Load/Dump below without
    # changing the actual API names.
    #
    # It might be better to put Load/Dump API in the SYNOPSIS instead of the
    # dubious OO API.
    #
    # null and bool explanations may be outdated.
    
    =pod
    
    =encoding UTF-8
    
    =head1 NAME
    
    CPAN::Meta::YAML - Read and write a subset of YAML for CPAN Meta files
    
    =head1 VERSION
    
    version 0.016
    
    =head1 SYNOPSIS
    
        use CPAN::Meta::YAML;
    
        # reading a META file
        open $fh, "<:utf8", "META.yml";
        $yaml_text = do { local $/; <$fh> };
        $yaml = CPAN::Meta::YAML->read_string($yaml_text)
          or die CPAN::Meta::YAML->errstr;
    
        # finding the metadata
        $meta = $yaml->[0];
    
        # writing a META file
        $yaml_text = $yaml->write_string
          or die CPAN::Meta::YAML->errstr;
        open $fh, ">:utf8", "META.yml";
        print $fh $yaml_text;
    
    =head1 DESCRIPTION
    
    This module implements a subset of the YAML specification for use in reading
    and writing CPAN metadata files like F<META.yml> and F<MYMETA.yml>.  It should
    not be used for any other general YAML parsing or generation task.
    
    NOTE: F<META.yml> (and F<MYMETA.yml>) files should be UTF-8 encoded.  Users are
    responsible for proper encoding and decoding.  In particular, the C<read> and
    C<write> methods do B<not> support UTF-8 and should not be used.
    
    =head1 SUPPORT
    
    This module is currently derived from L<YAML::Tiny> by Adam Kennedy.  If
    there are bugs in how it parses a particular META.yml file, please file
    a bug report in the YAML::Tiny bugtracker:
    L<https://github.com/Perl-Toolchain-Gang/YAML-Tiny/issues>
    
    =head1 SEE ALSO
    
    L<YAML::Tiny>, L<YAML>, L<YAML::XS>
    
    =head1 AUTHORS
    
    =over 4
    
    =item *
    
    Adam Kennedy <adamk@cpan.org>
    
    =item *
    
    David Golden <dagolden@cpan.org>
    
    =back
    
    =head1 COPYRIGHT AND LICENSE
    
    This software is copyright (c) 2010 by Adam Kennedy.
    
    This is free software; you can redistribute it and/or modify it under
    the same terms as the Perl 5 programming language system itself.
    
    =cut
    
    __END__
    
    
    # ABSTRACT: Read and write a subset of YAML for CPAN Meta files
    
    
  CPAN_META_YAML
  
  $fatpacked{"Exporter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER';
    package Exporter;
    
    require 5.006;
    
    # Be lean.
    #use strict;
    #no strict 'refs';
    
    our $Debug = 0;
    our $ExportLevel = 0;
    our $Verbose ||= 0;
    our $VERSION = '5.70';
    our (%Cache);
    
    sub as_heavy {
      require Exporter::Heavy;
      # Unfortunately, this does not work if the caller is aliased as *name = \&foo
      # Thus the need to create a lot of identical subroutines
      my $c = (caller(1))[3];
      $c =~ s/.*:://;
      \&{"Exporter::Heavy::heavy_$c"};
    }
    
    sub export {
      goto &{as_heavy()};
    }
    
    sub import {
      my $pkg = shift;
      my $callpkg = caller($ExportLevel);
    
      if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
        *{$callpkg."::import"} = \&import;
        return;
      }
    
      # We *need* to treat @{"$pkg\::EXPORT_FAIL"} since Carp uses it :-(
      my $exports = \@{"$pkg\::EXPORT"};
      # But, avoid creating things if they don't exist, which saves a couple of
      # hundred bytes per package processed.
      my $fail = ${$pkg . '::'}{EXPORT_FAIL} && \@{"$pkg\::EXPORT_FAIL"};
      return export $pkg, $callpkg, @_
        if $Verbose or $Debug or $fail && @$fail > 1;
      my $export_cache = ($Cache{$pkg} ||= {});
      my $args = @_ or @_ = @$exports;
    
      if ($args and not %$export_cache) {
        s/^&//, $export_cache->{$_} = 1
          foreach (@$exports, @{"$pkg\::EXPORT_OK"});
      }
      my $heavy;
      # Try very hard not to use {} and hence have to  enter scope on the foreach
      # We bomb out of the loop with last as soon as heavy is set.
      if ($args or $fail) {
        ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
                   or $fail and @$fail and $_ eq $fail->[0])) and last
                     foreach (@_);
      } else {
        ($heavy = /\W/) and last
          foreach (@_);
      }
      return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
      local $SIG{__WARN__} = 
    	sub {require Carp; &Carp::carp} if not $SIG{__WARN__};
      # shortcut for the common case of no type character
      *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    }
    
    # Default methods
    
    sub export_fail {
        my $self = shift;
        @_;
    }
    
    # Unfortunately, caller(1)[3] "does not work" if the caller is aliased as
    # *name = \&foo.  Thus the need to create a lot of identical subroutines
    # Otherwise we could have aliased them to export().
    
    sub export_to_level {
      goto &{as_heavy()};
    }
    
    sub export_tags {
      goto &{as_heavy()};
    }
    
    sub export_ok_tags {
      goto &{as_heavy()};
    }
    
    sub require_version {
      goto &{as_heavy()};
    }
    
    1;
    __END__
    
    =head1 NAME
    
    Exporter - Implements default import method for modules
    
    =head1 SYNOPSIS
    
    In module F<YourModule.pm>:
    
      package YourModule;
      require Exporter;
      @ISA = qw(Exporter);
      @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request
    
    or
    
      package YourModule;
      use Exporter 'import'; # gives you Exporter's import() method directly
      @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request
    
    In other files which wish to use C<YourModule>:
    
      use YourModule qw(frobnicate);      # import listed symbols
      frobnicate ($left, $right)          # calls YourModule::frobnicate
    
    Take a look at L</Good Practices> for some variants
    you will like to use in modern Perl code.
    
    =head1 DESCRIPTION
    
    The Exporter module implements an C<import> method which allows a module
    to export functions and variables to its users' namespaces.  Many modules
    use Exporter rather than implementing their own C<import> method because
    Exporter provides a highly flexible interface, with an implementation optimised
    for the common case.
    
    Perl automatically calls the C<import> method when processing a
    C<use> statement for a module.  Modules and C<use> are documented
    in L<perlfunc> and L<perlmod>.  Understanding the concept of
    modules and how the C<use> statement operates is important to
    understanding the Exporter.
    
    =head2 How to Export
    
    The arrays C<@EXPORT> and C<@EXPORT_OK> in a module hold lists of
    symbols that are going to be exported into the users name space by
    default, or which they can request to be exported, respectively.  The
    symbols can represent functions, scalars, arrays, hashes, or typeglobs.
    The symbols must be given by full name with the exception that the
    ampersand in front of a function is optional, e.g.
    
        @EXPORT    = qw(afunc $scalar @array);   # afunc is a function
        @EXPORT_OK = qw(&bfunc %hash *typeglob); # explicit prefix on &bfunc
    
    If you are only exporting function names it is recommended to omit the
    ampersand, as the implementation is faster this way.
    
    =head2 Selecting What to Export
    
    Do B<not> export method names!
    
    Do B<not> export anything else by default without a good reason!
    
    Exports pollute the namespace of the module user.  If you must export
    try to use C<@EXPORT_OK> in preference to C<@EXPORT> and avoid short or
    common symbol names to reduce the risk of name clashes.
    
    Generally anything not exported is still accessible from outside the
    module using the C<YourModule::item_name> (or C<< $blessed_ref->method >>)
    syntax.  By convention you can use a leading underscore on names to
    informally indicate that they are 'internal' and not for public use.
    
    (It is actually possible to get private functions by saying:
    
      my $subref = sub { ... };
      $subref->(@args);            # Call it as a function
      $obj->$subref(@args);        # Use it as a method
    
    However if you use them for methods it is up to you to figure out
    how to make inheritance work.)
    
    As a general rule, if the module is trying to be object oriented
    then export nothing.  If it's just a collection of functions then
    C<@EXPORT_OK> anything but use C<@EXPORT> with caution.  For function and
    method names use barewords in preference to names prefixed with
    ampersands for the export lists.
    
    Other module design guidelines can be found in L<perlmod>.
    
    =head2 How to Import
    
    In other files which wish to use your module there are three basic ways for
    them to load your module and import its symbols:
    
    =over 4
    
    =item C<use YourModule;>
    
    This imports all the symbols from YourModule's C<@EXPORT> into the namespace
    of the C<use> statement.
    
    =item C<use YourModule ();>
    
    This causes perl to load your module but does not import any symbols.
    
    =item C<use YourModule qw(...);>
    
    This imports only the symbols listed by the caller into their namespace.
    All listed symbols must be in your C<@EXPORT> or C<@EXPORT_OK>, else an error
    occurs.  The advanced export features of Exporter are accessed like this,
    but with list entries that are syntactically distinct from symbol names.
    
    =back
    
    Unless you want to use its advanced features, this is probably all you
    need to know to use Exporter.
    
    =head1 Advanced Features
    
    =head2 Specialised Import Lists
    
    If any of the entries in an import list begins with !, : or / then
    the list is treated as a series of specifications which either add to
    or delete from the list of names to import.  They are processed left to
    right. Specifications are in the form:
    
        [!]name         This name only
        [!]:DEFAULT     All names in @EXPORT
        [!]:tag         All names in $EXPORT_TAGS{tag} anonymous list
        [!]/pattern/    All names in @EXPORT and @EXPORT_OK which match
    
    A leading ! indicates that matching names should be deleted from the
    list of names to import.  If the first specification is a deletion it
    is treated as though preceded by :DEFAULT.  If you just want to import
    extra names in addition to the default set you will still need to
    include :DEFAULT explicitly.
    
    e.g., F<Module.pm> defines:
    
        @EXPORT      = qw(A1 A2 A3 A4 A5);
        @EXPORT_OK   = qw(B1 B2 B3 B4 B5);
        %EXPORT_TAGS = (T1 => [qw(A1 A2 B1 B2)], T2 => [qw(A1 A2 B3 B4)]);
    
    Note that you cannot use tags in @EXPORT or @EXPORT_OK.
    
    Names in EXPORT_TAGS must also appear in @EXPORT or @EXPORT_OK.
    
    An application using Module can say something like:
    
        use Module qw(:DEFAULT :T2 !B3 A3);
    
    Other examples include:
    
        use Socket qw(!/^[AP]F_/ !SOMAXCONN !SOL_SOCKET);
        use POSIX  qw(:errno_h :termios_h !TCSADRAIN !/^EXIT/);
    
    Remember that most patterns (using //) will need to be anchored
    with a leading ^, e.g., C</^EXIT/> rather than C</EXIT/>.
    
    You can say C<BEGIN { $Exporter::Verbose=1 }> to see how the
    specifications are being processed and what is actually being imported
    into modules.
    
    =head2 Exporting Without Using Exporter's import Method
    
    Exporter has a special method, 'export_to_level' which is used in situations
    where you can't directly call Exporter's
    import method.  The export_to_level
    method looks like:
    
        MyPackage->export_to_level(
    	$where_to_export, $package, @what_to_export
        );
    
    where C<$where_to_export> is an integer telling how far up the calling stack
    to export your symbols, and C<@what_to_export> is an array telling what
    symbols *to* export (usually this is C<@_>).  The C<$package> argument is
    currently unused.
    
    For example, suppose that you have a module, A, which already has an
    import function:
    
        package A;
    
        @ISA = qw(Exporter);
        @EXPORT_OK = qw($b);
    
        sub import
        {
    	$A::b = 1;     # not a very useful import method
        }
    
    and you want to Export symbol C<$A::b> back to the module that called 
    package A.  Since Exporter relies on the import method to work, via 
    inheritance, as it stands Exporter::import() will never get called. 
    Instead, say the following:
    
        package A;
        @ISA = qw(Exporter);
        @EXPORT_OK = qw($b);
    
        sub import
        {
    	$A::b = 1;
    	A->export_to_level(1, @_);
        }
    
    This will export the symbols one level 'above' the current package - ie: to 
    the program or module that used package A. 
    
    Note: Be careful not to modify C<@_> at all before you call export_to_level
    - or people using your package will get very unexplained results!
    
    =head2 Exporting Without Inheriting from Exporter
    
    By including Exporter in your C<@ISA> you inherit an Exporter's import() method
    but you also inherit several other helper methods which you probably don't
    want.  To avoid this you can do:
    
      package YourModule;
      use Exporter qw(import);
    
    which will export Exporter's own import() method into YourModule.
    Everything will work as before but you won't need to include Exporter in
    C<@YourModule::ISA>.
    
    Note: This feature was introduced in version 5.57
    of Exporter, released with perl 5.8.3.
    
    =head2 Module Version Checking
    
    The Exporter module will convert an attempt to import a number from a
    module into a call to C<< $module_name->VERSION($value) >>.  This can
    be used to validate that the version of the module being used is
    greater than or equal to the required version.
    
    For historical reasons, Exporter supplies a C<require_version> method that
    simply delegates to C<VERSION>.  Originally, before C<UNIVERSAL::VERSION>
    existed, Exporter would call C<require_version>.
    
    Since the C<UNIVERSAL::VERSION> method treats the C<$VERSION> number as
    a simple numeric value it will regard version 1.10 as lower than
    1.9.  For this reason it is strongly recommended that you use numbers
    with at least two decimal places, e.g., 1.09.
    
    =head2 Managing Unknown Symbols
    
    In some situations you may want to prevent certain symbols from being
    exported.  Typically this applies to extensions which have functions
    or constants that may not exist on some systems.
    
    The names of any symbols that cannot be exported should be listed
    in the C<@EXPORT_FAIL> array.
    
    If a module attempts to import any of these symbols the Exporter
    will give the module an opportunity to handle the situation before
    generating an error.  The Exporter will call an export_fail method
    with a list of the failed symbols:
    
      @failed_symbols = $module_name->export_fail(@failed_symbols);
    
    If the C<export_fail> method returns an empty list then no error is
    recorded and all the requested symbols are exported.  If the returned
    list is not empty then an error is generated for each symbol and the
    export fails.  The Exporter provides a default C<export_fail> method which
    simply returns the list unchanged.
    
    Uses for the C<export_fail> method include giving better error messages
    for some symbols and performing lazy architectural checks (put more
    symbols into C<@EXPORT_FAIL> by default and then take them out if someone
    actually tries to use them and an expensive check shows that they are
    usable on that platform).
    
    =head2 Tag Handling Utility Functions
    
    Since the symbols listed within C<%EXPORT_TAGS> must also appear in either
    C<@EXPORT> or C<@EXPORT_OK>, two utility functions are provided which allow
    you to easily add tagged sets of symbols to C<@EXPORT> or C<@EXPORT_OK>:
    
      %EXPORT_TAGS = (foo => [qw(aa bb cc)], bar => [qw(aa cc dd)]);
    
      Exporter::export_tags('foo');     # add aa, bb and cc to @EXPORT
      Exporter::export_ok_tags('bar');  # add aa, cc and dd to @EXPORT_OK
    
    Any names which are not tags are added to C<@EXPORT> or C<@EXPORT_OK>
    unchanged but will trigger a warning (with C<-w>) to avoid misspelt tags
    names being silently added to C<@EXPORT> or C<@EXPORT_OK>.  Future versions
    may make this a fatal error.
    
    =head2 Generating Combined Tags
    
    If several symbol categories exist in C<%EXPORT_TAGS>, it's usually
    useful to create the utility ":all" to simplify "use" statements.
    
    The simplest way to do this is:
    
      %EXPORT_TAGS = (foo => [qw(aa bb cc)], bar => [qw(aa cc dd)]);
    
      # add all the other ":class" tags to the ":all" class,
      # deleting duplicates
      {
        my %seen;
    
        push @{$EXPORT_TAGS{all}},
          grep {!$seen{$_}++} @{$EXPORT_TAGS{$_}} foreach keys %EXPORT_TAGS;
      }
    
    F<CGI.pm> creates an ":all" tag which contains some (but not really
    all) of its categories.  That could be done with one small
    change:
    
      # add some of the other ":class" tags to the ":all" class,
      # deleting duplicates
      {
        my %seen;
    
        push @{$EXPORT_TAGS{all}},
          grep {!$seen{$_}++} @{$EXPORT_TAGS{$_}}
            foreach qw/html2 html3 netscape form cgi internal/;
      }
    
    Note that the tag names in C<%EXPORT_TAGS> don't have the leading ':'.
    
    =head2 C<AUTOLOAD>ed Constants
    
    Many modules make use of C<AUTOLOAD>ing for constant subroutines to
    avoid having to compile and waste memory on rarely used values (see
    L<perlsub> for details on constant subroutines).  Calls to such
    constant subroutines are not optimized away at compile time because
    they can't be checked at compile time for constancy.
    
    Even if a prototype is available at compile time, the body of the
    subroutine is not (it hasn't been C<AUTOLOAD>ed yet).  perl needs to
    examine both the C<()> prototype and the body of a subroutine at
    compile time to detect that it can safely replace calls to that
    subroutine with the constant value.
    
    A workaround for this is to call the constants once in a C<BEGIN> block:
    
       package My ;
    
       use Socket ;
    
       foo( SO_LINGER );  ## SO_LINGER NOT optimized away; called at runtime
       BEGIN { SO_LINGER }
       foo( SO_LINGER );  ## SO_LINGER optimized away at compile time.
    
    This forces the C<AUTOLOAD> for C<SO_LINGER> to take place before
    SO_LINGER is encountered later in C<My> package.
    
    If you are writing a package that C<AUTOLOAD>s, consider forcing
    an C<AUTOLOAD> for any constants explicitly imported by other packages
    or which are usually used when your package is C<use>d.
    
    =head1 Good Practices
    
    =head2 Declaring C<@EXPORT_OK> and Friends
    
    When using C<Exporter> with the standard C<strict> and C<warnings>
    pragmas, the C<our> keyword is needed to declare the package
    variables C<@EXPORT_OK>, C<@EXPORT>, C<@ISA>, etc.
    
      our @ISA = qw(Exporter);
      our @EXPORT_OK = qw(munge frobnicate);
    
    If backward compatibility for Perls under 5.6 is important,
    one must write instead a C<use vars> statement.
    
      use vars qw(@ISA @EXPORT_OK);
      @ISA = qw(Exporter);
      @EXPORT_OK = qw(munge frobnicate);
    
    =head2 Playing Safe
    
    There are some caveats with the use of runtime statements
    like C<require Exporter> and the assignment to package
    variables, which can be very subtle for the unaware programmer.
    This may happen for instance with mutually recursive
    modules, which are affected by the time the relevant
    constructions are executed.
    
    The ideal (but a bit ugly) way to never have to think
    about that is to use C<BEGIN> blocks.  So the first part
    of the L</SYNOPSIS> code could be rewritten as:
    
      package YourModule;
    
      use strict;
      use warnings;
    
      our (@ISA, @EXPORT_OK);
      BEGIN {
         require Exporter;
         @ISA = qw(Exporter);
         @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request
      }
    
    The C<BEGIN> will assure that the loading of F<Exporter.pm>
    and the assignments to C<@ISA> and C<@EXPORT_OK> happen
    immediately, leaving no room for something to get awry
    or just plain wrong.
    
    With respect to loading C<Exporter> and inheriting, there
    are alternatives with the use of modules like C<base> and C<parent>.
    
      use base qw(Exporter);
      # or
      use parent qw(Exporter);
    
    Any of these statements are nice replacements for
    C<BEGIN { require Exporter; @ISA = qw(Exporter); }>
    with the same compile-time effect.  The basic difference
    is that C<base> code interacts with declared C<fields>
    while C<parent> is a streamlined version of the older
    C<base> code to just establish the IS-A relationship.
    
    For more details, see the documentation and code of
    L<base> and L<parent>.
    
    Another thorough remedy to that runtime
    vs. compile-time trap is to use L<Exporter::Easy>,
    which is a wrapper of Exporter that allows all
    boilerplate code at a single gulp in the
    use statement.
    
       use Exporter::Easy (
           OK => [ qw(munge frobnicate) ],
       );
       # @ISA setup is automatic
       # all assignments happen at compile time
    
    =head2 What Not to Export
    
    You have been warned already in L</Selecting What to Export>
    to not export:
    
    =over 4
    
    =item *
    
    method names (because you don't need to
    and that's likely to not do what you want),
    
    =item *
    
    anything by default (because you don't want to surprise your users...
    badly)
    
    =item *
    
    anything you don't need to (because less is more)
    
    =back
    
    There's one more item to add to this list.  Do B<not>
    export variable names.  Just because C<Exporter> lets you
    do that, it does not mean you should.
    
      @EXPORT_OK = qw($svar @avar %hvar); # DON'T!
    
    Exporting variables is not a good idea.  They can
    change under the hood, provoking horrible
    effects at-a-distance that are too hard to track
    and to fix.  Trust me: they are not worth it.
    
    To provide the capability to set/get class-wide
    settings, it is best instead to provide accessors
    as subroutines or class methods instead.
    
    =head1 SEE ALSO
    
    C<Exporter> is definitely not the only module with
    symbol exporter capabilities.  At CPAN, you may find
    a bunch of them.  Some are lighter.  Some
    provide improved APIs and features.  Pick the one
    that fits your needs.  The following is
    a sample list of such modules.
    
        Exporter::Easy
        Exporter::Lite
        Exporter::Renaming
        Exporter::Tidy
        Sub::Exporter / Sub::Installer
        Perl6::Export / Perl6::Export::Attrs
    
    =head1 LICENSE
    
    This library is free software.  You can redistribute it
    and/or modify it under the same terms as Perl itself.
    
    =cut
    
    
    
  EXPORTER
  
  $fatpacked{"Exporter/Heavy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER_HEAVY';
    package Exporter::Heavy;
    
    use strict;
    no strict 'refs';
    
    # On one line so MakeMaker will see it.
    require Exporter;  our $VERSION = $Exporter::VERSION;
    
    =head1 NAME
    
    Exporter::Heavy - Exporter guts
    
    =head1 SYNOPSIS
    
    (internal use only)
    
    =head1 DESCRIPTION
    
    No user-serviceable parts inside.
    
    =cut
    
    #
    # We go to a lot of trouble not to 'require Carp' at file scope,
    #  because Carp requires Exporter, and something has to give.
    #
    
    sub _rebuild_cache {
        my ($pkg, $exports, $cache) = @_;
        s/^&// foreach @$exports;
        @{$cache}{@$exports} = (1) x @$exports;
        my $ok = \@{"${pkg}::EXPORT_OK"};
        if (@$ok) {
    	s/^&// foreach @$ok;
    	@{$cache}{@$ok} = (1) x @$ok;
        }
    }
    
    sub heavy_export {
    
        # Save the old __WARN__ handler in case it was defined
        my $oldwarn = $SIG{__WARN__};
    
        # First make import warnings look like they're coming from the "use".
        local $SIG{__WARN__} = sub {
    	# restore it back so proper stacking occurs
    	local $SIG{__WARN__} = $oldwarn;
    	my $text = shift;
    	if ($text =~ s/ at \S*Exporter\S*.pm line \d+.*\n//) {
    	    require Carp;
    	    local $Carp::CarpLevel = 1;	# ignore package calling us too.
    	    Carp::carp($text);
    	}
    	else {
    	    warn $text;
    	}
        };
        local $SIG{__DIE__} = sub {
    	require Carp;
    	local $Carp::CarpLevel = 1;	# ignore package calling us too.
    	Carp::croak("$_[0]Illegal null symbol in \@${1}::EXPORT")
    	    if $_[0] =~ /^Unable to create sub named "(.*?)::"/;
        };
    
        my($pkg, $callpkg, @imports) = @_;
        my($type, $sym, $cache_is_current, $oops);
        my($exports, $export_cache) = (\@{"${pkg}::EXPORT"},
                                       $Exporter::Cache{$pkg} ||= {});
    
        if (@imports) {
    	if (!%$export_cache) {
    	    _rebuild_cache ($pkg, $exports, $export_cache);
    	    $cache_is_current = 1;
    	}
    
    	if (grep m{^[/!:]}, @imports) {
    	    my $tagsref = \%{"${pkg}::EXPORT_TAGS"};
    	    my $tagdata;
    	    my %imports;
    	    my($remove, $spec, @names, @allexports);
    	    # negated first item implies starting with default set:
    	    unshift @imports, ':DEFAULT' if $imports[0] =~ m/^!/;
    	    foreach $spec (@imports){
    		$remove = $spec =~ s/^!//;
    
    		if ($spec =~ s/^://){
    		    if ($spec eq 'DEFAULT'){
    			@names = @$exports;
    		    }
    		    elsif ($tagdata = $tagsref->{$spec}) {
    			@names = @$tagdata;
    		    }
    		    else {
    			warn qq["$spec" is not defined in %${pkg}::EXPORT_TAGS];
    			++$oops;
    			next;
    		    }
    		}
    		elsif ($spec =~ m:^/(.*)/$:){
    		    my $patn = $1;
    		    @allexports = keys %$export_cache unless @allexports; # only do keys once
    		    @names = grep(/$patn/, @allexports); # not anchored by default
    		}
    		else {
    		    @names = ($spec); # is a normal symbol name
    		}
    
    		warn "Import ".($remove ? "del":"add").": @names "
    		    if $Exporter::Verbose;
    
    		if ($remove) {
    		   foreach $sym (@names) { delete $imports{$sym} } 
    		}
    		else {
    		    @imports{@names} = (1) x @names;
    		}
    	    }
    	    @imports = keys %imports;
    	}
    
            my @carp;
    	foreach $sym (@imports) {
    	    if (!$export_cache->{$sym}) {
    		if ($sym =~ m/^\d/) {
    		    $pkg->VERSION($sym); # inherit from UNIVERSAL
    		    # If the version number was the only thing specified
    		    # then we should act as if nothing was specified:
    		    if (@imports == 1) {
    			@imports = @$exports;
    			last;
    		    }
    		    # We need a way to emulate 'use Foo ()' but still
    		    # allow an easy version check: "use Foo 1.23, ''";
    		    if (@imports == 2 and !$imports[1]) {
    			@imports = ();
    			last;
    		    }
    		} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {
    		    # Last chance - see if they've updated EXPORT_OK since we
    		    # cached it.
    
    		    unless ($cache_is_current) {
    			%$export_cache = ();
    			_rebuild_cache ($pkg, $exports, $export_cache);
    			$cache_is_current = 1;
    		    }
    
    		    if (!$export_cache->{$sym}) {
    			# accumulate the non-exports
    			push @carp,
    			  qq["$sym" is not exported by the $pkg module\n];
    			$oops++;
    		    }
    		}
    	    }
    	}
    	if ($oops) {
    	    require Carp;
    	    Carp::croak("@{carp}Can't continue after import errors");
    	}
        }
        else {
    	@imports = @$exports;
        }
    
        my($fail, $fail_cache) = (\@{"${pkg}::EXPORT_FAIL"},
                                  $Exporter::FailCache{$pkg} ||= {});
    
        if (@$fail) {
    	if (!%$fail_cache) {
    	    # Build cache of symbols. Optimise the lookup by adding
    	    # barewords twice... both with and without a leading &.
    	    # (Technique could be applied to $export_cache at cost of memory)
    	    my @expanded = map { /^\w/ ? ($_, '&'.$_) : $_ } @$fail;
    	    warn "${pkg}::EXPORT_FAIL cached: @expanded" if $Exporter::Verbose;
    	    @{$fail_cache}{@expanded} = (1) x @expanded;
    	}
    	my @failed;
    	foreach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }
    	if (@failed) {
    	    @failed = $pkg->export_fail(@failed);
    	    foreach $sym (@failed) {
                    require Carp;
    		Carp::carp(qq["$sym" is not implemented by the $pkg module ],
    			"on this architecture");
    	    }
    	    if (@failed) {
    		require Carp;
    		Carp::croak("Can't continue after import errors");
    	    }
    	}
        }
    
        warn "Importing into $callpkg from $pkg: ",
    		join(", ",sort @imports) if $Exporter::Verbose;
    
        foreach $sym (@imports) {
    	# shortcut for the common case of no type character
    	(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    	    unless $sym =~ s/^(\W)//;
    	$type = $1;
    	no warnings 'once';
    	*{"${callpkg}::$sym"} =
    	    $type eq '&' ? \&{"${pkg}::$sym"} :
    	    $type eq '$' ? \${"${pkg}::$sym"} :
    	    $type eq '@' ? \@{"${pkg}::$sym"} :
    	    $type eq '%' ? \%{"${pkg}::$sym"} :
    	    $type eq '*' ?  *{"${pkg}::$sym"} :
    	    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
        }
    }
    
    sub heavy_export_to_level
    {
          my $pkg = shift;
          my $level = shift;
          (undef) = shift;			# XXX redundant arg
          my $callpkg = caller($level);
          $pkg->export($callpkg, @_);
    }
    
    # Utility functions
    
    sub _push_tags {
        my($pkg, $var, $syms) = @_;
        my @nontag = ();
        my $export_tags = \%{"${pkg}::EXPORT_TAGS"};
        push(@{"${pkg}::$var"},
    	map { $export_tags->{$_} ? @{$export_tags->{$_}} 
                                     : scalar(push(@nontag,$_),$_) }
    		(@$syms) ? @$syms : keys %$export_tags);
        if (@nontag and $^W) {
    	# This may change to a die one day
    	require Carp;
    	Carp::carp(join(", ", @nontag)." are not tags of $pkg");
        }
    }
    
    sub heavy_require_version {
        my($self, $wanted) = @_;
        my $pkg = ref $self || $self;
        return ${pkg}->VERSION($wanted);
    }
    
    sub heavy_export_tags {
      _push_tags((caller)[0], "EXPORT",    \@_);
    }
    
    sub heavy_export_ok_tags {
      _push_tags((caller)[0], "EXPORT_OK", \@_);
    }
    
    1;
  EXPORTER_HEAVY
  
  $fatpacked{"File/pushd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_PUSHD';
    use strict;
    use warnings;
    
    package File::pushd;
    # ABSTRACT: change directory temporarily for a limited scope
    our $VERSION = '1.009'; # VERSION
    
    our @EXPORT = qw( pushd tempd );
    our @ISA    = qw( Exporter );
    
    use Exporter;
    use Carp;
    use Cwd qw( getcwd abs_path );
    use File::Path qw( rmtree );
    use File::Temp qw();
    use File::Spec;
    
    use overload
      q{""}    => sub { File::Spec->canonpath( $_[0]->{_pushd} ) },
      fallback => 1;
    
    #--------------------------------------------------------------------------#
    # pushd()
    #--------------------------------------------------------------------------#
    
    sub pushd {
        my ( $target_dir, $options ) = @_;
        $options->{untaint_pattern} ||= qr{^([-+@\w./]+)$};
    
        $target_dir = "." unless defined $target_dir;
        croak "Can't locate directory $target_dir" unless -d $target_dir;
    
        my $tainted_orig = getcwd;
        my $orig;
        if ( $tainted_orig =~ $options->{untaint_pattern} ) {
            $orig = $1;
        }
        else {
            $orig = $tainted_orig;
        }
    
        my $tainted_dest;
        eval { $tainted_dest = $target_dir ? abs_path($target_dir) : $orig };
        croak "Can't locate absolute path for $target_dir: $@" if $@;
    
        my $dest;
        if ( $tainted_dest =~ $options->{untaint_pattern} ) {
            $dest = $1;
        }
        else {
            $dest = $tainted_dest;
        }
    
        if ( $dest ne $orig ) {
            chdir $dest or croak "Can't chdir to $dest\: $!";
        }
    
        my $self = bless {
            _pushd    => $dest,
            _original => $orig
          },
          __PACKAGE__;
    
        return $self;
    }
    
    #--------------------------------------------------------------------------#
    # tempd()
    #--------------------------------------------------------------------------#
    
    sub tempd {
        my ($options) = @_;
        my $dir;
        eval { $dir = pushd( File::Temp::tempdir( CLEANUP => 0 ), $options ) };
        croak $@ if $@;
        $dir->{_tempd} = 1;
        return $dir;
    }
    
    #--------------------------------------------------------------------------#
    # preserve()
    #--------------------------------------------------------------------------#
    
    sub preserve {
        my $self = shift;
        return 1 if !$self->{"_tempd"};
        if ( @_ == 0 ) {
            return $self->{_preserve} = 1;
        }
        else {
            return $self->{_preserve} = $_[0] ? 1 : 0;
        }
    }
    
    #--------------------------------------------------------------------------#
    # DESTROY()
    # Revert to original directory as object is destroyed and cleanup
    # if necessary
    #--------------------------------------------------------------------------#
    
    sub DESTROY {
        my ($self) = @_;
        my $orig = $self->{_original};
        chdir $orig if $orig; # should always be so, but just in case...
        if ( $self->{_tempd}
            && !$self->{_preserve} )
        {
            # don't destroy existing $@ if there is no error.
            my $err = do {
                local $@;
                eval { rmtree( $self->{_pushd} ) };
                $@;
            };
            carp $err if $err;
        }
    }
    
    1;
    
    =pod
    
    =encoding UTF-8
    
    =head1 NAME
    
    File::pushd - change directory temporarily for a limited scope
    
    =head1 VERSION
    
    version 1.009
    
    =head1 SYNOPSIS
    
     use File::pushd;
    
     chdir $ENV{HOME};
    
     # change directory again for a limited scope
     {
         my $dir = pushd( '/tmp' );
         # working directory changed to /tmp
     }
     # working directory has reverted to $ENV{HOME}
    
     # tempd() is equivalent to pushd( File::Temp::tempdir )
     {
         my $dir = tempd();
     }
    
     # object stringifies naturally as an absolute path
     {
        my $dir = pushd( '/tmp' );
        my $filename = File::Spec->catfile( $dir, "somefile.txt" );
        # gives /tmp/somefile.txt
     }
    
    =head1 DESCRIPTION
    
    File::pushd does a temporary C<chdir> that is easily and automatically
    reverted, similar to C<pushd> in some Unix command shells.  It works by
    creating an object that caches the original working directory.  When the object
    is destroyed, the destructor calls C<chdir> to revert to the original working
    directory.  By storing the object in a lexical variable with a limited scope,
    this happens automatically at the end of the scope.
    
    This is very handy when working with temporary directories for tasks like
    testing; a function is provided to streamline getting a temporary
    directory from L<File::Temp>.
    
    For convenience, the object stringifies as the canonical form of the absolute
    pathname of the directory entered.
    
    B<Warning>: if you create multiple C<pushd> objects in the same lexical scope,
    their destruction order is not guaranteed and you might not wind up in the
    directory you expect.
    
    =head1 USAGE
    
     use File::pushd;
    
    Using File::pushd automatically imports the C<pushd> and C<tempd> functions.
    
    =head2 pushd
    
     {
         my $dir = pushd( $target_directory );
     }
    
    Caches the current working directory, calls C<chdir> to change to the target
    directory, and returns a File::pushd object.  When the object is
    destroyed, the working directory reverts to the original directory.
    
    The provided target directory can be a relative or absolute path. If
    called with no arguments, it uses the current directory as its target and
    returns to the current directory when the object is destroyed.
    
    If the target directory does not exist or if the directory change fails
    for some reason, C<pushd> will die with an error message.
    
    Can be given a hashref as an optional second argument.  The only supported
    option is C<untaint_pattern>, which is used to untaint file paths involved.
    It defaults to {qr{^(L<-+@\w./>+)$}}, which is reasonably restrictive (e.g.
    it does not even allow spaces in the path).  Change this to suit your
    circumstances and security needs if running under taint mode. *Note*: you
    must include the parentheses in the pattern to capture the untainted
    portion of the path.
    
    =head2 tempd
    
     {
         my $dir = tempd();
     }
    
    This function is like C<pushd> but automatically creates and calls C<chdir> to
    a temporary directory created by L<File::Temp>. Unlike normal L<File::Temp>
    cleanup which happens at the end of the program, this temporary directory is
    removed when the object is destroyed. (But also see C<preserve>.)  A warning
    will be issued if the directory cannot be removed.
    
    As with C<pushd>, C<tempd> will die if C<chdir> fails.
    
    It may be given a single options hash that will be passed internally
    to C<pushd>.
    
    =head2 preserve
    
     {
         my $dir = tempd();
         $dir->preserve;      # mark to preserve at end of scope
         $dir->preserve(0);   # mark to delete at end of scope
     }
    
    Controls whether a temporary directory will be cleaned up when the object is
    destroyed.  With no arguments, C<preserve> sets the directory to be preserved.
    With an argument, the directory will be preserved if the argument is true, or
    marked for cleanup if the argument is false.  Only C<tempd> objects may be
    marked for cleanup.  (Target directories to C<pushd> are always preserved.)
    C<preserve> returns true if the directory will be preserved, and false
    otherwise.
    
    =head1 SEE ALSO
    
    =over 4
    
    =item *
    
    L<File::chdir>
    
    =back
    
    =for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
    
    =head1 SUPPORT
    
    =head2 Bugs / Feature Requests
    
    Please report any bugs or feature requests through the issue tracker
    at L<https://github.com/dagolden/File-pushd/issues>.
    You will be notified automatically of any progress on your issue.
    
    =head2 Source Code
    
    This is open source software.  The code repository is available for
    public review and contribution under the terms of the license.
    
    L<https://github.com/dagolden/File-pushd>
    
      git clone https://github.com/dagolden/File-pushd.git
    
    =head1 AUTHOR
    
    David Golden <dagolden@cpan.org>
    
    =head1 CONTRIBUTORS
    
    =over 4
    
    =item *
    
    Diab Jerius <djerius@cfa.harvard.edu>
    
    =item *
    
    Graham Ollis <plicease@cpan.org>
    
    =back
    
    =head1 COPYRIGHT AND LICENSE
    
    This software is Copyright (c) 2014 by David A Golden.
    
    This is free software, licensed under:
    
      The Apache License, Version 2.0, January 2004
    
    =cut
    
    __END__
    
    
    # vim: ts=4 sts=4 sw=4 et:
  FILE_PUSHD
  
  $fatpacked{"HTTP/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINY';
    # vim: ts=4 sts=4 sw=4 et:
    package HTTP::Tiny;
    use strict;
    use warnings;
    # ABSTRACT: A small, simple, correct HTTP/1.1 client
    
    our $VERSION = '0.056';
    
    use Carp ();
    
    #pod =method new
    #pod
    #pod     $http = HTTP::Tiny->new( %attributes );
    #pod
    #pod This constructor returns a new HTTP::Tiny object.  Valid attributes include:
    #pod
    #pod =for :list
    #pod * C<agent> —
    #pod     A user-agent string (defaults to 'HTTP-Tiny/$VERSION'). If C<agent> — ends in a space character, the default user-agent string is appended.
    #pod * C<cookie_jar> —
    #pod     An instance of L<HTTP::CookieJar> — or equivalent class that supports the C<add> and C<cookie_header> methods
    #pod * C<default_headers> —
    #pod     A hashref of default headers to apply to requests
    #pod * C<local_address> —
    #pod     The local IP address to bind to
    #pod * C<keep_alive> —
    #pod     Whether to reuse the last connection (if for the same scheme, host and port) (defaults to 1)
    #pod * C<max_redirect> —
    #pod     Maximum number of redirects allowed (defaults to 5)
    #pod * C<max_size> —
    #pod     Maximum response size in bytes (only when not using a data callback).  If defined, responses larger than this will return an exception.
    #pod * C<http_proxy> —
    #pod     URL of a proxy server to use for HTTP connections (default is C<$ENV{http_proxy}> — if set)
    #pod * C<https_proxy> —
    #pod     URL of a proxy server to use for HTTPS connections (default is C<$ENV{https_proxy}> — if set)
    #pod * C<proxy> —
    #pod     URL of a generic proxy server for both HTTP and HTTPS connections (default is C<$ENV{all_proxy}> — if set)
    #pod * C<no_proxy> —
    #pod     List of domain suffixes that should not be proxied.  Must be a comma-separated string or an array reference. (default is C<$ENV{no_proxy}> —)
    #pod * C<timeout> —
    #pod     Request timeout in seconds (default is 60)
    #pod * C<verify_SSL> —
    #pod     A boolean that indicates whether to validate the SSL certificate of an C<https> —
    #pod     connection (default is false)
    #pod * C<SSL_options> —
    #pod     A hashref of C<SSL_*> — options to pass through to L<IO::Socket::SSL>
    #pod
    #pod Passing an explicit C<undef> for C<proxy>, C<http_proxy> or C<https_proxy> will
    #pod prevent getting the corresponding proxies from the environment.
    #pod
    #pod Exceptions from C<max_size>, C<timeout> or other errors will result in a
    #pod pseudo-HTTP status code of 599 and a reason of "Internal Exception". The
    #pod content field in the response will contain the text of the exception.
    #pod
    #pod The C<keep_alive> parameter enables a persistent connection, but only to a
    #pod single destination scheme, host and port.  Also, if any connection-relevant
    #pod attributes are modified, or if the process ID or thread ID change, the
    #pod persistent connection will be dropped.  If you want persistent connections
    #pod across multiple destinations, use multiple HTTP::Tiny objects.
    #pod
    #pod See L</SSL SUPPORT> for more on the C<verify_SSL> and C<SSL_options> attributes.
    #pod
    #pod =cut
    
    my @attributes;
    BEGIN {
        @attributes = qw(
            cookie_jar default_headers http_proxy https_proxy keep_alive
            local_address max_redirect max_size proxy no_proxy timeout
            SSL_options verify_SSL
        );
        my %persist_ok = map {; $_ => 1 } qw(
            cookie_jar default_headers max_redirect max_size
        );
        no strict 'refs';
        no warnings 'uninitialized';
        for my $accessor ( @attributes ) {
            *{$accessor} = sub {
                @_ > 1
                    ? do {
                        delete $_[0]->{handle} if !$persist_ok{$accessor} && $_[1] ne $_[0]->{$accessor};
                        $_[0]->{$accessor} = $_[1]
                    }
                    : $_[0]->{$accessor};
            };
        }
    }
    
    sub agent {
        my($self, $agent) = @_;
        if( @_ > 1 ){
            $self->{agent} =
                (defined $agent && $agent =~ / $/) ? $agent . $self->_agent : $agent;
        }
        return $self->{agent};
    }
    
    sub new {
        my($class, %args) = @_;
    
        my $self = {
            max_redirect => 5,
            timeout      => 60,
            keep_alive   => 1,
            verify_SSL   => $args{verify_SSL} || $args{verify_ssl} || 0, # no verification by default
            no_proxy     => $ENV{no_proxy},
        };
    
        bless $self, $class;
    
        $class->_validate_cookie_jar( $args{cookie_jar} ) if $args{cookie_jar};
    
        for my $key ( @attributes ) {
            $self->{$key} = $args{$key} if exists $args{$key}
        }
    
        $self->agent( exists $args{agent} ? $args{agent} : $class->_agent );
    
        $self->_set_proxies;
    
        return $self;
    }
    
    sub _set_proxies {
        my ($self) = @_;
    
        # get proxies from %ENV only if not provided; explicit undef will disable
        # getting proxies from the environment
    
        # generic proxy
        if (! exists $self->{proxy} ) {
            $self->{proxy} = $ENV{all_proxy} || $ENV{ALL_PROXY};
        }
    
        if ( defined $self->{proxy} ) {
            $self->_split_proxy( 'generic proxy' => $self->{proxy} ); # validate
        }
        else {
            delete $self->{proxy};
        }
    
        # http proxy
        if (! exists $self->{http_proxy} ) {
            # under CGI, bypass HTTP_PROXY as request sets it from Proxy header
            local $ENV{HTTP_PROXY} if $ENV{REQUEST_METHOD};
            $self->{http_proxy} = $ENV{http_proxy} || $ENV{HTTP_PROXY} || $self->{proxy};
        }
    
        if ( defined $self->{http_proxy} ) {
            $self->_split_proxy( http_proxy => $self->{http_proxy} ); # validate
            $self->{_has_proxy}{http} = 1;
        }
        else {
            delete $self->{http_proxy};
        }
    
        # https proxy
        if (! exists $self->{https_proxy} ) {
            $self->{https_proxy} = $ENV{https_proxy} || $ENV{HTTPS_PROXY} || $self->{proxy};
        }
    
        if ( $self->{https_proxy} ) {
            $self->_split_proxy( https_proxy => $self->{https_proxy} ); # validate
            $self->{_has_proxy}{https} = 1;
        }
        else {
            delete $self->{https_proxy};
        }
    
        # Split no_proxy to array reference if not provided as such
        unless ( ref $self->{no_proxy} eq 'ARRAY' ) {
            $self->{no_proxy} =
                (defined $self->{no_proxy}) ? [ split /\s*,\s*/, $self->{no_proxy} ] : [];
        }
    
        return;
    }
    
    #pod =method get|head|put|post|delete
    #pod
    #pod     $response = $http->get($url);
    #pod     $response = $http->get($url, \%options);
    #pod     $response = $http->head($url);
    #pod
    #pod These methods are shorthand for calling C<request()> for the given method.  The
    #pod URL must have unsafe characters escaped and international domain names encoded.
    #pod See C<request()> for valid options and a description of the response.
    #pod
    #pod The C<success> field of the response will be true if the status code is 2XX.
    #pod
    #pod =cut
    
    for my $sub_name ( qw/get head put post delete/ ) {
        my $req_method = uc $sub_name;
        no strict 'refs';
        eval <<"HERE"; ## no critic
        sub $sub_name {
            my (\$self, \$url, \$args) = \@_;
            \@_ == 2 || (\@_ == 3 && ref \$args eq 'HASH')
            or Carp::croak(q/Usage: \$http->$sub_name(URL, [HASHREF])/ . "\n");
            return \$self->request('$req_method', \$url, \$args || {});
        }
    HERE
    }
    
    #pod =method post_form
    #pod
    #pod     $response = $http->post_form($url, $form_data);
    #pod     $response = $http->post_form($url, $form_data, \%options);
    #pod
    #pod This method executes a C<POST> request and sends the key/value pairs from a
    #pod form data hash or array reference to the given URL with a C<content-type> of
    #pod C<application/x-www-form-urlencoded>.  If data is provided as an array
    #pod reference, the order is preserved; if provided as a hash reference, the terms
    #pod are sorted on key and value for consistency.  See documentation for the
    #pod C<www_form_urlencode> method for details on the encoding.
    #pod
    #pod The URL must have unsafe characters escaped and international domain names
    #pod encoded.  See C<request()> for valid options and a description of the response.
    #pod Any C<content-type> header or content in the options hashref will be ignored.
    #pod
    #pod The C<success> field of the response will be true if the status code is 2XX.
    #pod
    #pod =cut
    
    sub post_form {
        my ($self, $url, $data, $args) = @_;
        (@_ == 3 || @_ == 4 && ref $args eq 'HASH')
            or Carp::croak(q/Usage: $http->post_form(URL, DATAREF, [HASHREF])/ . "\n");
    
        my $headers = {};
        while ( my ($key, $value) = each %{$args->{headers} || {}} ) {
            $headers->{lc $key} = $value;
        }
        delete $args->{headers};
    
        return $self->request('POST', $url, {
                %$args,
                content => $self->www_form_urlencode($data),
                headers => {
                    %$headers,
                    'content-type' => 'application/x-www-form-urlencoded'
                },
            }
        );
    }
    
    #pod =method mirror
    #pod
    #pod     $response = $http->mirror($url, $file, \%options)
    #pod     if ( $response->{success} ) {
    #pod         print "$file is up to date\n";
    #pod     }
    #pod
    #pod Executes a C<GET> request for the URL and saves the response body to the file
    #pod name provided.  The URL must have unsafe characters escaped and international
    #pod domain names encoded.  If the file already exists, the request will include an
    #pod C<If-Modified-Since> header with the modification timestamp of the file.  You
    #pod may specify a different C<If-Modified-Since> header yourself in the C<<
    #pod $options->{headers} >> hash.
    #pod
    #pod The C<success> field of the response will be true if the status code is 2XX
    #pod or if the status code is 304 (unmodified).
    #pod
    #pod If the file was modified and the server response includes a properly
    #pod formatted C<Last-Modified> header, the file modification time will
    #pod be updated accordingly.
    #pod
    #pod =cut
    
    sub mirror {
        my ($self, $url, $file, $args) = @_;
        @_ == 3 || (@_ == 4 && ref $args eq 'HASH')
          or Carp::croak(q/Usage: $http->mirror(URL, FILE, [HASHREF])/ . "\n");
        if ( -e $file and my $mtime = (stat($file))[9] ) {
            $args->{headers}{'if-modified-since'} ||= $self->_http_date($mtime);
        }
        my $tempfile = $file . int(rand(2**31));
    
        require Fcntl;
        sysopen my $fh, $tempfile, Fcntl::O_CREAT()|Fcntl::O_EXCL()|Fcntl::O_WRONLY()
           or Carp::croak(qq/Error: Could not create temporary file $tempfile for downloading: $!\n/);
        binmode $fh;
        $args->{data_callback} = sub { print {$fh} $_[0] };
        my $response = $self->request('GET', $url, $args);
        close $fh
            or Carp::croak(qq/Error: Caught error closing temporary file $tempfile: $!\n/);
    
        if ( $response->{success} ) {
            rename $tempfile, $file
                or Carp::croak(qq/Error replacing $file with $tempfile: $!\n/);
            my $lm = $response->{headers}{'last-modified'};
            if ( $lm and my $mtime = $self->_parse_http_date($lm) ) {
                utime $mtime, $mtime, $file;
            }
        }
        $response->{success} ||= $response->{status} eq '304';
        unlink $tempfile;
        return $response;
    }
    
    #pod =method request
    #pod
    #pod     $response = $http->request($method, $url);
    #pod     $response = $http->request($method, $url, \%options);
    #pod
    #pod Executes an HTTP request of the given method type ('GET', 'HEAD', 'POST',
    #pod 'PUT', etc.) on the given URL.  The URL must have unsafe characters escaped and
    #pod international domain names encoded.
    #pod
    #pod If the URL includes a "user:password" stanza, they will be used for Basic-style
    #pod authorization headers.  (Authorization headers will not be included in a
    #pod redirected request.) For example:
    #pod
    #pod     $http->request('GET', 'http://Aladdin:open sesame@example.com/');
    #pod
    #pod If the "user:password" stanza contains reserved characters, they must
    #pod be percent-escaped:
    #pod
    #pod     $http->request('GET', 'http://john%40example.com:password@example.com/');
    #pod
    #pod A hashref of options may be appended to modify the request.
    #pod
    #pod Valid options are:
    #pod
    #pod =for :list
    #pod * C<headers> —
    #pod     A hashref containing headers to include with the request.  If the value for
    #pod     a header is an array reference, the header will be output multiple times with
    #pod     each value in the array.  These headers over-write any default headers.
    #pod * C<content> —
    #pod     A scalar to include as the body of the request OR a code reference
    #pod     that will be called iteratively to produce the body of the request
    #pod * C<trailer_callback> —
    #pod     A code reference that will be called if it exists to provide a hashref
    #pod     of trailing headers (only used with chunked transfer-encoding)
    #pod * C<data_callback> —
    #pod     A code reference that will be called for each chunks of the response
    #pod     body received.
    #pod
    #pod The C<Host> header is generated from the URL in accordance with RFC 2616.  It
    #pod is a fatal error to specify C<Host> in the C<headers> option.  Other headers
    #pod may be ignored or overwritten if necessary for transport compliance.
    #pod
    #pod If the C<content> option is a code reference, it will be called iteratively
    #pod to provide the content body of the request.  It should return the empty
    #pod string or undef when the iterator is exhausted.
    #pod
    #pod If the C<content> option is the empty string, no C<content-type> or
    #pod C<content-length> headers will be generated.
    #pod
    #pod If the C<data_callback> option is provided, it will be called iteratively until
    #pod the entire response body is received.  The first argument will be a string
    #pod containing a chunk of the response body, the second argument will be the
    #pod in-progress response hash reference, as described below.  (This allows
    #pod customizing the action of the callback based on the C<status> or C<headers>
    #pod received prior to the content body.)
    #pod
    #pod The C<request> method returns a hashref containing the response.  The hashref
    #pod will have the following keys:
    #pod
    #pod =for :list
    #pod * C<success> —
    #pod     Boolean indicating whether the operation returned a 2XX status code
    #pod * C<url> —
    #pod     URL that provided the response. This is the URL of the request unless
    #pod     there were redirections, in which case it is the last URL queried
    #pod     in a redirection chain
    #pod * C<status> —
    #pod     The HTTP status code of the response
    #pod * C<reason> —
    #pod     The response phrase returned by the server
    #pod * C<content> —
    #pod     The body of the response.  If the response does not have any content
    #pod     or if a data callback is provided to consume the response body,
    #pod     this will be the empty string
    #pod * C<headers> —
    #pod     A hashref of header fields.  All header field names will be normalized
    #pod     to be lower case. If a header is repeated, the value will be an arrayref;
    #pod     it will otherwise be a scalar string containing the value
    #pod
    #pod On an exception during the execution of the request, the C<status> field will
    #pod contain 599, and the C<content> field will contain the text of the exception.
    #pod
    #pod =cut
    
    my %idempotent = map { $_ => 1 } qw/GET HEAD PUT DELETE OPTIONS TRACE/;
    
    sub request {
        my ($self, $method, $url, $args) = @_;
        @_ == 3 || (@_ == 4 && ref $args eq 'HASH')
          or Carp::croak(q/Usage: $http->request(METHOD, URL, [HASHREF])/ . "\n");
        $args ||= {}; # we keep some state in this during _request
    
        # RFC 2616 Section 8.1.4 mandates a single retry on broken socket
        my $response;
        for ( 0 .. 1 ) {
            $response = eval { $self->_request($method, $url, $args) };
            last unless $@ && $idempotent{$method}
                && $@ =~ m{^(?:Socket closed|Unexpected end)};
        }
    
        if (my $e = $@) {
            # maybe we got a response hash thrown from somewhere deep
            if ( ref $e eq 'HASH' && exists $e->{status} ) {
                return $e;
            }
    
            # otherwise, stringify it
            $e = "$e";
            $response = {
                url     => $url,
                success => q{},
                status  => 599,
                reason  => 'Internal Exception',
                content => $e,
                headers => {
                    'content-type'   => 'text/plain',
                    'content-length' => length $e,
                }
            };
        }
        return $response;
    }
    
    #pod =method www_form_urlencode
    #pod
    #pod     $params = $http->www_form_urlencode( $data );
    #pod     $response = $http->get("http://example.com/query?$params");
    #pod
    #pod This method converts the key/value pairs from a data hash or array reference
    #pod into a C<x-www-form-urlencoded> string.  The keys and values from the data
    #pod reference will be UTF-8 encoded and escaped per RFC 3986.  If a value is an
    #pod array reference, the key will be repeated with each of the values of the array
    #pod reference.  If data is provided as a hash reference, the key/value pairs in the
    #pod resulting string will be sorted by key and value for consistent ordering.
    #pod
    #pod =cut
    
    sub www_form_urlencode {
        my ($self, $data) = @_;
        (@_ == 2 && ref $data)
            or Carp::croak(q/Usage: $http->www_form_urlencode(DATAREF)/ . "\n");
        (ref $data eq 'HASH' || ref $data eq 'ARRAY')
            or Carp::croak("form data must be a hash or array reference\n");
    
        my @params = ref $data eq 'HASH' ? %$data : @$data;
        @params % 2 == 0
            or Carp::croak("form data reference must have an even number of terms\n");
    
        my @terms;
        while( @params ) {
            my ($key, $value) = splice(@params, 0, 2);
            if ( ref $value eq 'ARRAY' ) {
                unshift @params, map { $key => $_ } @$value;
            }
            else {
                push @terms, join("=", map { $self->_uri_escape($_) } $key, $value);
            }
        }
    
        return join("&", (ref $data eq 'ARRAY') ? (@terms) : (sort @terms) );
    }
    
    #pod =method can_ssl
    #pod
    #pod     $ok         = HTTP::Tiny->can_ssl;
    #pod     ($ok, $why) = HTTP::Tiny->can_ssl;
    #pod     ($ok, $why) = $http->can_ssl;
    #pod
    #pod Indicates if SSL support is available.  When called as a class object, it
    #pod checks for the correct version of L<Net::SSLeay> and L<IO::Socket::SSL>.
    #pod When called as an object methods, if C<SSL_verify> is true or if C<SSL_verify_mode>
    #pod is set in C<SSL_options>, it checks that a CA file is available.
    #pod
    #pod In scalar context, returns a boolean indicating if SSL is available.
    #pod In list context, returns the boolean and a (possibly multi-line) string of
    #pod errors indicating why SSL isn't available.
    #pod
    #pod =cut
    
    sub can_ssl {
        my ($self) = @_;
    
        my($ok, $reason) = (1, '');
    
        # Need IO::Socket::SSL 1.42 for SSL_create_ctx_callback
        unless (eval {require IO::Socket::SSL; IO::Socket::SSL->VERSION(1.42)}) {
            $ok = 0;
            $reason .= qq/IO::Socket::SSL 1.42 must be installed for https support\n/;
        }
    
        # Need Net::SSLeay 1.49 for MODE_AUTO_RETRY
        unless (eval {require Net::SSLeay; Net::SSLeay->VERSION(1.49)}) {
            $ok = 0;
            $reason .= qq/Net::SSLeay 1.49 must be installed for https support\n/;
        }
    
        # If an object, check that SSL config lets us get a CA if necessary
        if ( ref($self) && ( $self->{verify_SSL} || $self->{SSL_options}{SSL_verify_mode} ) ) {
            my $handle = HTTP::Tiny::Handle->new(
                SSL_options => $self->{SSL_options},
                verify_SSL  => $self->{verify_SSL},
            );
            unless ( eval { $handle->_find_CA_file; 1 } ) {
                $ok = 0;
                $reason .= "$@";
            }
        }
    
        wantarray ? ($ok, $reason) : $ok;
    }
    
    #--------------------------------------------------------------------------#
    # private methods
    #--------------------------------------------------------------------------#
    
    my %DefaultPort = (
        http => 80,
        https => 443,
    );
    
    sub _agent {
        my $class = ref($_[0]) || $_[0];
        (my $default_agent = $class) =~ s{::}{-}g;
        return $default_agent . "/" . $class->VERSION;
    }
    
    sub _request {
        my ($self, $method, $url, $args) = @_;
    
        my ($scheme, $host, $port, $path_query, $auth) = $self->_split_url($url);
    
        my $request = {
            method    => $method,
            scheme    => $scheme,
            host      => $host,
            port      => $port,
            host_port => ($port == $DefaultPort{$scheme} ? $host : "$host:$port"),
            uri       => $path_query,
            headers   => {},
        };
    
        # We remove the cached handle so it is not reused in the case of redirect.
        # If all is well, it will be recached at the end of _request.  We only
        # reuse for the same scheme, host and port
        my $handle = delete $self->{handle};
        if ( $handle ) {
            unless ( $handle->can_reuse( $scheme, $host, $port ) ) {
                $handle->close;
                undef $handle;
            }
        }
        $handle ||= $self->_open_handle( $request, $scheme, $host, $port );
    
        $self->_prepare_headers_and_cb($request, $args, $url, $auth);
        $handle->write_request($request);
    
        my $response;
        do { $response = $handle->read_response_header }
            until (substr($response->{status},0,1) ne '1');
    
        $self->_update_cookie_jar( $url, $response ) if $self->{cookie_jar};
    
        if ( my @redir_args = $self->_maybe_redirect($request, $response, $args) ) {
            $handle->close;
            return $self->_request(@redir_args, $args);
        }
    
        my $known_message_length;
        if ($method eq 'HEAD' || $response->{status} =~ /^[23]04/) {
            # response has no message body
            $known_message_length = 1;
        }
        else {
            my $data_cb = $self->_prepare_data_cb($response, $args);
            $known_message_length = $handle->read_body($data_cb, $response);
        }
    
        if ( $self->{keep_alive}
            && $known_message_length
            && $response->{protocol} eq 'HTTP/1.1'
            && ($response->{headers}{connection} || '') ne 'close'
        ) {
            $self->{handle} = $handle;
        }
        else {
            $handle->close;
        }
    
        $response->{success} = substr( $response->{status}, 0, 1 ) eq '2';
        $response->{url} = $url;
        return $response;
    }
    
    sub _open_handle {
        my ($self, $request, $scheme, $host, $port) = @_;
    
        my $handle  = HTTP::Tiny::Handle->new(
            timeout         => $self->{timeout},
            SSL_options     => $self->{SSL_options},
            verify_SSL      => $self->{verify_SSL},
            local_address   => $self->{local_address},
            keep_alive      => $self->{keep_alive}
        );
    
        if ($self->{_has_proxy}{$scheme} && ! grep { $host =~ /\Q$_\E$/ } @{$self->{no_proxy}}) {
            return $self->_proxy_connect( $request, $handle );
        }
        else {
            return $handle->connect($scheme, $host, $port);
        }
    }
    
    sub _proxy_connect {
        my ($self, $request, $handle) = @_;
    
        my @proxy_vars;
        if ( $request->{scheme} eq 'https' ) {
            Carp::croak(qq{No https_proxy defined}) unless $self->{https_proxy};
            @proxy_vars = $self->_split_proxy( https_proxy => $self->{https_proxy} );
            if ( $proxy_vars[0] eq 'https' ) {
                Carp::croak(qq{Can't proxy https over https: $request->{uri} via $self->{https_proxy}});
            }
        }
        else {
            Carp::croak(qq{No http_proxy defined}) unless $self->{http_proxy};
            @proxy_vars = $self->_split_proxy( http_proxy => $self->{http_proxy} );
        }
    
        my ($p_scheme, $p_host, $p_port, $p_auth) = @proxy_vars;
    
        if ( length $p_auth && ! defined $request->{headers}{'proxy-authorization'} ) {
            $self->_add_basic_auth_header( $request, 'proxy-authorization' => $p_auth );
        }
    
        $handle->connect($p_scheme, $p_host, $p_port);
    
        if ($request->{scheme} eq 'https') {
            $self->_create_proxy_tunnel( $request, $handle );
        }
        else {
            # non-tunneled proxy requires absolute URI
            $request->{uri} = "$request->{scheme}://$request->{host_port}$request->{uri}";
        }
    
        return $handle;
    }
    
    sub _split_proxy {
        my ($self, $type, $proxy) = @_;
    
        my ($scheme, $host, $port, $path_query, $auth) = eval { $self->_split_url($proxy) };
    
        unless(
            defined($scheme) && length($scheme) && length($host) && length($port)
            && $path_query eq '/'
        ) {
            Carp::croak(qq{$type URL must be in format http[s]://[auth@]<host>:<port>/\n});
        }
    
        return ($scheme, $host, $port, $auth);
    }
    
    sub _create_proxy_tunnel {
        my ($self, $request, $handle) = @_;
    
        $handle->_assert_ssl;
    
        my $agent = exists($request->{headers}{'user-agent'})
            ? $request->{headers}{'user-agent'} : $self->{agent};
    
        my $connect_request = {
            method    => 'CONNECT',
            uri       => "$request->{host}:$request->{port}",
            headers   => {
                host => "$request->{host}:$request->{port}",
                'user-agent' => $agent,
            }
        };
    
        if ( $request->{headers}{'proxy-authorization'} ) {
            $connect_request->{headers}{'proxy-authorization'} =
                delete $request->{headers}{'proxy-authorization'};
        }
    
        $handle->write_request($connect_request);
        my $response;
        do { $response = $handle->read_response_header }
            until (substr($response->{status},0,1) ne '1');
    
        # if CONNECT failed, throw the response so it will be
        # returned from the original request() method;
        unless (substr($response->{status},0,1) eq '2') {
            die $response;
        }
    
        # tunnel established, so start SSL handshake
        $handle->start_ssl( $request->{host} );
    
        return;
    }
    
    sub _prepare_headers_and_cb {
        my ($self, $request, $args, $url, $auth) = @_;
    
        for ($self->{default_headers}, $args->{headers}) {
            next unless defined;
            while (my ($k, $v) = each %$_) {
                $request->{headers}{lc $k} = $v;
            }
        }
    
        if (exists $request->{headers}{'host'}) {
            die(qq/The 'Host' header must not be provided as header option\n/);
        }
    
        $request->{headers}{'host'}         = $request->{host_port};
        $request->{headers}{'user-agent'} ||= $self->{agent};
        $request->{headers}{'connection'}   = "close"
            unless $self->{keep_alive};
    
        if ( defined $args->{content} ) {
            if (ref $args->{content} eq 'CODE') {
                $request->{headers}{'content-type'} ||= "application/octet-stream";
                $request->{headers}{'transfer-encoding'} = 'chunked'
                  unless $request->{headers}{'content-length'}
                      || $request->{headers}{'transfer-encoding'};
                $request->{cb} = $args->{content};
            }
            elsif ( length $args->{content} ) {
                my $content = $args->{content};
                if ( $] ge '5.008' ) {
                    utf8::downgrade($content, 1)
                        or die(qq/Wide character in request message body\n/);
                }
                $request->{headers}{'content-type'} ||= "application/octet-stream";
                $request->{headers}{'content-length'} = length $content
                  unless $request->{headers}{'content-length'}
                      || $request->{headers}{'transfer-encoding'};
                $request->{cb} = sub { substr $content, 0, length $content, '' };
            }
            $request->{trailer_cb} = $args->{trailer_callback}
                if ref $args->{trailer_callback} eq 'CODE';
        }
    
        ### If we have a cookie jar, then maybe add relevant cookies
        if ( $self->{cookie_jar} ) {
            my $cookies = $self->cookie_jar->cookie_header( $url );
            $request->{headers}{cookie} = $cookies if length $cookies;
        }
    
        # if we have Basic auth parameters, add them
        if ( length $auth && ! defined $request->{headers}{authorization} ) {
            $self->_add_basic_auth_header( $request, 'authorization' => $auth );
        }
    
        return;
    }
    
    sub _add_basic_auth_header {
        my ($self, $request, $header, $auth) = @_;
        require MIME::Base64;
        $request->{headers}{$header} =
            "Basic " . MIME::Base64::encode_base64($auth, "");
        return;
    }
    
    sub _prepare_data_cb {
        my ($self, $response, $args) = @_;
        my $data_cb = $args->{data_callback};
        $response->{content} = '';
    
        if (!$data_cb || $response->{status} !~ /^2/) {
            if (defined $self->{max_size}) {
                $data_cb = sub {
                    $_[1]->{content} .= $_[0];
                    die(qq/Size of response body exceeds the maximum allowed of $self->{max_size}\n/)
                      if length $_[1]->{content} > $self->{max_size};
                };
            }
            else {
                $data_cb = sub { $_[1]->{content} .= $_[0] };
            }
        }
        return $data_cb;
    }
    
    sub _update_cookie_jar {
        my ($self, $url, $response) = @_;
    
        my $cookies = $response->{headers}->{'set-cookie'};
        return unless defined $cookies;
    
        my @cookies = ref $cookies ? @$cookies : $cookies;
    
        $self->cookie_jar->add( $url, $_ ) for @cookies;
    
        return;
    }
    
    sub _validate_cookie_jar {
        my ($class, $jar) = @_;
    
        # duck typing
        for my $method ( qw/add cookie_header/ ) {
            Carp::croak(qq/Cookie jar must provide the '$method' method\n/)
                unless ref($jar) && ref($jar)->can($method);
        }
    
        return;
    }
    
    sub _maybe_redirect {
        my ($self, $request, $response, $args) = @_;
        my $headers = $response->{headers};
        my ($status, $method) = ($response->{status}, $request->{method});
        if (($status eq '303' or ($status =~ /^30[1278]/ && $method =~ /^GET|HEAD$/))
            and $headers->{location}
            and ++$args->{redirects} <= $self->{max_redirect}
        ) {
            my $location = ($headers->{location} =~ /^\//)
                ? "$request->{scheme}://$request->{host_port}$headers->{location}"
                : $headers->{location} ;
            return (($status eq '303' ? 'GET' : $method), $location);
        }
        return;
    }
    
    sub _split_url {
        my $url = pop;
    
        # URI regex adapted from the URI module
        my ($scheme, $host, $path_query) = $url =~ m<\A([^:/?#]+)://([^/?#]*)([^#]*)>
          or die(qq/Cannot parse URL: '$url'\n/);
    
        $scheme     = lc $scheme;
        $path_query = "/$path_query" unless $path_query =~ m<\A/>;
    
        my $auth = '';
        if ( (my $i = index $host, '@') != -1 ) {
            # user:pass@host
            $auth = substr $host, 0, $i, ''; # take up to the @ for auth
            substr $host, 0, 1, '';          # knock the @ off the host
    
            # userinfo might be percent escaped, so recover real auth info
            $auth =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
        }
        my $port = $host =~ s/:(\d*)\z// && length $1 ? $1
                 : $scheme eq 'http'                  ? 80
                 : $scheme eq 'https'                 ? 443
                 : undef;
    
        return ($scheme, (length $host ? lc $host : "localhost") , $port, $path_query, $auth);
    }
    
    # Date conversions adapted from HTTP::Date
    my $DoW = "Sun|Mon|Tue|Wed|Thu|Fri|Sat";
    my $MoY = "Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec";
    sub _http_date {
        my ($sec, $min, $hour, $mday, $mon, $year, $wday) = gmtime($_[1]);
        return sprintf("%s, %02d %s %04d %02d:%02d:%02d GMT",
            substr($DoW,$wday*4,3),
            $mday, substr($MoY,$mon*4,3), $year+1900,
            $hour, $min, $sec
        );
    }
    
    sub _parse_http_date {
        my ($self, $str) = @_;
        require Time::Local;
        my @tl_parts;
        if ($str =~ /^[SMTWF][a-z]+, +(\d{1,2}) ($MoY) +(\d\d\d\d) +(\d\d):(\d\d):(\d\d) +GMT$/) {
            @tl_parts = ($6, $5, $4, $1, (index($MoY,$2)/4), $3);
        }
        elsif ($str =~ /^[SMTWF][a-z]+, +(\d\d)-($MoY)-(\d{2,4}) +(\d\d):(\d\d):(\d\d) +GMT$/ ) {
            @tl_parts = ($6, $5, $4, $1, (index($MoY,$2)/4), $3);
        }
        elsif ($str =~ /^[SMTWF][a-z]+ +($MoY) +(\d{1,2}) +(\d\d):(\d\d):(\d\d) +(?:[^0-9]+ +)?(\d\d\d\d)$/ ) {
            @tl_parts = ($5, $4, $3, $2, (index($MoY,$1)/4), $6);
        }
        return eval {
            my $t = @tl_parts ? Time::Local::timegm(@tl_parts) : -1;
            $t < 0 ? undef : $t;
        };
    }
    
    # URI escaping adapted from URI::Escape
    # c.f. http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.1
    # perl 5.6 ready UTF-8 encoding adapted from JSON::PP
    my %escapes = map { chr($_) => sprintf("%%%02X", $_) } 0..255;
    $escapes{' '}="+";
    my $unsafe_char = qr/[^A-Za-z0-9\-\._~]/;
    
    sub _uri_escape {
        my ($self, $str) = @_;
        if ( $] ge '5.008' ) {
            utf8::encode($str);
        }
        else {
            $str = pack("U*", unpack("C*", $str)) # UTF-8 encode a byte string
                if ( length $str == do { use bytes; length $str } );
            $str = pack("C*", unpack("C*", $str)); # clear UTF-8 flag
        }
        $str =~ s/($unsafe_char)/$escapes{$1}/ge;
        return $str;
    }
    
    package
        HTTP::Tiny::Handle; # hide from PAUSE/indexers
    use strict;
    use warnings;
    
    use Errno      qw[EINTR EPIPE];
    use IO::Socket qw[SOCK_STREAM];
    
    # PERL_HTTP_TINY_IPV4_ONLY is a private environment variable to force old
    # behavior if someone is unable to boostrap CPAN from a new perl install; it is
    # not intended for general, per-client use and may be removed in the future
    my $SOCKET_CLASS =
        $ENV{PERL_HTTP_TINY_IPV4_ONLY} ? 'IO::Socket::INET' :
        eval { require IO::Socket::IP; IO::Socket::IP->VERSION(0.25) } ? 'IO::Socket::IP' :
        'IO::Socket::INET';
    
    sub BUFSIZE () { 32768 } ## no critic
    
    my $Printable = sub {
        local $_ = shift;
        s/\r/\\r/g;
        s/\n/\\n/g;
        s/\t/\\t/g;
        s/([^\x20-\x7E])/sprintf('\\x%.2X', ord($1))/ge;
        $_;
    };
    
    my $Token = qr/[\x21\x23-\x27\x2A\x2B\x2D\x2E\x30-\x39\x41-\x5A\x5E-\x7A\x7C\x7E]/;
    
    sub new {
        my ($class, %args) = @_;
        return bless {
            rbuf             => '',
            timeout          => 60,
            max_line_size    => 16384,
            max_header_lines => 64,
            verify_SSL       => 0,
            SSL_options      => {},
            %args
        }, $class;
    }
    
    sub connect {
        @_ == 4 || die(q/Usage: $handle->connect(scheme, host, port)/ . "\n");
        my ($self, $scheme, $host, $port) = @_;
    
        if ( $scheme eq 'https' ) {
            $self->_assert_ssl;
        }
        elsif ( $scheme ne 'http' ) {
          die(qq/Unsupported URL scheme '$scheme'\n/);
        }
        $self->{fh} = $SOCKET_CLASS->new(
            PeerHost  => $host,
            PeerPort  => $port,
            $self->{local_address} ?
                ( LocalAddr => $self->{local_address} ) : (),
            Proto     => 'tcp',
            Type      => SOCK_STREAM,
            Timeout   => $self->{timeout},
            KeepAlive => !!$self->{keep_alive}
        ) or die(qq/Could not connect to '$host:$port': $@\n/);
    
        binmode($self->{fh})
          or die(qq/Could not binmode() socket: '$!'\n/);
    
        $self->start_ssl($host) if $scheme eq 'https';
    
        $self->{scheme} = $scheme;
        $self->{host} = $host;
        $self->{port} = $port;
        $self->{pid} = $$;
        $self->{tid} = _get_tid();
    
        return $self;
    }
    
    sub start_ssl {
        my ($self, $host) = @_;
    
        # As this might be used via CONNECT after an SSL session
        # to a proxy, we shut down any existing SSL before attempting
        # the handshake
        if ( ref($self->{fh}) eq 'IO::Socket::SSL' ) {
            unless ( $self->{fh}->stop_SSL ) {
                my $ssl_err = IO::Socket::SSL->errstr;
                die(qq/Error halting prior SSL connection: $ssl_err/);
            }
        }
    
        my $ssl_args = $self->_ssl_args($host);
        IO::Socket::SSL->start_SSL(
            $self->{fh},
            %$ssl_args,
            SSL_create_ctx_callback => sub {
                my $ctx = shift;
                Net::SSLeay::CTX_set_mode($ctx, Net::SSLeay::MODE_AUTO_RETRY());
            },
        );
    
        unless ( ref($self->{fh}) eq 'IO::Socket::SSL' ) {
            my $ssl_err = IO::Socket::SSL->errstr;
            die(qq/SSL connection failed for $host: $ssl_err\n/);
        }
    }
    
    sub close {
        @_ == 1 || die(q/Usage: $handle->close()/ . "\n");
        my ($self) = @_;
        CORE::close($self->{fh})
          or die(qq/Could not close socket: '$!'\n/);
    }
    
    sub write {
        @_ == 2 || die(q/Usage: $handle->write(buf)/ . "\n");
        my ($self, $buf) = @_;
    
        if ( $] ge '5.008' ) {
            utf8::downgrade($buf, 1)
                or die(qq/Wide character in write()\n/);
        }
    
        my $len = length $buf;
        my $off = 0;
    
        local $SIG{PIPE} = 'IGNORE';
    
        while () {
            $self->can_write
              or die(qq/Timed out while waiting for socket to become ready for writing\n/);
            my $r = syswrite($self->{fh}, $buf, $len, $off);
            if (defined $r) {
                $len -= $r;
                $off += $r;
                last unless $len > 0;
            }
            elsif ($! == EPIPE) {
                die(qq/Socket closed by remote server: $!\n/);
            }
            elsif ($! != EINTR) {
                if ($self->{fh}->can('errstr')){
                    my $err = $self->{fh}->errstr();
                    die (qq/Could not write to SSL socket: '$err'\n /);
                }
                else {
                    die(qq/Could not write to socket: '$!'\n/);
                }
    
            }
        }
        return $off;
    }
    
    sub read {
        @_ == 2 || @_ == 3 || die(q/Usage: $handle->read(len [, allow_partial])/ . "\n");
        my ($self, $len, $allow_partial) = @_;
    
        my $buf  = '';
        my $got = length $self->{rbuf};
    
        if ($got) {
            my $take = ($got < $len) ? $got : $len;
            $buf  = substr($self->{rbuf}, 0, $take, '');
            $len -= $take;
        }
    
        while ($len > 0) {
            $self->can_read
              or die(q/Timed out while waiting for socket to become ready for reading/ . "\n");
            my $r = sysread($self->{fh}, $buf, $len, length $buf);
            if (defined $r) {
                last unless $r;
                $len -= $r;
            }
            elsif ($! != EINTR) {
                if ($self->{fh}->can('errstr')){
                    my $err = $self->{fh}->errstr();
                    die (qq/Could not read from SSL socket: '$err'\n /);
                }
                else {
                    die(qq/Could not read from socket: '$!'\n/);
                }
            }
        }
        if ($len && !$allow_partial) {
            die(qq/Unexpected end of stream\n/);
        }
        return $buf;
    }
    
    sub readline {
        @_ == 1 || die(q/Usage: $handle->readline()/ . "\n");
        my ($self) = @_;
    
        while () {
            if ($self->{rbuf} =~ s/\A ([^\x0D\x0A]* \x0D?\x0A)//x) {
                return $1;
            }
            if (length $self->{rbuf} >= $self->{max_line_size}) {
                die(qq/Line size exceeds the maximum allowed size of $self->{max_line_size}\n/);
            }
            $self->can_read
              or die(qq/Timed out while waiting for socket to become ready for reading\n/);
            my $r = sysread($self->{fh}, $self->{rbuf}, BUFSIZE, length $self->{rbuf});
            if (defined $r) {
                last unless $r;
            }
            elsif ($! != EINTR) {
                if ($self->{fh}->can('errstr')){
                    my $err = $self->{fh}->errstr();
                    die (qq/Could not read from SSL socket: '$err'\n /);
                }
                else {
                    die(qq/Could not read from socket: '$!'\n/);
                }
            }
        }
        die(qq/Unexpected end of stream while looking for line\n/);
    }
    
    sub read_header_lines {
        @_ == 1 || @_ == 2 || die(q/Usage: $handle->read_header_lines([headers])/ . "\n");
        my ($self, $headers) = @_;
        $headers ||= {};
        my $lines   = 0;
        my $val;
    
        while () {
             my $line = $self->readline;
    
             if (++$lines >= $self->{max_header_lines}) {
                 die(qq/Header lines exceeds maximum number allowed of $self->{max_header_lines}\n/);
             }
             elsif ($line =~ /\A ([^\x00-\x1F\x7F:]+) : [\x09\x20]* ([^\x0D\x0A]*)/x) {
                 my ($field_name) = lc $1;
                 if (exists $headers->{$field_name}) {
                     for ($headers->{$field_name}) {
                         $_ = [$_] unless ref $_ eq "ARRAY";
                         push @$_, $2;
                         $val = \$_->[-1];
                     }
                 }
                 else {
                     $val = \($headers->{$field_name} = $2);
                 }
             }
             elsif ($line =~ /\A [\x09\x20]+ ([^\x0D\x0A]*)/x) {
                 $val
                   or die(qq/Unexpected header continuation line\n/);
                 next unless length $1;
                 $$val .= ' ' if length $$val;
                 $$val .= $1;
             }
             elsif ($line =~ /\A \x0D?\x0A \z/x) {
                last;
             }
             else {
                die(q/Malformed header line: / . $Printable->($line) . "\n");
             }
        }
        return $headers;
    }
    
    sub write_request {
        @_ == 2 || die(q/Usage: $handle->write_request(request)/ . "\n");
        my($self, $request) = @_;
        $self->write_request_header(@{$request}{qw/method uri headers/});
        $self->write_body($request) if $request->{cb};
        return;
    }
    
    my %HeaderCase = (
        'content-md5'      => 'Content-MD5',
        'etag'             => 'ETag',
        'te'               => 'TE',
        'www-authenticate' => 'WWW-Authenticate',
        'x-xss-protection' => 'X-XSS-Protection',
    );
    
    # to avoid multiple small writes and hence nagle, you can pass the method line or anything else to
    # combine writes.
    sub write_header_lines {
        (@_ == 2 || @_ == 3 && ref $_[1] eq 'HASH') || die(q/Usage: $handle->write_header_lines(headers[,prefix])/ . "\n");
        my($self, $headers, $prefix_data) = @_;
    
        my $buf = (defined $prefix_data ? $prefix_data : '');
        while (my ($k, $v) = each %$headers) {
            my $field_name = lc $k;
            if (exists $HeaderCase{$field_name}) {
                $field_name = $HeaderCase{$field_name};
            }
            else {
                $field_name =~ /\A $Token+ \z/xo
                  or die(q/Invalid HTTP header field name: / . $Printable->($field_name) . "\n");
                $field_name =~ s/\b(\w)/\u$1/g;
                $HeaderCase{lc $field_name} = $field_name;
            }
            for (ref $v eq 'ARRAY' ? @$v : $v) {
                $_ = '' unless defined $_;
                $buf .= "$field_name: $_\x0D\x0A";
            }
        }
        $buf .= "\x0D\x0A";
        return $self->write($buf);
    }
    
    # return value indicates whether message length was defined; this is generally
    # true unless there was no content-length header and we just read until EOF.
    # Other message length errors are thrown as exceptions
    sub read_body {
        @_ == 3 || die(q/Usage: $handle->read_body(callback, response)/ . "\n");
        my ($self, $cb, $response) = @_;
        my $te = $response->{headers}{'transfer-encoding'} || '';
        my $chunked = grep { /chunked/i } ( ref $te eq 'ARRAY' ? @$te : $te ) ;
        return $chunked
            ? $self->read_chunked_body($cb, $response)
            : $self->read_content_body($cb, $response);
    }
    
    sub write_body {
        @_ == 2 || die(q/Usage: $handle->write_body(request)/ . "\n");
        my ($self, $request) = @_;
        if ($request->{headers}{'content-length'}) {
            return $self->write_content_body($request);
        }
        else {
            return $self->write_chunked_body($request);
        }
    }
    
    sub read_content_body {
        @_ == 3 || @_ == 4 || die(q/Usage: $handle->read_content_body(callback, response, [read_length])/ . "\n");
        my ($self, $cb, $response, $content_length) = @_;
        $content_length ||= $response->{headers}{'content-length'};
    
        if ( defined $content_length ) {
            my $len = $content_length;
            while ($len > 0) {
                my $read = ($len > BUFSIZE) ? BUFSIZE : $len;
                $cb->($self->read($read, 0), $response);
                $len -= $read;
            }
            return length($self->{rbuf}) == 0;
        }
    
        my $chunk;
        $cb->($chunk, $response) while length( $chunk = $self->read(BUFSIZE, 1) );
    
        return;
    }
    
    sub write_content_body {
        @_ == 2 || die(q/Usage: $handle->write_content_body(request)/ . "\n");
        my ($self, $request) = @_;
    
        my ($len, $content_length) = (0, $request->{headers}{'content-length'});
        while () {
            my $data = $request->{cb}->();
    
            defined $data && length $data
              or last;
    
            if ( $] ge '5.008' ) {
                utf8::downgrade($data, 1)
                    or die(qq/Wide character in write_content()\n/);
            }
    
            $len += $self->write($data);
        }
    
        $len == $content_length
          or die(qq/Content-Length mismatch (got: $len expected: $content_length)\n/);
    
        return $len;
    }
    
    sub read_chunked_body {
        @_ == 3 || die(q/Usage: $handle->read_chunked_body(callback, $response)/ . "\n");
        my ($self, $cb, $response) = @_;
    
        while () {
            my $head = $self->readline;
    
            $head =~ /\A ([A-Fa-f0-9]+)/x
              or die(q/Malformed chunk head: / . $Printable->($head) . "\n");
    
            my $len = hex($1)
              or last;
    
            $self->read_content_body($cb, $response, $len);
    
            $self->read(2) eq "\x0D\x0A"
              or die(qq/Malformed chunk: missing CRLF after chunk data\n/);
        }
        $self->read_header_lines($response->{headers});
        return 1;
    }
    
    sub write_chunked_body {
        @_ == 2 || die(q/Usage: $handle->write_chunked_body(request)/ . "\n");
        my ($self, $request) = @_;
    
        my $len = 0;
        while () {
            my $data = $request->{cb}->();
    
            defined $data && length $data
              or last;
    
            if ( $] ge '5.008' ) {
                utf8::downgrade($data, 1)
                    or die(qq/Wide character in write_chunked_body()\n/);
            }
    
            $len += length $data;
    
            my $chunk  = sprintf '%X', length $data;
               $chunk .= "\x0D\x0A";
               $chunk .= $data;
               $chunk .= "\x0D\x0A";
    
            $self->write($chunk);
        }
        $self->write("0\x0D\x0A");
        $self->write_header_lines($request->{trailer_cb}->())
            if ref $request->{trailer_cb} eq 'CODE';
        return $len;
    }
    
    sub read_response_header {
        @_ == 1 || die(q/Usage: $handle->read_response_header()/ . "\n");
        my ($self) = @_;
    
        my $line = $self->readline;
    
        $line =~ /\A (HTTP\/(0*\d+\.0*\d+)) [\x09\x20]+ ([0-9]{3}) [\x09\x20]+ ([^\x0D\x0A]*) \x0D?\x0A/x
          or die(q/Malformed Status-Line: / . $Printable->($line). "\n");
    
        my ($protocol, $version, $status, $reason) = ($1, $2, $3, $4);
    
        die (qq/Unsupported HTTP protocol: $protocol\n/)
            unless $version =~ /0*1\.0*[01]/;
    
        return {
            status       => $status,
            reason       => $reason,
            headers      => $self->read_header_lines,
            protocol     => $protocol,
        };
    }
    
    sub write_request_header {
        @_ == 4 || die(q/Usage: $handle->write_request_header(method, request_uri, headers)/ . "\n");
        my ($self, $method, $request_uri, $headers) = @_;
    
        return $self->write_header_lines($headers, "$method $request_uri HTTP/1.1\x0D\x0A");
    }
    
    sub _do_timeout {
        my ($self, $type, $timeout) = @_;
        $timeout = $self->{timeout}
            unless defined $timeout && $timeout >= 0;
    
        my $fd = fileno $self->{fh};
        defined $fd && $fd >= 0
          or die(qq/select(2): 'Bad file descriptor'\n/);
    
        my $initial = time;
        my $pending = $timeout;
        my $nfound;
    
        vec(my $fdset = '', $fd, 1) = 1;
    
        while () {
            $nfound = ($type eq 'read')
                ? select($fdset, undef, undef, $pending)
                : select(undef, $fdset, undef, $pending) ;
            if ($nfound == -1) {
                $! == EINTR
                  or die(qq/select(2): '$!'\n/);
                redo if !$timeout || ($pending = $timeout - (time - $initial)) > 0;
                $nfound = 0;
            }
            last;
        }
        $! = 0;
        return $nfound;
    }
    
    sub can_read {
        @_ == 1 || @_ == 2 || die(q/Usage: $handle->can_read([timeout])/ . "\n");
        my $self = shift;
        if ( ref($self->{fh}) eq 'IO::Socket::SSL' ) {
            return 1 if $self->{fh}->pending;
        }
        return $self->_do_timeout('read', @_)
    }
    
    sub can_write {
        @_ == 1 || @_ == 2 || die(q/Usage: $handle->can_write([timeout])/ . "\n");
        my $self = shift;
        return $self->_do_timeout('write', @_)
    }
    
    sub _assert_ssl {
        my($ok, $reason) = HTTP::Tiny->can_ssl();
        die $reason unless $ok;
    }
    
    sub can_reuse {
        my ($self,$scheme,$host,$port) = @_;
        return 0 if
            $self->{pid} != $$
            || $self->{tid} != _get_tid()
            || length($self->{rbuf})
            || $scheme ne $self->{scheme}
            || $host ne $self->{host}
            || $port ne $self->{port}
            || eval { $self->can_read(0) }
            || $@ ;
            return 1;
    }
    
    # Try to find a CA bundle to validate the SSL cert,
    # prefer Mozilla::CA or fallback to a system file
    sub _find_CA_file {
        my $self = shift();
    
        if ( $self->{SSL_options}->{SSL_ca_file} ) {
            unless ( -r $self->{SSL_options}->{SSL_ca_file} ) {
                die qq/SSL_ca_file '$self->{SSL_options}->{SSL_ca_file}' not found or not readable\n/;
            }
            return $self->{SSL_options}->{SSL_ca_file};
        }
    
        return Mozilla::CA::SSL_ca_file()
            if eval { require Mozilla::CA; 1 };
    
        # cert list copied from golang src/crypto/x509/root_unix.go
        foreach my $ca_bundle (
            "/etc/ssl/certs/ca-certificates.crt",     # Debian/Ubuntu/Gentoo etc.
            "/etc/pki/tls/certs/ca-bundle.crt",       # Fedora/RHEL
            "/etc/ssl/ca-bundle.pem",                 # OpenSUSE
            "/etc/openssl/certs/ca-certificates.crt", # NetBSD
            "/etc/ssl/cert.pem",                      # OpenBSD
            "/usr/local/share/certs/ca-root-nss.crt", # FreeBSD/DragonFly
            "/etc/pki/tls/cacert.pem",                # OpenELEC
            "/etc/certs/ca-certificates.crt",         # Solaris 11.2+
        ) {
            return $ca_bundle if -e $ca_bundle;
        }
    
        die qq/Couldn't find a CA bundle with which to verify the SSL certificate.\n/
          . qq/Try installing Mozilla::CA from CPAN\n/;
    }
    
    # for thread safety, we need to know thread id if threads are loaded
    sub _get_tid {
        no warnings 'reserved'; # for 'threads'
        return threads->can("tid") ? threads->tid : 0;
    }
    
    sub _ssl_args {
        my ($self, $host) = @_;
    
        my %ssl_args;
    
        # This test reimplements IO::Socket::SSL::can_client_sni(), which wasn't
        # added until IO::Socket::SSL 1.84
        if ( Net::SSLeay::OPENSSL_VERSION_NUMBER() >= 0x01000000 ) {
            $ssl_args{SSL_hostname} = $host,          # Sane SNI support
        }
    
        if ($self->{verify_SSL}) {
            $ssl_args{SSL_verifycn_scheme}  = 'http'; # enable CN validation
            $ssl_args{SSL_verifycn_name}    = $host;  # set validation hostname
            $ssl_args{SSL_verify_mode}      = 0x01;   # enable cert validation
            $ssl_args{SSL_ca_file}          = $self->_find_CA_file;
        }
        else {
            $ssl_args{SSL_verifycn_scheme}  = 'none'; # disable CN validation
            $ssl_args{SSL_verify_mode}      = 0x00;   # disable cert validation
        }
    
        # user options override settings from verify_SSL
        for my $k ( keys %{$self->{SSL_options}} ) {
            $ssl_args{$k} = $self->{SSL_options}{$k} if $k =~ m/^SSL_/;
        }
    
        return \%ssl_args;
    }
    
    1;
    
    __END__
    
    =pod
    
    =encoding UTF-8
    
    =head1 NAME
    
    HTTP::Tiny - A small, simple, correct HTTP/1.1 client
    
    =head1 VERSION
    
    version 0.056
    
    =head1 SYNOPSIS
    
        use HTTP::Tiny;
    
        my $response = HTTP::Tiny->new->get('http://example.com/');
    
        die "Failed!\n" unless $response->{success};
    
        print "$response->{status} $response->{reason}\n";
    
        while (my ($k, $v) = each %{$response->{headers}}) {
            for (ref $v eq 'ARRAY' ? @$v : $v) {
                print "$k: $_\n";
            }
        }
    
        print $response->{content} if length $response->{content};
    
    =head1 DESCRIPTION
    
    This is a very simple HTTP/1.1 client, designed for doing simple
    requests without the overhead of a large framework like L<LWP::UserAgent>.
    
    It is more correct and more complete than L<HTTP::Lite>.  It supports
    proxies and redirection.  It also correctly resumes after EINTR.
    
    If L<IO::Socket::IP> 0.25 or later is installed, HTTP::Tiny will use it instead
    of L<IO::Socket::INET> for transparent support for both IPv4 and IPv6.
    
    Cookie support requires L<HTTP::CookieJar> or an equivalent class.
    
    =head1 METHODS
    
    =head2 new
    
        $http = HTTP::Tiny->new( %attributes );
    
    This constructor returns a new HTTP::Tiny object.  Valid attributes include:
    
    =over 4
    
    =item *
    
    C<agent> — A user-agent string (defaults to 'HTTP-Tiny/$VERSION'). If C<agent> — ends in a space character, the default user-agent string is appended.
    
    =item *
    
    C<cookie_jar> — An instance of L<HTTP::CookieJar> — or equivalent class that supports the C<add> and C<cookie_header> methods
    
    =item *
    
    C<default_headers> — A hashref of default headers to apply to requests
    
    =item *
    
    C<local_address> — The local IP address to bind to
    
    =item *
    
    C<keep_alive> — Whether to reuse the last connection (if for the same scheme, host and port) (defaults to 1)
    
    =item *
    
    C<max_redirect> — Maximum number of redirects allowed (defaults to 5)
    
    =item *
    
    C<max_size> — Maximum response size in bytes (only when not using a data callback).  If defined, responses larger than this will return an exception.
    
    =item *
    
    C<http_proxy> — URL of a proxy server to use for HTTP connections (default is C<$ENV{http_proxy}> — if set)
    
    =item *
    
    C<https_proxy> — URL of a proxy server to use for HTTPS connections (default is C<$ENV{https_proxy}> — if set)
    
    =item *
    
    C<proxy> — URL of a generic proxy server for both HTTP and HTTPS connections (default is C<$ENV{all_proxy}> — if set)
    
    =item *
    
    C<no_proxy> — List of domain suffixes that should not be proxied.  Must be a comma-separated string or an array reference. (default is C<$ENV{no_proxy}> —)
    
    =item *
    
    C<timeout> — Request timeout in seconds (default is 60)
    
    =item *
    
    C<verify_SSL> — A boolean that indicates whether to validate the SSL certificate of an C<https> — connection (default is false)
    
    =item *
    
    C<SSL_options> — A hashref of C<SSL_*> — options to pass through to L<IO::Socket::SSL>
    
    =back
    
    Passing an explicit C<undef> for C<proxy>, C<http_proxy> or C<https_proxy> will
    prevent getting the corresponding proxies from the environment.
    
    Exceptions from C<max_size>, C<timeout> or other errors will result in a
    pseudo-HTTP status code of 599 and a reason of "Internal Exception". The
    content field in the response will contain the text of the exception.
    
    The C<keep_alive> parameter enables a persistent connection, but only to a
    single destination scheme, host and port.  Also, if any connection-relevant
    attributes are modified, or if the process ID or thread ID change, the
    persistent connection will be dropped.  If you want persistent connections
    across multiple destinations, use multiple HTTP::Tiny objects.
    
    See L</SSL SUPPORT> for more on the C<verify_SSL> and C<SSL_options> attributes.
    
    =head2 get|head|put|post|delete
    
        $response = $http->get($url);
        $response = $http->get($url, \%options);
        $response = $http->head($url);
    
    These methods are shorthand for calling C<request()> for the given method.  The
    URL must have unsafe characters escaped and international domain names encoded.
    See C<request()> for valid options and a description of the response.
    
    The C<success> field of the response will be true if the status code is 2XX.
    
    =head2 post_form
    
        $response = $http->post_form($url, $form_data);
        $response = $http->post_form($url, $form_data, \%options);
    
    This method executes a C<POST> request and sends the key/value pairs from a
    form data hash or array reference to the given URL with a C<content-type> of
    C<application/x-www-form-urlencoded>.  If data is provided as an array
    reference, the order is preserved; if provided as a hash reference, the terms
    are sorted on key and value for consistency.  See documentation for the
    C<www_form_urlencode> method for details on the encoding.
    
    The URL must have unsafe characters escaped and international domain names
    encoded.  See C<request()> for valid options and a description of the response.
    Any C<content-type> header or content in the options hashref will be ignored.
    
    The C<success> field of the response will be true if the status code is 2XX.
    
    =head2 mirror
    
        $response = $http->mirror($url, $file, \%options)
        if ( $response->{success} ) {
            print "$file is up to date\n";
        }
    
    Executes a C<GET> request for the URL and saves the response body to the file
    name provided.  The URL must have unsafe characters escaped and international
    domain names encoded.  If the file already exists, the request will include an
    C<If-Modified-Since> header with the modification timestamp of the file.  You
    may specify a different C<If-Modified-Since> header yourself in the C<<
    $options->{headers} >> hash.
    
    The C<success> field of the response will be true if the status code is 2XX
    or if the status code is 304 (unmodified).
    
    If the file was modified and the server response includes a properly
    formatted C<Last-Modified> header, the file modification time will
    be updated accordingly.
    
    =head2 request
    
        $response = $http->request($method, $url);
        $response = $http->request($method, $url, \%options);
    
    Executes an HTTP request of the given method type ('GET', 'HEAD', 'POST',
    'PUT', etc.) on the given URL.  The URL must have unsafe characters escaped and
    international domain names encoded.
    
    If the URL includes a "user:password" stanza, they will be used for Basic-style
    authorization headers.  (Authorization headers will not be included in a
    redirected request.) For example:
    
        $http->request('GET', 'http://Aladdin:open sesame@example.com/');
    
    If the "user:password" stanza contains reserved characters, they must
    be percent-escaped:
    
        $http->request('GET', 'http://john%40example.com:password@example.com/');
    
    A hashref of options may be appended to modify the request.
    
    Valid options are:
    
    =over 4
    
    =item *
    
    C<headers> — A hashref containing headers to include with the request.  If the value for a header is an array reference, the header will be output multiple times with each value in the array.  These headers over-write any default headers.
    
    =item *
    
    C<content> — A scalar to include as the body of the request OR a code reference that will be called iteratively to produce the body of the request
    
    =item *
    
    C<trailer_callback> — A code reference that will be called if it exists to provide a hashref of trailing headers (only used with chunked transfer-encoding)
    
    =item *
    
    C<data_callback> — A code reference that will be called for each chunks of the response body received.
    
    =back
    
    The C<Host> header is generated from the URL in accordance with RFC 2616.  It
    is a fatal error to specify C<Host> in the C<headers> option.  Other headers
    may be ignored or overwritten if necessary for transport compliance.
    
    If the C<content> option is a code reference, it will be called iteratively
    to provide the content body of the request.  It should return the empty
    string or undef when the iterator is exhausted.
    
    If the C<content> option is the empty string, no C<content-type> or
    C<content-length> headers will be generated.
    
    If the C<data_callback> option is provided, it will be called iteratively until
    the entire response body is received.  The first argument will be a string
    containing a chunk of the response body, the second argument will be the
    in-progress response hash reference, as described below.  (This allows
    customizing the action of the callback based on the C<status> or C<headers>
    received prior to the content body.)
    
    The C<request> method returns a hashref containing the response.  The hashref
    will have the following keys:
    
    =over 4
    
    =item *
    
    C<success> — Boolean indicating whether the operation returned a 2XX status code
    
    =item *
    
    C<url> — URL that provided the response. This is the URL of the request unless there were redirections, in which case it is the last URL queried in a redirection chain
    
    =item *
    
    C<status> — The HTTP status code of the response
    
    =item *
    
    C<reason> — The response phrase returned by the server
    
    =item *
    
    C<content> — The body of the response.  If the response does not have any content or if a data callback is provided to consume the response body, this will be the empty string
    
    =item *
    
    C<headers> — A hashref of header fields.  All header field names will be normalized to be lower case. If a header is repeated, the value will be an arrayref; it will otherwise be a scalar string containing the value
    
    =back
    
    On an exception during the execution of the request, the C<status> field will
    contain 599, and the C<content> field will contain the text of the exception.
    
    =head2 www_form_urlencode
    
        $params = $http->www_form_urlencode( $data );
        $response = $http->get("http://example.com/query?$params");
    
    This method converts the key/value pairs from a data hash or array reference
    into a C<x-www-form-urlencoded> string.  The keys and values from the data
    reference will be UTF-8 encoded and escaped per RFC 3986.  If a value is an
    array reference, the key will be repeated with each of the values of the array
    reference.  If data is provided as a hash reference, the key/value pairs in the
    resulting string will be sorted by key and value for consistent ordering.
    
    =head2 can_ssl
    
        $ok         = HTTP::Tiny->can_ssl;
        ($ok, $why) = HTTP::Tiny->can_ssl;
        ($ok, $why) = $http->can_ssl;
    
    Indicates if SSL support is available.  When called as a class object, it
    checks for the correct version of L<Net::SSLeay> and L<IO::Socket::SSL>.
    When called as an object methods, if C<SSL_verify> is true or if C<SSL_verify_mode>
    is set in C<SSL_options>, it checks that a CA file is available.
    
    In scalar context, returns a boolean indicating if SSL is available.
    In list context, returns the boolean and a (possibly multi-line) string of
    errors indicating why SSL isn't available.
    
    =for Pod::Coverage SSL_options
    agent
    cookie_jar
    default_headers
    http_proxy
    https_proxy
    keep_alive
    local_address
    max_redirect
    max_size
    no_proxy
    proxy
    timeout
    verify_SSL
    
    =head1 SSL SUPPORT
    
    Direct C<https> connections are supported only if L<IO::Socket::SSL> 1.56 or
    greater and L<Net::SSLeay> 1.49 or greater are installed. An exception will be
    thrown if new enough versions of these modules are not installed or if the SSL
    encryption fails. You can also use C<HTTP::Tiny::can_ssl()> utility function
    that returns boolean to see if the required modules are installed.
    
    An C<https> connection may be made via an C<http> proxy that supports the CONNECT
    command (i.e. RFC 2817).  You may not proxy C<https> via a proxy that itself
    requires C<https> to communicate.
    
    SSL provides two distinct capabilities:
    
    =over 4
    
    =item *
    
    Encrypted communication channel
    
    =item *
    
    Verification of server identity
    
    =back
    
    B<By default, HTTP::Tiny does not verify server identity>.
    
    Server identity verification is controversial and potentially tricky because it
    depends on a (usually paid) third-party Certificate Authority (CA) trust model
    to validate a certificate as legitimate.  This discriminates against servers
    with self-signed certificates or certificates signed by free, community-driven
    CA's such as L<CAcert.org|http://cacert.org>.
    
    By default, HTTP::Tiny does not make any assumptions about your trust model,
    threat level or risk tolerance.  It just aims to give you an encrypted channel
    when you need one.
    
    Setting the C<verify_SSL> attribute to a true value will make HTTP::Tiny verify
    that an SSL connection has a valid SSL certificate corresponding to the host
    name of the connection and that the SSL certificate has been verified by a CA.
    Assuming you trust the CA, this will protect against a L<man-in-the-middle
    attack|http://en.wikipedia.org/wiki/Man-in-the-middle_attack>.  If you are
    concerned about security, you should enable this option.
    
    Certificate verification requires a file containing trusted CA certificates.
    If the L<Mozilla::CA> module is installed, HTTP::Tiny will use the CA file
    included with it as a source of trusted CA's.  (This means you trust Mozilla,
    the author of Mozilla::CA, the CPAN mirror where you got Mozilla::CA, the
    toolchain used to install it, and your operating system security, right?)
    
    If that module is not available, then HTTP::Tiny will search several
    system-specific default locations for a CA certificate file:
    
    =over 4
    
    =item *
    
    /etc/ssl/certs/ca-certificates.crt
    
    =item *
    
    /etc/pki/tls/certs/ca-bundle.crt
    
    =item *
    
    /etc/ssl/ca-bundle.pem
    
    =back
    
    An exception will be raised if C<verify_SSL> is true and no CA certificate file
    is available.
    
    If you desire complete control over SSL connections, the C<SSL_options> attribute
    lets you provide a hash reference that will be passed through to
    C<IO::Socket::SSL::start_SSL()>, overriding any options set by HTTP::Tiny. For
    example, to provide your own trusted CA file:
    
        SSL_options => {
            SSL_ca_file => $file_path,
        }
    
    The C<SSL_options> attribute could also be used for such things as providing a
    client certificate for authentication to a server or controlling the choice of
    cipher used for the SSL connection. See L<IO::Socket::SSL> documentation for
    details.
    
    =head1 PROXY SUPPORT
    
    HTTP::Tiny can proxy both C<http> and C<https> requests.  Only Basic proxy
    authorization is supported and it must be provided as part of the proxy URL:
    C<http://user:pass@proxy.example.com/>.
    
    HTTP::Tiny supports the following proxy environment variables:
    
    =over 4
    
    =item *
    
    http_proxy or HTTP_PROXY
    
    =item *
    
    https_proxy or HTTPS_PROXY
    
    =item *
    
    all_proxy or ALL_PROXY
    
    =back
    
    If the C<REQUEST_METHOD> environment variable is set, then this might be a CGI
    process and C<HTTP_PROXY> would be set from the C<Proxy:> header, which is a
    security risk.  If C<REQUEST_METHOD> is set, C<HTTP_PROXY> (the upper case
    variant only) is ignored.
    
    Tunnelling C<https> over an C<http> proxy using the CONNECT method is
    supported.  If your proxy uses C<https> itself, you can not tunnel C<https>
    over it.
    
    Be warned that proxying an C<https> connection opens you to the risk of a
    man-in-the-middle attack by the proxy server.
    
    The C<no_proxy> environment variable is supported in the format of a
    comma-separated list of domain extensions proxy should not be used for.
    
    Proxy arguments passed to C<new> will override their corresponding
    environment variables.
    
    =head1 LIMITATIONS
    
    HTTP::Tiny is I<conditionally compliant> with the
    L<HTTP/1.1 specifications|http://www.w3.org/Protocols/>:
    
    =over 4
    
    =item *
    
    "Message Syntax and Routing" [RFC7230]
    
    =item *
    
    "Semantics and Content" [RFC7231]
    
    =item *
    
    "Conditional Requests" [RFC7232]
    
    =item *
    
    "Range Requests" [RFC7233]
    
    =item *
    
    "Caching" [RFC7234]
    
    =item *
    
    "Authentication" [RFC7235]
    
    =back
    
    It attempts to meet all "MUST" requirements of the specification, but does not
    implement all "SHOULD" requirements.  (Note: it was developed against the
    earlier RFC 2616 specification and may not yet meet the revised RFC 7230-7235
    spec.)
    
    Some particular limitations of note include:
    
    =over
    
    =item *
    
    HTTP::Tiny focuses on correct transport.  Users are responsible for ensuring
    that user-defined headers and content are compliant with the HTTP/1.1
    specification.
    
    =item *
    
    Users must ensure that URLs are properly escaped for unsafe characters and that
    international domain names are properly encoded to ASCII. See L<URI::Escape>,
    L<URI::_punycode> and L<Net::IDN::Encode>.
    
    =item *
    
    Redirection is very strict against the specification.  Redirection is only
    automatic for response codes 301, 302, 307 and 308 if the request method is
    'GET' or 'HEAD'.  Response code 303 is always converted into a 'GET'
    redirection, as mandated by the specification.  There is no automatic support
    for status 305 ("Use proxy") redirections.
    
    =item *
    
    There is no provision for delaying a request body using an C<Expect> header.
    Unexpected C<1XX> responses are silently ignored as per the specification.
    
    =item *
    
    Only 'chunked' C<Transfer-Encoding> is supported.
    
    =item *
    
    There is no support for a Request-URI of '*' for the 'OPTIONS' request.
    
    =back
    
    Despite the limitations listed above, HTTP::Tiny is considered
    feature-complete.  New feature requests should be directed to
    L<HTTP::Tiny::UA>.
    
    =head1 SEE ALSO
    
    =over 4
    
    =item *
    
    L<HTTP::Tiny::UA> - Higher level UA features for HTTP::Tiny
    
    =item *
    
    L<HTTP::Thin> - HTTP::Tiny wrapper with L<HTTP::Request>/L<HTTP::Response> compatibility
    
    =item *
    
    L<HTTP::Tiny::Mech> - Wrap L<WWW::Mechanize> instance in HTTP::Tiny compatible interface
    
    =item *
    
    L<IO::Socket::IP> - Required for IPv6 support
    
    =item *
    
    L<IO::Socket::SSL> - Required for SSL support
    
    =item *
    
    L<LWP::UserAgent> - If HTTP::Tiny isn't enough for you, this is the "standard" way to do things
    
    =item *
    
    L<Mozilla::CA> - Required if you want to validate SSL certificates
    
    =item *
    
    L<Net::SSLeay> - Required for SSL support
    
    =back
    
    =for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
    
    =head1 SUPPORT
    
    =head2 Bugs / Feature Requests
    
    Please report any bugs or feature requests through the issue tracker
    at L<https://github.com/chansen/p5-http-tiny/issues>.
    You will be notified automatically of any progress on your issue.
    
    =head2 Source Code
    
    This is open source software.  The code repository is available for
    public review and contribution under the terms of the license.
    
    L<https://github.com/chansen/p5-http-tiny>
    
      git clone https://github.com/chansen/p5-http-tiny.git
    
    =head1 AUTHORS
    
    =over 4
    
    =item *
    
    Christian Hansen <chansen@cpan.org>
    
    =item *
    
    David Golden <dagolden@cpan.org>
    
    =back
    
    =head1 CONTRIBUTORS
    
    =for stopwords Alan Gardner Alessandro Ghedini Brad Gilbert Chris Nehren Weyl Claes Jakobsson Clinton Gormley Dean Pearce Edward Zborowski James Raspass Jeremy Mates Jess Robinson Lukas Eklund Martin J. Evans Martin-Louis Bright Mike Doherty Olaf Alders Olivier Mengué Petr Písař Sören Kornetzki Syohei YOSHIDA Tatsuhiko Miyagawa Tom Hukins Tony Cook
    
    =over 4
    
    =item *
    
    Alan Gardner <gardner@pythian.com>
    
    =item *
    
    Alessandro Ghedini <al3xbio@gmail.com>
    
    =item *
    
    Brad Gilbert <bgills@cpan.org>
    
    =item *
    
    Chris Nehren <apeiron@cpan.org>
    
    =item *
    
    Chris Weyl <cweyl@alumni.drew.edu>
    
    =item *
    
    Claes Jakobsson <claes@surfar.nu>
    
    =item *
    
    Clinton Gormley <clint@traveljury.com>
    
    =item *
    
    Dean Pearce <pearce@pythian.com>
    
    =item *
    
    Edward Zborowski <ed@rubensteintech.com>
    
    =item *
    
    James Raspass <jraspass@gmail.com>
    
    =item *
    
    Jeremy Mates <jmates@cpan.org>
    
    =item *
    
    Jess Robinson <castaway@desert-island.me.uk>
    
    =item *
    
    Lukas Eklund <leklund@gmail.com>
    
    =item *
    
    Martin J. Evans <mjegh@ntlworld.com>
    
    =item *
    
    Martin-Louis Bright <mlbright@gmail.com>
    
    =item *
    
    Mike Doherty <doherty@cpan.org>
    
    =item *
    
    Olaf Alders <olaf@wundersolutions.com>
    
    =item *
    
    Olivier Mengué <dolmen@cpan.org>
    
    =item *
    
    Petr Písař <ppisar@redhat.com>
    
    =item *
    
    Sören Kornetzki <soeren.kornetzki@delti.com>
    
    =item *
    
    Syohei YOSHIDA <syohex@gmail.com>
    
    =item *
    
    Tatsuhiko Miyagawa <miyagawa@bulknews.net>
    
    =item *
    
    Tom Hukins <tom@eborcom.com>
    
    =item *
    
    Tony Cook <tony@develop-help.com>
    
    =back
    
    =head1 COPYRIGHT AND LICENSE
    
    This software is copyright (c) 2015 by Christian Hansen.
    
    This is free software; you can redistribute it and/or modify it under
    the same terms as the Perl 5 programming language system itself.
    
    =cut
  HTTP_TINY
  
  $fatpacked{"JSON/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_PP';
    package JSON::PP;
    
    # JSON-2.0
    
    use 5.005;
    use strict;
    use base qw(Exporter);
    use overload ();
    
    use Carp ();
    use B ();
    #use Devel::Peek;
    
    $JSON::PP::VERSION = '2.27300';
    
    @JSON::PP::EXPORT = qw(encode_json decode_json from_json to_json);
    
    # instead of hash-access, i tried index-access for speed.
    # but this method is not faster than what i expected. so it will be changed.
    
    use constant P_ASCII                => 0;
    use constant P_LATIN1               => 1;
    use constant P_UTF8                 => 2;
    use constant P_INDENT               => 3;
    use constant P_CANONICAL            => 4;
    use constant P_SPACE_BEFORE         => 5;
    use constant P_SPACE_AFTER          => 6;
    use constant P_ALLOW_NONREF         => 7;
    use constant P_SHRINK               => 8;
    use constant P_ALLOW_BLESSED        => 9;
    use constant P_CONVERT_BLESSED      => 10;
    use constant P_RELAXED              => 11;
    
    use constant P_LOOSE                => 12;
    use constant P_ALLOW_BIGNUM         => 13;
    use constant P_ALLOW_BAREKEY        => 14;
    use constant P_ALLOW_SINGLEQUOTE    => 15;
    use constant P_ESCAPE_SLASH         => 16;
    use constant P_AS_NONBLESSED        => 17;
    
    use constant P_ALLOW_UNKNOWN        => 18;
    
    use constant OLD_PERL => $] < 5.008 ? 1 : 0;
    
    BEGIN {
        my @xs_compati_bit_properties = qw(
                latin1 ascii utf8 indent canonical space_before space_after allow_nonref shrink
                allow_blessed convert_blessed relaxed allow_unknown
        );
        my @pp_bit_properties = qw(
                allow_singlequote allow_bignum loose
                allow_barekey escape_slash as_nonblessed
        );
    
        # Perl version check, Unicode handling is enable?
        # Helper module sets @JSON::PP::_properties.
        if ($] < 5.008 ) {
            my $helper = $] >= 5.006 ? 'JSON::PP::Compat5006' : 'JSON::PP::Compat5005';
            eval qq| require $helper |;
            if ($@) { Carp::croak $@; }
        }
    
        for my $name (@xs_compati_bit_properties, @pp_bit_properties) {
            my $flag_name = 'P_' . uc($name);
    
            eval qq/
                sub $name {
                    my \$enable = defined \$_[1] ? \$_[1] : 1;
    
                    if (\$enable) {
                        \$_[0]->{PROPS}->[$flag_name] = 1;
                    }
                    else {
                        \$_[0]->{PROPS}->[$flag_name] = 0;
                    }
    
                    \$_[0];
                }
    
                sub get_$name {
                    \$_[0]->{PROPS}->[$flag_name] ? 1 : '';
                }
            /;
        }
    
    }
    
    
    
    # Functions
    
    my %encode_allow_method
         = map {($_ => 1)} qw/utf8 pretty allow_nonref latin1 self_encode escape_slash
                              allow_blessed convert_blessed indent indent_length allow_bignum
                              as_nonblessed
                            /;
    my %decode_allow_method
         = map {($_ => 1)} qw/utf8 allow_nonref loose allow_singlequote allow_bignum
                              allow_barekey max_size relaxed/;
    
    
    my $JSON; # cache
    
    sub encode_json ($) { # encode
        ($JSON ||= __PACKAGE__->new->utf8)->encode(@_);
    }
    
    
    sub decode_json { # decode
        ($JSON ||= __PACKAGE__->new->utf8)->decode(@_);
    }
    
    # Obsoleted
    
    sub to_json($) {
       Carp::croak ("JSON::PP::to_json has been renamed to encode_json.");
    }
    
    
    sub from_json($) {
       Carp::croak ("JSON::PP::from_json has been renamed to decode_json.");
    }
    
    
    # Methods
    
    sub new {
        my $class = shift;
        my $self  = {
            max_depth   => 512,
            max_size    => 0,
            indent      => 0,
            FLAGS       => 0,
            fallback      => sub { encode_error('Invalid value. JSON can only reference.') },
            indent_length => 3,
        };
    
        bless $self, $class;
    }
    
    
    sub encode {
        return $_[0]->PP_encode_json($_[1]);
    }
    
    
    sub decode {
        return $_[0]->PP_decode_json($_[1], 0x00000000);
    }
    
    
    sub decode_prefix {
        return $_[0]->PP_decode_json($_[1], 0x00000001);
    }
    
    
    # accessor
    
    
    # pretty printing
    
    sub pretty {
        my ($self, $v) = @_;
        my $enable = defined $v ? $v : 1;
    
        if ($enable) { # indent_length(3) for JSON::XS compatibility
            $self->indent(1)->indent_length(3)->space_before(1)->space_after(1);
        }
        else {
            $self->indent(0)->space_before(0)->space_after(0);
        }
    
        $self;
    }
    
    # etc
    
    sub max_depth {
        my $max  = defined $_[1] ? $_[1] : 0x80000000;
        $_[0]->{max_depth} = $max;
        $_[0];
    }
    
    
    sub get_max_depth { $_[0]->{max_depth}; }
    
    
    sub max_size {
        my $max  = defined $_[1] ? $_[1] : 0;
        $_[0]->{max_size} = $max;
        $_[0];
    }
    
    
    sub get_max_size { $_[0]->{max_size}; }
    
    
    sub filter_json_object {
        $_[0]->{cb_object} = defined $_[1] ? $_[1] : 0;
        $_[0]->{F_HOOK} = ($_[0]->{cb_object} or $_[0]->{cb_sk_object}) ? 1 : 0;
        $_[0];
    }
    
    sub filter_json_single_key_object {
        if (@_ > 1) {
            $_[0]->{cb_sk_object}->{$_[1]} = $_[2];
        }
        $_[0]->{F_HOOK} = ($_[0]->{cb_object} or $_[0]->{cb_sk_object}) ? 1 : 0;
        $_[0];
    }
    
    sub indent_length {
        if (!defined $_[1] or $_[1] > 15 or $_[1] < 0) {
            Carp::carp "The acceptable range of indent_length() is 0 to 15.";
        }
        else {
            $_[0]->{indent_length} = $_[1];
        }
        $_[0];
    }
    
    sub get_indent_length {
        $_[0]->{indent_length};
    }
    
    sub sort_by {
        $_[0]->{sort_by} = defined $_[1] ? $_[1] : 1;
        $_[0];
    }
    
    sub allow_bigint {
        Carp::carp("allow_bigint() is obsoleted. use allow_bignum() insted.");
    }
    
    ###############################
    
    ###
    ### Perl => JSON
    ###
    
    
    { # Convert
    
        my $max_depth;
        my $indent;
        my $ascii;
        my $latin1;
        my $utf8;
        my $space_before;
        my $space_after;
        my $canonical;
        my $allow_blessed;
        my $convert_blessed;
    
        my $indent_length;
        my $escape_slash;
        my $bignum;
        my $as_nonblessed;
    
        my $depth;
        my $indent_count;
        my $keysort;
    
    
        sub PP_encode_json {
            my $self = shift;
            my $obj  = shift;
    
            $indent_count = 0;
            $depth        = 0;
    
            my $idx = $self->{PROPS};
    
            ($ascii, $latin1, $utf8, $indent, $canonical, $space_before, $space_after, $allow_blessed,
                $convert_blessed, $escape_slash, $bignum, $as_nonblessed)
             = @{$idx}[P_ASCII .. P_SPACE_AFTER, P_ALLOW_BLESSED, P_CONVERT_BLESSED,
                        P_ESCAPE_SLASH, P_ALLOW_BIGNUM, P_AS_NONBLESSED];
    
            ($max_depth, $indent_length) = @{$self}{qw/max_depth indent_length/};
    
            $keysort = $canonical ? sub { $a cmp $b } : undef;
    
            if ($self->{sort_by}) {
                $keysort = ref($self->{sort_by}) eq 'CODE' ? $self->{sort_by}
                         : $self->{sort_by} =~ /\D+/       ? $self->{sort_by}
                         : sub { $a cmp $b };
            }
    
            encode_error("hash- or arrayref expected (not a simple scalar, use allow_nonref to allow this)")
                 if(!ref $obj and !$idx->[ P_ALLOW_NONREF ]);
    
            my $str  = $self->object_to_json($obj);
    
            $str .= "\n" if ( $indent ); # JSON::XS 2.26 compatible
    
            unless ($ascii or $latin1 or $utf8) {
                utf8::upgrade($str);
            }
    
            if ($idx->[ P_SHRINK ]) {
                utf8::downgrade($str, 1);
            }
    
            return $str;
        }
    
    
        sub object_to_json {
            my ($self, $obj) = @_;
            my $type = ref($obj);
    
            if($type eq 'HASH'){
                return $self->hash_to_json($obj);
            }
            elsif($type eq 'ARRAY'){
                return $self->array_to_json($obj);
            }
            elsif ($type) { # blessed object?
                if (blessed($obj)) {
    
                    return $self->value_to_json($obj) if ( $obj->isa('JSON::PP::Boolean') );
    
                    if ( $convert_blessed and $obj->can('TO_JSON') ) {
                        my $result = $obj->TO_JSON();
                        if ( defined $result and ref( $result ) ) {
                            if ( refaddr( $obj ) eq refaddr( $result ) ) {
                                encode_error( sprintf(
                                    "%s::TO_JSON method returned same object as was passed instead of a new one",
                                    ref $obj
                                ) );
                            }
                        }
    
                        return $self->object_to_json( $result );
                    }
    
                    return "$obj" if ( $bignum and _is_bignum($obj) );
                    return $self->blessed_to_json($obj) if ($allow_blessed and $as_nonblessed); # will be removed.
    
                    encode_error( sprintf("encountered object '%s', but neither allow_blessed "
                        . "nor convert_blessed settings are enabled", $obj)
                    ) unless ($allow_blessed);
    
                    return 'null';
                }
                else {
                    return $self->value_to_json($obj);
                }
            }
            else{
                return $self->value_to_json($obj);
            }
        }
    
    
        sub hash_to_json {
            my ($self, $obj) = @_;
            my @res;
    
            encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")
                                             if (++$depth > $max_depth);
    
            my ($pre, $post) = $indent ? $self->_up_indent() : ('', '');
            my $del = ($space_before ? ' ' : '') . ':' . ($space_after ? ' ' : '');
    
            for my $k ( _sort( $obj ) ) {
                if ( OLD_PERL ) { utf8::decode($k) } # key for Perl 5.6 / be optimized
                push @res, string_to_json( $self, $k )
                              .  $del
                              . ( $self->object_to_json( $obj->{$k} ) || $self->value_to_json( $obj->{$k} ) );
            }
    
            --$depth;
            $self->_down_indent() if ($indent);
    
            return   '{' . ( @res ? $pre : '' ) . ( @res ? join( ",$pre", @res ) . $post : '' )  . '}';
        }
    
    
        sub array_to_json {
            my ($self, $obj) = @_;
            my @res;
    
            encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")
                                             if (++$depth > $max_depth);
    
            my ($pre, $post) = $indent ? $self->_up_indent() : ('', '');
    
            for my $v (@$obj){
                push @res, $self->object_to_json($v) || $self->value_to_json($v);
            }
    
            --$depth;
            $self->_down_indent() if ($indent);
    
            return '[' . ( @res ? $pre : '' ) . ( @res ? join( ",$pre", @res ) . $post : '' ) . ']';
        }
    
    
        sub value_to_json {
            my ($self, $value) = @_;
    
            return 'null' if(!defined $value);
    
            my $b_obj = B::svref_2object(\$value);  # for round trip problem
            my $flags = $b_obj->FLAGS;
    
            return $value # as is 
                if $flags & ( B::SVp_IOK | B::SVp_NOK ) and !( $flags & B::SVp_POK ); # SvTYPE is IV or NV?
    
            my $type = ref($value);
    
            if(!$type){
                return string_to_json($self, $value);
            }
            elsif( blessed($value) and  $value->isa('JSON::PP::Boolean') ){
                return $$value == 1 ? 'true' : 'false';
            }
            elsif ($type) {
                if ((overload::StrVal($value) =~ /=(\w+)/)[0]) {
                    return $self->value_to_json("$value");
                }
    
                if ($type eq 'SCALAR' and defined $$value) {
                    return   $$value eq '1' ? 'true'
                           : $$value eq '0' ? 'false'
                           : $self->{PROPS}->[ P_ALLOW_UNKNOWN ] ? 'null'
                           : encode_error("cannot encode reference to scalar");
                }
    
                 if ( $self->{PROPS}->[ P_ALLOW_UNKNOWN ] ) {
                     return 'null';
                 }
                 else {
                     if ( $type eq 'SCALAR' or $type eq 'REF' ) {
                        encode_error("cannot encode reference to scalar");
                     }
                     else {
                        encode_error("encountered $value, but JSON can only represent references to arrays or hashes");
                     }
                 }
    
            }
            else {
                return $self->{fallback}->($value)
                     if ($self->{fallback} and ref($self->{fallback}) eq 'CODE');
                return 'null';
            }
    
        }
    
    
        my %esc = (
            "\n" => '\n',
            "\r" => '\r',
            "\t" => '\t',
            "\f" => '\f',
            "\b" => '\b',
            "\"" => '\"',
            "\\" => '\\\\',
            "\'" => '\\\'',
        );
    
    
        sub string_to_json {
            my ($self, $arg) = @_;
    
            $arg =~ s/([\x22\x5c\n\r\t\f\b])/$esc{$1}/g;
            $arg =~ s/\//\\\//g if ($escape_slash);
            $arg =~ s/([\x00-\x08\x0b\x0e-\x1f])/'\\u00' . unpack('H2', $1)/eg;
    
            if ($ascii) {
                $arg = JSON_PP_encode_ascii($arg);
            }
    
            if ($latin1) {
                $arg = JSON_PP_encode_latin1($arg);
            }
    
            if ($utf8) {
                utf8::encode($arg);
            }
    
            return '"' . $arg . '"';
        }
    
    
        sub blessed_to_json {
            my $reftype = reftype($_[1]) || '';
            if ($reftype eq 'HASH') {
                return $_[0]->hash_to_json($_[1]);
            }
            elsif ($reftype eq 'ARRAY') {
                return $_[0]->array_to_json($_[1]);
            }
            else {
                return 'null';
            }
        }
    
    
        sub encode_error {
            my $error  = shift;
            Carp::croak "$error";
        }
    
    
        sub _sort {
            defined $keysort ? (sort $keysort (keys %{$_[0]})) : keys %{$_[0]};
        }
    
    
        sub _up_indent {
            my $self  = shift;
            my $space = ' ' x $indent_length;
    
            my ($pre,$post) = ('','');
    
            $post = "\n" . $space x $indent_count;
    
            $indent_count++;
    
            $pre = "\n" . $space x $indent_count;
    
            return ($pre,$post);
        }
    
    
        sub _down_indent { $indent_count--; }
    
    
        sub PP_encode_box {
            {
                depth        => $depth,
                indent_count => $indent_count,
            };
        }
    
    } # Convert
    
    
    sub _encode_ascii {
        join('',
            map {
                $_ <= 127 ?
                    chr($_) :
                $_ <= 65535 ?
                    sprintf('\u%04x', $_) : sprintf('\u%x\u%x', _encode_surrogates($_));
            } unpack('U*', $_[0])
        );
    }
    
    
    sub _encode_latin1 {
        join('',
            map {
                $_ <= 255 ?
                    chr($_) :
                $_ <= 65535 ?
                    sprintf('\u%04x', $_) : sprintf('\u%x\u%x', _encode_surrogates($_));
            } unpack('U*', $_[0])
        );
    }
    
    
    sub _encode_surrogates { # from perlunicode
        my $uni = $_[0] - 0x10000;
        return ($uni / 0x400 + 0xD800, $uni % 0x400 + 0xDC00);
    }
    
    
    sub _is_bignum {
        $_[0]->isa('Math::BigInt') or $_[0]->isa('Math::BigFloat');
    }
    
    
    
    #
    # JSON => Perl
    #
    
    my $max_intsize;
    
    BEGIN {
        my $checkint = 1111;
        for my $d (5..64) {
            $checkint .= 1;
            my $int   = eval qq| $checkint |;
            if ($int =~ /[eE]/) {
                $max_intsize = $d - 1;
                last;
            }
        }
    }
    
    { # PARSE 
    
        my %escapes = ( #  by Jeremy Muhlich <jmuhlich [at] bitflood.org>
            b    => "\x8",
            t    => "\x9",
            n    => "\xA",
            f    => "\xC",
            r    => "\xD",
            '\\' => '\\',
            '"'  => '"',
            '/'  => '/',
        );
    
        my $text; # json data
        my $at;   # offset
        my $ch;   # 1chracter
        my $len;  # text length (changed according to UTF8 or NON UTF8)
        # INTERNAL
        my $depth;          # nest counter
        my $encoding;       # json text encoding
        my $is_valid_utf8;  # temp variable
        my $utf8_len;       # utf8 byte length
        # FLAGS
        my $utf8;           # must be utf8
        my $max_depth;      # max nest nubmer of objects and arrays
        my $max_size;
        my $relaxed;
        my $cb_object;
        my $cb_sk_object;
    
        my $F_HOOK;
    
        my $allow_bigint;   # using Math::BigInt
        my $singlequote;    # loosely quoting
        my $loose;          # 
        my $allow_barekey;  # bareKey
    
        # $opt flag
        # 0x00000001 .... decode_prefix
        # 0x10000000 .... incr_parse
    
        sub PP_decode_json {
            my ($self, $opt); # $opt is an effective flag during this decode_json.
    
            ($self, $text, $opt) = @_;
    
            ($at, $ch, $depth) = (0, '', 0);
    
            if ( !defined $text or ref $text ) {
                decode_error("malformed JSON string, neither array, object, number, string or atom");
            }
    
            my $idx = $self->{PROPS};
    
            ($utf8, $relaxed, $loose, $allow_bigint, $allow_barekey, $singlequote)
                = @{$idx}[P_UTF8, P_RELAXED, P_LOOSE .. P_ALLOW_SINGLEQUOTE];
    
            if ( $utf8 ) {
                utf8::downgrade( $text, 1 ) or Carp::croak("Wide character in subroutine entry");
            }
            else {
                utf8::upgrade( $text );
                utf8::encode( $text );
            }
    
            $len = length $text;
    
            ($max_depth, $max_size, $cb_object, $cb_sk_object, $F_HOOK)
                 = @{$self}{qw/max_depth  max_size cb_object cb_sk_object F_HOOK/};
    
            if ($max_size > 1) {
                use bytes;
                my $bytes = length $text;
                decode_error(
                    sprintf("attempted decode of JSON text of %s bytes size, but max_size is set to %s"
                        , $bytes, $max_size), 1
                ) if ($bytes > $max_size);
            }
    
            # Currently no effect
            # should use regexp
            my @octets = unpack('C4', $text);
            $encoding =   ( $octets[0] and  $octets[1]) ? 'UTF-8'
                        : (!$octets[0] and  $octets[1]) ? 'UTF-16BE'
                        : (!$octets[0] and !$octets[1]) ? 'UTF-32BE'
                        : ( $octets[2]                ) ? 'UTF-16LE'
                        : (!$octets[2]                ) ? 'UTF-32LE'
                        : 'unknown';
    
            white(); # remove head white space
    
            my $valid_start = defined $ch; # Is there a first character for JSON structure?
    
            my $result = value();
    
            return undef if ( !$result && ( $opt & 0x10000000 ) ); # for incr_parse
    
            decode_error("malformed JSON string, neither array, object, number, string or atom") unless $valid_start;
    
            if ( !$idx->[ P_ALLOW_NONREF ] and !ref $result ) {
                    decode_error(
                    'JSON text must be an object or array (but found number, string, true, false or null,'
                           . ' use allow_nonref to allow this)', 1);
            }
    
            Carp::croak('something wrong.') if $len < $at; # we won't arrive here.
    
            my $consumed = defined $ch ? $at - 1 : $at; # consumed JSON text length
    
            white(); # remove tail white space
    
            if ( $ch ) {
                return ( $result, $consumed ) if ($opt & 0x00000001); # all right if decode_prefix
                decode_error("garbage after JSON object");
            }
    
            ( $opt & 0x00000001 ) ? ( $result, $consumed ) : $result;
        }
    
    
        sub next_chr {
            return $ch = undef if($at >= $len);
            $ch = substr($text, $at++, 1);
        }
    
    
        sub value {
            white();
            return          if(!defined $ch);
            return object() if($ch eq '{');
            return array()  if($ch eq '[');
            return string() if($ch eq '"' or ($singlequote and $ch eq "'"));
            return number() if($ch =~ /[0-9]/ or $ch eq '-');
            return word();
        }
    
        sub string {
            my ($i, $s, $t, $u);
            my $utf16;
            my $is_utf8;
    
            ($is_valid_utf8, $utf8_len) = ('', 0);
    
            $s = ''; # basically UTF8 flag on
    
            if($ch eq '"' or ($singlequote and $ch eq "'")){
                my $boundChar = $ch;
    
                OUTER: while( defined(next_chr()) ){
    
                    if($ch eq $boundChar){
                        next_chr();
    
                        if ($utf16) {
                            decode_error("missing low surrogate character in surrogate pair");
                        }
    
                        utf8::decode($s) if($is_utf8);
    
                        return $s;
                    }
                    elsif($ch eq '\\'){
                        next_chr();
                        if(exists $escapes{$ch}){
                            $s .= $escapes{$ch};
                        }
                        elsif($ch eq 'u'){ # UNICODE handling
                            my $u = '';
    
                            for(1..4){
                                $ch = next_chr();
                                last OUTER if($ch !~ /[0-9a-fA-F]/);
                                $u .= $ch;
                            }
    
                            # U+D800 - U+DBFF
                            if ($u =~ /^[dD][89abAB][0-9a-fA-F]{2}/) { # UTF-16 high surrogate?
                                $utf16 = $u;
                            }
                            # U+DC00 - U+DFFF
                            elsif ($u =~ /^[dD][c-fC-F][0-9a-fA-F]{2}/) { # UTF-16 low surrogate?
                                unless (defined $utf16) {
                                    decode_error("missing high surrogate character in surrogate pair");
                                }
                                $is_utf8 = 1;
                                $s .= JSON_PP_decode_surrogates($utf16, $u) || next;
                                $utf16 = undef;
                            }
                            else {
                                if (defined $utf16) {
                                    decode_error("surrogate pair expected");
                                }
    
                                if ( ( my $hex = hex( $u ) ) > 127 ) {
                                    $is_utf8 = 1;
                                    $s .= JSON_PP_decode_unicode($u) || next;
                                }
                                else {
                                    $s .= chr $hex;
                                }
                            }
    
                        }
                        else{
                            unless ($loose) {
                                $at -= 2;
                                decode_error('illegal backslash escape sequence in string');
                            }
                            $s .= $ch;
                        }
                    }
                    else{
    
                        if ( ord $ch  > 127 ) {
                            unless( $ch = is_valid_utf8($ch) ) {
                                $at -= 1;
                                decode_error("malformed UTF-8 character in JSON string");
                            }
                            else {
                                $at += $utf8_len - 1;
                            }
    
                            $is_utf8 = 1;
                        }
    
                        if (!$loose) {
                            if ($ch =~ /[\x00-\x1f\x22\x5c]/)  { # '/' ok
                                $at--;
                                decode_error('invalid character encountered while parsing JSON string');
                            }
                        }
    
                        $s .= $ch;
                    }
                }
            }
    
            decode_error("unexpected end of string while parsing JSON string");
        }
    
    
        sub white {
            while( defined $ch  ){
                if($ch le ' '){
                    next_chr();
                }
                elsif($ch eq '/'){
                    next_chr();
                    if(defined $ch and $ch eq '/'){
                        1 while(defined(next_chr()) and $ch ne "\n" and $ch ne "\r");
                    }
                    elsif(defined $ch and $ch eq '*'){
                        next_chr();
                        while(1){
                            if(defined $ch){
                                if($ch eq '*'){
                                    if(defined(next_chr()) and $ch eq '/'){
                                        next_chr();
                                        last;
                                    }
                                }
                                else{
                                    next_chr();
                                }
                            }
                            else{
                                decode_error("Unterminated comment");
                            }
                        }
                        next;
                    }
                    else{
                        $at--;
                        decode_error("malformed JSON string, neither array, object, number, string or atom");
                    }
                }
                else{
                    if ($relaxed and $ch eq '#') { # correctly?
                        pos($text) = $at;
                        $text =~ /\G([^\n]*(?:\r\n|\r|\n|$))/g;
                        $at = pos($text);
                        next_chr;
                        next;
                    }
    
                    last;
                }
            }
        }
    
    
        sub array {
            my $a  = $_[0] || []; # you can use this code to use another array ref object.
    
            decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')
                                                        if (++$depth > $max_depth);
    
            next_chr();
            white();
    
            if(defined $ch and $ch eq ']'){
                --$depth;
                next_chr();
                return $a;
            }
            else {
                while(defined($ch)){
                    push @$a, value();
    
                    white();
    
                    if (!defined $ch) {
                        last;
                    }
    
                    if($ch eq ']'){
                        --$depth;
                        next_chr();
                        return $a;
                    }
    
                    if($ch ne ','){
                        last;
                    }
    
                    next_chr();
                    white();
    
                    if ($relaxed and $ch eq ']') {
                        --$depth;
                        next_chr();
                        return $a;
                    }
    
                }
            }
    
            decode_error(", or ] expected while parsing array");
        }
    
    
        sub object {
            my $o = $_[0] || {}; # you can use this code to use another hash ref object.
            my $k;
    
            decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')
                                                    if (++$depth > $max_depth);
            next_chr();
            white();
    
            if(defined $ch and $ch eq '}'){
                --$depth;
                next_chr();
                if ($F_HOOK) {
                    return _json_object_hook($o);
                }
                return $o;
            }
            else {
                while (defined $ch) {
                    $k = ($allow_barekey and $ch ne '"' and $ch ne "'") ? bareKey() : string();
                    white();
    
                    if(!defined $ch or $ch ne ':'){
                        $at--;
                        decode_error("':' expected");
                    }
    
                    next_chr();
                    $o->{$k} = value();
                    white();
    
                    last if (!defined $ch);
    
                    if($ch eq '}'){
                        --$depth;
                        next_chr();
                        if ($F_HOOK) {
                            return _json_object_hook($o);
                        }
                        return $o;
                    }
    
                    if($ch ne ','){
                        last;
                    }
    
                    next_chr();
                    white();
    
                    if ($relaxed and $ch eq '}') {
                        --$depth;
                        next_chr();
                        if ($F_HOOK) {
                            return _json_object_hook($o);
                        }
                        return $o;
                    }
    
                }
    
            }
    
            $at--;
            decode_error(", or } expected while parsing object/hash");
        }
    
    
        sub bareKey { # doesn't strictly follow Standard ECMA-262 3rd Edition
            my $key;
            while($ch =~ /[^\x00-\x23\x25-\x2F\x3A-\x40\x5B-\x5E\x60\x7B-\x7F]/){
                $key .= $ch;
                next_chr();
            }
            return $key;
        }
    
    
        sub word {
            my $word =  substr($text,$at-1,4);
    
            if($word eq 'true'){
                $at += 3;
                next_chr;
                return $JSON::PP::true;
            }
            elsif($word eq 'null'){
                $at += 3;
                next_chr;
                return undef;
            }
            elsif($word eq 'fals'){
                $at += 3;
                if(substr($text,$at,1) eq 'e'){
                    $at++;
                    next_chr;
                    return $JSON::PP::false;
                }
            }
    
            $at--; # for decode_error report
    
            decode_error("'null' expected")  if ($word =~ /^n/);
            decode_error("'true' expected")  if ($word =~ /^t/);
            decode_error("'false' expected") if ($word =~ /^f/);
            decode_error("malformed JSON string, neither array, object, number, string or atom");
        }
    
    
        sub number {
            my $n    = '';
            my $v;
    
            # According to RFC4627, hex or oct digts are invalid.
            if($ch eq '0'){
                my $peek = substr($text,$at,1);
                my $hex  = $peek =~ /[xX]/; # 0 or 1
    
                if($hex){
                    decode_error("malformed number (leading zero must not be followed by another digit)");
                    ($n) = ( substr($text, $at+1) =~ /^([0-9a-fA-F]+)/);
                }
                else{ # oct
                    ($n) = ( substr($text, $at) =~ /^([0-7]+)/);
                    if (defined $n and length $n > 1) {
                        decode_error("malformed number (leading zero must not be followed by another digit)");
                    }
                }
    
                if(defined $n and length($n)){
                    if (!$hex and length($n) == 1) {
                       decode_error("malformed number (leading zero must not be followed by another digit)");
                    }
                    $at += length($n) + $hex;
                    next_chr;
                    return $hex ? hex($n) : oct($n);
                }
            }
    
            if($ch eq '-'){
                $n = '-';
                next_chr;
                if (!defined $ch or $ch !~ /\d/) {
                    decode_error("malformed number (no digits after initial minus)");
                }
            }
    
            while(defined $ch and $ch =~ /\d/){
                $n .= $ch;
                next_chr;
            }
    
            if(defined $ch and $ch eq '.'){
                $n .= '.';
    
                next_chr;
                if (!defined $ch or $ch !~ /\d/) {
                    decode_error("malformed number (no digits after decimal point)");
                }
                else {
                    $n .= $ch;
                }
    
                while(defined(next_chr) and $ch =~ /\d/){
                    $n .= $ch;
                }
            }
    
            if(defined $ch and ($ch eq 'e' or $ch eq 'E')){
                $n .= $ch;
                next_chr;
    
                if(defined($ch) and ($ch eq '+' or $ch eq '-')){
                    $n .= $ch;
                    next_chr;
                    if (!defined $ch or $ch =~ /\D/) {
                        decode_error("malformed number (no digits after exp sign)");
                    }
                    $n .= $ch;
                }
                elsif(defined($ch) and $ch =~ /\d/){
                    $n .= $ch;
                }
                else {
                    decode_error("malformed number (no digits after exp sign)");
                }
    
                while(defined(next_chr) and $ch =~ /\d/){
                    $n .= $ch;
                }
    
            }
    
            $v .= $n;
    
            if ($v !~ /[.eE]/ and length $v > $max_intsize) {
                if ($allow_bigint) { # from Adam Sussman
                    require Math::BigInt;
                    return Math::BigInt->new($v);
                }
                else {
                    return "$v";
                }
            }
            elsif ($allow_bigint) {
                require Math::BigFloat;
                return Math::BigFloat->new($v);
            }
    
            return 0+$v;
        }
    
    
        sub is_valid_utf8 {
    
            $utf8_len = $_[0] =~ /[\x00-\x7F]/  ? 1
                      : $_[0] =~ /[\xC2-\xDF]/  ? 2
                      : $_[0] =~ /[\xE0-\xEF]/  ? 3
                      : $_[0] =~ /[\xF0-\xF4]/  ? 4
                      : 0
                      ;
    
            return unless $utf8_len;
    
            my $is_valid_utf8 = substr($text, $at - 1, $utf8_len);
    
            return ( $is_valid_utf8 =~ /^(?:
                 [\x00-\x7F]
                |[\xC2-\xDF][\x80-\xBF]
                |[\xE0][\xA0-\xBF][\x80-\xBF]
                |[\xE1-\xEC][\x80-\xBF][\x80-\xBF]
                |[\xED][\x80-\x9F][\x80-\xBF]
                |[\xEE-\xEF][\x80-\xBF][\x80-\xBF]
                |[\xF0][\x90-\xBF][\x80-\xBF][\x80-\xBF]
                |[\xF1-\xF3][\x80-\xBF][\x80-\xBF][\x80-\xBF]
                |[\xF4][\x80-\x8F][\x80-\xBF][\x80-\xBF]
            )$/x )  ? $is_valid_utf8 : '';
        }
    
    
        sub decode_error {
            my $error  = shift;
            my $no_rep = shift;
            my $str    = defined $text ? substr($text, $at) : '';
            my $mess   = '';
            my $type   = $] >= 5.008           ? 'U*'
                       : $] <  5.006           ? 'C*'
                       : utf8::is_utf8( $str ) ? 'U*' # 5.6
                       : 'C*'
                       ;
    
            for my $c ( unpack( $type, $str ) ) { # emulate pv_uni_display() ?
                $mess .=  $c == 0x07 ? '\a'
                        : $c == 0x09 ? '\t'
                        : $c == 0x0a ? '\n'
                        : $c == 0x0d ? '\r'
                        : $c == 0x0c ? '\f'
                        : $c <  0x20 ? sprintf('\x{%x}', $c)
                        : $c == 0x5c ? '\\\\'
                        : $c <  0x80 ? chr($c)
                        : sprintf('\x{%x}', $c)
                        ;
                if ( length $mess >= 20 ) {
                    $mess .= '...';
                    last;
                }
            }
    
            unless ( length $mess ) {
                $mess = '(end of string)';
            }
    
            Carp::croak (
                $no_rep ? "$error" : "$error, at character offset $at (before \"$mess\")"
            );
    
        }
    
    
        sub _json_object_hook {
            my $o    = $_[0];
            my @ks = keys %{$o};
    
            if ( $cb_sk_object and @ks == 1 and exists $cb_sk_object->{ $ks[0] } and ref $cb_sk_object->{ $ks[0] } ) {
                my @val = $cb_sk_object->{ $ks[0] }->( $o->{$ks[0]} );
                if (@val == 1) {
                    return $val[0];
                }
            }
    
            my @val = $cb_object->($o) if ($cb_object);
            if (@val == 0 or @val > 1) {
                return $o;
            }
            else {
                return $val[0];
            }
        }
    
    
        sub PP_decode_box {
            {
                text    => $text,
                at      => $at,
                ch      => $ch,
                len     => $len,
                depth   => $depth,
                encoding      => $encoding,
                is_valid_utf8 => $is_valid_utf8,
            };
        }
    
    } # PARSE
    
    
    sub _decode_surrogates { # from perlunicode
        my $uni = 0x10000 + (hex($_[0]) - 0xD800) * 0x400 + (hex($_[1]) - 0xDC00);
        my $un  = pack('U*', $uni);
        utf8::encode( $un );
        return $un;
    }
    
    
    sub _decode_unicode {
        my $un = pack('U', hex shift);
        utf8::encode( $un );
        return $un;
    }
    
    #
    # Setup for various Perl versions (the code from JSON::PP58)
    #
    
    BEGIN {
    
        unless ( defined &utf8::is_utf8 ) {
           require Encode;
           *utf8::is_utf8 = *Encode::is_utf8;
        }
    
        if ( $] >= 5.008 ) {
            *JSON::PP::JSON_PP_encode_ascii      = \&_encode_ascii;
            *JSON::PP::JSON_PP_encode_latin1     = \&_encode_latin1;
            *JSON::PP::JSON_PP_decode_surrogates = \&_decode_surrogates;
            *JSON::PP::JSON_PP_decode_unicode    = \&_decode_unicode;
        }
    
        if ($] >= 5.008 and $] < 5.008003) { # join() in 5.8.0 - 5.8.2 is broken.
            package JSON::PP;
            require subs;
            subs->import('join');
            eval q|
                sub join {
                    return '' if (@_ < 2);
                    my $j   = shift;
                    my $str = shift;
                    for (@_) { $str .= $j . $_; }
                    return $str;
                }
            |;
        }
    
    
        sub JSON::PP::incr_parse {
            local $Carp::CarpLevel = 1;
            ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_parse( @_ );
        }
    
    
        sub JSON::PP::incr_skip {
            ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_skip;
        }
    
    
        sub JSON::PP::incr_reset {
            ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_reset;
        }
    
        eval q{
            sub JSON::PP::incr_text : lvalue {
                $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new;
    
                if ( $_[0]->{_incr_parser}->{incr_parsing} ) {
                    Carp::croak("incr_text can not be called when the incremental parser already started parsing");
                }
                $_[0]->{_incr_parser}->{incr_text};
            }
        } if ( $] >= 5.006 );
    
    } # Setup for various Perl versions (the code from JSON::PP58)
    
    
    ###############################
    # Utilities
    #
    
    BEGIN {
        eval 'require Scalar::Util';
        unless($@){
            *JSON::PP::blessed = \&Scalar::Util::blessed;
            *JSON::PP::reftype = \&Scalar::Util::reftype;
            *JSON::PP::refaddr = \&Scalar::Util::refaddr;
        }
        else{ # This code is from Sclar::Util.
            # warn $@;
            eval 'sub UNIVERSAL::a_sub_not_likely_to_be_here { ref($_[0]) }';
            *JSON::PP::blessed = sub {
                local($@, $SIG{__DIE__}, $SIG{__WARN__});
                ref($_[0]) ? eval { $_[0]->a_sub_not_likely_to_be_here } : undef;
            };
            my %tmap = qw(
                B::NULL   SCALAR
                B::HV     HASH
                B::AV     ARRAY
                B::CV     CODE
                B::IO     IO
                B::GV     GLOB
                B::REGEXP REGEXP
            );
            *JSON::PP::reftype = sub {
                my $r = shift;
    
                return undef unless length(ref($r));
    
                my $t = ref(B::svref_2object($r));
    
                return
                    exists $tmap{$t} ? $tmap{$t}
                  : length(ref($$r)) ? 'REF'
                  :                    'SCALAR';
            };
            *JSON::PP::refaddr = sub {
              return undef unless length(ref($_[0]));
    
              my $addr;
              if(defined(my $pkg = blessed($_[0]))) {
                $addr .= bless $_[0], 'Scalar::Util::Fake';
                bless $_[0], $pkg;
              }
              else {
                $addr .= $_[0]
              }
    
              $addr =~ /0x(\w+)/;
              local $^W;
              #no warnings 'portable';
              hex($1);
            }
        }
    }
    
    
    # shamely copied and modified from JSON::XS code.
    
    $JSON::PP::true  = do { bless \(my $dummy = 1), "JSON::PP::Boolean" };
    $JSON::PP::false = do { bless \(my $dummy = 0), "JSON::PP::Boolean" };
    
    sub is_bool { defined $_[0] and UNIVERSAL::isa($_[0], "JSON::PP::Boolean"); }
    
    sub true  { $JSON::PP::true  }
    sub false { $JSON::PP::false }
    sub null  { undef; }
    
    ###############################
    
    package JSON::PP::Boolean;
    
    use overload (
       "0+"     => sub { ${$_[0]} },
       "++"     => sub { $_[0] = ${$_[0]} + 1 },
       "--"     => sub { $_[0] = ${$_[0]} - 1 },
       fallback => 1,
    );
    
    
    ###############################
    
    package JSON::PP::IncrParser;
    
    use strict;
    
    use constant INCR_M_WS   => 0; # initial whitespace skipping
    use constant INCR_M_STR  => 1; # inside string
    use constant INCR_M_BS   => 2; # inside backslash
    use constant INCR_M_JSON => 3; # outside anything, count nesting
    use constant INCR_M_C0   => 4;
    use constant INCR_M_C1   => 5;
    
    $JSON::PP::IncrParser::VERSION = '1.01';
    
    my $unpack_format = $] < 5.006 ? 'C*' : 'U*';
    
    sub new {
        my ( $class ) = @_;
    
        bless {
            incr_nest    => 0,
            incr_text    => undef,
            incr_parsing => 0,
            incr_p       => 0,
        }, $class;
    }
    
    
    sub incr_parse {
        my ( $self, $coder, $text ) = @_;
    
        $self->{incr_text} = '' unless ( defined $self->{incr_text} );
    
        if ( defined $text ) {
            if ( utf8::is_utf8( $text ) and !utf8::is_utf8( $self->{incr_text} ) ) {
                utf8::upgrade( $self->{incr_text} ) ;
                utf8::decode( $self->{incr_text} ) ;
            }
            $self->{incr_text} .= $text;
        }
    
    
        my $max_size = $coder->get_max_size;
    
        if ( defined wantarray ) {
    
            $self->{incr_mode} = INCR_M_WS unless defined $self->{incr_mode};
    
            if ( wantarray ) {
                my @ret;
    
                $self->{incr_parsing} = 1;
    
                do {
                    push @ret, $self->_incr_parse( $coder, $self->{incr_text} );
    
                    unless ( !$self->{incr_nest} and $self->{incr_mode} == INCR_M_JSON ) {
                        $self->{incr_mode} = INCR_M_WS if $self->{incr_mode} != INCR_M_STR;
                    }
    
                } until ( length $self->{incr_text} >= $self->{incr_p} );
    
                $self->{incr_parsing} = 0;
    
                return @ret;
            }
            else { # in scalar context
                $self->{incr_parsing} = 1;
                my $obj = $self->_incr_parse( $coder, $self->{incr_text} );
                $self->{incr_parsing} = 0 if defined $obj; # pointed by Martin J. Evans
                return $obj ? $obj : undef; # $obj is an empty string, parsing was completed.
            }
    
        }
    
    }
    
    
    sub _incr_parse {
        my ( $self, $coder, $text, $skip ) = @_;
        my $p = $self->{incr_p};
        my $restore = $p;
    
        my @obj;
        my $len = length $text;
    
        if ( $self->{incr_mode} == INCR_M_WS ) {
            while ( $len > $p ) {
                my $s = substr( $text, $p, 1 );
                $p++ and next if ( 0x20 >= unpack($unpack_format, $s) );
                $self->{incr_mode} = INCR_M_JSON;
                last;
           }
        }
    
        while ( $len > $p ) {
            my $s = substr( $text, $p++, 1 );
    
            if ( $s eq '"' ) {
                if (substr( $text, $p - 2, 1 ) eq '\\' ) {
                    next;
                }
    
                if ( $self->{incr_mode} != INCR_M_STR  ) {
                    $self->{incr_mode} = INCR_M_STR;
                }
                else {
                    $self->{incr_mode} = INCR_M_JSON;
                    unless ( $self->{incr_nest} ) {
                        last;
                    }
                }
            }
    
            if ( $self->{incr_mode} == INCR_M_JSON ) {
    
                if ( $s eq '[' or $s eq '{' ) {
                    if ( ++$self->{incr_nest} > $coder->get_max_depth ) {
                        Carp::croak('json text or perl structure exceeds maximum nesting level (max_depth set too low?)');
                    }
                }
                elsif ( $s eq ']' or $s eq '}' ) {
                    last if ( --$self->{incr_nest} <= 0 );
                }
                elsif ( $s eq '#' ) {
                    while ( $len > $p ) {
                        last if substr( $text, $p++, 1 ) eq "\n";
                    }
                }
    
            }
    
        }
    
        $self->{incr_p} = $p;
    
        return if ( $self->{incr_mode} == INCR_M_STR and not $self->{incr_nest} );
        return if ( $self->{incr_mode} == INCR_M_JSON and $self->{incr_nest} > 0 );
    
        return '' unless ( length substr( $self->{incr_text}, 0, $p ) );
    
        local $Carp::CarpLevel = 2;
    
        $self->{incr_p} = $restore;
        $self->{incr_c} = $p;
    
        my ( $obj, $tail ) = $coder->PP_decode_json( substr( $self->{incr_text}, 0, $p ), 0x10000001 );
    
        $self->{incr_text} = substr( $self->{incr_text}, $p );
        $self->{incr_p} = 0;
    
        return $obj || '';
    }
    
    
    sub incr_text {
        if ( $_[0]->{incr_parsing} ) {
            Carp::croak("incr_text can not be called when the incremental parser already started parsing");
        }
        $_[0]->{incr_text};
    }
    
    
    sub incr_skip {
        my $self  = shift;
        $self->{incr_text} = substr( $self->{incr_text}, $self->{incr_c} );
        $self->{incr_p} = 0;
    }
    
    
    sub incr_reset {
        my $self = shift;
        $self->{incr_text}    = undef;
        $self->{incr_p}       = 0;
        $self->{incr_mode}    = 0;
        $self->{incr_nest}    = 0;
        $self->{incr_parsing} = 0;
    }
    
    ###############################
    
    
    1;
    __END__
    =pod
    
    =head1 NAME
    
    JSON::PP - JSON::XS compatible pure-Perl module.
    
    =head1 SYNOPSIS
    
     use JSON::PP;
    
     # exported functions, they croak on error
     # and expect/generate UTF-8
    
     $utf8_encoded_json_text = encode_json $perl_hash_or_arrayref;
     $perl_hash_or_arrayref  = decode_json $utf8_encoded_json_text;
    
     # OO-interface
    
     $coder = JSON::PP->new->ascii->pretty->allow_nonref;
     
     $json_text   = $json->encode( $perl_scalar );
     $perl_scalar = $json->decode( $json_text );
     
     $pretty_printed = $json->pretty->encode( $perl_scalar ); # pretty-printing
     
     # Note that JSON version 2.0 and above will automatically use
     # JSON::XS or JSON::PP, so you should be able to just:
     
     use JSON;
    
    
    =head1 VERSION
    
        2.27300
    
    L<JSON::XS> 2.27 (~2.30) compatible.
    
    =head1 NOTE
    
    JSON::PP had been inculded in JSON distribution (CPAN module).
    It was a perl core module in Perl 5.14.
    
    =head1 DESCRIPTION
    
    This module is L<JSON::XS> compatible pure Perl module.
    (Perl 5.8 or later is recommended)
    
    JSON::XS is the fastest and most proper JSON module on CPAN.
    It is written by Marc Lehmann in C, so must be compiled and
    installed in the used environment.
    
    JSON::PP is a pure-Perl module and has compatibility to JSON::XS.
    
    
    =head2 FEATURES
    
    =over
    
    =item * correct unicode handling
    
    This module knows how to handle Unicode (depending on Perl version).
    
    See to L<JSON::XS/A FEW NOTES ON UNICODE AND PERL> and L<UNICODE HANDLING ON PERLS>.
    
    
    =item * round-trip integrity
    
    When you serialise a perl data structure using only data types supported
    by JSON and Perl, the deserialised data structure is identical on the Perl
    level. (e.g. the string "2.0" doesn't suddenly become "2" just because
    it looks like a number). There I<are> minor exceptions to this, read the
    MAPPING section below to learn about those.
    
    
    =item * strict checking of JSON correctness
    
    There is no guessing, no generating of illegal JSON texts by default,
    and only JSON is accepted as input by default (the latter is a security feature).
    But when some options are set, loose chcking features are available.
    
    =back
    
    =head1 FUNCTIONAL INTERFACE
    
    Some documents are copied and modified from L<JSON::XS/FUNCTIONAL INTERFACE>.
    
    =head2 encode_json
    
        $json_text = encode_json $perl_scalar
    
    Converts the given Perl data structure to a UTF-8 encoded, binary string.
    
    This function call is functionally identical to:
    
        $json_text = JSON::PP->new->utf8->encode($perl_scalar)
    
    =head2 decode_json
    
        $perl_scalar = decode_json $json_text
    
    The opposite of C<encode_json>: expects an UTF-8 (binary) string and tries
    to parse that as an UTF-8 encoded JSON text, returning the resulting
    reference.
    
    This function call is functionally identical to:
    
        $perl_scalar = JSON::PP->new->utf8->decode($json_text)
    
    =head2 JSON::PP::is_bool
    
        $is_boolean = JSON::PP::is_bool($scalar)
    
    Returns true if the passed scalar represents either JSON::PP::true or
    JSON::PP::false, two constants that act like C<1> and C<0> respectively
    and are also used to represent JSON C<true> and C<false> in Perl strings.
    
    =head2 JSON::PP::true
    
    Returns JSON true value which is blessed object.
    It C<isa> JSON::PP::Boolean object.
    
    =head2 JSON::PP::false
    
    Returns JSON false value which is blessed object.
    It C<isa> JSON::PP::Boolean object.
    
    =head2 JSON::PP::null
    
    Returns C<undef>.
    
    See L<MAPPING>, below, for more information on how JSON values are mapped to
    Perl.
    
    
    =head1 HOW DO I DECODE A DATA FROM OUTER AND ENCODE TO OUTER
    
    This section supposes that your perl vresion is 5.8 or later.
    
    If you know a JSON text from an outer world - a network, a file content, and so on,
    is encoded in UTF-8, you should use C<decode_json> or C<JSON> module object
    with C<utf8> enable. And the decoded result will contain UNICODE characters.
    
      # from network
      my $json        = JSON::PP->new->utf8;
      my $json_text   = CGI->new->param( 'json_data' );
      my $perl_scalar = $json->decode( $json_text );
      
      # from file content
      local $/;
      open( my $fh, '<', 'json.data' );
      $json_text   = <$fh>;
      $perl_scalar = decode_json( $json_text );
    
    If an outer data is not encoded in UTF-8, firstly you should C<decode> it.
    
      use Encode;
      local $/;
      open( my $fh, '<', 'json.data' );
      my $encoding = 'cp932';
      my $unicode_json_text = decode( $encoding, <$fh> ); # UNICODE
      
      # or you can write the below code.
      #
      # open( my $fh, "<:encoding($encoding)", 'json.data' );
      # $unicode_json_text = <$fh>;
    
    In this case, C<$unicode_json_text> is of course UNICODE string.
    So you B<cannot> use C<decode_json> nor C<JSON> module object with C<utf8> enable.
    Instead of them, you use C<JSON> module object with C<utf8> disable.
    
      $perl_scalar = $json->utf8(0)->decode( $unicode_json_text );
    
    Or C<encode 'utf8'> and C<decode_json>:
    
      $perl_scalar = decode_json( encode( 'utf8', $unicode_json_text ) );
      # this way is not efficient.
    
    And now, you want to convert your C<$perl_scalar> into JSON data and
    send it to an outer world - a network or a file content, and so on.
    
    Your data usually contains UNICODE strings and you want the converted data to be encoded
    in UTF-8, you should use C<encode_json> or C<JSON> module object with C<utf8> enable.
    
      print encode_json( $perl_scalar ); # to a network? file? or display?
      # or
      print $json->utf8->encode( $perl_scalar );
    
    If C<$perl_scalar> does not contain UNICODE but C<$encoding>-encoded strings
    for some reason, then its characters are regarded as B<latin1> for perl
    (because it does not concern with your $encoding).
    You B<cannot> use C<encode_json> nor C<JSON> module object with C<utf8> enable.
    Instead of them, you use C<JSON> module object with C<utf8> disable.
    Note that the resulted text is a UNICODE string but no problem to print it.
    
      # $perl_scalar contains $encoding encoded string values
      $unicode_json_text = $json->utf8(0)->encode( $perl_scalar );
      # $unicode_json_text consists of characters less than 0x100
      print $unicode_json_text;
    
    Or C<decode $encoding> all string values and C<encode_json>:
    
      $perl_scalar->{ foo } = decode( $encoding, $perl_scalar->{ foo } );
      # ... do it to each string values, then encode_json
      $json_text = encode_json( $perl_scalar );
    
    This method is a proper way but probably not efficient.
    
    See to L<Encode>, L<perluniintro>.
    
    
    =head1 METHODS
    
    Basically, check to L<JSON> or L<JSON::XS>.
    
    =head2 new
    
        $json = JSON::PP->new
    
    Rturns a new JSON::PP object that can be used to de/encode JSON
    strings.
    
    All boolean flags described below are by default I<disabled>.
    
    The mutators for flags all return the JSON object again and thus calls can
    be chained:
    
       my $json = JSON::PP->new->utf8->space_after->encode({a => [1,2]})
       => {"a": [1, 2]}
    
    =head2 ascii
    
        $json = $json->ascii([$enable])
        
        $enabled = $json->get_ascii
    
    If $enable is true (or missing), then the encode method will not generate characters outside
    the code range 0..127. Any Unicode characters outside that range will be escaped using either
    a single \uXXXX or a double \uHHHH\uLLLLL escape sequence, as per RFC4627.
    (See to L<JSON::XS/OBJECT-ORIENTED INTERFACE>).
    
    In Perl 5.005, there is no character having high value (more than 255).
    See to L<UNICODE HANDLING ON PERLS>.
    
    If $enable is false, then the encode method will not escape Unicode characters unless
    required by the JSON syntax or other flags. This results in a faster and more compact format.
    
      JSON::PP->new->ascii(1)->encode([chr 0x10401])
      => ["\ud801\udc01"]
    
    =head2 latin1
    
        $json = $json->latin1([$enable])
        
        $enabled = $json->get_latin1
    
    If $enable is true (or missing), then the encode method will encode the resulting JSON
    text as latin1 (or iso-8859-1), escaping any characters outside the code range 0..255.
    
    If $enable is false, then the encode method will not escape Unicode characters
    unless required by the JSON syntax or other flags.
    
      JSON::XS->new->latin1->encode (["\x{89}\x{abc}"]
      => ["\x{89}\\u0abc"]    # (perl syntax, U+abc escaped, U+89 not)
    
    See to L<UNICODE HANDLING ON PERLS>.
    
    =head2 utf8
    
        $json = $json->utf8([$enable])
        
        $enabled = $json->get_utf8
    
    If $enable is true (or missing), then the encode method will encode the JSON result
    into UTF-8, as required by many protocols, while the decode method expects to be handled
    an UTF-8-encoded string. Please note that UTF-8-encoded strings do not contain any
    characters outside the range 0..255, they are thus useful for bytewise/binary I/O.
    
    (In Perl 5.005, any character outside the range 0..255 does not exist.
    See to L<UNICODE HANDLING ON PERLS>.)
    
    In future versions, enabling this option might enable autodetection of the UTF-16 and UTF-32
    encoding families, as described in RFC4627.
    
    If $enable is false, then the encode method will return the JSON string as a (non-encoded)
    Unicode string, while decode expects thus a Unicode string. Any decoding or encoding
    (e.g. to UTF-8 or UTF-16) needs to be done yourself, e.g. using the Encode module.
    
    Example, output UTF-16BE-encoded JSON:
    
      use Encode;
      $jsontext = encode "UTF-16BE", JSON::PP->new->encode ($object);
    
    Example, decode UTF-32LE-encoded JSON:
    
      use Encode;
      $object = JSON::PP->new->decode (decode "UTF-32LE", $jsontext);
    
    
    =head2 pretty
    
        $json = $json->pretty([$enable])
    
    This enables (or disables) all of the C<indent>, C<space_before> and
    C<space_after> flags in one call to generate the most readable
    (or most compact) form possible.
    
    Equivalent to:
    
       $json->indent->space_before->space_after
    
    =head2 indent
    
        $json = $json->indent([$enable])
        
        $enabled = $json->get_indent
    
    The default indent space length is three.
    You can use C<indent_length> to change the length.
    
    =head2 space_before
    
        $json = $json->space_before([$enable])
        
        $enabled = $json->get_space_before
    
    If C<$enable> is true (or missing), then the C<encode> method will add an extra
    optional space before the C<:> separating keys from values in JSON objects.
    
    If C<$enable> is false, then the C<encode> method will not add any extra
    space at those places.
    
    This setting has no effect when decoding JSON texts.
    
    Example, space_before enabled, space_after and indent disabled:
    
       {"key" :"value"}
    
    =head2 space_after
    
        $json = $json->space_after([$enable])
        
        $enabled = $json->get_space_after
    
    If C<$enable> is true (or missing), then the C<encode> method will add an extra
    optional space after the C<:> separating keys from values in JSON objects
    and extra whitespace after the C<,> separating key-value pairs and array
    members.
    
    If C<$enable> is false, then the C<encode> method will not add any extra
    space at those places.
    
    This setting has no effect when decoding JSON texts.
    
    Example, space_before and indent disabled, space_after enabled:
    
       {"key": "value"}
    
    =head2 relaxed
    
        $json = $json->relaxed([$enable])
        
        $enabled = $json->get_relaxed
    
    If C<$enable> is true (or missing), then C<decode> will accept some
    extensions to normal JSON syntax (see below). C<encode> will not be
    affected in anyway. I<Be aware that this option makes you accept invalid
    JSON texts as if they were valid!>. I suggest only to use this option to
    parse application-specific files written by humans (configuration files,
    resource files etc.)
    
    If C<$enable> is false (the default), then C<decode> will only accept
    valid JSON texts.
    
    Currently accepted extensions are:
    
    =over 4
    
    =item * list items can have an end-comma
    
    JSON I<separates> array elements and key-value pairs with commas. This
    can be annoying if you write JSON texts manually and want to be able to
    quickly append elements, so this extension accepts comma at the end of
    such items not just between them:
    
       [
          1,
          2, <- this comma not normally allowed
       ]
       {
          "k1": "v1",
          "k2": "v2", <- this comma not normally allowed
       }
    
    =item * shell-style '#'-comments
    
    Whenever JSON allows whitespace, shell-style comments are additionally
    allowed. They are terminated by the first carriage-return or line-feed
    character, after which more white-space and comments are allowed.
    
      [
         1, # this comment not allowed in JSON
            # neither this one...
      ]
    
    =back
    
    =head2 canonical
    
        $json = $json->canonical([$enable])
        
        $enabled = $json->get_canonical
    
    If C<$enable> is true (or missing), then the C<encode> method will output JSON objects
    by sorting their keys. This is adding a comparatively high overhead.
    
    If C<$enable> is false, then the C<encode> method will output key-value
    pairs in the order Perl stores them (which will likely change between runs
    of the same script).
    
    This option is useful if you want the same data structure to be encoded as
    the same JSON text (given the same overall settings). If it is disabled,
    the same hash might be encoded differently even if contains the same data,
    as key-value pairs have no inherent ordering in Perl.
    
    This setting has no effect when decoding JSON texts.
    
    If you want your own sorting routine, you can give a code referece
    or a subroutine name to C<sort_by>. See to C<JSON::PP OWN METHODS>.
    
    =head2 allow_nonref
    
        $json = $json->allow_nonref([$enable])
        
        $enabled = $json->get_allow_nonref
    
    If C<$enable> is true (or missing), then the C<encode> method can convert a
    non-reference into its corresponding string, number or null JSON value,
    which is an extension to RFC4627. Likewise, C<decode> will accept those JSON
    values instead of croaking.
    
    If C<$enable> is false, then the C<encode> method will croak if it isn't
    passed an arrayref or hashref, as JSON texts must either be an object
    or array. Likewise, C<decode> will croak if given something that is not a
    JSON object or array.
    
       JSON::PP->new->allow_nonref->encode ("Hello, World!")
       => "Hello, World!"
    
    =head2 allow_unknown
    
        $json = $json->allow_unknown ([$enable])
        
        $enabled = $json->get_allow_unknown
    
    If $enable is true (or missing), then "encode" will *not* throw an
    exception when it encounters values it cannot represent in JSON (for
    example, filehandles) but instead will encode a JSON "null" value.
    Note that blessed objects are not included here and are handled
    separately by c<allow_nonref>.
    
    If $enable is false (the default), then "encode" will throw an
    exception when it encounters anything it cannot encode as JSON.
    
    This option does not affect "decode" in any way, and it is
    recommended to leave it off unless you know your communications
    partner.
    
    =head2 allow_blessed
    
        $json = $json->allow_blessed([$enable])
        
        $enabled = $json->get_allow_blessed
    
    If C<$enable> is true (or missing), then the C<encode> method will not
    barf when it encounters a blessed reference. Instead, the value of the
    B<convert_blessed> option will decide whether C<null> (C<convert_blessed>
    disabled or no C<TO_JSON> method found) or a representation of the
    object (C<convert_blessed> enabled and C<TO_JSON> method found) is being
    encoded. Has no effect on C<decode>.
    
    If C<$enable> is false (the default), then C<encode> will throw an
    exception when it encounters a blessed object.
    
    =head2 convert_blessed
    
        $json = $json->convert_blessed([$enable])
        
        $enabled = $json->get_convert_blessed
    
    If C<$enable> is true (or missing), then C<encode>, upon encountering a
    blessed object, will check for the availability of the C<TO_JSON> method
    on the object's class. If found, it will be called in scalar context
    and the resulting scalar will be encoded instead of the object. If no
    C<TO_JSON> method is found, the value of C<allow_blessed> will decide what
    to do.
    
    The C<TO_JSON> method may safely call die if it wants. If C<TO_JSON>
    returns other blessed objects, those will be handled in the same
    way. C<TO_JSON> must take care of not causing an endless recursion cycle
    (== crash) in this case. The name of C<TO_JSON> was chosen because other
    methods called by the Perl core (== not by the user of the object) are
    usually in upper case letters and to avoid collisions with the C<to_json>
    function or method.
    
    This setting does not yet influence C<decode> in any way.
    
    If C<$enable> is false, then the C<allow_blessed> setting will decide what
    to do when a blessed object is found.
    
    =head2 filter_json_object
    
        $json = $json->filter_json_object([$coderef])
    
    When C<$coderef> is specified, it will be called from C<decode> each
    time it decodes a JSON object. The only argument passed to the coderef
    is a reference to the newly-created hash. If the code references returns
    a single scalar (which need not be a reference), this value
    (i.e. a copy of that scalar to avoid aliasing) is inserted into the
    deserialised data structure. If it returns an empty list
    (NOTE: I<not> C<undef>, which is a valid scalar), the original deserialised
    hash will be inserted. This setting can slow down decoding considerably.
    
    When C<$coderef> is omitted or undefined, any existing callback will
    be removed and C<decode> will not change the deserialised hash in any
    way.
    
    Example, convert all JSON objects into the integer 5:
    
       my $js = JSON::PP->new->filter_json_object (sub { 5 });
       # returns [5]
       $js->decode ('[{}]'); # the given subroutine takes a hash reference.
       # throw an exception because allow_nonref is not enabled
       # so a lone 5 is not allowed.
       $js->decode ('{"a":1, "b":2}');
    
    =head2 filter_json_single_key_object
    
        $json = $json->filter_json_single_key_object($key [=> $coderef])
    
    Works remotely similar to C<filter_json_object>, but is only called for
    JSON objects having a single key named C<$key>.
    
    This C<$coderef> is called before the one specified via
    C<filter_json_object>, if any. It gets passed the single value in the JSON
    object. If it returns a single value, it will be inserted into the data
    structure. If it returns nothing (not even C<undef> but the empty list),
    the callback from C<filter_json_object> will be called next, as if no
    single-key callback were specified.
    
    If C<$coderef> is omitted or undefined, the corresponding callback will be
    disabled. There can only ever be one callback for a given key.
    
    As this callback gets called less often then the C<filter_json_object>
    one, decoding speed will not usually suffer as much. Therefore, single-key
    objects make excellent targets to serialise Perl objects into, especially
    as single-key JSON objects are as close to the type-tagged value concept
    as JSON gets (it's basically an ID/VALUE tuple). Of course, JSON does not
    support this in any way, so you need to make sure your data never looks
    like a serialised Perl hash.
    
    Typical names for the single object key are C<__class_whatever__>, or
    C<$__dollars_are_rarely_used__$> or C<}ugly_brace_placement>, or even
    things like C<__class_md5sum(classname)__>, to reduce the risk of clashing
    with real hashes.
    
    Example, decode JSON objects of the form C<< { "__widget__" => <id> } >>
    into the corresponding C<< $WIDGET{<id>} >> object:
    
       # return whatever is in $WIDGET{5}:
       JSON::PP
          ->new
          ->filter_json_single_key_object (__widget__ => sub {
                $WIDGET{ $_[0] }
             })
          ->decode ('{"__widget__": 5')
    
       # this can be used with a TO_JSON method in some "widget" class
       # for serialisation to json:
       sub WidgetBase::TO_JSON {
          my ($self) = @_;
    
          unless ($self->{id}) {
             $self->{id} = ..get..some..id..;
             $WIDGET{$self->{id}} = $self;
          }
    
          { __widget__ => $self->{id} }
       }
    
    =head2 shrink
    
        $json = $json->shrink([$enable])
        
        $enabled = $json->get_shrink
    
    In JSON::XS, this flag resizes strings generated by either
    C<encode> or C<decode> to their minimum size possible.
    It will also try to downgrade any strings to octet-form if possible.
    
    In JSON::PP, it is noop about resizing strings but tries
    C<utf8::downgrade> to the returned string by C<encode>.
    See to L<utf8>.
    
    See to L<JSON::XS/OBJECT-ORIENTED INTERFACE>
    
    =head2 max_depth
    
        $json = $json->max_depth([$maximum_nesting_depth])
        
        $max_depth = $json->get_max_depth
    
    Sets the maximum nesting level (default C<512>) accepted while encoding
    or decoding. If a higher nesting level is detected in JSON text or a Perl
    data structure, then the encoder and decoder will stop and croak at that
    point.
    
    Nesting level is defined by number of hash- or arrayrefs that the encoder
    needs to traverse to reach a given point or the number of C<{> or C<[>
    characters without their matching closing parenthesis crossed to reach a
    given character in a string.
    
    If no argument is given, the highest possible setting will be used, which
    is rarely useful.
    
    See L<JSON::XS/SSECURITY CONSIDERATIONS> for more info on why this is useful.
    
    When a large value (100 or more) was set and it de/encodes a deep nested object/text,
    it may raise a warning 'Deep recursion on subroutin' at the perl runtime phase.
    
    =head2 max_size
    
        $json = $json->max_size([$maximum_string_size])
        
        $max_size = $json->get_max_size
    
    Set the maximum length a JSON text may have (in bytes) where decoding is
    being attempted. The default is C<0>, meaning no limit. When C<decode>
    is called on a string that is longer then this many bytes, it will not
    attempt to decode the string but throw an exception. This setting has no
    effect on C<encode> (yet).
    
    If no argument is given, the limit check will be deactivated (same as when
    C<0> is specified).
    
    See L<JSON::XS/SSECURITY CONSIDERATIONS> for more info on why this is useful.
    
    =head2 encode
    
        $json_text = $json->encode($perl_scalar)
    
    Converts the given Perl data structure (a simple scalar or a reference
    to a hash or array) to its JSON representation. Simple scalars will be
    converted into JSON string or number sequences, while references to arrays
    become JSON arrays and references to hashes become JSON objects. Undefined
    Perl values (e.g. C<undef>) become JSON C<null> values.
    References to the integers C<0> and C<1> are converted into C<true> and C<false>.
    
    =head2 decode
    
        $perl_scalar = $json->decode($json_text)
    
    The opposite of C<encode>: expects a JSON text and tries to parse it,
    returning the resulting simple scalar or reference. Croaks on error.
    
    JSON numbers and strings become simple Perl scalars. JSON arrays become
    Perl arrayrefs and JSON objects become Perl hashrefs. C<true> becomes
    C<1> (C<JSON::true>), C<false> becomes C<0> (C<JSON::false>) and
    C<null> becomes C<undef>.
    
    =head2 decode_prefix
    
        ($perl_scalar, $characters) = $json->decode_prefix($json_text)
    
    This works like the C<decode> method, but instead of raising an exception
    when there is trailing garbage after the first JSON object, it will
    silently stop parsing there and return the number of characters consumed
    so far.
    
       JSON->new->decode_prefix ("[1] the tail")
       => ([], 3)
    
    =head1 INCREMENTAL PARSING
    
    Most of this section are copied and modified from L<JSON::XS/INCREMENTAL PARSING>.
    
    In some cases, there is the need for incremental parsing of JSON texts.
    This module does allow you to parse a JSON stream incrementally.
    It does so by accumulating text until it has a full JSON object, which
    it then can decode. This process is similar to using C<decode_prefix>
    to see if a full JSON object is available, but is much more efficient
    (and can be implemented with a minimum of method calls).
    
    This module will only attempt to parse the JSON text once it is sure it
    has enough text to get a decisive result, using a very simple but
    truly incremental parser. This means that it sometimes won't stop as
    early as the full parser, for example, it doesn't detect parenthese
    mismatches. The only thing it guarantees is that it starts decoding as
    soon as a syntactically valid JSON text has been seen. This means you need
    to set resource limits (e.g. C<max_size>) to ensure the parser will stop
    parsing in the presence if syntax errors.
    
    The following methods implement this incremental parser.
    
    =head2 incr_parse
    
        $json->incr_parse( [$string] ) # void context
        
        $obj_or_undef = $json->incr_parse( [$string] ) # scalar context
        
        @obj_or_empty = $json->incr_parse( [$string] ) # list context
    
    This is the central parsing function. It can both append new text and
    extract objects from the stream accumulated so far (both of these
    functions are optional).
    
    If C<$string> is given, then this string is appended to the already
    existing JSON fragment stored in the C<$json> object.
    
    After that, if the function is called in void context, it will simply
    return without doing anything further. This can be used to add more text
    in as many chunks as you want.
    
    If the method is called in scalar context, then it will try to extract
    exactly I<one> JSON object. If that is successful, it will return this
    object, otherwise it will return C<undef>. If there is a parse error,
    this method will croak just as C<decode> would do (one can then use
    C<incr_skip> to skip the errornous part). This is the most common way of
    using the method.
    
    And finally, in list context, it will try to extract as many objects
    from the stream as it can find and return them, or the empty list
    otherwise. For this to work, there must be no separators between the JSON
    objects or arrays, instead they must be concatenated back-to-back. If
    an error occurs, an exception will be raised as in the scalar context
    case. Note that in this case, any previously-parsed JSON texts will be
    lost.
    
    Example: Parse some JSON arrays/objects in a given string and return them.
    
        my @objs = JSON->new->incr_parse ("[5][7][1,2]");
    
    =head2 incr_text
    
        $lvalue_string = $json->incr_text
    
    This method returns the currently stored JSON fragment as an lvalue, that
    is, you can manipulate it. This I<only> works when a preceding call to
    C<incr_parse> in I<scalar context> successfully returned an object. Under
    all other circumstances you must not call this function (I mean it.
    although in simple tests it might actually work, it I<will> fail under
    real world conditions). As a special exception, you can also call this
    method before having parsed anything.
    
    This function is useful in two cases: a) finding the trailing text after a
    JSON object or b) parsing multiple JSON objects separated by non-JSON text
    (such as commas).
    
        $json->incr_text =~ s/\s*,\s*//;
    
    In Perl 5.005, C<lvalue> attribute is not available.
    You must write codes like the below:
    
        $string = $json->incr_text;
        $string =~ s/\s*,\s*//;
        $json->incr_text( $string );
    
    =head2 incr_skip
    
        $json->incr_skip
    
    This will reset the state of the incremental parser and will remove the
    parsed text from the input buffer. This is useful after C<incr_parse>
    died, in which case the input buffer and incremental parser state is left
    unchanged, to skip the text parsed so far and to reset the parse state.
    
    =head2 incr_reset
    
        $json->incr_reset
    
    This completely resets the incremental parser, that is, after this call,
    it will be as if the parser had never parsed anything.
    
    This is useful if you want ot repeatedly parse JSON objects and want to
    ignore any trailing data, which means you have to reset the parser after
    each successful decode.
    
    See to L<JSON::XS/INCREMENTAL PARSING> for examples.
    
    
    =head1 JSON::PP OWN METHODS
    
    =head2 allow_singlequote
    
        $json = $json->allow_singlequote([$enable])
    
    If C<$enable> is true (or missing), then C<decode> will accept
    JSON strings quoted by single quotations that are invalid JSON
    format.
    
        $json->allow_singlequote->decode({"foo":'bar'});
        $json->allow_singlequote->decode({'foo':"bar"});
        $json->allow_singlequote->decode({'foo':'bar'});
    
    As same as the C<relaxed> option, this option may be used to parse
    application-specific files written by humans.
    
    
    =head2 allow_barekey
    
        $json = $json->allow_barekey([$enable])
    
    If C<$enable> is true (or missing), then C<decode> will accept
    bare keys of JSON object that are invalid JSON format.
    
    As same as the C<relaxed> option, this option may be used to parse
    application-specific files written by humans.
    
        $json->allow_barekey->decode('{foo:"bar"}');
    
    =head2 allow_bignum
    
        $json = $json->allow_bignum([$enable])
    
    If C<$enable> is true (or missing), then C<decode> will convert
    the big integer Perl cannot handle as integer into a L<Math::BigInt>
    object and convert a floating number (any) into a L<Math::BigFloat>.
    
    On the contary, C<encode> converts C<Math::BigInt> objects and C<Math::BigFloat>
    objects into JSON numbers with C<allow_blessed> enable.
    
       $json->allow_nonref->allow_blessed->allow_bignum;
       $bigfloat = $json->decode('2.000000000000000000000000001');
       print $json->encode($bigfloat);
       # => 2.000000000000000000000000001
    
    See to L<JSON::XS/MAPPING> aboout the normal conversion of JSON number.
    
    =head2 loose
    
        $json = $json->loose([$enable])
    
    The unescaped [\x00-\x1f\x22\x2f\x5c] strings are invalid in JSON strings
    and the module doesn't allow to C<decode> to these (except for \x2f).
    If C<$enable> is true (or missing), then C<decode>  will accept these
    unescaped strings.
    
        $json->loose->decode(qq|["abc
                                       def"]|);
    
    See L<JSON::XS/SSECURITY CONSIDERATIONS>.
    
    =head2 escape_slash
    
        $json = $json->escape_slash([$enable])
    
    According to JSON Grammar, I<slash> (U+002F) is escaped. But default
    JSON::PP (as same as JSON::XS) encodes strings without escaping slash.
    
    If C<$enable> is true (or missing), then C<encode> will escape slashes.
    
    =head2 indent_length
    
        $json = $json->indent_length($length)
    
    JSON::XS indent space length is 3 and cannot be changed.
    JSON::PP set the indent space length with the given $length.
    The default is 3. The acceptable range is 0 to 15.
    
    =head2 sort_by
    
        $json = $json->sort_by($function_name)
        $json = $json->sort_by($subroutine_ref)
    
    If $function_name or $subroutine_ref are set, its sort routine are used
    in encoding JSON objects.
    
       $js = $pc->sort_by(sub { $JSON::PP::a cmp $JSON::PP::b })->encode($obj);
       # is($js, q|{"a":1,"b":2,"c":3,"d":4,"e":5,"f":6,"g":7,"h":8,"i":9}|);
    
       $js = $pc->sort_by('own_sort')->encode($obj);
       # is($js, q|{"a":1,"b":2,"c":3,"d":4,"e":5,"f":6,"g":7,"h":8,"i":9}|);
    
       sub JSON::PP::own_sort { $JSON::PP::a cmp $JSON::PP::b }
    
    As the sorting routine runs in the JSON::PP scope, the given
    subroutine name and the special variables C<$a>, C<$b> will begin
    'JSON::PP::'.
    
    If $integer is set, then the effect is same as C<canonical> on.
    
    =head1 INTERNAL
    
    For developers.
    
    =over
    
    =item PP_encode_box
    
    Returns
    
            {
                depth        => $depth,
                indent_count => $indent_count,
            }
    
    
    =item PP_decode_box
    
    Returns
    
            {
                text    => $text,
                at      => $at,
                ch      => $ch,
                len     => $len,
                depth   => $depth,
                encoding      => $encoding,
                is_valid_utf8 => $is_valid_utf8,
            };
    
    =back
    
    =head1 MAPPING
    
    This section is copied from JSON::XS and modified to C<JSON::PP>.
    JSON::XS and JSON::PP mapping mechanisms are almost equivalent.
    
    See to L<JSON::XS/MAPPING>.
    
    =head2 JSON -> PERL
    
    =over 4
    
    =item object
    
    A JSON object becomes a reference to a hash in Perl. No ordering of object
    keys is preserved (JSON does not preserver object key ordering itself).
    
    =item array
    
    A JSON array becomes a reference to an array in Perl.
    
    =item string
    
    A JSON string becomes a string scalar in Perl - Unicode codepoints in JSON
    are represented by the same codepoints in the Perl string, so no manual
    decoding is necessary.
    
    =item number
    
    A JSON number becomes either an integer, numeric (floating point) or
    string scalar in perl, depending on its range and any fractional parts. On
    the Perl level, there is no difference between those as Perl handles all
    the conversion details, but an integer may take slightly less memory and
    might represent more values exactly than floating point numbers.
    
    If the number consists of digits only, C<JSON> will try to represent
    it as an integer value. If that fails, it will try to represent it as
    a numeric (floating point) value if that is possible without loss of
    precision. Otherwise it will preserve the number as a string value (in
    which case you lose roundtripping ability, as the JSON number will be
    re-encoded toa JSON string).
    
    Numbers containing a fractional or exponential part will always be
    represented as numeric (floating point) values, possibly at a loss of
    precision (in which case you might lose perfect roundtripping ability, but
    the JSON number will still be re-encoded as a JSON number).
    
    Note that precision is not accuracy - binary floating point values cannot
    represent most decimal fractions exactly, and when converting from and to
    floating point, C<JSON> only guarantees precision up to but not including
    the leats significant bit.
    
    When C<allow_bignum> is enable, the big integers 
    and the numeric can be optionally converted into L<Math::BigInt> and
    L<Math::BigFloat> objects.
    
    =item true, false
    
    These JSON atoms become C<JSON::PP::true> and C<JSON::PP::false>,
    respectively. They are overloaded to act almost exactly like the numbers
    C<1> and C<0>. You can check wether a scalar is a JSON boolean by using
    the C<JSON::is_bool> function.
    
       print JSON::PP::true . "\n";
        => true
       print JSON::PP::true + 1;
        => 1
    
       ok(JSON::true eq  '1');
       ok(JSON::true == 1);
    
    C<JSON> will install these missing overloading features to the backend modules.
    
    
    =item null
    
    A JSON null atom becomes C<undef> in Perl.
    
    C<JSON::PP::null> returns C<unddef>.
    
    =back
    
    
    =head2 PERL -> JSON
    
    The mapping from Perl to JSON is slightly more difficult, as Perl is a
    truly typeless language, so we can only guess which JSON type is meant by
    a Perl value.
    
    =over 4
    
    =item hash references
    
    Perl hash references become JSON objects. As there is no inherent ordering
    in hash keys (or JSON objects), they will usually be encoded in a
    pseudo-random order that can change between runs of the same program but
    stays generally the same within a single run of a program. C<JSON>
    optionally sort the hash keys (determined by the I<canonical> flag), so
    the same datastructure will serialise to the same JSON text (given same
    settings and version of JSON::XS), but this incurs a runtime overhead
    and is only rarely useful, e.g. when you want to compare some JSON text
    against another for equality.
    
    
    =item array references
    
    Perl array references become JSON arrays.
    
    =item other references
    
    Other unblessed references are generally not allowed and will cause an
    exception to be thrown, except for references to the integers C<0> and
    C<1>, which get turned into C<false> and C<true> atoms in JSON. You can
    also use C<JSON::false> and C<JSON::true> to improve readability.
    
       to_json [\0,JSON::PP::true]      # yields [false,true]
    
    =item JSON::PP::true, JSON::PP::false, JSON::PP::null
    
    These special values become JSON true and JSON false values,
    respectively. You can also use C<\1> and C<\0> directly if you want.
    
    JSON::PP::null returns C<undef>.
    
    =item blessed objects
    
    Blessed objects are not directly representable in JSON. See the
    C<allow_blessed> and C<convert_blessed> methods on various options on
    how to deal with this: basically, you can choose between throwing an
    exception, encoding the reference as if it weren't blessed, or provide
    your own serialiser method.
    
    See to L<convert_blessed>.
    
    =item simple scalars
    
    Simple Perl scalars (any scalar that is not a reference) are the most
    difficult objects to encode: JSON::XS and JSON::PP will encode undefined scalars as
    JSON C<null> values, scalars that have last been used in a string context
    before encoding as JSON strings, and anything else as number value:
    
       # dump as number
       encode_json [2]                      # yields [2]
       encode_json [-3.0e17]                # yields [-3e+17]
       my $value = 5; encode_json [$value]  # yields [5]
    
       # used as string, so dump as string
       print $value;
       encode_json [$value]                 # yields ["5"]
    
       # undef becomes null
       encode_json [undef]                  # yields [null]
    
    You can force the type to be a string by stringifying it:
    
       my $x = 3.1; # some variable containing a number
       "$x";        # stringified
       $x .= "";    # another, more awkward way to stringify
       print $x;    # perl does it for you, too, quite often
    
    You can force the type to be a number by numifying it:
    
       my $x = "3"; # some variable containing a string
       $x += 0;     # numify it, ensuring it will be dumped as a number
       $x *= 1;     # same thing, the choise is yours.
    
    You can not currently force the type in other, less obscure, ways.
    
    Note that numerical precision has the same meaning as under Perl (so
    binary to decimal conversion follows the same rules as in Perl, which
    can differ to other languages). Also, your perl interpreter might expose
    extensions to the floating point numbers of your platform, such as
    infinities or NaN's - these cannot be represented in JSON, and it is an
    error to pass those in.
    
    =item Big Number
    
    When C<allow_bignum> is enable, 
    C<encode> converts C<Math::BigInt> objects and C<Math::BigFloat>
    objects into JSON numbers.
    
    
    =back
    
    =head1 UNICODE HANDLING ON PERLS
    
    If you do not know about Unicode on Perl well,
    please check L<JSON::XS/A FEW NOTES ON UNICODE AND PERL>.
    
    =head2 Perl 5.8 and later
    
    Perl can handle Unicode and the JSON::PP de/encode methods also work properly.
    
        $json->allow_nonref->encode(chr hex 3042);
        $json->allow_nonref->encode(chr hex 12345);
    
    Reuturns C<"\u3042"> and C<"\ud808\udf45"> respectively.
    
        $json->allow_nonref->decode('"\u3042"');
        $json->allow_nonref->decode('"\ud808\udf45"');
    
    Returns UTF-8 encoded strings with UTF8 flag, regarded as C<U+3042> and C<U+12345>.
    
    Note that the versions from Perl 5.8.0 to 5.8.2, Perl built-in C<join> was broken,
    so JSON::PP wraps the C<join> with a subroutine. Thus JSON::PP works slow in the versions.
    
    
    =head2 Perl 5.6
    
    Perl can handle Unicode and the JSON::PP de/encode methods also work.
    
    =head2 Perl 5.005
    
    Perl 5.005 is a byte sementics world -- all strings are sequences of bytes.
    That means the unicode handling is not available.
    
    In encoding,
    
        $json->allow_nonref->encode(chr hex 3042);  # hex 3042 is 12354.
        $json->allow_nonref->encode(chr hex 12345); # hex 12345 is 74565.
    
    Returns C<B> and C<E>, as C<chr> takes a value more than 255, it treats
    as C<$value % 256>, so the above codes are equivalent to :
    
        $json->allow_nonref->encode(chr 66);
        $json->allow_nonref->encode(chr 69);
    
    In decoding,
    
        $json->decode('"\u00e3\u0081\u0082"');
    
    The returned is a byte sequence C<0xE3 0x81 0x82> for UTF-8 encoded
    japanese character (C<HIRAGANA LETTER A>).
    And if it is represented in Unicode code point, C<U+3042>.
    
    Next, 
    
        $json->decode('"\u3042"');
    
    We ordinary expect the returned value is a Unicode character C<U+3042>.
    But here is 5.005 world. This is C<0xE3 0x81 0x82>.
    
        $json->decode('"\ud808\udf45"');
    
    This is not a character C<U+12345> but bytes - C<0xf0 0x92 0x8d 0x85>.
    
    
    =head1 TODO
    
    =over
    
    =item speed
    
    =item memory saving
    
    =back
    
    
    =head1 SEE ALSO
    
    Most of the document are copied and modified from JSON::XS doc.
    
    L<JSON::XS>
    
    RFC4627 (L<http://www.ietf.org/rfc/rfc4627.txt>)
    
    =head1 AUTHOR
    
    Makamaka Hannyaharamitu, E<lt>makamaka[at]cpan.orgE<gt>
    
    
    =head1 COPYRIGHT AND LICENSE
    
    Copyright 2007-2014 by Makamaka Hannyaharamitu
    
    This library is free software; you can redistribute it and/or modify
    it under the same terms as Perl itself. 
    
    =cut
  JSON_PP
  
  $fatpacked{"JSON/PP/Boolean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_PP_BOOLEAN';
    =head1 NAME
    
    JSON::PP::Boolean - dummy module providing JSON::PP::Boolean
    
    =head1 SYNOPSIS
    
     # do not "use" yourself
    
    =head1 DESCRIPTION
    
    This module exists only to provide overload resolution for Storable and similar modules. See
    L<JSON::PP> for more info about this class.
    
    =cut
    
    use JSON::PP ();
    use strict;
    
    1;
    
    =head1 AUTHOR
    
    This idea is from L<JSON::XS::Boolean> written by Marc Lehmann <schmorp[at]schmorp.de>
    
    =cut
    
  JSON_PP_BOOLEAN
  
  $fatpacked{"Module/CPANfile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE';
    package Module::CPANfile;
    use strict;
    use warnings;
    use Cwd;
    use Carp ();
    use Module::CPANfile::Environment;
    use Module::CPANfile::Requirement;
    
    our $VERSION = '1.1000';
    
    sub new {
        my($class, $file) = @_;
        bless {}, $class;
    }
    
    sub load {
        my($proto, $file) = @_;
    
        my $self = ref $proto ? $proto : $proto->new;
        $self->parse($file || Cwd::abs_path('cpanfile'));
        $self;
    }
    
    sub save {
        my($self, $path) = @_;
    
        open my $out, ">", $path or die "$path: $!";
        print {$out} $self->to_string;
    }
    
    sub parse {
        my($self, $file) = @_;
    
        my $code = do {
            open my $fh, "<", $file or die "$file: $!";
            join '', <$fh>;
        };
    
        my $env = Module::CPANfile::Environment->new($file);
        $env->parse($code) or die $@;
    
        $self->{_mirrors} = $env->mirrors;
        $self->{_prereqs} = $env->prereqs;
    }
    
    sub from_prereqs {
        my($proto, $prereqs) = @_;
    
        my $self = $proto->new;
        $self->{_prereqs} = Module::CPANfile::Prereqs->from_cpan_meta($prereqs);
    
        $self;
    }
    
    sub mirrors {
        my $self = shift;
        $self->{_mirrors} || [];
    }
    
    sub features {
        my $self = shift;
        map $self->feature($_), $self->{_prereqs}->identifiers;
    }
    
    sub feature {
        my($self, $identifier) = @_;
        $self->{_prereqs}->feature($identifier);
    }
    
    sub prereq { shift->prereqs }
    
    sub prereqs {
        my $self = shift;
        $self->{_prereqs}->as_cpan_meta;
    }
    
    sub merged_requirements {
        my $self = shift;
        $self->{_prereqs}->merged_requirements;
    }
    
    sub effective_prereqs {
        my($self, $features) = @_;
        $self->prereqs_with(@{$features || []});
    }
    
    sub prereqs_with {
        my($self, @feature_identifiers) = @_;
    
        my $prereqs = $self->prereqs;
        my @others = map { $self->feature($_)->prereqs } @feature_identifiers;
    
        $prereqs->with_merged_prereqs(\@others);
    }
    
    sub prereq_specs {
        my $self = shift;
        $self->prereqs->as_string_hash;
    }
    
    sub prereq_for_module {
        my($self, $module) = @_;
        $self->{_prereqs}->find($module);
    }
    
    sub options_for_module {
        my($self, $module) = @_;
        my $prereq = $self->prereq_for_module($module) or return;
        $prereq->requirement->options;
    }
    
    sub merge_meta {
        my($self, $file, $version) = @_;
    
        require CPAN::Meta;
    
        $version ||= $file =~ /\.yml$/ ? '1.4' : '2';
    
        my $prereq = $self->prereqs;
    
        my $meta = CPAN::Meta->load_file($file);
        my $prereqs_hash = $prereq->with_merged_prereqs($meta->effective_prereqs)->as_string_hash;
        my $struct = { %{$meta->as_struct}, prereqs => $prereqs_hash };
    
        CPAN::Meta->new($struct)->save($file, { version => $version });
    }
    
    sub _dump {
        my $str = shift;
        require Data::Dumper;
        chomp(my $value = Data::Dumper->new([$str])->Terse(1)->Dump);
        $value;
    }
    
    sub to_string {
        my($self, $include_empty) = @_;
    
        my $mirrors = $self->mirrors;
        my $prereqs = $self->prereq_specs;
    
        my $code = '';
        $code .= $self->_dump_mirrors($mirrors);
        $code .= $self->_dump_prereqs($prereqs, $include_empty);
    
        for my $feature ($self->features) {
            $code .= sprintf "feature %s, %s => sub {\n", _dump($feature->{identifier}), _dump($feature->{description});
            $code .= $self->_dump_prereqs($feature->{spec}, $include_empty, 4);
            $code .= "}\n\n";
        }
    
        $code =~ s/\n+$/\n/s;
        $code;
    }
    
    sub _dump_mirrors {
        my($self, $mirrors) = @_;
    
        my $code = "";
    
        for my $url (@$mirrors) {
            $code .= "mirror '$url';\n";
        }
    
        $code =~ s/\n+$/\n/s;
        $code;
    }
    
    sub _dump_prereqs {
        my($self, $prereqs, $include_empty, $base_indent) = @_;
    
        my $code = '';
        for my $phase (qw(runtime configure build test develop)) {
            my $indent = $phase eq 'runtime' ? '' : '    ';
            $indent = (' ' x ($base_indent || 0)) . $indent;
    
            my($phase_code, $requirements);
            $phase_code .= "on $phase => sub {\n" unless $phase eq 'runtime';
    
            for my $type (qw(requires recommends suggests conflicts)) {
                for my $mod (sort keys %{$prereqs->{$phase}{$type}}) {
                    my $ver = $prereqs->{$phase}{$type}{$mod};
                    $phase_code .= $ver eq '0'
                                 ? "${indent}$type '$mod';\n"
                                 : "${indent}$type '$mod', '$ver';\n";
                    $requirements++;
                }
            }
    
            $phase_code .= "\n" unless $requirements;
            $phase_code .= "};\n" unless $phase eq 'runtime';
    
            $code .= $phase_code . "\n" if $requirements or $include_empty;
        }
    
        $code =~ s/\n+$/\n/s;
        $code;
    }
    
    1;
    
    __END__
    
    =head1 NAME
    
    Module::CPANfile - Parse cpanfile
    
    =head1 SYNOPSIS
    
      use Module::CPANfile;
    
      my $file = Module::CPANfile->load("cpanfile");
      my $prereqs = $file->prereqs; # CPAN::Meta::Prereqs object
    
      my @features = $file->features; # CPAN::Meta::Feature objects
      my $merged_prereqs = $file->prereqs_with(@identifiers); # CPAN::Meta::Prereqs
    
      $file->merge_meta('MYMETA.json');
    
    =head1 DESCRIPTION
    
    Module::CPANfile is a tool to handle L<cpanfile> format to load application
    specific dependencies, not just for CPAN distributions.
    
    =head1 METHODS
    
    =over 4
    
    =item load
    
      $file = Module::CPANfile->load;
      $file = Module::CPANfile->load('cpanfile');
    
    Load and parse a cpanfile. By default it tries to load C<cpanfile> in
    the current directory, unless you pass the path to its argument.
    
    =item from_prereqs
    
      $file = Module::CPANfile->from_prereqs({
        runtime => { requires => { DBI => '1.000' } },
      });
    
    Creates a new Module::CPANfile object from prereqs hash you can get
    via L<CPAN::Meta>'s C<prereqs>, or L<CPAN::Meta::Prereqs>'
    C<as_string_hash>.
    
      # read MYMETA, then feed the prereqs to create Module::CPANfile
      my $meta = CPAN::Meta->load_file('MYMETA.json');
      my $file = Module::CPANfile->from_prereqs($meta->prereqs);
    
      # load cpanfile, then recreate it with round-trip
      my $file = Module::CPANfile->load('cpanfile');
      $file = Module::CPANfile->from_prereqs($file->prereq_specs);
                                        # or $file->prereqs->as_string_hash
    
    =item prereqs
    
    Returns L<CPAN::Meta::Prereqs> object out of the parsed cpanfile.
    
    =item prereq_specs
    
    Returns a hash reference that should be passed to C<< CPAN::Meta::Prereqs->new >>.
    
    =item features
    
    Returns a list of features available in the cpanfile as L<CPAN::Meta::Feature>.
    
    =item prereqs_with(@identifiers), effective_prereqs(\@identifiers)
    
    Returns L<CPAN::Meta::Prereqs> object, with merged prereqs for
    features identified with the C<@identifiers>.
    
    =item to_string($include_empty)
    
      $file->to_string;
      $file->to_string(1);
    
    Returns a canonical string (code) representation for cpanfile. Useful
    if you want to convert L<CPAN::Meta::Prereqs> to a new cpanfile.
    
      # read MYMETA's prereqs and print cpanfile representation of it
      my $meta = CPAN::Meta->load_file('MYMETA.json');
      my $file = Module::CPANfile->from_prereqs($meta->prereqs);
      print $file->to_string;
    
    By default, it omits the phase where there're no modules
    registered. If you pass the argument of a true value, it will print
    them as well.
    
    =item save
    
      $file->save('cpanfile');
    
    Saves the currently loaded prereqs as a new C<cpanfile> by calling
    C<to_string>. Beware B<this method will overwrite the existing
    cpanfile without any warning or backup>. Taking a backup or giving
    warnings to users is a caller's responsibility.
    
      # Read MYMETA.json and creates a new cpanfile
      my $meta = CPAN::Meta->load_file('MYMETA.json');
      my $file = Module::CPANfile->from_prereqs($meta->prereqs);
      $file->save('cpanfile');
    
    =item merge_meta
    
      $file->merge_meta('META.yml');
      $file->merge_meta('MYMETA.json', '2.0');
    
    Merge the effective prereqs with Meta specification loaded from the
    given META file, using CPAN::Meta. You can specify the META spec
    version in the second argument, which defaults to 1.4 in case the
    given file is YAML, and 2 if it is JSON.
    
    =back
    
    =head1 AUTHOR
    
    Tatsuhiko Miyagawa
    
    =head1 SEE ALSO
    
    L<cpanfile>, L<CPAN::Meta>, L<CPAN::Meta::Spec>
    
    =cut
  MODULE_CPANFILE
  
  $fatpacked{"Module/CPANfile/Environment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE_ENVIRONMENT';
    package Module::CPANfile::Environment;
    use strict;
    use warnings;
    use Module::CPANfile::Prereqs;
    use Carp ();
    
    my @bindings = qw(
        on requires recommends suggests conflicts
        feature
        osname
        mirror
        configure_requires build_requires test_requires author_requires
    );
    
    my $file_id = 1;
    
    sub new {
        my($class, $file) = @_;
        bless {
            file     => $file,
            phase    => 'runtime', # default phase
            feature  => undef,
            features => {},
            prereqs  => Module::CPANfile::Prereqs->new,
            mirrors  => [],
        }, $class;
    }
    
    sub bind {
        my $self = shift;
        my $pkg = caller;
    
        for my $binding (@bindings) {
            no strict 'refs';
            *{"$pkg\::$binding"} = sub { $self->$binding(@_) };
        }
    }
    
    sub parse {
        my($self, $code) = @_;
    
        my $err;
        {
            local $@;
            $file_id++;
            $self->_evaluate(<<EVAL);
    package Module::CPANfile::Sandbox$file_id;
    no warnings;
    BEGIN { \$_environment->bind }
    
    # line 1 "$self->{file}"
    $code;
    EVAL
            $err = $@;
        }
    
        if ($err) { die "Parsing $self->{file} failed: $err" };
    
        return 1;
    }
    
    sub _evaluate {
        my $_environment = $_[0];
        eval $_[1];
    }
    
    sub prereqs { $_[0]->{prereqs} }
    
    sub mirrors { $_[0]->{mirrors} }
    
    # DSL goes from here
    
    sub on {
        my($self, $phase, $code) = @_;
        local $self->{phase} = $phase;
        $code->();
    }
    
    sub feature {
        my($self, $identifier, $description, $code) = @_;
    
        # shortcut: feature identifier => sub { ... }
        if (@_ == 3 && ref($description) eq 'CODE') {
            $code = $description;
            $description = $identifier;
        }
    
        unless (ref $description eq '' && ref $code eq 'CODE') {
            Carp::croak("Usage: feature 'identifier', 'Description' => sub { ... }");
        }
    
        local $self->{feature} = $identifier;
        $self->prereqs->add_feature($identifier, $description);
    
        $code->();
    }
    
    sub osname { die "TODO" }
    
    sub mirror {
        my($self, $url) = @_;
        push @{$self->{mirrors}}, $url;
    }
    
    sub requirement_for {
        my($self, $module, @args) = @_;
    
        my $requirement = 0;
        $requirement = shift @args if @args % 2;
    
        return Module::CPANfile::Requirement->new(
            name    => $module,
            version => $requirement,
            @args,
        );
    }
    
    sub requires {
        my $self = shift;
        $self->add_prereq(requires => @_);
    }
    
    sub recommends {
        my $self = shift;
        $self->add_prereq(recommends => @_);
    }
    
    sub suggests {
        my $self = shift;
        $self->add_prereq(suggests => @_);
    }
    
    sub conflicts {
        my $self = shift;
        $self->add_prereq(conflicts => @_);
    }
    
    sub add_prereq {
        my($self, $type, $module, @args) = @_;
    
        $self->prereqs->add_prereq(
            feature => $self->{feature},
            phase   => $self->{phase},
            type    => $type,
            module  => $module,
            requirement => $self->requirement_for($module, @args),
        );
    }
    
    # Module::Install compatible shortcuts
    
    sub configure_requires {
        my($self, @args) = @_;
        $self->on(configure => sub { $self->requires(@args) });
    }
    
    sub build_requires {
        my($self, @args) = @_;
        $self->on(build => sub { $self->requires(@args) });
    }
    
    sub test_requires {
        my($self, @args) = @_;
        $self->on(test => sub { $self->requires(@args) });
    }
    
    sub author_requires {
        my($self, @args) = @_;
        $self->on(develop => sub { $self->requires(@args) });
    }
    
    1;
    
  MODULE_CPANFILE_ENVIRONMENT
  
  $fatpacked{"Module/CPANfile/Prereq.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE_PREREQ';
    package Module::CPANfile::Prereq;
    use strict;
    
    sub new {
        my($class, %options) = @_;
        bless \%options, $class;
    }
    
    sub feature { $_[0]->{feature} }
    sub phase   { $_[0]->{phase} }
    sub type    { $_[0]->{type} }
    sub module  { $_[0]->{module} }
    sub requirement { $_[0]->{requirement} }
    
    sub match_feature {
        my($self, $identifier) = @_;
        no warnings 'uninitialized';
        $self->feature eq $identifier;
    }
    
    1;
  MODULE_CPANFILE_PREREQ
  
  $fatpacked{"Module/CPANfile/Prereqs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE_PREREQS';
    package Module::CPANfile::Prereqs;
    use strict;
    use Carp ();
    use CPAN::Meta::Feature;
    use Module::CPANfile::Prereq;
    
    sub from_cpan_meta {
        my($class, $prereqs) = @_;
    
        my $self = $class->new;
    
        for my $phase (keys %$prereqs) {
            for my $type (keys %{ $prereqs->{$phase} }) {
                while (my($module, $requirement) = each %{ $prereqs->{$phase}{$type} }) {
                    $self->add_prereq(
                        phase => $phase,
                        type  => $type,
                        module => $module,
                        requirement => Module::CPANfile::Requirement->new(name => $module, version => $requirement),
                    );
                }
            }
        }
    
        $self;
    }
    
    sub new {
        my $class = shift;
        bless {
            prereqs => [],
            features => {},
        }, $class;
    }
    
    sub add_feature {
        my($self, $identifier, $description) = @_;
        $self->{features}{$identifier} = { description => $description };
    }
    
    sub add_prereq {
        my($self, %args) = @_;
        $self->add( Module::CPANfile::Prereq->new(%args) );
    }
    
    sub add {
        my($self, $prereq) = @_;
        push @{$self->{prereqs}}, $prereq;
    }
    
    sub as_cpan_meta {
        my $self = shift;
        $self->{cpanmeta} ||= $self->build_cpan_meta;
    }
    
    sub build_cpan_meta {
        my($self, $identifier) = @_;
    
        my $prereq_spec = {};
        $self->prereq_each($identifier, sub {
            my $prereq = shift;
            $prereq_spec->{$prereq->phase}{$prereq->type}{$prereq->module} = $prereq->requirement->version;
        });
    
        CPAN::Meta::Prereqs->new($prereq_spec);
    }
    
    sub prereq_each {
        my($self, $identifier, $code) = @_;
    
        for my $prereq (@{$self->{prereqs}}) {
            next unless $prereq->match_feature($identifier);
            $code->($prereq);
        }
    }
    
    sub merged_requirements {
        my $self = shift;
    
        my $reqs = CPAN::Meta::Requirements->new;
        for my $prereq (@{$self->{prereqs}}) {
            $reqs->add_string_requirement($prereq->module, $prereq->requirement->version);
        }
    
        $reqs;
    }
    
    sub find {
        my($self, $module) = @_;
    
        for my $prereq (@{$self->{prereqs}}) {
            return $prereq if $prereq->module eq $module;
        }
    
        return;
    }
    
    sub identifiers {
        my $self = shift;
        keys %{$self->{features}};
    }
    
    sub feature {
        my($self, $identifier) = @_;
    
        my $data = $self->{features}{$identifier}
          or Carp::croak("Unknown feature '$identifier'");
    
        my $prereqs = $self->build_cpan_meta($identifier);
    
        CPAN::Meta::Feature->new($identifier, {
            description => $data->{description},
            prereqs => $prereqs->as_string_hash,
        });
    }
    
    1;
  MODULE_CPANFILE_PREREQS
  
  $fatpacked{"Module/CPANfile/Requirement.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE_REQUIREMENT';
    package Module::CPANfile::Requirement;
    use strict;
    
    sub new {
        my ($class, %args) = @_;
    
        $args{version} ||= 0;
    
        bless +{
            name    => delete $args{name},
            version => delete $args{version},
            options => \%args,
        }, $class;
    }
    
    sub name    { $_[0]->{name} }
    sub version { $_[0]->{version} }
    
    sub options { $_[0]->{options} }
    
    sub has_options {
        keys %{$_[0]->{options}} > 0;
    }
    
    1;
  MODULE_CPANFILE_REQUIREMENT
  
  $fatpacked{"Module/Metadata.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_METADATA';
    # -*- mode: cperl; tab-width: 8; indent-tabs-mode: nil; basic-offset: 2 -*-
    # vim:ts=8:sw=2:et:sta:sts=2
    package Module::Metadata; # git description: v1.000026-12-g9b12bf1
    
    # Adapted from Perl-licensed code originally distributed with
    # Module-Build by Ken Williams
    
    # This module provides routines to gather information about
    # perl modules (assuming this may be expanded in the distant
    # parrot future to look at other types of modules).
    
    sub __clean_eval { eval $_[0] }
    use strict;
    use warnings;
    
    our $VERSION = '1.000027';
    
    use Carp qw/croak/;
    use File::Spec;
    BEGIN {
           # Try really hard to not depend ony any DynaLoaded module, such as IO::File or Fcntl
           eval {
                   require Fcntl; Fcntl->import('SEEK_SET'); 1;
           } or *SEEK_SET = sub { 0 }
    }
    use version 0.87;
    BEGIN {
      if ($INC{'Log/Contextual.pm'}) {
        require "Log/Contextual/WarnLogger.pm"; # Hide from AutoPrereqs
        Log::Contextual->import('log_info',
          '-default_logger' => Log::Contextual::WarnLogger->new({ env_prefix => 'MODULE_METADATA', }),
        );
      } else {
        *log_info = sub (&) { warn $_[0]->() };
      }
    }
    use File::Find qw(find);
    
    my $V_NUM_REGEXP = qr{v?[0-9._]+};  # crudely, a v-string or decimal
    
    my $PKG_FIRST_WORD_REGEXP = qr{ # the FIRST word in a package name
      [a-zA-Z_]                     # the first word CANNOT start with a digit
        (?:
          [\w']?                    # can contain letters, digits, _, or ticks
          \w                        # But, NO multi-ticks or trailing ticks
        )*
    }x;
    
    my $PKG_ADDL_WORD_REGEXP = qr{ # the 2nd+ word in a package name
      \w                           # the 2nd+ word CAN start with digits
        (?:
          [\w']?                   # and can contain letters or ticks
          \w                       # But, NO multi-ticks or trailing ticks
        )*
    }x;
    
    my $PKG_NAME_REGEXP = qr{ # match a package name
      (?: :: )?               # a pkg name can start with arisdottle
      $PKG_FIRST_WORD_REGEXP  # a package word
      (?:
        (?: :: )+             ### arisdottle (allow one or many times)
        $PKG_ADDL_WORD_REGEXP ### a package word
      )*                      # ^ zero, one or many times
      (?:
        ::                    # allow trailing arisdottle
      )?
    }x;
    
    my $PKG_REGEXP  = qr{   # match a package declaration
      ^[\s\{;]*             # intro chars on a line
      package               # the word 'package'
      \s+                   # whitespace
      ($PKG_NAME_REGEXP)    # a package name
      \s*                   # optional whitespace
      ($V_NUM_REGEXP)?        # optional version number
      \s*                   # optional whitesapce
      [;\{]                 # semicolon line terminator or block start (since 5.16)
    }x;
    
    my $VARNAME_REGEXP = qr{ # match fully-qualified VERSION name
      ([\$*])         # sigil - $ or *
      (
        (             # optional leading package name
          (?:::|\')?  # possibly starting like just :: (a la $::VERSION)
          (?:\w+(?:::|\'))*  # Foo::Bar:: ...
        )?
        VERSION
      )\b
    }x;
    
    my $VERS_REGEXP = qr{ # match a VERSION definition
      (?:
        \(\s*$VARNAME_REGEXP\s*\) # with parens
      |
        $VARNAME_REGEXP           # without parens
      )
      \s*
      =[^=~>]  # = but not ==, nor =~, nor =>
    }x;
    
    sub new_from_file {
      my $class    = shift;
      my $filename = File::Spec->rel2abs( shift );
    
      return undef unless defined( $filename ) && -f $filename;
      return $class->_init(undef, $filename, @_);
    }
    
    sub new_from_handle {
      my $class    = shift;
      my $handle   = shift;
      my $filename = shift;
      return undef unless defined($handle) && defined($filename);
      $filename = File::Spec->rel2abs( $filename );
    
      return $class->_init(undef, $filename, @_, handle => $handle);
    
    }
    
    
    sub new_from_module {
      my $class   = shift;
      my $module  = shift;
      my %props   = @_;
    
      $props{inc} ||= \@INC;
      my $filename = $class->find_module_by_name( $module, $props{inc} );
      return undef unless defined( $filename ) && -f $filename;
      return $class->_init($module, $filename, %props);
    }
    
    {
    
      my $compare_versions = sub {
        my ($v1, $op, $v2) = @_;
        $v1 = version->new($v1)
          unless UNIVERSAL::isa($v1,'version');
    
        my $eval_str = "\$v1 $op \$v2";
        my $result   = eval $eval_str;
        log_info { "error comparing versions: '$eval_str' $@" } if $@;
    
        return $result;
      };
    
      my $normalize_version = sub {
        my ($version) = @_;
        if ( $version =~ /[=<>!,]/ ) { # logic, not just version
          # take as is without modification
        }
        elsif ( ref $version eq 'version' ) { # version objects
          $version = $version->is_qv ? $version->normal : $version->stringify;
        }
        elsif ( $version =~ /^[^v][^.]*\.[^.]+\./ ) { # no leading v, multiple dots
          # normalize string tuples without "v": "1.2.3" -> "v1.2.3"
          $version = "v$version";
        }
        else {
          # leave alone
        }
        return $version;
      };
    
      # separate out some of the conflict resolution logic
    
      my $resolve_module_versions = sub {
        my $packages = shift;
    
        my( $file, $version );
        my $err = '';
          foreach my $p ( @$packages ) {
            if ( defined( $p->{version} ) ) {
              if ( defined( $version ) ) {
                if ( $compare_versions->( $version, '!=', $p->{version} ) ) {
                  $err .= "  $p->{file} ($p->{version})\n";
                } else {
                  # same version declared multiple times, ignore
                }
              } else {
                $file    = $p->{file};
                $version = $p->{version};
              }
            }
          $file ||= $p->{file} if defined( $p->{file} );
        }
    
        if ( $err ) {
          $err = "  $file ($version)\n" . $err;
        }
    
        my %result = (
          file    => $file,
          version => $version,
          err     => $err
        );
    
        return \%result;
      };
    
      sub provides {
        my $class = shift;
    
        croak "provides() requires key/value pairs \n" if @_ % 2;
        my %args = @_;
    
        croak "provides() takes only one of 'dir' or 'files'\n"
          if $args{dir} && $args{files};
    
        croak "provides() requires a 'version' argument"
          unless defined $args{version};
    
        croak "provides() does not support version '$args{version}' metadata"
            unless grep { $args{version} eq $_ } qw/1.4 2/;
    
        $args{prefix} = 'lib' unless defined $args{prefix};
    
        my $p;
        if ( $args{dir} ) {
          $p = $class->package_versions_from_directory($args{dir});
        }
        else {
          croak "provides() requires 'files' to be an array reference\n"
            unless ref $args{files} eq 'ARRAY';
          $p = $class->package_versions_from_directory($args{files});
        }
    
        # Now, fix up files with prefix
        if ( length $args{prefix} ) { # check in case disabled with q{}
          $args{prefix} =~ s{/$}{};
          for my $v ( values %$p ) {
            $v->{file} = "$args{prefix}/$v->{file}";
          }
        }
    
        return $p
      }
    
      sub package_versions_from_directory {
        my ( $class, $dir, $files ) = @_;
    
        my @files;
    
        if ( $files ) {
          @files = @$files;
        } else {
          find( {
            wanted => sub {
              push @files, $_ if -f $_ && /\.pm$/;
            },
            no_chdir => 1,
          }, $dir );
        }
    
        # First, we enumerate all packages & versions,
        # separating into primary & alternative candidates
        my( %prime, %alt );
        foreach my $file (@files) {
          my $mapped_filename = File::Spec::Unix->abs2rel( $file, $dir );
          my @path = split( /\//, $mapped_filename );
          (my $prime_package = join( '::', @path )) =~ s/\.pm$//;
    
          my $pm_info = $class->new_from_file( $file );
    
          foreach my $package ( $pm_info->packages_inside ) {
            next if $package eq 'main';  # main can appear numerous times, ignore
            next if $package eq 'DB';    # special debugging package, ignore
            next if grep /^_/, split( /::/, $package ); # private package, ignore
    
            my $version = $pm_info->version( $package );
    
            $prime_package = $package if lc($prime_package) eq lc($package);
            if ( $package eq $prime_package ) {
              if ( exists( $prime{$package} ) ) {
                croak "Unexpected conflict in '$package'; multiple versions found.\n";
              } else {
                $mapped_filename = "$package.pm" if lc("$package.pm") eq lc($mapped_filename);
                $prime{$package}{file} = $mapped_filename;
                $prime{$package}{version} = $version if defined( $version );
              }
            } else {
              push( @{$alt{$package}}, {
                                        file    => $mapped_filename,
                                        version => $version,
                                       } );
            }
          }
        }
    
        # Then we iterate over all the packages found above, identifying conflicts
        # and selecting the "best" candidate for recording the file & version
        # for each package.
        foreach my $package ( keys( %alt ) ) {
          my $result = $resolve_module_versions->( $alt{$package} );
    
          if ( exists( $prime{$package} ) ) { # primary package selected
    
            if ( $result->{err} ) {
            # Use the selected primary package, but there are conflicting
            # errors among multiple alternative packages that need to be
            # reported
              log_info {
                "Found conflicting versions for package '$package'\n" .
                "  $prime{$package}{file} ($prime{$package}{version})\n" .
                $result->{err}
              };
    
            } elsif ( defined( $result->{version} ) ) {
            # There is a primary package selected, and exactly one
            # alternative package
    
            if ( exists( $prime{$package}{version} ) &&
                 defined( $prime{$package}{version} ) ) {
              # Unless the version of the primary package agrees with the
              # version of the alternative package, report a conflict
            if ( $compare_versions->(
                     $prime{$package}{version}, '!=', $result->{version}
                   )
                 ) {
    
                log_info {
                  "Found conflicting versions for package '$package'\n" .
                  "  $prime{$package}{file} ($prime{$package}{version})\n" .
                  "  $result->{file} ($result->{version})\n"
                };
              }
    
            } else {
              # The prime package selected has no version so, we choose to
              # use any alternative package that does have a version
              $prime{$package}{file}    = $result->{file};
              $prime{$package}{version} = $result->{version};
            }
    
            } else {
            # no alt package found with a version, but we have a prime
            # package so we use it whether it has a version or not
            }
    
          } else { # No primary package was selected, use the best alternative
    
            if ( $result->{err} ) {
              log_info {
                "Found conflicting versions for package '$package'\n" .
                $result->{err}
              };
            }
    
            # Despite possible conflicting versions, we choose to record
            # something rather than nothing
            $prime{$package}{file}    = $result->{file};
            $prime{$package}{version} = $result->{version}
              if defined( $result->{version} );
          }
        }
    
        # Normalize versions.  Can't use exists() here because of bug in YAML::Node.
        # XXX "bug in YAML::Node" comment seems irrelevant -- dagolden, 2009-05-18
        for (grep defined $_->{version}, values %prime) {
          $_->{version} = $normalize_version->( $_->{version} );
        }
    
        return \%prime;
      }
    }
    
    
    sub _init {
      my $class    = shift;
      my $module   = shift;
      my $filename = shift;
      my %props = @_;
    
      my $handle = delete $props{handle};
      my( %valid_props, @valid_props );
      @valid_props = qw( collect_pod inc );
      @valid_props{@valid_props} = delete( @props{@valid_props} );
      warn "Unknown properties: @{[keys %props]}\n" if scalar( %props );
    
      my %data = (
        module       => $module,
        filename     => $filename,
        version      => undef,
        packages     => [],
        versions     => {},
        pod          => {},
        pod_headings => [],
        collect_pod  => 0,
    
        %valid_props,
      );
    
      my $self = bless(\%data, $class);
    
      if ( not $handle ) {
        my $filename = $self->{filename};
        open $handle, '<', $filename
          or croak( "Can't open '$filename': $!" );
    
        $self->_handle_bom($handle, $filename);
      }
      $self->_parse_fh($handle);
    
      unless($self->{module} and length($self->{module})) {
        my ($v, $d, $f) = File::Spec->splitpath($self->{filename});
        if($f =~ /\.pm$/) {
          $f =~ s/\..+$//;
          my @candidates = grep /$f$/, @{$self->{packages}};
          $self->{module} = shift(@candidates); # punt
        }
        else {
          if(grep /main/, @{$self->{packages}}) {
            $self->{module} = 'main';
          }
          else {
            $self->{module} = $self->{packages}[0] || '';
          }
        }
      }
    
      $self->{version} = $self->{versions}{$self->{module}}
          if defined( $self->{module} );
    
      return $self;
    }
    
    # class method
    sub _do_find_module {
      my $class   = shift;
      my $module  = shift || croak 'find_module_by_name() requires a package name';
      my $dirs    = shift || \@INC;
    
      my $file = File::Spec->catfile(split( /::/, $module));
      foreach my $dir ( @$dirs ) {
        my $testfile = File::Spec->catfile($dir, $file);
        return [ File::Spec->rel2abs( $testfile ), $dir ]
          if -e $testfile and !-d _;  # For stuff like ExtUtils::xsubpp
        $testfile .= '.pm';
        return [ File::Spec->rel2abs( $testfile ), $dir ]
          if -e $testfile;
      }
      return;
    }
    
    # class method
    sub find_module_by_name {
      my $found = shift()->_do_find_module(@_) or return;
      return $found->[0];
    }
    
    # class method
    sub find_module_dir_by_name {
      my $found = shift()->_do_find_module(@_) or return;
      return $found->[1];
    }
    
    
    # given a line of perl code, attempt to parse it if it looks like a
    # $VERSION assignment, returning sigil, full name, & package name
    sub _parse_version_expression {
      my $self = shift;
      my $line = shift;
    
      my( $sigil, $variable_name, $package);
      if ( $line =~ /$VERS_REGEXP/o ) {
        ( $sigil, $variable_name, $package) = $2 ? ( $1, $2, $3 ) : ( $4, $5, $6 );
        if ( $package ) {
          $package = ($package eq '::') ? 'main' : $package;
          $package =~ s/::$//;
        }
      }
    
      return ( $sigil, $variable_name, $package );
    }
    
    # Look for a UTF-8/UTF-16BE/UTF-16LE BOM at the beginning of the stream.
    # If there's one, then skip it and set the :encoding layer appropriately.
    sub _handle_bom {
      my ($self, $fh, $filename) = @_;
    
      my $pos = tell $fh;
      return unless defined $pos;
    
      my $buf = ' ' x 2;
      my $count = read $fh, $buf, length $buf;
      return unless defined $count and $count >= 2;
    
      my $encoding;
      if ( $buf eq "\x{FE}\x{FF}" ) {
        $encoding = 'UTF-16BE';
      } elsif ( $buf eq "\x{FF}\x{FE}" ) {
        $encoding = 'UTF-16LE';
      } elsif ( $buf eq "\x{EF}\x{BB}" ) {
        $buf = ' ';
        $count = read $fh, $buf, length $buf;
        if ( defined $count and $count >= 1 and $buf eq "\x{BF}" ) {
          $encoding = 'UTF-8';
        }
      }
    
      if ( defined $encoding ) {
        if ( "$]" >= 5.008 ) {
          binmode( $fh, ":encoding($encoding)" );
        }
      } else {
        seek $fh, $pos, SEEK_SET
          or croak( sprintf "Can't reset position to the top of '$filename'" );
      }
    
      return $encoding;
    }
    
    sub _parse_fh {
      my ($self, $fh) = @_;
    
      my( $in_pod, $seen_end, $need_vers ) = ( 0, 0, 0 );
      my( @packages, %vers, %pod, @pod );
      my $package = 'main';
      my $pod_sect = '';
      my $pod_data = '';
      my $in_end = 0;
    
      while (defined( my $line = <$fh> )) {
        my $line_num = $.;
    
        chomp( $line );
    
        # From toke.c : any line that begins by "=X", where X is an alphabetic
        # character, introduces a POD segment.
        my $is_cut;
        if ( $line =~ /^=([a-zA-Z].*)/ ) {
          my $cmd = $1;
          # Then it goes back to Perl code for "=cutX" where X is a non-alphabetic
          # character (which includes the newline, but here we chomped it away).
          $is_cut = $cmd =~ /^cut(?:[^a-zA-Z]|$)/;
          $in_pod = !$is_cut;
        }
    
        if ( $in_pod ) {
    
          if ( $line =~ /^=head[1-4]\s+(.+)\s*$/ ) {
            push( @pod, $1 );
            if ( $self->{collect_pod} && length( $pod_data ) ) {
              $pod{$pod_sect} = $pod_data;
              $pod_data = '';
            }
            $pod_sect = $1;
    
          } elsif ( $self->{collect_pod} ) {
            $pod_data .= "$line\n";
    
          }
    
        } elsif ( $is_cut ) {
    
          if ( $self->{collect_pod} && length( $pod_data ) ) {
            $pod{$pod_sect} = $pod_data;
            $pod_data = '';
          }
          $pod_sect = '';
    
        } else {
    
          # Skip after __END__
          next if $in_end;
    
          # Skip comments in code
          next if $line =~ /^\s*#/;
    
          # Would be nice if we could also check $in_string or something too
          if ($line eq '__END__') {
            $in_end++;
            next;
          }
          last if $line eq '__DATA__';
    
          # parse $line to see if it's a $VERSION declaration
          my( $version_sigil, $version_fullname, $version_package ) =
              index($line, 'VERSION') >= 1
                  ? $self->_parse_version_expression( $line )
                  : ();
    
          if ( $line =~ /$PKG_REGEXP/o ) {
            $package = $1;
            my $version = $2;
            push( @packages, $package ) unless grep( $package eq $_, @packages );
            $need_vers = defined $version ? 0 : 1;
    
            if ( not exists $vers{$package} and defined $version ){
              # Upgrade to a version object.
              my $dwim_version = eval { _dwim_version($version) };
              croak "Version '$version' from $self->{filename} does not appear to be valid:\n$line\n\nThe fatal error was: $@\n"
                  unless defined $dwim_version;  # "0" is OK!
              $vers{$package} = $dwim_version;
            }
    
          # VERSION defined with full package spec, i.e. $Module::VERSION
          } elsif ( $version_fullname && $version_package ) {
            push( @packages, $version_package ) unless grep( $version_package eq $_, @packages );
            $need_vers = 0 if $version_package eq $package;
    
            unless ( defined $vers{$version_package} && length $vers{$version_package} ) {
            $vers{$version_package} = $self->_evaluate_version_line( $version_sigil, $version_fullname, $line );
          }
    
          # first non-comment line in undeclared package main is VERSION
          } elsif ( $package eq 'main' && $version_fullname && !exists($vers{main}) ) {
            $need_vers = 0;
            my $v = $self->_evaluate_version_line( $version_sigil, $version_fullname, $line );
            $vers{$package} = $v;
            push( @packages, 'main' );
    
          # first non-comment line in undeclared package defines package main
          } elsif ( $package eq 'main' && !exists($vers{main}) && $line =~ /\w/ ) {
            $need_vers = 1;
            $vers{main} = '';
            push( @packages, 'main' );
    
          # only keep if this is the first $VERSION seen
          } elsif ( $version_fullname && $need_vers ) {
            $need_vers = 0;
            my $v = $self->_evaluate_version_line( $version_sigil, $version_fullname, $line );
    
            unless ( defined $vers{$package} && length $vers{$package} ) {
              $vers{$package} = $v;
            }
          }
        }
      }
    
      if ( $self->{collect_pod} && length($pod_data) ) {
        $pod{$pod_sect} = $pod_data;
      }
    
      $self->{versions} = \%vers;
      $self->{packages} = \@packages;
      $self->{pod} = \%pod;
      $self->{pod_headings} = \@pod;
    }
    
    {
    my $pn = 0;
    sub _evaluate_version_line {
      my $self = shift;
      my( $sigil, $variable_name, $line ) = @_;
    
      # We compile into a local sub because 'use version' would cause
      # compiletime/runtime issues with local()
      $pn++; # everybody gets their own package
      my $eval = qq{ my \$dummy = q#  Hide from _packages_inside()
        #; package Module::Metadata::_version::p${pn};
        use version;
        sub {
          local $sigil$variable_name;
          $line;
          \$$variable_name
        };
      };
    
      $eval = $1 if $eval =~ m{^(.+)}s;
    
      local $^W;
      # Try to get the $VERSION
      my $vsub = __clean_eval($eval);
      # some modules say $VERSION <equal sign> $Foo::Bar::VERSION, but Foo::Bar isn't
      # installed, so we need to hunt in ./lib for it
      if ( $@ =~ /Can't locate/ && -d 'lib' ) {
        local @INC = ('lib',@INC);
        $vsub = __clean_eval($eval);
      }
      warn "Error evaling version line '$eval' in $self->{filename}: $@\n"
        if $@;
    
      (ref($vsub) eq 'CODE') or
        croak "failed to build version sub for $self->{filename}";
    
      my $result = eval { $vsub->() };
      # FIXME: $eval is not the right thing to print here
      croak "Could not get version from $self->{filename} by executing:\n$eval\n\nThe fatal error was: $@\n"
        if $@;
    
      # Upgrade it into a version object
      my $version = eval { _dwim_version($result) };
    
      # FIXME: $eval is not the right thing to print here
      croak "Version '$result' from $self->{filename} does not appear to be valid:\n$eval\n\nThe fatal error was: $@\n"
        unless defined $version; # "0" is OK!
    
      return $version;
    }
    }
    
    # Try to DWIM when things fail the lax version test in obvious ways
    {
      my @version_prep = (
        # Best case, it just works
        sub { return shift },
    
        # If we still don't have a version, try stripping any
        # trailing junk that is prohibited by lax rules
        sub {
          my $v = shift;
          $v =~ s{([0-9])[a-z-].*$}{$1}i; # 1.23-alpha or 1.23b
          return $v;
        },
    
        # Activestate apparently creates custom versions like '1.23_45_01', which
        # cause version.pm to think it's an invalid alpha.  So check for that
        # and strip them
        sub {
          my $v = shift;
          my $num_dots = () = $v =~ m{(\.)}g;
          my $num_unders = () = $v =~ m{(_)}g;
          my $leading_v = substr($v,0,1) eq 'v';
          if ( ! $leading_v && $num_dots < 2 && $num_unders > 1 ) {
            $v =~ s{_}{}g;
            $num_unders = () = $v =~ m{(_)}g;
          }
          return $v;
        },
    
        # Worst case, try numifying it like we would have before version objects
        sub {
          my $v = shift;
          no warnings 'numeric';
          return 0 + $v;
        },
    
      );
    
      sub _dwim_version {
        my ($result) = shift;
    
        return $result if ref($result) eq 'version';
    
        my ($version, $error);
        for my $f (@version_prep) {
          $result = $f->($result);
          $version = eval { version->new($result) };
          $error ||= $@ if $@; # capture first failure
          last if defined $version;
        }
    
        croak $error unless defined $version;
    
        return $version;
      }
    }
    
    ############################################################
    
    # accessors
    sub name            { $_[0]->{module}            }
    
    sub filename        { $_[0]->{filename}          }
    sub packages_inside { @{$_[0]->{packages}}       }
    sub pod_inside      { @{$_[0]->{pod_headings}}   }
    sub contains_pod    { 0+@{$_[0]->{pod_headings}} }
    
    sub version {
        my $self = shift;
        my $mod  = shift || $self->{module};
        my $vers;
        if ( defined( $mod ) && length( $mod ) &&
             exists( $self->{versions}{$mod} ) ) {
            return $self->{versions}{$mod};
        } else {
            return undef;
        }
    }
    
    sub pod {
        my $self = shift;
        my $sect = shift;
        if ( defined( $sect ) && length( $sect ) &&
             exists( $self->{pod}{$sect} ) ) {
            return $self->{pod}{$sect};
        } else {
            return undef;
        }
    }
    
    sub is_indexable {
      my ($self, $package) = @_;
    
      my @indexable_packages = grep { $_ ne 'main' } $self->packages_inside;
    
      # check for specific package, if provided
      return !! grep { $_ eq $package } @indexable_packages if $package;
    
      # otherwise, check for any indexable packages at all
      return !! @indexable_packages;
    }
    
    1;
    
    =head1 NAME
    
    Module::Metadata - Gather package and POD information from perl module files
    
    =head1 SYNOPSIS
    
      use Module::Metadata;
    
      # information about a .pm file
      my $info = Module::Metadata->new_from_file( $file );
      my $version = $info->version;
    
      # CPAN META 'provides' field for .pm files in a directory
      my $provides = Module::Metadata->provides(
        dir => 'lib', version => 2
      );
    
    =head1 DESCRIPTION
    
    This module provides a standard way to gather metadata about a .pm file through
    (mostly) static analysis and (some) code execution.  When determining the
    version of a module, the C<$VERSION> assignment is C<eval>ed, as is traditional
    in the CPAN toolchain.
    
    =head1 CLASS METHODS
    
    =head2 C<< new_from_file($filename, collect_pod => 1) >>
    
    Constructs a C<Module::Metadata> object given the path to a file.  Returns
    undef if the filename does not exist.
    
    C<collect_pod> is a optional boolean argument that determines whether POD
    data is collected and stored for reference.  POD data is not collected by
    default.  POD headings are always collected.
    
    If the file begins by an UTF-8, UTF-16BE or UTF-16LE byte-order mark, then
    it is skipped before processing, and the content of the file is also decoded
    appropriately starting from perl 5.8.
    
    =head2 C<< new_from_handle($handle, $filename, collect_pod => 1) >>
    
    This works just like C<new_from_file>, except that a handle can be provided
    as the first argument.
    
    Note that there is no validation to confirm that the handle is a handle or
    something that can act like one.  Passing something that isn't a handle will
    cause a exception when trying to read from it.  The C<filename> argument is
    mandatory or undef will be returned.
    
    You are responsible for setting the decoding layers on C<$handle> if
    required.
    
    =head2 C<< new_from_module($module, collect_pod => 1, inc => \@dirs) >>
    
    Constructs a C<Module::Metadata> object given a module or package name.
    Returns undef if the module cannot be found.
    
    In addition to accepting the C<collect_pod> argument as described above,
    this method accepts a C<inc> argument which is a reference to an array of
    directories to search for the module.  If none are given, the default is
    @INC.
    
    If the file that contains the module begins by an UTF-8, UTF-16BE or
    UTF-16LE byte-order mark, then it is skipped before processing, and the
    content of the file is also decoded appropriately starting from perl 5.8.
    
    =head2 C<< find_module_by_name($module, \@dirs) >>
    
    Returns the path to a module given the module or package name. A list
    of directories can be passed in as an optional parameter, otherwise
    @INC is searched.
    
    Can be called as either an object or a class method.
    
    =head2 C<< find_module_dir_by_name($module, \@dirs) >>
    
    Returns the entry in C<@dirs> (or C<@INC> by default) that contains
    the module C<$module>. A list of directories can be passed in as an
    optional parameter, otherwise @INC is searched.
    
    Can be called as either an object or a class method.
    
    =head2 C<< provides( %options ) >>
    
    This is a convenience wrapper around C<package_versions_from_directory>
    to generate a CPAN META C<provides> data structure.  It takes key/value
    pairs.  Valid option keys include:
    
    =over
    
    =item version B<(required)>
    
    Specifies which version of the L<CPAN::Meta::Spec> should be used as
    the format of the C<provides> output.  Currently only '1.4' and '2'
    are supported (and their format is identical).  This may change in
    the future as the definition of C<provides> changes.
    
    The C<version> option is required.  If it is omitted or if
    an unsupported version is given, then C<provides> will throw an error.
    
    =item dir
    
    Directory to search recursively for F<.pm> files.  May not be specified with
    C<files>.
    
    =item files
    
    Array reference of files to examine.  May not be specified with C<dir>.
    
    =item prefix
    
    String to prepend to the C<file> field of the resulting output. This defaults
    to F<lib>, which is the common case for most CPAN distributions with their
    F<.pm> files in F<lib>.  This option ensures the META information has the
    correct relative path even when the C<dir> or C<files> arguments are
    absolute or have relative paths from a location other than the distribution
    root.
    
    =back
    
    For example, given C<dir> of 'lib' and C<prefix> of 'lib', the return value
    is a hashref of the form:
    
      {
        'Package::Name' => {
          version => '0.123',
          file => 'lib/Package/Name.pm'
        },
        'OtherPackage::Name' => ...
      }
    
    =head2 C<< package_versions_from_directory($dir, \@files?) >>
    
    Scans C<$dir> for .pm files (unless C<@files> is given, in which case looks
    for those files in C<$dir> - and reads each file for packages and versions,
    returning a hashref of the form:
    
      {
        'Package::Name' => {
          version => '0.123',
          file => 'Package/Name.pm'
        },
        'OtherPackage::Name' => ...
      }
    
    The C<DB> and C<main> packages are always omitted, as are any "private"
    packages that have leading underscores in the namespace (e.g.
    C<Foo::_private>)
    
    Note that the file path is relative to C<$dir> if that is specified.
    This B<must not> be used directly for CPAN META C<provides>.  See
    the C<provides> method instead.
    
    =head2 C<< log_info (internal) >>
    
    Used internally to perform logging; imported from Log::Contextual if
    Log::Contextual has already been loaded, otherwise simply calls warn.
    
    =head1 OBJECT METHODS
    
    =head2 C<< name() >>
    
    Returns the name of the package represented by this module. If there
    is more than one package, it makes a best guess based on the
    filename. If it's a script (i.e. not a *.pm) the package name is
    'main'.
    
    =head2 C<< version($package) >>
    
    Returns the version as defined by the $VERSION variable for the
    package as returned by the C<name> method if no arguments are
    given. If given the name of a package it will attempt to return the
    version of that package if it is specified in the file.
    
    =head2 C<< filename() >>
    
    Returns the absolute path to the file.
    Note that this file may not actually exist on disk yet, e.g. if the module was read from an in-memory filehandle.
    
    =head2 C<< packages_inside() >>
    
    Returns a list of packages. Note: this is a raw list of packages
    discovered (or assumed, in the case of C<main>).  It is not
    filtered for C<DB>, C<main> or private packages the way the
    C<provides> method does.  Invalid package names are not returned,
    for example "Foo:Bar".  Strange but valid package names are
    returned, for example "Foo::Bar::", and are left up to the caller
    on how to handle.
    
    =head2 C<< pod_inside() >>
    
    Returns a list of POD sections.
    
    =head2 C<< contains_pod() >>
    
    Returns true if there is any POD in the file.
    
    =head2 C<< pod($section) >>
    
    Returns the POD data in the given section.
    
    =head2 C<< is_indexable($package) >> or C<< is_indexable() >>
    
    Returns a boolean indicating whether the package (if provided) or any package
    (otherwise) is eligible for indexing by PAUSE, the Perl Authors Upload Server.
    Note This only checks for valid C<package> declarations, and does not take any
    ownership information into account.
    
    =head1 AUTHOR
    
    Original code from Module::Build::ModuleInfo by Ken Williams
    <kwilliams@cpan.org>, Randy W. Sims <RandyS@ThePierianSpring.org>
    
    Released as Module::Metadata by Matt S Trout (mst) <mst@shadowcat.co.uk> with
    assistance from David Golden (xdg) <dagolden@cpan.org>.
    
    =head1 COPYRIGHT & LICENSE
    
    Original code Copyright (c) 2001-2011 Ken Williams.
    Additional code Copyright (c) 2010-2011 Matt Trout and David Golden.
    All rights reserved.
    
    This library is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.
    
    =cut
  MODULE_METADATA
  
  $fatpacked{"Parse/CPAN/Meta.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARSE_CPAN_META';
    use 5.008001;
    use strict;
    package Parse::CPAN::Meta;
    # ABSTRACT: Parse META.yml and META.json CPAN metadata files
    our $VERSION = '1.4414'; # VERSION
    
    use Exporter;
    use Carp 'croak';
    
    our @ISA = qw/Exporter/;
    our @EXPORT_OK = qw/Load LoadFile/;
    
    sub load_file {
      my ($class, $filename) = @_;
    
      my $meta = _slurp($filename);
    
      if ($filename =~ /\.ya?ml$/) {
        return $class->load_yaml_string($meta);
      }
      elsif ($filename =~ /\.json$/) {
        return $class->load_json_string($meta);
      }
      else {
        $class->load_string($meta); # try to detect yaml/json
      }
    }
    
    sub load_string {
      my ($class, $string) = @_;
      if ( $string =~ /^---/ ) { # looks like YAML
        return $class->load_yaml_string($string);
      }
      elsif ( $string =~ /^\s*\{/ ) { # looks like JSON
        return $class->load_json_string($string);
      }
      else { # maybe doc-marker-free YAML
        return $class->load_yaml_string($string);
      }
    }
    
    sub load_yaml_string {
      my ($class, $string) = @_;
      my $backend = $class->yaml_backend();
      my $data = eval { no strict 'refs'; &{"$backend\::Load"}($string) };
      croak $@ if $@;
      return $data || {}; # in case document was valid but empty
    }
    
    sub load_json_string {
      my ($class, $string) = @_;
      my $data = eval { $class->json_backend()->new->decode($string) };
      croak $@ if $@;
      return $data || {};
    }
    
    sub yaml_backend {
      if (! defined $ENV{PERL_YAML_BACKEND} ) {
        _can_load( 'CPAN::Meta::YAML', 0.011 )
          or croak "CPAN::Meta::YAML 0.011 is not available\n";
        return "CPAN::Meta::YAML";
      }
      else {
        my $backend = $ENV{PERL_YAML_BACKEND};
        _can_load( $backend )
          or croak "Could not load PERL_YAML_BACKEND '$backend'\n";
        $backend->can("Load")
          or croak "PERL_YAML_BACKEND '$backend' does not implement Load()\n";
        return $backend;
      }
    }
    
    sub json_backend {
      if (! $ENV{PERL_JSON_BACKEND} or $ENV{PERL_JSON_BACKEND} eq 'JSON::PP') {
        _can_load( 'JSON::PP' => 2.27103 )
          or croak "JSON::PP 2.27103 is not available\n";
        return 'JSON::PP';
      }
      else {
        _can_load( 'JSON' => 2.5 )
          or croak  "JSON 2.5 is required for " .
                    "\$ENV{PERL_JSON_BACKEND} = '$ENV{PERL_JSON_BACKEND}'\n";
        return "JSON";
      }
    }
    
    sub _slurp {
      require Encode;
      open my $fh, "<:raw", "$_[0]" ## no critic
        or die "can't open $_[0] for reading: $!";
      my $content = do { local $/; <$fh> };
      $content = Encode::decode('UTF-8', $content, Encode::PERLQQ());
      return $content;
    }
      
    sub _can_load {
      my ($module, $version) = @_;
      (my $file = $module) =~ s{::}{/}g;
      $file .= ".pm";
      return 1 if $INC{$file};
      return 0 if exists $INC{$file}; # prior load failed
      eval { require $file; 1 }
        or return 0;
      if ( defined $version ) {
        eval { $module->VERSION($version); 1 }
          or return 0;
      }
      return 1;
    }
    
    # Kept for backwards compatibility only
    # Create an object from a file
    sub LoadFile ($) {
      return Load(_slurp(shift));
    }
    
    # Parse a document from a string.
    sub Load ($) {
      require CPAN::Meta::YAML;
      my $object = eval { CPAN::Meta::YAML::Load(shift) };
      croak $@ if $@;
      return $object;
    }
    
    1;
    
    __END__
    
    =pod
    
    =encoding UTF-8
    
    =head1 NAME
    
    Parse::CPAN::Meta - Parse META.yml and META.json CPAN metadata files
    
    =head1 VERSION
    
    version 1.4414
    
    =head1 SYNOPSIS
    
        #############################################
        # In your file
        
        ---
        name: My-Distribution
        version: 1.23
        resources:
          homepage: "http://example.com/dist/My-Distribution"
        
        
        #############################################
        # In your program
        
        use Parse::CPAN::Meta;
        
        my $distmeta = Parse::CPAN::Meta->load_file('META.yml');
        
        # Reading properties
        my $name     = $distmeta->{name};
        my $version  = $distmeta->{version};
        my $homepage = $distmeta->{resources}{homepage};
    
    =head1 DESCRIPTION
    
    B<Parse::CPAN::Meta> is a parser for F<META.json> and F<META.yml> files, using
    L<JSON::PP> and/or L<CPAN::Meta::YAML>.
    
    B<Parse::CPAN::Meta> provides three methods: C<load_file>, C<load_json_string>,
    and C<load_yaml_string>.  These will read and deserialize CPAN metafiles, and
    are described below in detail.
    
    B<Parse::CPAN::Meta> provides a legacy API of only two functions,
    based on the YAML functions of the same name. Wherever possible,
    identical calling semantics are used.  These may only be used with YAML sources.
    
    All error reporting is done with exceptions (die'ing).
    
    Note that META files are expected to be in UTF-8 encoding, only.  When
    converted string data, it must first be decoded from UTF-8.
    
    =begin Pod::Coverage
    
    
    
    
    =end Pod::Coverage
    
    =head1 METHODS
    
    =head2 load_file
    
      my $metadata_structure = Parse::CPAN::Meta->load_file('META.json');
    
      my $metadata_structure = Parse::CPAN::Meta->load_file('META.yml');
    
    This method will read the named file and deserialize it to a data structure,
    determining whether it should be JSON or YAML based on the filename.
    The file will be read using the ":utf8" IO layer.
    
    =head2 load_yaml_string
    
      my $metadata_structure = Parse::CPAN::Meta->load_yaml_string($yaml_string);
    
    This method deserializes the given string of YAML and returns the first
    document in it.  (CPAN metadata files should always have only one document.)
    If the source was UTF-8 encoded, the string must be decoded before calling
    C<load_yaml_string>.
    
    =head2 load_json_string
    
      my $metadata_structure = Parse::CPAN::Meta->load_json_string($json_string);
    
    This method deserializes the given string of JSON and the result.  
    If the source was UTF-8 encoded, the string must be decoded before calling
    C<load_json_string>.
    
    =head2 load_string
    
      my $metadata_structure = Parse::CPAN::Meta->load_string($some_string);
    
    If you don't know whether a string contains YAML or JSON data, this method
    will use some heuristics and guess.  If it can't tell, it assumes YAML.
    
    =head2 yaml_backend
    
      my $backend = Parse::CPAN::Meta->yaml_backend;
    
    Returns the module name of the YAML serializer. See L</ENVIRONMENT>
    for details.
    
    =head2 json_backend
    
      my $backend = Parse::CPAN::Meta->json_backend;
    
    Returns the module name of the JSON serializer.  This will either
    be L<JSON::PP> or L<JSON>.  Even if C<PERL_JSON_BACKEND> is set,
    this will return L<JSON> as further delegation is handled by
    the L<JSON> module.  See L</ENVIRONMENT> for details.
    
    =head1 FUNCTIONS
    
    For maintenance clarity, no functions are exported by default.  These functions
    are available for backwards compatibility only and are best avoided in favor of
    C<load_file>.
    
    =head2 Load
    
      my @yaml = Parse::CPAN::Meta::Load( $string );
    
    Parses a string containing a valid YAML stream into a list of Perl data
    structures.
    
    =head2 LoadFile
    
      my @yaml = Parse::CPAN::Meta::LoadFile( 'META.yml' );
    
    Reads the YAML stream from a file instead of a string.
    
    =head1 ENVIRONMENT
    
    =head2 PERL_JSON_BACKEND
    
    By default, L<JSON::PP> will be used for deserializing JSON data. If the
    C<PERL_JSON_BACKEND> environment variable exists, is true and is not
    "JSON::PP", then the L<JSON> module (version 2.5 or greater) will be loaded and
    used to interpret C<PERL_JSON_BACKEND>.  If L<JSON> is not installed or is too
    old, an exception will be thrown.
    
    =head2 PERL_YAML_BACKEND
    
    By default, L<CPAN::Meta::YAML> will be used for deserializing YAML data. If
    the C<PERL_YAML_BACKEND> environment variable is defined, then it is interpreted
    as a module to use for deserialization.  The given module must be installed,
    must load correctly and must implement the C<Load()> function or an exception
    will be thrown.
    
    =for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
    
    =head1 SUPPORT
    
    =head2 Bugs / Feature Requests
    
    Please report any bugs or feature requests through the issue tracker
    at L<http://rt.cpan.org/Public/Dist/Display.html?Name=Parse-CPAN-Meta>.
    You will be notified automatically of any progress on your issue.
    
    =head2 Source Code
    
    This is open source software.  The code repository is available for
    public review and contribution under the terms of the license.
    
    L<https://github.com/Perl-Toolchain-Gang/Parse-CPAN-Meta>
    
      git clone https://github.com/Perl-Toolchain-Gang/Parse-CPAN-Meta.git
    
    =head1 AUTHORS
    
    =over 4
    
    =item *
    
    Adam Kennedy <adamk@cpan.org>
    
    =item *
    
    David Golden <dagolden@cpan.org>
    
    =back
    
    =head1 CONTRIBUTORS
    
    =over 4
    
    =item *
    
    Graham Knop <haarg@haarg.org>
    
    =item *
    
    Joshua ben Jore <jjore@cpan.org>
    
    =item *
    
    Neil Bowers <neil@bowers.com>
    
    =item *
    
    Ricardo Signes <rjbs@cpan.org>
    
    =item *
    
    Steffen Mueller <smueller@cpan.org>
    
    =back
    
    =head1 COPYRIGHT AND LICENSE
    
    This software is copyright (c) 2014 by Adam Kennedy and Contributors.
    
    This is free software; you can redistribute it and/or modify it under
    the same terms as the Perl 5 programming language system itself.
    
    =cut
  PARSE_CPAN_META
  
  $fatpacked{"Parse/PMFile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARSE_PMFILE';
    package Parse::PMFile;
    
    sub __clean_eval { eval $_[0] } # needs to be here (RT#101273)
    
    use strict;
    use warnings;
    use Safe;
    use JSON::PP ();
    use Dumpvalue;
    use version ();
    use File::Spec ();
    
    our $VERSION = '0.36';
    our $VERBOSE = 0;
    our $ALLOW_DEV_VERSION = 0;
    our $FORK = 0;
    our $UNSAFE = $] < 5.010000 ? 1 : 0;
    
    sub new {
        my ($class, $meta, $opts) = @_;
        bless {%{ $opts || {} }, META_CONTENT => $meta}, $class;
    }
    
    # from PAUSE::pmfile::examine_fio
    sub parse {
        my ($self, $pmfile) = @_;
    
        $pmfile =~ s|\\|/|g;
    
        my($filemtime) = (stat $pmfile)[9];
        $self->{MTIME} = $filemtime;
        $self->{PMFILE} = $pmfile;
    
        unless ($self->_version_from_meta_ok) {
            my $version;
            unless (eval { $version = $self->_parse_version; 1 }) {
              $self->_verbose(1, "error with version in $pmfile: $@");
              return;
            }
    
            $self->{VERSION} = $version;
            if ($self->{VERSION} =~ /^\{.*\}$/) {
                # JSON error message
            } elsif ($self->{VERSION} =~ /[_\s]/ && !$self->{ALLOW_DEV_VERSION} && !$ALLOW_DEV_VERSION){   # ignore developer releases and "You suck!"
                return;
            }
        }
    
        my($ppp) = $self->_packages_per_pmfile;
        my @keys_ppp = $self->_filter_ppps(sort keys %$ppp);
        $self->_verbose(1,"Will check keys_ppp[@keys_ppp]\n");
    
        #
        # Immediately after each package (pmfile) examined contact
        # the database
        #
    
        my ($package, %errors);
        my %checked_in;
      DBPACK: foreach $package (@keys_ppp) {
            # this part is taken from PAUSE::package::examine_pkg
            # and PAUSE::package::_pkg_name_insane
            if ($package !~ /^\w[\w\:\']*\w?\z/
             || $package !~ /\w\z/
             || $package =~ /:/ && $package !~ /::/
             || $package =~ /\w:\w/
             || $package =~ /:::/
            ){
                $self->_verbose(1,"Package[$package] did not pass the ultimate sanity check");
                delete $ppp->{$package};
                next;
            }
    
            if ($self->{USERID} && $self->{PERMISSIONS} && !$self->_perm_check($package)) {
                delete $ppp->{$package};
                next;
            }
    
            # Check that package name matches case of file name
            {
              my (undef, $module) = split m{/lib/}, $self->{PMFILE}, 2;
              if ($module) {
                $module =~ s{\.pm\z}{};
                $module =~ s{/}{::}g;
    
                if (lc $module eq lc $package && $module ne $package) {
                  # warn "/// $self->{PMFILE} vs. $module vs. $package\n";
                  $errors{$package} = {
                    indexing_warning => "Capitalization of package ($package) does not match filename!",
                    infile => $self->{PMFILE},
                  };
                }
              }
            }
    
            my $pp = $ppp->{$package};
            if ($pp->{version} && $pp->{version} =~ /^\{.*\}$/) { # JSON parser error
                my $err = JSON::PP::decode_json($pp->{version});
                if ($err->{x_normalize}) {
                    $errors{$package} = {
                        normalize => $err->{version},
                        infile => $pp->{infile},
                    };
                    $pp->{version} = "undef";
                } elsif ($err->{openerr}) {
                    $pp->{version} = "undef";
                    $self->_verbose(1,
                                  qq{Parse::PMFile was not able to
            read the file. It issued the following error: C< $err->{r} >},
                                  );
                    $errors{$package} = {
                        open => $err->{r},
                        infile => $pp->{infile},
                    };
                } else {
                    $pp->{version} = "undef";
                    $self->_verbose(1, 
                                  qq{Parse::PMFile was not able to
            parse the following line in that file: C< $err->{line} >
    
            Note: the indexer is running in a Safe compartement and cannot
            provide the full functionality of perl in the VERSION line. It
            is trying hard, but sometime it fails. As a workaround, please
            consider writing a META.yml that contains a 'provides'
            attribute or contact the CPAN admins to investigate (yet
            another) workaround against "Safe" limitations.)},
    
                                  );
                    $errors{$package} = {
                        parse_version => $err->{line},
                        infile => $err->{file},
                    };
                }
            }
    
            # Sanity checks
    
            for (
                $package,
                $pp->{version},
            ) {
                if (!defined || /^\s*$/ || /\s/){  # for whatever reason I come here
                    delete $ppp->{$package};
                    next;            # don't screw up 02packages
                }
            }
            $checked_in{$package} = $ppp->{$package};
        }                       # end foreach package
    
        return (wantarray && %errors) ? (\%checked_in, \%errors) : \%checked_in;
    }
    
    sub _perm_check {
        my ($self, $package) = @_;
        my $userid = $self->{USERID};
        my $module = $self->{PERMISSIONS}->module_permissions($package);
        return 1 if !$module; # not listed yet
        return 1 if defined $module->m && $module->m eq $userid;
        return 1 if defined $module->f && $module->f eq $userid;
        return 1 if defined $module->c && grep {$_ eq $userid} @{$module->c};
        return;
    }
    
    # from PAUSE::pmfile;
    sub _parse_version {
        my $self = shift;
    
        use strict;
    
        my $pmfile = $self->{PMFILE};
        my $tmpfile = File::Spec->catfile(File::Spec->tmpdir, "ParsePMFile$$" . rand(1000));
    
        my $pmcp = $pmfile;
        for ($pmcp) {
            s/([^\\](\\\\)*)@/$1\\@/g; # thanks to Raphael Manfredi for the
            # solution to escape @s and \
        }
        my($v);
        {
    
            package main; # seems necessary
    
            # XXX: do we need to fork as PAUSE does?
            # or, is alarm() just fine?
            my $pid;
            if ($self->{FORK} || $FORK) {
                $pid = fork();
                die "Can't fork: $!" unless defined $pid;
            }
            if ($pid) {
                waitpid($pid, 0);
                if (open my $fh, '<', $tmpfile) {
                    $v = <$fh>;
                }
            } else {
                # XXX Limit Resources too
    
                my($comp) = Safe->new;
                my $eval = qq{
                    local(\$^W) = 0;
                    Parse::PMFile::_parse_version_safely("$pmcp");
                };
                $comp->permit("entereval"); # for MBARBON/Module-Info-0.30.tar.gz
                $comp->share("*Parse::PMFile::_parse_version_safely");
                $comp->share("*version::new");
                $comp->share("*version::numify");
                $comp->share_from('main', ['*version::',
                                            '*charstar::',
                                            '*Exporter::',
                                            '*DynaLoader::']);
                $comp->share_from('version', ['&qv']);
                $comp->permit(":base_math"); # atan2 (Acme-Pi)
                # $comp->permit("require"); # no strict!
                $comp->deny(qw/enteriter iter unstack goto/); # minimum protection against Acme::BadExample
    
                version->import('qv') if $self->{UNSAFE} || $UNSAFE;
                {
                    no strict;
                    $v = ($self->{UNSAFE} || $UNSAFE) ? eval $eval : $comp->reval($eval);
                }
                if ($@){ # still in the child process, out of Safe::reval
                    my $err = $@;
                    # warn ">>>>>>>err[$err]<<<<<<<<";
                    if (ref $err) {
                        if ($err->{line} =~ /([\$*])([\w\:\']*)\bVERSION\b.*?\=(.*)/) {
                            local($^W) = 0;
                            my ($sigil, $vstr) = ($1, $3);
                            $self->_restore_overloaded_stuff(1) if $err->{line} =~ /use\s+version\b|version\->|qv\(/;
                            $v = ($self->{UNSAFE} || $UNSAFE) ? eval $vstr : $comp->reval($vstr);
                            $v = $$v if $sigil eq '*' && ref $v;
                        }
                        if ($@ or !$v) {
                            $self->_verbose(1, sprintf("reval failed: err[%s] for eval[%s]",
                                          JSON::PP::encode_json($err),
                                          $eval,
                                        ));
                            $v = JSON::PP::encode_json($err);
                        }
                    } else {
                        $v = JSON::PP::encode_json({ openerr => $err });
                    }
                }
                if (defined $v) {
                    $v = $v->numify if ref($v) =~ /^version(::vpp)?$/;
                } else {
                    $v = "";
                }
                if ($self->{FORK} || $FORK) {
                    open my $fh, '>:utf8', $tmpfile;
                    print $fh $v;
                    exit 0;
                } else {
                    utf8::encode($v);
                    # undefine empty $v as if read from the tmpfile
                    $v = undef if defined $v && !length $v;
                    $comp->erase;
                    $self->_restore_overloaded_stuff;
                }
            }
        }
        unlink $tmpfile if ($self->{FORK} || $FORK) && -e $tmpfile;
    
        return $self->_normalize_version($v);
    }
    
    sub _restore_overloaded_stuff {
        my ($self, $used_version_in_safe) = @_;
        return if $self->{UNSAFE} || $UNSAFE;
    
        no strict 'refs';
        no warnings 'redefine';
    
        # version XS in CPAN
        my $restored;
        if ($INC{'version/vxs.pm'}) {
            *{'version::(""'} = \&version::vxs::stringify;
            *{'version::(0+'} = \&version::vxs::numify;
            *{'version::(cmp'} = \&version::vxs::VCMP;
            *{'version::(<=>'} = \&version::vxs::VCMP;
            *{'version::(bool'} = \&version::vxs::boolean;
            $restored = 1;
        }
        # version PP in CPAN
        if ($INC{'version/vpp.pm'}) {
            {
                package # hide from PAUSE
                    charstar;
                overload->import;
            }
            if (!$used_version_in_safe) {
                package # hide from PAUSE
                    version::vpp;
                overload->import;
            }
            unless ($restored) {
                *{'version::(""'} = \&version::vpp::stringify;
                *{'version::(0+'} = \&version::vpp::numify;
                *{'version::(cmp'} = \&version::vpp::vcmp;
                *{'version::(<=>'} = \&version::vpp::vcmp;
                *{'version::(bool'} = \&version::vpp::vbool;
            }
            *{'version::vpp::(""'} = \&version::vpp::stringify;
            *{'version::vpp::(0+'} = \&version::vpp::numify;
            *{'version::vpp::(cmp'} = \&version::vpp::vcmp;
            *{'version::vpp::(<=>'} = \&version::vpp::vcmp;
            *{'version::vpp::(bool'} = \&version::vpp::vbool;
            *{'charstar::(""'} = \&charstar::thischar;
            *{'charstar::(0+'} = \&charstar::thischar;
            *{'charstar::(++'} = \&charstar::increment;
            *{'charstar::(--'} = \&charstar::decrement;
            *{'charstar::(+'} = \&charstar::plus;
            *{'charstar::(-'} = \&charstar::minus;
            *{'charstar::(*'} = \&charstar::multiply;
            *{'charstar::(cmp'} = \&charstar::cmp;
            *{'charstar::(<=>'} = \&charstar::spaceship;
            *{'charstar::(bool'} = \&charstar::thischar;
            *{'charstar::(='} = \&charstar::clone;
            $restored = 1;
        }
        # version in core
        if (!$restored) {
            *{'version::(""'} = \&version::stringify;
            *{'version::(0+'} = \&version::numify;
            *{'version::(cmp'} = \&version::vcmp;
            *{'version::(<=>'} = \&version::vcmp;
            *{'version::(bool'} = \&version::boolean;
        }
    }
    
    # from PAUSE::pmfile;
    sub _packages_per_pmfile {
        my $self = shift;
    
        my $ppp = {};
        my $pmfile = $self->{PMFILE};
        my $filemtime = $self->{MTIME};
        my $version = $self->{VERSION};
    
        open my $fh, "<", "$pmfile" or return $ppp;
    
        local $/ = "\n";
        my $inpod = 0;
    
      PLINE: while (<$fh>) {
            chomp;
            my($pline) = $_;
            $inpod = $pline =~ /^=(?!cut)/ ? 1 :
                $pline =~ /^=cut/ ? 0 : $inpod;
            next if $inpod;
            next if substr($pline,0,4) eq "=cut";
    
            $pline =~ s/\#.*//;
            next if $pline =~ /^\s*$/;
            if ($pline =~ /^__(?:END|DATA)__\b/
                and $pmfile !~ /\.PL$/   # PL files may well have code after __DATA__
                ){
                last PLINE;
            }
    
            my $pkg;
            my $strict_version;
    
            if (
                $pline =~ m{
                          # (.*) # takes too much time if $pline is long
                          (?<![*\$\\@%&]) # no sigils
                          \bpackage\s+
                          ([\w\:\']+)
                          \s*
                          (?: $ | [\}\;] | \{ | \s+($version::STRICT) )
                        }x) {
                $pkg = $1;
                $strict_version = $2;
                if ($pkg eq "DB"){
                    # XXX if pumpkin and perl make him comaintainer! I
                    # think I always made the pumpkins comaint on DB
                    # without further ado (?)
                    next PLINE;
                }
            }
    
            if ($pkg) {
                # Found something
    
                # from package
                $pkg =~ s/\'/::/;
                next PLINE unless $pkg =~ /^[A-Za-z]/;
                next PLINE unless $pkg =~ /\w$/;
                next PLINE if $pkg eq "main";
                # Perl::Critic::Policy::TestingAndDebugging::ProhibitShebangWarningsArg
                # database for modid in mods, package in packages, package in perms
                # alter table mods modify modid varchar(128) binary NOT NULL default '';
                # alter table packages modify package varchar(128) binary NOT NULL default '';
                next PLINE if length($pkg) > 128;
                #restriction
                $ppp->{$pkg}{parsed}++;
                $ppp->{$pkg}{infile} = $pmfile;
                if ($self->_simile($pmfile,$pkg)) {
                    $ppp->{$pkg}{simile} = $pmfile;
                    if ($self->_version_from_meta_ok) {
                        my $provides = $self->{META_CONTENT}{provides};
                        if (exists $provides->{$pkg}) {
                            if (defined $provides->{$pkg}{version}) {
                                my $v = $provides->{$pkg}{version};
                                if ($v =~ /[_\s]/ && !$self->{ALLOW_DEV_VERSION} && !$ALLOW_DEV_VERSION){   # ignore developer releases and "You suck!"
                                    next PLINE;
                                }
    
                                unless (eval { $version = $self->_normalize_version($v); 1 }) {
                                  $self->_verbose(1, "error with version in $pmfile: $@");
                                  next;
    
                                }
                                $ppp->{$pkg}{version} = $version;
                            } else {
                                $ppp->{$pkg}{version} = "undef";
                            }
                        }
                    } else {
                        if (defined $strict_version){
                            $ppp->{$pkg}{version} = $strict_version ;
                        } else {
                            $ppp->{$pkg}{version} = defined $version ? $version : "";
                        }
                        no warnings;
                        if ($version eq 'undef') {
                            $ppp->{$pkg}{version} = $version unless defined $ppp->{$pkg}{version};
                        } else {
                            $ppp->{$pkg}{version} =
                                $version
                                    if $version
                                        > $ppp->{$pkg}{version} ||
                                            $version
                                                gt $ppp->{$pkg}{version};
                        }
                    }
                } else {        # not simile
                    #### it comes later, it would be nonsense
                    #### to set to "undef". MM_Unix gives us
                    #### the best we can reasonably consider
                    $ppp->{$pkg}{version} =
                        $version
                            unless defined $ppp->{$pkg}{version} &&
                                length($ppp->{$pkg}{version});
                }
                $ppp->{$pkg}{filemtime} = $filemtime;
            } else {
                # $self->_verbose(2,"no pkg found");
            }
        }
    
        close $fh;
        $ppp;
    }
    
    # from PAUSE::pmfile;
    {
        no strict;
        sub _parse_version_safely {
            my($parsefile) = @_;
            my $result;
            local *FH;
            local $/ = "\n";
            open(FH,$parsefile) or die "Could not open '$parsefile': $!";
            my $inpod = 0;
            while (<FH>) {
                $inpod = /^=(?!cut)/ ? 1 : /^=cut/ ? 0 : $inpod;
                next if $inpod || /^\s*#/;
                last if /^__(?:END|DATA)__\b/; # fails on quoted __END__ but this is rare -> __END__ in the middle of a line is rarer
                chop;
    
                if (my ($ver) = /package \s+ \S+ \s+ (\S+) \s* [;{]/x) {
                  # XXX: should handle this better if version is bogus -- rjbs,
                  # 2014-03-16
                  return $ver if version::is_lax($ver);
                }
    
                # next unless /\$(([\w\:\']*)\bVERSION)\b.*\=/;
                next unless /(?<!\\)([\$*])(([\w\:\']*)\bVERSION)\b.*(?<![!><=])\=(?![=>])/;
                my $current_parsed_line = $_;
                my $eval = qq{
                    package #
                        ExtUtils::MakeMaker::_version;
    
                    local $1$2;
                    \$$2=undef; do {
                        $_
                    }; \$$2
                };
                local $^W = 0;
                local $SIG{__WARN__} = sub {};
                $result = __clean_eval($eval);
                # warn "current_parsed_line[$current_parsed_line]\$\@[$@]";
                if ($@ or !defined $result){
                    die +{
                          eval => $eval,
                          line => $current_parsed_line,
                          file => $parsefile,
                          err => $@,
                          };
                }
                last;
            } #;
            close FH;
    
            $result = "undef" unless defined $result;
            if ((ref $result) =~ /^version(?:::vpp)?\b/) {
                $result = $result->numify;
            }
            return $result;
        }
    }
    
    # from PAUSE::pmfile;
    sub _filter_ppps {
        my($self,@ppps) = @_;
        my @res;
    
        # very similar code is in PAUSE::dist::filter_pms
      MANI: for my $ppp ( @ppps ) {
            if ($self->{META_CONTENT}){
                my $no_index = $self->{META_CONTENT}{no_index}
                                || $self->{META_CONTENT}{private}; # backward compat
                if (ref($no_index) eq 'HASH') {
                    my %map = (
                                package => qr{\z},
                                namespace => qr{::},
                              );
                    for my $k (qw(package namespace)) {
                        next unless my $v = $no_index->{$k};
                        my $rest = $map{$k};
                        if (ref $v eq "ARRAY") {
                            for my $ve (@$v) {
                                $ve =~ s|::$||;
                                if ($ppp =~ /^$ve$rest/){
                                    $self->_verbose(1,"Skipping ppp[$ppp] due to ve[$ve]");
                                    next MANI;
                                } else {
                                    $self->_verbose(1,"NOT skipping ppp[$ppp] due to ve[$ve]");
                                }
                            }
                        } else {
                            $v =~ s|::$||;
                            if ($ppp =~ /^$v$rest/){
                                $self->_verbose(1,"Skipping ppp[$ppp] due to v[$v]");
                                next MANI;
                            } else {
                                $self->_verbose(1,"NOT skipping ppp[$ppp] due to v[$v]");
                            }
                        }
                    }
                } else {
                    $self->_verbose(1,"No keyword 'no_index' or 'private' in META_CONTENT");
                }
            } else {
                # $self->_verbose(1,"no META_CONTENT"); # too noisy
            }
            push @res, $ppp;
        }
        $self->_verbose(1,"Result of filter_ppps: res[@res]");
        @res;
    }
    
    # from PAUSE::pmfile;
    sub _simile {
        my($self,$file,$package) = @_;
        # MakeMaker gives them the chance to have the file Simple.pm in
        # this directory but have the package HTML::Simple in it.
        # Afaik, they wouldn't be able to do so with deeper nested packages
        $file =~ s|.*/||;
        $file =~ s|\.pm(?:\.PL)?||;
        my $ret = $package =~ m/\b\Q$file\E$/;
        $ret ||= 0;
        unless ($ret) {
            # Apache::mod_perl_guide stuffs it into Version.pm
            $ret = 1 if lc $file eq 'version';
        }
        $self->_verbose(1,"Result of simile(): file[$file] package[$package] ret[$ret]\n");
        $ret;
    }
    
    # from PAUSE::pmfile
    sub _normalize_version {
        my($self,$v) = @_;
        $v = "undef" unless defined $v;
        my $dv = Dumpvalue->new;
        my $sdv = $dv->stringify($v,1); # second argument prevents ticks
        $self->_verbose(1,"Result of normalize_version: sdv[$sdv]\n");
    
        return $v if $v eq "undef";
        return $v if $v =~ /^\{.*\}$/; # JSON object
        $v =~ s/^\s+//;
        $v =~ s/\s+\z//;
        if ($v =~ /_/) {
            # XXX should pass something like EDEVELOPERRELEASE up e.g.
            # SIXTEASE/XML-Entities-0.0306.tar.gz had nothing but one
            # such modules and the mesage was not helpful that "nothing
            # was found".
            return $v ;
        }
        if (!version::is_lax($v)) {
            return JSON::PP::encode_json({ x_normalize => 'version::is_lax failed', version => $v });
        }
        # may warn "Integer overflow"
        my $vv = eval { no warnings; version->new($v)->numify };
        if ($@) {
            # warn "$v: $@";
            return JSON::PP::encode_json({ x_normalize => $@, version => $v });
            # return "undef";
        }
        if ($vv eq $v) {
            # the boring 3.14
        } else {
            my $forced = $self->_force_numeric($v);
            if ($forced eq $vv) {
            } elsif ($forced =~ /^v(.+)/) {
                # rare case where a v1.0.23 slipped in (JANL/w3mir-1.0.10.tar.gz)
                $vv = version->new($1)->numify;
            } else {
                # warn "Unequal forced[$forced] and vv[$vv]";
                if ($forced == $vv) {
                    # the trailing zeroes would cause unnecessary havoc
                    $vv = $forced;
                }
            }
        }
        return $vv;
    }
    
    # from PAUSE::pmfile;
    sub _force_numeric {
        my($self,$v) = @_;
        $v = $self->_readable($v);
    
        if (
            $v =~
            /^(\+?)(\d*)(\.(\d*))?/ &&
            # "$2$4" ne ''
            (
              defined $2 && length $2
              ||
              defined $4 && length $4
            )
            ) {
            my $two = defined $2 ? $2 : "";
            my $three = defined $3 ? $3 : "";
            $v = "$two$three";
        }
        # no else branch! We simply say, everything else is a string.
        $v;
    }
    
    # from PAUSE::dist
    sub _version_from_meta_ok {
      my($self) = @_;
      return $self->{VERSION_FROM_META_OK} if exists $self->{VERSION_FROM_META_OK};
      my $c = $self->{META_CONTENT};
    
      # If there's no provides hash, we can't get our module versions from the
      # provides hash! -- rjbs, 2012-03-31
      return($self->{VERSION_FROM_META_OK} = 0) unless $c->{provides};
    
      # Some versions of Module::Build geneated an empty provides hash.  If we're
      # *not* looking at a Module::Build-generated metafile, then it's okay.
      my ($mb_v) = (defined $c->{generated_by} ? $c->{generated_by} : '') =~ /Module::Build version ([\d\.]+)/;
      return($self->{VERSION_FROM_META_OK} = 1) unless $mb_v;
    
      # ??? I don't know why this is here.
      return($self->{VERSION_FROM_META_OK} = 1) if $mb_v eq '0.250.0';
    
      if ($mb_v >= 0.19 && $mb_v < 0.26 && ! keys %{$c->{provides}}) {
          # RSAVAGE/Javascript-SHA1-1.01.tgz had an empty provides hash. Ron
          # did not find the reason why this happened, but let's not go
          # overboard, 0.26 seems a good threshold from the statistics: there
          # are not many empty provides hashes from 0.26 up.
          return($self->{VERSION_FROM_META_OK} = 0);
      }
    
      # We're not in the suspect range of M::B versions.  It's good to go.
      return($self->{VERSION_FROM_META_OK} = 1);
    }
    
    sub _verbose {
        my($self,$level,@what) = @_;
        warn @what if $level <= ((ref $self && $self->{VERBOSE}) || $VERBOSE);
    }
    
    # all of the following methods are stripped from CPAN::Version
    # (as of version 5.5001, bundled in CPAN 2.03), and slightly
    # modified (ie. made private, as well as CPAN->debug(...) are
    # replaced with $self->_verbose(9, ...).)
    
    # CPAN::Version::vcmp courtesy Jost Krieger
    sub _vcmp {
        my($self,$l,$r) = @_;
        local($^W) = 0;
        $self->_verbose(9, "l[$l] r[$r]");
    
        return 0 if $l eq $r; # short circuit for quicker success
    
        for ($l,$r) {
            s/_//g;
        }
        $self->_verbose(9, "l[$l] r[$r]");
        for ($l,$r) {
            next unless tr/.// > 1 || /^v/;
            s/^v?/v/;
            1 while s/\.0+(\d)/.$1/; # remove leading zeroes per group
        }
        $self->_verbose(9, "l[$l] r[$r]");
        if ($l=~/^v/ <=> $r=~/^v/) {
            for ($l,$r) {
                next if /^v/;
                $_ = $self->_float2vv($_);
            }
        }
        $self->_verbose(9, "l[$l] r[$r]");
        my $lvstring = "v0";
        my $rvstring = "v0";
        if ($] >= 5.006
         && $l =~ /^v/
         && $r =~ /^v/) {
            $lvstring = $self->_vstring($l);
            $rvstring = $self->_vstring($r);
            $self->_verbose(9, sprintf "lv[%vd] rv[%vd]", $lvstring, $rvstring);
        }
    
        return (
                ($l ne "undef") <=> ($r ne "undef")
                ||
                $lvstring cmp $rvstring
                ||
                $l <=> $r
                ||
                $l cmp $r
        );
    }
    
    sub _vgt {
        my($self,$l,$r) = @_;
        $self->_vcmp($l,$r) > 0;
    }
    
    sub _vlt {
        my($self,$l,$r) = @_;
        $self->_vcmp($l,$r) < 0;
    }
    
    sub _vge {
        my($self,$l,$r) = @_;
        $self->_vcmp($l,$r) >= 0;
    }
    
    sub _vle {
        my($self,$l,$r) = @_;
        $self->_vcmp($l,$r) <= 0;
    }
    
    sub _vstring {
        my($self,$n) = @_;
        $n =~ s/^v// or die "Parse::PMFile::_vstring() called with invalid arg [$n]";
        pack "U*", split /\./, $n;
    }
    
    # vv => visible vstring
    sub _float2vv {
        my($self,$n) = @_;
        my($rev) = int($n);
        $rev ||= 0;
        my($mantissa) = $n =~ /\.(\d{1,12})/; # limit to 12 digits to limit
                                              # architecture influence
        $mantissa ||= 0;
        $mantissa .= "0" while length($mantissa)%3;
        my $ret = "v" . $rev;
        while ($mantissa) {
            $mantissa =~ s/(\d{1,3})// or
                die "Panic: length>0 but not a digit? mantissa[$mantissa]";
            $ret .= ".".int($1);
        }
        # warn "n[$n]ret[$ret]";
        $ret =~ s/(\.0)+/.0/; # v1.0.0 => v1.0
        $ret;
    }
    
    sub _readable {
        my($self,$n) = @_;
        $n =~ /^([\w\-\+\.]+)/;
    
        return $1 if defined $1 && length($1)>0;
        # if the first user reaches version v43, he will be treated as "+".
        # We'll have to decide about a new rule here then, depending on what
        # will be the prevailing versioning behavior then.
    
        if ($] < 5.006) { # or whenever v-strings were introduced
            # we get them wrong anyway, whatever we do, because 5.005 will
            # have already interpreted 0.2.4 to be "0.24". So even if he
            # indexer sends us something like "v0.2.4" we compare wrongly.
    
            # And if they say v1.2, then the old perl takes it as "v12"
    
            $self->_verbose(9, "Suspicious version string seen [$n]\n");
            return $n;
        }
        my $better = sprintf "v%vd", $n;
        $self->_verbose(9, "n[$n] better[$better]");
        return $better;
    }
    
    1;
    
    __END__
    
    =head1 NAME
    
    Parse::PMFile - parses .pm file as PAUSE does
    
    =head1 SYNOPSIS
    
        use Parse::PMFile;
    
        my $parser = Parse::PMFile->new($metadata, {VERBOSE => 1});
        my $packages_info = $parser->parse($pmfile);
    
        # if you need info about invalid versions
        my ($packages_info, $errors) = $parser->parse($pmfile);
    
        # to check permissions
        my $parser = Parse::PMFile->new($metadata, {
            USERID => 'ISHIGAKI',
            PERMISSIONS => PAUSE::Permissions->new,
        });
    
    =head1 DESCRIPTION
    
    The most of the code of this module is taken from the PAUSE code as of April 2013 almost verbatim. Thus, the heart of this module should be quite stable. However, I made it not to use pipe ("-|") as well as I stripped database-related code. If you encounter any issue, that's most probably because of my modification.
    
    This module doesn't provide features to extract a distribution or parse meta files intentionally.
    
    =head1 METHODS
    
    =head2 new
    
    creates an object. You can also pass a hashref taken from META.yml etc, and an optional hashref. Options are:
    
    =over 4
    
    =item ALLOW_DEV_VERSION
    
    Parse::PMFile usually ignores a version with an underscore as PAUSE does (because it's for a developer release, and should not be indexed). Set this option to true if you happen to need to keep such a version for better analysis.
    
    =item VERBOSE
    
    Set this to true if you need to know some details.
    
    =item FORK
    
    As of version 0.17, Parse::PMFile stops forking while parsing a version for better performance. Parse::PMFile should return the same result no matter how this option is set, but if you do care, set this to true to fork as PAUSE does.
    
    =item USERID, PERMISSIONS
    
    As of version 0.21, Parse::PMFile checks permissions of a package if both USERID and PERMISSIONS (which should be an instance of L<PAUSE::Permissions>) are provided. Unauthorized packages are removed.
    
    =item UNSAFE
    
    Parse::PMFile usually parses a module version in a Safe compartment. However, this approach doesn't work smoothly under older perls (prior to 5.10) plus some combinations of recent versions of Safe.pm (2.24 and above) and version.pm (0.9905 and above) for various reasons. As of version 0.27, Parse::PMFile simply uses C<eval> to parse a version under older perls. If you want it to use always C<eval> (even under recent perls), set this to true.
    
    =back
    
    =head2 parse
    
    takes a path to a .pm file, and returns a hash reference that holds information for package(s) found in the file.
    
    =head1 SEE ALSO
    
    L<Parse::LocalDistribution>, L<PAUSE::Permissions>
    
    Most part of this module is derived from PAUSE and CPAN::Version.
    
    L<https://github.com/andk/pause>
    
    L<https://github.com/andk/cpanpm>
    
    =head1 AUTHOR
    
    Andreas Koenig E<lt>andreas.koenig@anima.deE<gt>
    
    Kenichi Ishigaki, E<lt>ishigaki@cpan.orgE<gt>
    
    =head1 COPYRIGHT AND LICENSE
    
    Copyright 1995 - 2013 by Andreas Koenig E<lt>andk@cpan.orgE<gt> for most of the code.
    
    Copyright 2013 by Kenichi Ishigaki for some.
    
    This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.
    
    =cut
  PARSE_PMFILE
  
  $fatpacked{"String/ShellQuote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STRING_SHELLQUOTE';
    # $Id: ShellQuote.pm,v 1.11 2010-06-11 20:08:57 roderick Exp $
    #
    # Copyright (c) 1997 Roderick Schertler.  All rights reserved.  This
    # program is free software; you can redistribute it and/or modify it
    # under the same terms as Perl itself.
    
    =head1 NAME
    
    String::ShellQuote - quote strings for passing through the shell
    
    =head1 SYNOPSIS
    
        $string = shell_quote @list;
        $string = shell_quote_best_effort @list;
        $string = shell_comment_quote $string;
    
    =head1 DESCRIPTION
    
    This module contains some functions which are useful for quoting strings
    which are going to pass through the shell or a shell-like object.
    
    =over
    
    =cut
    
    package String::ShellQuote;
    
    use strict;
    use vars qw($VERSION @ISA @EXPORT);
    
    require Exporter;
    
    $VERSION	= '1.04';
    @ISA		= qw(Exporter);
    @EXPORT		= qw(shell_quote shell_quote_best_effort shell_comment_quote);
    
    sub croak {
        require Carp;
        goto &Carp::croak;
    }
    
    sub _shell_quote_backend {
        my @in = @_;
        my @err = ();
    
        if (0) {
    	require RS::Handy;
    	print RS::Handy::data_dump(\@in);
        }
    
        return \@err, '' unless @in;
    
        my $ret = '';
        my $saw_non_equal = 0;
        foreach (@in) {
    	if (!defined $_ or $_ eq '') {
    	    $_ = "''";
    	    next;
    	}
    
    	if (s/\x00//g) {
    	    push @err, "No way to quote string containing null (\\000) bytes";
    	}
    
        	my $escape = 0;
    
    	# = needs quoting when it's the first element (or part of a
    	# series of such elements), as in command position it's a
    	# program-local environment setting
    
    	if (/=/) {
    	    if (!$saw_non_equal) {
    	    	$escape = 1;
    	    }
    	}
    	else {
    	    $saw_non_equal = 1;
    	}
    
    	if (m|[^\w!%+,\-./:=@^]|) {
    	    $escape = 1;
    	}
    
    	if ($escape
    		|| (!$saw_non_equal && /=/)) {
    
    	    # ' -> '\''
        	    s/'/'\\''/g;
    
    	    # make multiple ' in a row look simpler
    	    # '\'''\'''\'' -> '"'''"'
        	    s|((?:'\\''){2,})|q{'"} . (q{'} x (length($1) / 4)) . q{"'}|ge;
    
    	    $_ = "'$_'";
    	    s/^''//;
    	    s/''$//;
    	}
        }
        continue {
    	$ret .= "$_ ";
        }
    
        chop $ret;
        return \@err, $ret;
    }
    
    =item B<shell_quote> [I<string>]...
    
    B<shell_quote> quotes strings so they can be passed through the shell.
    Each I<string> is quoted so that the shell will pass it along as a
    single argument and without further interpretation.  If no I<string>s
    are given an empty string is returned.
    
    If any I<string> can't be safely quoted B<shell_quote> will B<croak>.
    
    =cut
    
    sub shell_quote {
        my ($rerr, $s) = _shell_quote_backend @_;
    
        if (@$rerr) {
        	my %seen;
        	@$rerr = grep { !$seen{$_}++ } @$rerr;
    	my $s = join '', map { "shell_quote(): $_\n" } @$rerr;
    	chomp $s;
    	croak $s;
        }
        return $s;
    }
    
    =item B<shell_quote_best_effort> [I<string>]...
    
    This is like B<shell_quote>, excpet if the string can't be safely quoted
    it does the best it can and returns the result, instead of dying.
    
    =cut
    
    sub shell_quote_best_effort {
        my ($rerr, $s) = _shell_quote_backend @_;
    
        return $s;
    }
    
    =item B<shell_comment_quote> [I<string>]
    
    B<shell_comment_quote> quotes the I<string> so that it can safely be
    included in a shell-style comment (the current algorithm is that a sharp
    character is placed after any newlines in the string).
    
    This routine might be changed to accept multiple I<string> arguments
    in the future.  I haven't done this yet because I'm not sure if the
    I<string>s should be joined with blanks ($") or nothing ($,).  Cast
    your vote today!  Be sure to justify your answer.
    
    =cut
    
    sub shell_comment_quote {
        return '' unless @_;
        unless (@_ == 1) {
    	croak "Too many arguments to shell_comment_quote "
    	    	    . "(got " . @_ . " expected 1)";
        }
        local $_ = shift;
        s/\n/\n#/g;
        return $_;
    }
    
    1;
    
    __END__
    
    =back
    
    =head1 EXAMPLES
    
        $cmd = 'fuser 2>/dev/null ' . shell_quote @files;
        @pids = split ' ', `$cmd`;
    
        print CFG "# Configured by: ",
    		shell_comment_quote($ENV{LOGNAME}), "\n";
    
    =head1 BUGS
    
    Only Bourne shell quoting is supported.  I'd like to add other shells
    (particularly cmd.exe), but I'm not familiar with them.  It would be a
    big help if somebody supplied the details.
    
    =head1 AUTHOR
    
    Roderick Schertler <F<roderick@argon.org>>
    
    =head1 SEE ALSO
    
    perl(1).
    
    =cut
  STRING_SHELLQUOTE
  
  $fatpacked{"lib/core/only.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LIB_CORE_ONLY';
    package lib::core::only;
    
    use strict;
    use warnings FATAL => 'all';
    use Config;
    
    sub import {
      @INC = @Config{qw(privlibexp archlibexp)};
      return
    }
    
    =head1 NAME
    
    lib::core::only - Remove all non-core paths from @INC to avoid site/vendor dirs
    
    =head1 SYNOPSIS
    
      use lib::core::only; # now @INC contains only the two core directories
    
    To get only the core directories plus the ones for the local::lib in scope:
    
      $ perl -mlocal::lib -Mlib::core::only -Mlocal::lib=~/perl5 myscript.pl
    
    To attempt to do a self-contained build (but note this will not reliably
    propagate into subprocesses, see the CAVEATS below):
    
      $ PERL5OPT='-mlocal::lib -Mlib::core::only -Mlocal::lib=~/perl5' cpan
    
    Please note that it is necessary to use C<local::lib> twice for this to work.
    First so that C<lib::core::only> doesn't prevent C<local::lib> from loading
    (it's not currently in core) and then again after C<lib::core::only> so that
    the local paths are not removed.
    
    =head1 DESCRIPTION
    
    lib::core::only is simply a shortcut to say "please reduce my @INC to only
    the core lib and archlib (architecture-specific lib) directories of this perl".
    
    You might want to do this to ensure a local::lib contains only the code you
    need, or to test an L<App::FatPacker|App::FatPacker> tree, or to avoid known
    bad vendor packages.
    
    You might want to use this to try and install a self-contained tree of perl
    modules. Be warned that that probably won't work (see L</CAVEATS>).
    
    This module was extracted from L<local::lib|local::lib>'s --self-contained
    feature, and contains the only part that ever worked. I apologise to anybody
    who thought anything else did.
    
    =head1 CAVEATS
    
    This does B<not> propagate properly across perl invocations like local::lib's
    stuff does. It can't. It's only a module import, so it B<only affects the
    specific perl VM instance in which you load and import() it>.
    
    If you want to cascade it across invocations, you can set the PERL5OPT
    environment variable to '-Mlib::core::only' and it'll sort of work. But be
    aware that taint mode ignores this, so some modules' build and test code
    probably will as well.
    
    You also need to be aware that perl's command line options are not processed
    in order - -I options take effect before -M options, so
    
      perl -Mlib::core::only -Ilib
    
    is unlike to do what you want - it's exactly equivalent to:
    
      perl -Mlib::core::only
    
    If you want to combine a core-only @INC with additional paths, you need to
    add the additional paths using -M options and the L<lib|lib> module:
    
      perl -Mlib::core::only -Mlib=lib
    
      # or if you're trying to test compiled code:
    
      perl -Mlib::core::only -Mblib
    
    For more information on the impossibility of sanely propagating this across
    module builds without help from the build program, see
    L<http://www.shadowcat.co.uk/blog/matt-s-trout/tainted-love> - and for ways
    to achieve the old --self-contained feature's results, look at
    L<App::FatPacker|App::FatPacker>'s tree function, and at
    L<App::cpanminus|cpanm>'s --local-lib-contained feature.
    
    =head1 AUTHOR
    
    Matt S. Trout <mst@shadowcat.co.uk>
    
    =head1 LICENSE
    
    This library is free software under the same terms as perl itself.
    
    =head1 COPYRIGHT
    
    (c) 2010 the lib::core::only L</AUTHOR> as specified above.
    
    =cut
    
    1;
  LIB_CORE_ONLY
  
  $fatpacked{"local/lib.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOCAL_LIB';
    package local::lib;
    use 5.006;
    use strict;
    use warnings;
    use Config;
    
    our $VERSION = '2.000015';
    $VERSION = eval $VERSION;
    
    BEGIN {
      *_WIN32 = ($^O eq 'MSWin32' || $^O eq 'NetWare' || $^O eq 'symbian')
        ? sub(){1} : sub(){0};
      # punt on these systems
      *_USE_FSPEC = ($^O eq 'MacOS' || $^O eq 'VMS' || $INC{'File/Spec.pm'})
        ? sub(){1} : sub(){0};
    }
    our $_DIR_JOIN = _WIN32 ? '\\' : '/';
    our $_DIR_SPLIT = (_WIN32 || $^O eq 'cygwin') ? qr{[\\/]}
                                                  : qr{/};
    our $_ROOT = _WIN32 ? do {
      my $UNC = qr{[\\/]{2}[^\\/]+[\\/][^\\/]+};
      qr{^(?:$UNC|[A-Za-z]:|)$_DIR_SPLIT};
    } : qr{^/};
    our $_PERL;
    
    sub _cwd {
      my $drive = shift;
      if (!$_PERL) {
        ($_PERL) = $^X =~ /(.+)/; # $^X is internal how could it be tainted?!
        if (_is_abs($_PERL)) {
        }
        elsif (-x $Config{perlpath}) {
          $_PERL = $Config{perlpath};
        }
        else {
          ($_PERL) =
            map { /(.*)/ }
            grep { -x $_ }
            map { join($_DIR_JOIN, $_, $_PERL) }
            split /\Q$Config{path_sep}\E/, $ENV{PATH};
        }
      }
      local @ENV{qw(PATH IFS CDPATH ENV BASH_ENV)};
      my $cmd = $drive ? "eval { Cwd::getdcwd(q($drive)) }"
                       : 'getcwd';
      my $cwd = `"$_PERL" -MCwd -le "print $cmd"`;
      chomp $cwd;
      if (!length $cwd && $drive) {
        $cwd = $drive;
      }
      $cwd =~ s/$_DIR_SPLIT?$/$_DIR_JOIN/;
      $cwd;
    }
    
    sub _catdir {
      if (_USE_FSPEC) {
        require File::Spec;
        File::Spec->catdir(@_);
      }
      else {
        my $dir = join($_DIR_JOIN, @_);
        $dir =~ s{($_DIR_SPLIT)(?:\.?$_DIR_SPLIT)+}{$1}g;
        $dir;
      }
    }
    
    sub _is_abs {
      if (_USE_FSPEC) {
        require File::Spec;
        File::Spec->file_name_is_absolute($_[0]);
      }
      else {
        $_[0] =~ $_ROOT;
      }
    }
    
    sub _rel2abs {
      my ($dir, $base) = @_;
      return $dir
        if _is_abs($dir);
    
      $base = _WIN32 && $dir =~ s/^([A-Za-z]:)// ? _cwd("$1")
            : $base                              ? $base
                                                 : _cwd;
      return _catdir($base, $dir);
    }
    
    sub import {
      my ($class, @args) = @_;
      push @args, @ARGV
        if $0 eq '-';
    
      my @steps;
      my %opts;
      my $shelltype;
    
      while (@args) {
        my $arg = shift @args;
        # check for lethal dash first to stop processing before causing problems
        # the fancy dash is U+2212 or \xE2\x88\x92
        if ($arg =~ /\xE2\x88\x92/ or $arg =~ /−/) {
          die <<'DEATH';
    WHOA THERE! It looks like you've got some fancy dashes in your commandline!
    These are *not* the traditional -- dashes that software recognizes. You
    probably got these by copy-pasting from the perldoc for this module as
    rendered by a UTF8-capable formatter. This most typically happens on an OS X
    terminal, but can happen elsewhere too. Please try again after replacing the
    dashes with normal minus signs.
    DEATH
        }
        elsif ($arg eq '--self-contained') {
          die <<'DEATH';
    FATAL: The local::lib --self-contained flag has never worked reliably and the
    original author, Mark Stosberg, was unable or unwilling to maintain it. As
    such, this flag has been removed from the local::lib codebase in order to
    prevent misunderstandings and potentially broken builds. The local::lib authors
    recommend that you look at the lib::core::only module shipped with this
    distribution in order to create a more robust environment that is equivalent to
    what --self-contained provided (although quite possibly not what you originally
    thought it provided due to the poor quality of the documentation, for which we
    apologise).
    DEATH
        }
        elsif( $arg =~ /^--deactivate(?:=(.*))?$/ ) {
          my $path = defined $1 ? $1 : shift @args;
          push @steps, ['deactivate', $path];
        }
        elsif ( $arg eq '--deactivate-all' ) {
          push @steps, ['deactivate_all'];
        }
        elsif ( $arg =~ /^--shelltype(?:=(.*))?$/ ) {
          $shelltype = defined $1 ? $1 : shift @args;
        }
        elsif ( $arg eq '--no-create' ) {
          $opts{no_create} = 1;
        }
        elsif ( $arg =~ /^--/ ) {
          die "Unknown import argument: $arg";
        }
        else {
          push @steps, ['activate', $arg];
        }
      }
      if (!@steps) {
        push @steps, ['activate', undef];
      }
    
      my $self = $class->new(%opts);
    
      for (@steps) {
        my ($method, @args) = @$_;
        $self = $self->$method(@args);
      }
    
      if ($0 eq '-') {
        print $self->environment_vars_string($shelltype);
        exit 0;
      }
      else {
        $self->setup_local_lib;
      }
    }
    
    sub new {
      my $class = shift;
      bless {@_}, $class;
    }
    
    sub clone {
      my $self = shift;
      bless {%$self, @_}, ref $self;
    }
    
    sub inc { $_[0]->{inc}     ||= \@INC }
    sub libs { $_[0]->{libs}   ||= [ \'PERL5LIB' ] }
    sub bins { $_[0]->{bins}   ||= [ \'PATH' ] }
    sub roots { $_[0]->{roots} ||= [ \'PERL_LOCAL_LIB_ROOT' ] }
    sub extra { $_[0]->{extra} ||= {} }
    sub no_create { $_[0]->{no_create} }
    
    my $_archname = $Config{archname};
    my $_version  = $Config{version};
    my @_inc_version_list = reverse split / /, $Config{inc_version_list};
    my $_path_sep = $Config{path_sep};
    
    sub _as_list {
      my $list = shift;
      grep length, map {
        !(ref $_ && ref $_ eq 'SCALAR') ? $_ : (
          defined $ENV{$$_} ? split(/\Q$_path_sep/, $ENV{$$_})
                            : ()
        )
      } ref $list ? @$list : $list;
    }
    sub _remove_from {
      my ($list, @remove) = @_;
      return @$list
        if !@remove;
      my %remove = map { $_ => 1 } @remove;
      grep !$remove{$_}, _as_list($list);
    }
    
    my @_lib_subdirs = (
      [$_version, $_archname],
      [$_version],
      [$_archname],
      (@_inc_version_list ? \@_inc_version_list : ()),
      [],
    );
    
    sub install_base_bin_path {
      my ($class, $path) = @_;
      return _catdir($path, 'bin');
    }
    sub install_base_perl_path {
      my ($class, $path) = @_;
      return _catdir($path, 'lib', 'perl5');
    }
    sub install_base_arch_path {
      my ($class, $path) = @_;
      _catdir($class->install_base_perl_path($path), $_archname);
    }
    
    sub lib_paths_for {
      my ($class, $path) = @_;
      my $base = $class->install_base_perl_path($path);
      return map { _catdir($base, @$_) } @_lib_subdirs;
    }
    
    sub _mm_escape_path {
      my $path = shift;
      $path =~ s/\\/\\\\/g;
      if ($path =~ s/ /\\ /g) {
        $path = qq{"$path"};
      }
      return $path;
    }
    
    sub _mb_escape_path {
      my $path = shift;
      $path =~ s/\\/\\\\/g;
      return qq{"$path"};
    }
    
    sub installer_options_for {
      my ($class, $path) = @_;
      return (
        PERL_MM_OPT =>
          defined $path ? "INSTALL_BASE="._mm_escape_path($path) : undef,
        PERL_MB_OPT =>
          defined $path ? "--install_base "._mb_escape_path($path) : undef,
      );
    }
    
    sub active_paths {
      my ($self) = @_;
      $self = ref $self ? $self : $self->new;
    
      return grep {
        # screen out entries that aren't actually reflected in @INC
        my $active_ll = $self->install_base_perl_path($_);
        grep { $_ eq $active_ll } @{$self->inc};
      } _as_list($self->roots);
    }
    
    
    sub deactivate {
      my ($self, $path) = @_;
      $self = $self->new unless ref $self;
      $path = $self->resolve_path($path);
      $path = $self->normalize_path($path);
    
      my @active_lls = $self->active_paths;
    
      if (!grep { $_ eq $path } @active_lls) {
        warn "Tried to deactivate inactive local::lib '$path'\n";
        return $self;
      }
    
      my %args = (
        bins  => [ _remove_from($self->bins,
          $self->install_base_bin_path($path)) ],
        libs  => [ _remove_from($self->libs,
          $self->install_base_perl_path($path)) ],
        inc   => [ _remove_from($self->inc,
          $self->lib_paths_for($path)) ],
        roots => [ _remove_from($self->roots, $path) ],
      );
    
      $args{extra} = { $self->installer_options_for($args{roots}[0]) };
    
      $self->clone(%args);
    }
    
    sub deactivate_all {
      my ($self) = @_;
      $self = $self->new unless ref $self;
    
      my @active_lls = $self->active_paths;
    
      my %args;
      if (@active_lls) {
        %args = (
          bins => [ _remove_from($self->bins,
            map $self->install_base_bin_path($_), @active_lls) ],
          libs => [ _remove_from($self->libs,
            map $self->install_base_perl_path($_), @active_lls) ],
          inc => [ _remove_from($self->inc,
            map $self->lib_paths_for($_), @active_lls) ],
          roots => [ _remove_from($self->roots, @active_lls) ],
        );
      }
    
      $args{extra} = { $self->installer_options_for(undef) };
    
      $self->clone(%args);
    }
    
    sub activate {
      my ($self, $path) = @_;
      $self = $self->new unless ref $self;
      $path = $self->resolve_path($path);
      $self->ensure_dir_structure_for($path)
        unless $self->no_create;
    
      $path = $self->normalize_path($path);
    
      my @active_lls = $self->active_paths;
    
      if (grep { $_ eq $path } @active_lls[1 .. $#active_lls]) {
        $self = $self->deactivate($path);
      }
    
      my %args;
      if (!@active_lls || $active_lls[0] ne $path) {
        %args = (
          bins  => [ $self->install_base_bin_path($path), @{$self->bins} ],
          libs  => [ $self->install_base_perl_path($path), @{$self->libs} ],
          inc   => [ $self->lib_paths_for($path), @{$self->inc} ],
          roots => [ $path, @{$self->roots} ],
        );
      }
    
      $args{extra} = { $self->installer_options_for($path) };
    
      $self->clone(%args);
    }
    
    sub normalize_path {
      my ($self, $path) = @_;
      $path = ( Win32::GetShortPathName($path) || $path )
        if $^O eq 'MSWin32';
      return $path;
    }
    
    sub build_environment_vars_for {
      my $self = $_[0]->new->activate($_[1]);
      $self->build_environment_vars;
    }
    sub build_activate_environment_vars_for {
      my $self = $_[0]->new->activate($_[1]);
      $self->build_environment_vars;
    }
    sub build_deactivate_environment_vars_for {
      my $self = $_[0]->new->deactivate($_[1]);
      $self->build_environment_vars;
    }
    sub build_deact_all_environment_vars_for {
      my $self = $_[0]->new->deactivate_all;
      $self->build_environment_vars;
    }
    sub build_environment_vars {
      my $self = shift;
      (
        PATH                => join($_path_sep, _as_list($self->bins)),
        PERL5LIB            => join($_path_sep, _as_list($self->libs)),
        PERL_LOCAL_LIB_ROOT => join($_path_sep, _as_list($self->roots)),
        %{$self->extra},
      );
    }
    
    sub setup_local_lib_for {
      my $self = $_[0]->new->activate($_[1]);
      $self->setup_local_lib;
    }
    
    sub setup_local_lib {
      my $self = shift;
    
      # if Carp is already loaded, ensure Carp::Heavy is also loaded, to avoid
      # $VERSION mismatch errors (Carp::Heavy loads Carp, so we do not need to
      # check in the other direction)
      require Carp::Heavy if $INC{'Carp.pm'};
    
      $self->setup_env_hash;
      @INC = @{$self->inc};
    }
    
    sub setup_env_hash_for {
      my $self = $_[0]->new->activate($_[1]);
      $self->setup_env_hash;
    }
    sub setup_env_hash {
      my $self = shift;
      my %env = $self->build_environment_vars;
      for my $key (keys %env) {
        if (defined $env{$key}) {
          $ENV{$key} = $env{$key};
        }
        else {
          delete $ENV{$key};
        }
      }
    }
    
    sub print_environment_vars_for {
      print $_[0]->environment_vars_string_for(@_[1..$#_]);
    }
    
    sub environment_vars_string_for {
      my $self = $_[0]->new->activate($_[1]);
      $self->environment_vars_string;
    }
    sub environment_vars_string {
      my ($self, $shelltype) = @_;
    
      $shelltype ||= $self->guess_shelltype;
    
      my $extra = $self->extra;
      my @envs = (
        PATH                => $self->bins,
        PERL5LIB            => $self->libs,
        PERL_LOCAL_LIB_ROOT => $self->roots,
        map { $_ => $extra->{$_} } sort keys %$extra,
      );
      $self->_build_env_string($shelltype, \@envs);
    }
    
    sub _build_env_string {
      my ($self, $shelltype, $envs) = @_;
      my @envs = @$envs;
    
      my $build_method = "build_${shelltype}_env_declaration";
    
      my $out = '';
      while (@envs) {
        my ($name, $value) = (shift(@envs), shift(@envs));
        if (
            ref $value
            && @$value == 1
            && ref $value->[0]
            && ref $value->[0] eq 'SCALAR'
            && ${$value->[0]} eq $name) {
          next;
        }
        $out .= $self->$build_method($name, $value);
      }
      my $wrap_method = "wrap_${shelltype}_output";
      if ($self->can($wrap_method)) {
        return $self->$wrap_method($out);
      }
      return $out;
    }
    
    sub build_bourne_env_declaration {
      my ($class, $name, $args) = @_;
      my $value = $class->_interpolate($args, '${%s}', qr/["\\\$!`]/, '\\%s');
    
      if (!defined $value) {
        return qq{unset $name;\n};
      }
    
      $value =~ s/(^|\G|$_path_sep)\$\{$name\}$_path_sep/$1\${$name}\${$name+$_path_sep}/g;
      $value =~ s/$_path_sep\$\{$name\}$/\${$name+$_path_sep}\${$name}/;
    
      qq{${name}="$value"; export ${name};\n}
    }
    
    sub build_csh_env_declaration {
      my ($class, $name, $args) = @_;
      my ($value, @vars) = $class->_interpolate($args, '${%s}', '"', '"\\%s"');
      if (!defined $value) {
        return qq{unsetenv $name;\n};
      }
    
      my $out = '';
      for my $var (@vars) {
        $out .= qq{if ! \$?$name setenv $name '';\n};
      }
    
      my $value_without = $value;
      if ($value_without =~ s/(?:^|$_path_sep)\$\{$name\}(?:$_path_sep|$)//g) {
        $out .= qq{if "\${$name}" != '' setenv $name "$value";\n};
        $out .= qq{if "\${$name}" == '' };
      }
      $out .= qq{setenv $name "$value_without";\n};
      return $out;
    }
    
    sub build_cmd_env_declaration {
      my ($class, $name, $args) = @_;
      my $value = $class->_interpolate($args, '%%%s%%', qr(%), '%s');
      if (!$value) {
        return qq{\@set $name=\n};
      }
    
      my $out = '';
      my $value_without = $value;
      if ($value_without =~ s/(?:^|$_path_sep)%$name%(?:$_path_sep|$)//g) {
        $out .= qq{\@if not "%$name%"=="" set "$name=$value"\n};
        $out .= qq{\@if "%$name%"=="" };
      }
      $out .= qq{\@set "$name=$value_without"\n};
      return $out;
    }
    
    sub build_powershell_env_declaration {
      my ($class, $name, $args) = @_;
      my $value = $class->_interpolate($args, '$env:%s', '"', '`%s');
    
      if (!$value) {
        return qq{Remove-Item -ErrorAction 0 Env:\\$name;\n};
      }
    
      my $maybe_path_sep = qq{\$(if("\$env:$name"-eq""){""}else{"$_path_sep"})};
      $value =~ s/(^|\G|$_path_sep)\$env:$name$_path_sep/$1\$env:$name"+$maybe_path_sep+"/g;
      $value =~ s/$_path_sep\$env:$name$/"+$maybe_path_sep+\$env:$name+"/;
    
      qq{\$env:$name = \$("$value");\n};
    }
    sub wrap_powershell_output {
      my ($class, $out) = @_;
      return $out || " \n";
    }
    
    sub build_fish_env_declaration {
      my ($class, $name, $args) = @_;
      my $value = $class->_interpolate($args, '$%s', qr/[\\"' ]/, '\\%s');
      if (!defined $value) {
        return qq{set -e $name;\n};
      }
      $value =~ s/$_path_sep/ /g;
      qq{set -x $name $value;\n};
    }
    
    sub _interpolate {
      my ($class, $args, $var_pat, $escape, $escape_pat) = @_;
      return
        unless defined $args;
      my @args = ref $args ? @$args : $args;
      return
        unless @args;
      my @vars = map { $$_ } grep { ref $_ eq 'SCALAR' } @args;
      my $string = join $_path_sep, map {
        ref $_ eq 'SCALAR' ? sprintf($var_pat, $$_) : do {
          s/($escape)/sprintf($escape_pat, $1)/ge; $_;
        };
      } @args;
      return wantarray ? ($string, \@vars) : $string;
    }
    
    sub pipeline;
    
    sub pipeline {
      my @methods = @_;
      my $last = pop(@methods);
      if (@methods) {
        \sub {
          my ($obj, @args) = @_;
          $obj->${pipeline @methods}(
            $obj->$last(@args)
          );
        };
      } else {
        \sub {
          shift->$last(@_);
        };
      }
    }
    
    sub resolve_path {
      my ($class, $path) = @_;
    
      $path = $class->${pipeline qw(
        resolve_relative_path
        resolve_home_path
        resolve_empty_path
      )}($path);
    
      $path;
    }
    
    sub resolve_empty_path {
      my ($class, $path) = @_;
      if (defined $path) {
        $path;
      } else {
        '~/perl5';
      }
    }
    
    sub resolve_home_path {
      my ($class, $path) = @_;
      $path =~ /^~([^\/]*)/ or return $path;
      my $user = $1;
      my $homedir = do {
        if (! length($user) && defined $ENV{HOME}) {
          $ENV{HOME};
        }
        else {
          require File::Glob;
          File::Glob::bsd_glob("~$user", File::Glob::GLOB_TILDE());
        }
      };
      unless (defined $homedir) {
        require Carp; require Carp::Heavy;
        Carp::croak(
          "Couldn't resolve homedir for "
          .(defined $user ? $user : 'current user')
        );
      }
      $path =~ s/^~[^\/]*/$homedir/;
      $path;
    }
    
    sub resolve_relative_path {
      my ($class, $path) = @_;
      _rel2abs($path);
    }
    
    sub ensure_dir_structure_for {
      my ($class, $path) = @_;
      unless (-d $path) {
        warn "Attempting to create directory ${path}\n";
      }
      require File::Basename;
      my @dirs;
      while(!-d $path) {
        push @dirs, $path;
        $path = File::Basename::dirname($path);
      }
      mkdir $_ for reverse @dirs;
      return;
    }
    
    sub guess_shelltype {
      my $shellbin
        = defined $ENV{SHELL}
          ? ($ENV{SHELL} =~ /([\w.]+)$/)[-1]
        : ( $^O eq 'MSWin32' && exists $ENV{'!EXITCODE'} )
          ? 'bash'
        : ( $^O eq 'MSWin32' && $ENV{PROMPT} && $ENV{COMSPEC} )
          ? ($ENV{COMSPEC} =~ /([\w.]+)$/)[-1]
        : ( $^O eq 'MSWin32' && !$ENV{PROMPT} )
          ? 'powershell.exe'
        : 'sh';
    
      for ($shellbin) {
        return
            /csh$/                   ? 'csh'
          : /fish/                   ? 'fish'
          : /command(?:\.com)?$/i    ? 'cmd'
          : /cmd(?:\.exe)?$/i        ? 'cmd'
          : /4nt(?:\.exe)?$/i        ? 'cmd'
          : /powershell(?:\.exe)?$/i ? 'powershell'
                                     : 'bourne';
      }
    }
    
    1;
    __END__
    
    =encoding utf8
    
    =head1 NAME
    
    local::lib - create and use a local lib/ for perl modules with PERL5LIB
    
    =head1 SYNOPSIS
    
    In code -
    
      use local::lib; # sets up a local lib at ~/perl5
    
      use local::lib '~/foo'; # same, but ~/foo
    
      # Or...
      use FindBin;
      use local::lib "$FindBin::Bin/../support";  # app-local support library
    
    From the shell -
    
      # Install LWP and its missing dependencies to the '~/perl5' directory
      perl -MCPAN -Mlocal::lib -e 'CPAN::install(LWP)'
    
      # Just print out useful shell commands
      $ perl -Mlocal::lib
      PERL_MB_OPT='--install_base /home/username/perl5'; export PERL_MB_OPT;
      PERL_MM_OPT='INSTALL_BASE=/home/username/perl5'; export PERL_MM_OPT;
      PERL5LIB="/home/username/perl5/lib/perl5"; export PERL5LIB;
      PATH="/home/username/perl5/bin:$PATH"; export PATH;
      PERL_LOCAL_LIB_ROOT="/home/usename/perl5:$PERL_LOCAL_LIB_ROOT"; export PERL_LOCAL_LIB_ROOT;
    
    From a .bashrc file -
    
      [ $SHLVL -eq 1 ] && eval "$(perl -I$HOME/perl5/lib/perl5 -Mlocal::lib)"
    
    =head2 The bootstrapping technique
    
    A typical way to install local::lib is using what is known as the
    "bootstrapping" technique.  You would do this if your system administrator
    hasn't already installed local::lib.  In this case, you'll need to install
    local::lib in your home directory.
    
    Even if you do have administrative privileges, you will still want to set up your
    environment variables, as discussed in step 4. Without this, you would still
    install the modules into the system CPAN installation and also your Perl scripts
    will not use the lib/ path you bootstrapped with local::lib.
    
    By default local::lib installs itself and the CPAN modules into ~/perl5.
    
    Windows users must also see L</Differences when using this module under Win32>.
    
    =over 4
    
    =item 1.
    
    Download and unpack the local::lib tarball from CPAN (search for "Download"
    on the CPAN page about local::lib).  Do this as an ordinary user, not as root
    or administrator.  Unpack the file in your home directory or in any other
    convenient location.
    
    =item 2.
    
    Run this:
    
      perl Makefile.PL --bootstrap
    
    If the system asks you whether it should automatically configure as much
    as possible, you would typically answer yes.
    
    In order to install local::lib into a directory other than the default, you need
    to specify the name of the directory when you call bootstrap, as follows:
    
      perl Makefile.PL --bootstrap=~/foo
    
    =item 3.
    
    Run this: (local::lib assumes you have make installed on your system)
    
      make test && make install
    
    =item 4.
    
    Now we need to setup the appropriate environment variables, so that Perl
    starts using our newly generated lib/ directory. If you are using bash or
    any other Bourne shells, you can add this to your shell startup script this
    way:
    
      echo '[ $SHLVL -eq 1 ] && eval "$(perl -I$HOME/perl5/lib/perl5 -Mlocal::lib)"' >>~/.bashrc
    
    If you are using C shell, you can do this as follows:
    
      /bin/csh
      echo $SHELL
      /bin/csh
      echo 'eval `perl -I$HOME/perl5/lib/perl5 -Mlocal::lib`' >> ~/.cshrc
    
    If you passed to bootstrap a directory other than default, you also need to
    give that as import parameter to the call of the local::lib module like this
    way:
    
      echo '[ $SHLVL -eq 1 ] && eval "$(perl -I$HOME/foo/lib/perl5 -Mlocal::lib=$HOME/foo)"' >>~/.bashrc
    
    After writing your shell configuration file, be sure to re-read it to get the
    changed settings into your current shell's environment. Bourne shells use
    C<. ~/.bashrc> for this, whereas C shells use C<source ~/.cshrc>.
    
    =back
    
    If you're on a slower machine, or are operating under draconian disk space
    limitations, you can disable the automatic generation of manpages from POD when
    installing modules by using the C<--no-manpages> argument when bootstrapping:
    
      perl Makefile.PL --bootstrap --no-manpages
    
    To avoid doing several bootstrap for several Perl module environments on the
    same account, for example if you use it for several different deployed
    applications independently, you can use one bootstrapped local::lib
    installation to install modules in different directories directly this way:
    
      cd ~/mydir1
      perl -Mlocal::lib=./
      eval $(perl -Mlocal::lib=./)  ### To set the environment for this shell alone
      printenv                      ### You will see that ~/mydir1 is in the PERL5LIB
      perl -MCPAN -e install ...    ### whatever modules you want
      cd ../mydir2
      ... REPEAT ...
    
    When used in a C<.bashrc> file, it is recommended that you protect against
    re-activating a directory in a sub-shell.  This can be done by checking the
    C<$SHLVL> variable as shown in synopsis.  Without this, sub-shells created by
    the user or other programs will override changes made to the parent shell's
    environment.
    
    If you are working with several C<local::lib> environments, you may want to
    remove some of them from the current environment without disturbing the others.
    You can deactivate one environment like this (using bourne sh):
    
      eval $(perl -Mlocal::lib=--deactivate,~/path)
    
    which will generate and run the commands needed to remove C<~/path> from your
    various search paths. Whichever environment was B<activated most recently> will
    remain the target for module installations. That is, if you activate
    C<~/path_A> and then you activate C<~/path_B>, new modules you install will go
    in C<~/path_B>. If you deactivate C<~/path_B> then modules will be installed
    into C<~/pathA> -- but if you deactivate C<~/path_A> then they will still be
    installed in C<~/pathB> because pathB was activated later.
    
    You can also ask C<local::lib> to clean itself completely out of the current
    shell's environment with the C<--deactivate-all> option.
    For multiple environments for multiple apps you may need to include a modified
    version of the C<< use FindBin >> instructions in the "In code" sample above.
    If you did something like the above, you have a set of Perl modules at C<<
    ~/mydir1/lib >>. If you have a script at C<< ~/mydir1/scripts/myscript.pl >>,
    you need to tell it where to find the modules you installed for it at C<<
    ~/mydir1/lib >>.
    
    In C<< ~/mydir1/scripts/myscript.pl >>:
    
      use strict;
      use warnings;
      use local::lib "$FindBin::Bin/..";  ### points to ~/mydir1 and local::lib finds lib
      use lib "$FindBin::Bin/../lib";     ### points to ~/mydir1/lib
    
    Put this before any BEGIN { ... } blocks that require the modules you installed.
    
    =head2 Differences when using this module under Win32
    
    To set up the proper environment variables for your current session of
    C<CMD.exe>, you can use this:
    
      C:\>perl -Mlocal::lib
      set PERL_MB_OPT=--install_base C:\DOCUME~1\ADMINI~1\perl5
      set PERL_MM_OPT=INSTALL_BASE=C:\DOCUME~1\ADMINI~1\perl5
      set PERL5LIB=C:\DOCUME~1\ADMINI~1\perl5\lib\perl5
      set PATH=C:\DOCUME~1\ADMINI~1\perl5\bin;%PATH%
    
      ### To set the environment for this shell alone
      C:\>perl -Mlocal::lib > %TEMP%\tmp.bat && %TEMP%\tmp.bat && del %TEMP%\tmp.bat
      ### instead of $(perl -Mlocal::lib=./)
    
    If you want the environment entries to persist, you'll need to add them to the
    Control Panel's System applet yourself or use L<App::local::lib::Win32Helper>.
    
    The "~" is translated to the user's profile directory (the directory named for
    the user under "Documents and Settings" (Windows XP or earlier) or "Users"
    (Windows Vista or later)) unless $ENV{HOME} exists. After that, the home
    directory is translated to a short name (which means the directory must exist)
    and the subdirectories are created.
    
    =head3 PowerShell
    
    local::lib also supports PowerShell, and can be used with the
    C<Invoke-Expression> cmdlet.
    
      Invoke-Expression "$(perl -Mlocal::lib)"
    
    =head1 RATIONALE
    
    The version of a Perl package on your machine is not always the version you
    need.  Obviously, the best thing to do would be to update to the version you
    need.  However, you might be in a situation where you're prevented from doing
    this.  Perhaps you don't have system administrator privileges; or perhaps you
    are using a package management system such as Debian, and nobody has yet gotten
    around to packaging up the version you need.
    
    local::lib solves this problem by allowing you to create your own directory of
    Perl packages downloaded from CPAN (in a multi-user system, this would typically
    be within your own home directory).  The existing system Perl installation is
    not affected; you simply invoke Perl with special options so that Perl uses the
    packages in your own local package directory rather than the system packages.
    local::lib arranges things so that your locally installed version of the Perl
    packages takes precedence over the system installation.
    
    If you are using a package management system (such as Debian), you don't need to
    worry about Debian and CPAN stepping on each other's toes.  Your local version
    of the packages will be written to an entirely separate directory from those
    installed by Debian.
    
    =head1 DESCRIPTION
    
    This module provides a quick, convenient way of bootstrapping a user-local Perl
    module library located within the user's home directory. It also constructs and
    prints out for the user the list of environment variables using the syntax
    appropriate for the user's current shell (as specified by the C<SHELL>
    environment variable), suitable for directly adding to one's shell
    configuration file.
    
    More generally, local::lib allows for the bootstrapping and usage of a
    directory containing Perl modules outside of Perl's C<@INC>. This makes it
    easier to ship an application with an app-specific copy of a Perl module, or
    collection of modules. Useful in cases like when an upstream maintainer hasn't
    applied a patch to a module of theirs that you need for your application.
    
    On import, local::lib sets the following environment variables to appropriate
    values:
    
    =over 4
    
    =item PERL_MB_OPT
    
    =item PERL_MM_OPT
    
    =item PERL5LIB
    
    =item PATH
    
    =item PERL_LOCAL_LIB_ROOT
    
    =back
    
    When possible, these will be appended to instead of overwritten entirely.
    
    These values are then available for reference by any code after import.
    
    =head1 CREATING A SELF-CONTAINED SET OF MODULES
    
    See L<lib::core::only> for one way to do this - but note that
    there are a number of caveats, and the best approach is always to perform a
    build against a clean perl (i.e. site and vendor as close to empty as possible).
    
    =head1 IMPORT OPTIONS
    
    Options are values that can be passed to the C<local::lib> import besides the
    directory to use. They are specified as C<use local::lib '--option'[, path];>
    or C<perl -Mlocal::lib=--option[,path]>.
    
    =head2 --deactivate
    
    Remove the chosen path (or the default path) from the module search paths if it
    was added by C<local::lib>, instead of adding it.
    
    =head2 --deactivate-all
    
    Remove all directories that were added to search paths by C<local::lib> from the
    search paths.
    
    =head2 --shelltype
    
    Specify the shell type to use for output.  By default, the shell will be
    detected based on the environment.  Should be one of: C<bourne>, C<csh>,
    C<cmd>, or C<powershell>.
    
    =head2 --no-create
    
    Prevents C<local::lib> from creating directories when activating dirs.  This is
    likely to cause issues on Win32 systems.
    
    =head1 CLASS METHODS
    
    =head2 ensure_dir_structure_for
    
    =over 4
    
    =item Arguments: $path
    
    =item Return value: None
    
    =back
    
    Attempts to create the given path, and all required parent directories. Throws
    an exception on failure.
    
    =head2 print_environment_vars_for
    
    =over 4
    
    =item Arguments: $path
    
    =item Return value: None
    
    =back
    
    Prints to standard output the variables listed above, properly set to use the
    given path as the base directory.
    
    =head2 build_environment_vars_for
    
    =over 4
    
    =item Arguments: $path
    
    =item Return value: %environment_vars
    
    =back
    
    Returns a hash with the variables listed above, properly set to use the
    given path as the base directory.
    
    =head2 setup_env_hash_for
    
    =over 4
    
    =item Arguments: $path
    
    =item Return value: None
    
    =back
    
    Constructs the C<%ENV> keys for the given path, by calling
    L</build_environment_vars_for>.
    
    =head2 active_paths
    
    =over 4
    
    =item Arguments: None
    
    =item Return value: @paths
    
    =back
    
    Returns a list of active C<local::lib> paths, according to the
    C<PERL_LOCAL_LIB_ROOT> environment variable and verified against
    what is really in C<@INC>.
    
    =head2 install_base_perl_path
    
    =over 4
    
    =item Arguments: $path
    
    =item Return value: $install_base_perl_path
    
    =back
    
    Returns a path describing where to install the Perl modules for this local
    library installation. Appends the directories C<lib> and C<perl5> to the given
    path.
    
    =head2 lib_paths_for
    
    =over 4
    
    =item Arguments: $path
    
    =item Return value: @lib_paths
    
    =back
    
    Returns the list of paths perl will search for libraries, given a base path.
    This includes the base path itself, the architecture specific subdirectory, and
    perl version specific subdirectories.  These paths may not all exist.
    
    =head2 install_base_bin_path
    
    =over 4
    
    =item Arguments: $path
    
    =item Return value: $install_base_bin_path
    
    =back
    
    Returns a path describing where to install the executable programs for this
    local library installation. Appends the directory C<bin> to the given path.
    
    =head2 installer_options_for
    
    =over 4
    
    =item Arguments: $path
    
    =item Return value: %installer_env_vars
    
    =back
    
    Returns a hash of environment variables that should be set to cause
    installation into the given path.
    
    =head2 resolve_empty_path
    
    =over 4
    
    =item Arguments: $path
    
    =item Return value: $base_path
    
    =back
    
    Builds and returns the base path into which to set up the local module
    installation. Defaults to C<~/perl5>.
    
    =head2 resolve_home_path
    
    =over 4
    
    =item Arguments: $path
    
    =item Return value: $home_path
    
    =back
    
    Attempts to find the user's home directory. If installed, uses C<File::HomeDir>
    for this purpose. If no definite answer is available, throws an exception.
    
    =head2 resolve_relative_path
    
    =over 4
    
    =item Arguments: $path
    
    =item Return value: $absolute_path
    
    =back
    
    Translates the given path into an absolute path.
    
    =head2 resolve_path
    
    =over 4
    
    =item Arguments: $path
    
    =item Return value: $absolute_path
    
    =back
    
    Calls the following in a pipeline, passing the result from the previous to the
    next, in an attempt to find where to configure the environment for a local
    library installation: L</resolve_empty_path>, L</resolve_home_path>,
    L</resolve_relative_path>. Passes the given path argument to
    L</resolve_empty_path> which then returns a result that is passed to
    L</resolve_home_path>, which then has its result passed to
    L</resolve_relative_path>. The result of this final call is returned from
    L</resolve_path>.
    
    =head1 OBJECT INTERFACE
    
    =head2 new
    
    =over 4
    
    =item Arguments: %attributes
    
    =item Return value: $local_lib
    
    =back
    
    Constructs a new C<local::lib> object, representing the current state of
    C<@INC> and the relevant environment variables.
    
    =head1 ATTRIBUTES
    
    =head2 roots
    
    An arrayref representing active C<local::lib> directories.
    
    =head2 inc
    
    An arrayref representing C<@INC>.
    
    =head2 libs
    
    An arrayref representing the PERL5LIB environment variable.
    
    =head2 bins
    
    An arrayref representing the PATH environment variable.
    
    =head2 extra
    
    A hashref of extra environment variables (e.g. C<PERL_MM_OPT> and
    C<PERL_MB_OPT>)
    
    =head2 no_create
    
    If set, C<local::lib> will not try to create directories when activating them.
    
    =head1 OBJECT METHODS
    
    =head2 clone
    
    =over 4
    
    =item Arguments: %attributes
    
    =item Return value: $local_lib
    
    =back
    
    Constructs a new C<local::lib> object based on the existing one, overriding the
    specified attributes.
    
    =head2 activate
    
    =over 4
    
    =item Arguments: $path
    
    =item Return value: $new_local_lib
    
    =back
    
    Constructs a new instance with the specified path active.
    
    =head2 deactivate
    
    =over 4
    
    =item Arguments: $path
    
    =item Return value: $new_local_lib
    
    =back
    
    Constructs a new instance with the specified path deactivated.
    
    =head2 deactivate_all
    
    =over 4
    
    =item Arguments: None
    
    =item Return value: $new_local_lib
    
    =back
    
    Constructs a new instance with all C<local::lib> directories deactivated.
    
    =head2 environment_vars_string
    
    =over 4
    
    =item Arguments: [ $shelltype ]
    
    =item Return value: $shell_env_string
    
    =back
    
    Returns a string to set up the C<local::lib>, meant to be run by a shell.
    
    =head2 build_environment_vars
    
    =over 4
    
    =item Arguments: None
    
    =item Return value: %environment_vars
    
    =back
    
    Returns a hash with the variables listed above, properly set to use the
    given path as the base directory.
    
    =head2 setup_env_hash
    
    =over 4
    
    =item Arguments: None
    
    =item Return value: None
    
    =back
    
    Constructs the C<%ENV> keys for the given path, by calling
    L</build_environment_vars>.
    
    =head2 setup_local_lib
    
    Constructs the C<%ENV> hash using L</setup_env_hash>, and set up C<@INC>.
    
    =head1 A WARNING ABOUT UNINST=1
    
    Be careful about using local::lib in combination with "make install UNINST=1".
    The idea of this feature is that will uninstall an old version of a module
    before installing a new one. However it lacks a safety check that the old
    version and the new version will go in the same directory. Used in combination
    with local::lib, you can potentially delete a globally accessible version of a
    module while installing the new version in a local place. Only combine "make
    install UNINST=1" and local::lib if you understand these possible consequences.
    
    =head1 LIMITATIONS
    
    =over 4
    
    =item * Directory names with spaces in them are not well supported by the perl
    toolchain and the programs it uses.  Pure-perl distributions should support
    spaces, but problems are more likely with dists that require compilation. A
    workaround you can do is moving your local::lib to a directory with spaces
    B<after> you installed all modules inside your local::lib bootstrap. But be
    aware that you can't update or install CPAN modules after the move.
    
    =item * Rather basic shell detection. Right now anything with csh in its name is
    assumed to be a C shell or something compatible, and everything else is assumed
    to be Bourne, except on Win32 systems. If the C<SHELL> environment variable is
    not set, a Bourne-compatible shell is assumed.
    
    =item * Kills any existing PERL_MM_OPT or PERL_MB_OPT.
    
    =item * Should probably auto-fixup CPAN config if not already done.
    
    =item * On VMS and MacOS Classic (pre-OS X), local::lib loads L<File::Spec>.
    This means any L<File::Spec> version installed in the local::lib will be
    ignored by scripts using local::lib.  A workaround for this is using
    C<use lib "$local_lib/lib/perl5";> instead of using C<local::lib> directly.
    
    =item * Conflicts with L<ExtUtils::MakeMaker>'s C<PREFIX> option.
    C<local::lib> uses the C<INSTALL_BASE> option, as it has more predictable and
    sane behavior.  If something attempts to use the C<PREFIX> option when running
    a F<Makefile.PL>, L<ExtUtils::MakeMaker> will refuse to run, as the two
    options conflict.  This can be worked around by temporarily unsetting the
    C<PERL_MM_OPT> environment variable.
    
    =item * Conflicts with L<Module::Build>'s C<--prefix> option.  Similar to the
    previous limitation, but any C<--prefix> option specified will be ignored.
    This can be worked around by temporarily unsetting the C<PERL_MB_OPT>
    environment variable.
    
    =back
    
    Patches very much welcome for any of the above.
    
    =over 4
    
    =item * On Win32 systems, does not have a way to write the created environment
    variables to the registry, so that they can persist through a reboot.
    
    =back
    
    =head1 TROUBLESHOOTING
    
    If you've configured local::lib to install CPAN modules somewhere in to your
    home directory, and at some point later you try to install a module with C<cpan
    -i Foo::Bar>, but it fails with an error like: C<Warning: You do not have
    permissions to install into /usr/lib64/perl5/site_perl/5.8.8/x86_64-linux at
    /usr/lib64/perl5/5.8.8/Foo/Bar.pm> and buried within the install log is an
    error saying C<'INSTALL_BASE' is not a known MakeMaker parameter name>, then
    you've somehow lost your updated ExtUtils::MakeMaker module.
    
    To remedy this situation, rerun the bootstrapping procedure documented above.
    
    Then, run C<rm -r ~/.cpan/build/Foo-Bar*>
    
    Finally, re-run C<cpan -i Foo::Bar> and it should install without problems.
    
    =head1 ENVIRONMENT
    
    =over 4
    
    =item SHELL
    
    =item COMSPEC
    
    local::lib looks at the user's C<SHELL> environment variable when printing out
    commands to add to the shell configuration file.
    
    On Win32 systems, C<COMSPEC> is also examined.
    
    =back
    
    =head1 SEE ALSO
    
    =over 4
    
    =item * L<Perl Advent article, 2011|http://perladvent.org/2011/2011-12-01.html>
    
    =back
    
    =head1 SUPPORT
    
    IRC:
    
        Join #local-lib on irc.perl.org.
    
    =head1 AUTHOR
    
    Matt S Trout <mst@shadowcat.co.uk> http://www.shadowcat.co.uk/
    
    auto_install fixes kindly sponsored by http://www.takkle.com/
    
    =head1 CONTRIBUTORS
    
    Patches to correctly output commands for csh style shells, as well as some
    documentation additions, contributed by Christopher Nehren <apeiron@cpan.org>.
    
    Doc patches for a custom local::lib directory, more cleanups in the english
    documentation and a L<german documentation|POD2::DE::local::lib> contributed by
    Torsten Raudssus <torsten@raudssus.de>.
    
    Hans Dieter Pearcey <hdp@cpan.org> sent in some additional tests for ensuring
    things will install properly, submitted a fix for the bug causing problems with
    writing Makefiles during bootstrapping, contributed an example program, and
    submitted yet another fix to ensure that local::lib can install and bootstrap
    properly. Many, many thanks!
    
    pattern of Freenode IRC contributed the beginnings of the Troubleshooting
    section. Many thanks!
    
    Patch to add Win32 support contributed by Curtis Jewell <csjewell@cpan.org>.
    
    Warnings for missing PATH/PERL5LIB (as when not running interactively) silenced
    by a patch from Marco Emilio Poleggi.
    
    Mark Stosberg <mark@summersault.com> provided the code for the now deleted
    '--self-contained' option.
    
    Documentation patches to make win32 usage clearer by
    David Mertens <dcmertens.perl@gmail.com> (run4flat).
    
    Brazilian L<portuguese translation|POD2::PT_BR::local::lib> and minor doc
    patches contributed by Breno G. de Oliveira <garu@cpan.org>.
    
    Improvements to stacking multiple local::lib dirs and removing them from the
    environment later on contributed by Andrew Rodland <arodland@cpan.org>.
    
    Patch for Carp version mismatch contributed by Hakim Cassimally
    <osfameron@cpan.org>.
    
    Rewrite of internals and numerous bug fixes and added features contributed by
    Graham Knop <haarg@haarg.org>.
    
    =head1 COPYRIGHT
    
    Copyright (c) 2007 - 2013 the local::lib L</AUTHOR> and L</CONTRIBUTORS> as
    listed above.
    
    =head1 LICENSE
    
    This is free software; you can redistribute it and/or modify it under
    the same terms as the Perl 5 programming language system itself.
    
    =cut
  LOCAL_LIB
  
  $fatpacked{"parent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARENT';
    package parent;
    use strict;
    use vars qw($VERSION);
    $VERSION = '0.228';
    
    sub import {
        my $class = shift;
    
        my $inheritor = caller(0);
    
        if ( @_ and $_[0] eq '-norequire' ) {
            shift @_;
        } else {
            for ( my @filename = @_ ) {
                if ( $_ eq $inheritor ) {
                    warn "Class '$inheritor' tried to inherit from itself\n";
                };
    
                s{::|'}{/}g;
                require "$_.pm"; # dies if the file is not found
            }
        }
    
        {
            no strict 'refs';
            push @{"$inheritor\::ISA"}, @_;
        };
    };
    
    "All your base are belong to us"
    
    __END__
    
    =encoding utf8
    
    =head1 NAME
    
    parent - Establish an ISA relationship with base classes at compile time
    
    =head1 SYNOPSIS
    
        package Baz;
        use parent qw(Foo Bar);
    
    =head1 DESCRIPTION
    
    Allows you to both load one or more modules, while setting up inheritance from
    those modules at the same time.  Mostly similar in effect to
    
        package Baz;
        BEGIN {
            require Foo;
            require Bar;
            push @ISA, qw(Foo Bar);
        }
    
    By default, every base class needs to live in a file of its own.
    If you want to have a subclass and its parent class in the same file, you
    can tell C<parent> not to load any modules by using the C<-norequire> switch:
    
      package Foo;
      sub exclaim { "I CAN HAS PERL" }
    
      package DoesNotLoadFooBar;
      use parent -norequire, 'Foo', 'Bar';
      # will not go looking for Foo.pm or Bar.pm
    
    This is equivalent to the following code:
    
      package Foo;
      sub exclaim { "I CAN HAS PERL" }
    
      package DoesNotLoadFooBar;
      push @DoesNotLoadFooBar::ISA, 'Foo', 'Bar';
    
    This is also helpful for the case where a package lives within
    a differently named file:
    
      package MyHash;
      use Tie::Hash;
      use parent -norequire, 'Tie::StdHash';
    
    This is equivalent to the following code:
    
      package MyHash;
      require Tie::Hash;
      push @ISA, 'Tie::StdHash';
    
    If you want to load a subclass from a file that C<require> would
    not consider an eligible filename (that is, it does not end in
    either C<.pm> or C<.pmc>), use the following code:
    
      package MySecondPlugin;
      require './plugins/custom.plugin'; # contains Plugin::Custom
      use parent -norequire, 'Plugin::Custom';
    
    =head1 DIAGNOSTICS
    
    =over 4
    
    =item Class 'Foo' tried to inherit from itself
    
    Attempting to inherit from yourself generates a warning.
    
        package Foo;
        use parent 'Foo';
    
    =back
    
    =head1 HISTORY
    
    This module was forked from L<base> to remove the cruft
    that had accumulated in it.
    
    =head1 CAVEATS
    
    =head1 SEE ALSO
    
    L<base>
    
    =head1 AUTHORS AND CONTRIBUTORS
    
    Rafaël Garcia-Suarez, Bart Lateur, Max Maischein, Anno Siegel, Michael Schwern
    
    =head1 MAINTAINER
    
    Max Maischein C< corion@cpan.org >
    
    Copyright (c) 2007-10 Max Maischein C<< <corion@cpan.org> >>
    Based on the idea of C<base.pm>, which was introduced with Perl 5.004_04.
    
    =head1 LICENSE
    
    This module is released under the same terms as Perl itself.
    
    =cut
  PARENT
  
  $fatpacked{"version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VERSION';
    #!perl -w
    package version;
    
    use 5.006002;
    use strict;
    use warnings::register;
    if ($] >= 5.015) {
        warnings::register_categories(qw/version/);
    }
    
    use vars qw(@ISA $VERSION $CLASS $STRICT $LAX *declare *qv);
    
    $VERSION = 0.9912;
    $CLASS = 'version';
    
    # !!!!Delete this next block completely when adding to Perl core!!!!
    {
        local $SIG{'__DIE__'};
        if (1) { # always pretend there's no XS
    	eval "use version::vpp $VERSION"; # don't tempt fate
    	die "$@" if ( $@ );
    	push @ISA, "version::vpp";
    	local $^W;
    	*version::qv = \&version::vpp::qv;
    	*version::declare = \&version::vpp::declare;
    	*version::_VERSION = \&version::vpp::_VERSION;
    	*version::vcmp = \&version::vpp::vcmp;
    	*version::new = \&version::vpp::new;
    	*version::numify = \&version::vpp::numify;
    	*version::normal = \&version::vpp::normal;
    	if ($] >= 5.009000) {
    	    no strict 'refs';
    	    *version::stringify = \&version::vpp::stringify;
    	    *{'version::(""'} = \&version::vpp::stringify;
    	    *{'version::(<=>'} = \&version::vpp::vcmp;
    	    *version::parse = \&version::vpp::parse;
    	}
        }
        else { # use XS module
    	push @ISA, "version::vxs";
    	local $^W;
    	*version::declare = \&version::vxs::declare;
    	*version::qv = \&version::vxs::qv;
    	*version::_VERSION = \&version::vxs::_VERSION;
    	*version::vcmp = \&version::vxs::VCMP;
    	*version::new = \&version::vxs::new;
    	*version::numify = \&version::vxs::numify;
    	*version::normal = \&version::vxs::normal;
    	if ($] >= 5.009000) {
    	    no strict 'refs';
    	    *version::stringify = \&version::vxs::stringify;
    	    *{'version::(""'} = \&version::vxs::stringify;
    	    *{'version::(<=>'} = \&version::vxs::VCMP;
    	    *version::parse = \&version::vxs::parse;
    	}
        }
    }
    
    # avoid using Exporter
    require version::regex;
    *version::is_lax = \&version::regex::is_lax;
    *version::is_strict = \&version::regex::is_strict;
    *LAX = \$version::regex::LAX;
    *STRICT = \$version::regex::STRICT;
    
    sub import {
        no strict 'refs';
        my ($class) = shift;
    
        # Set up any derived class
        unless ($class eq $CLASS) {
    	local $^W;
    	*{$class.'::declare'} =  \&{$CLASS.'::declare'};
    	*{$class.'::qv'} = \&{$CLASS.'::qv'};
        }
    
        my %args;
        if (@_) { # any remaining terms are arguments
    	map { $args{$_} = 1 } @_
        }
        else { # no parameters at all on use line
    	%args =
    	(
    	    qv => 1,
    	    'UNIVERSAL::VERSION' => 1,
    	);
        }
    
        my $callpkg = caller();
    
        if (exists($args{declare})) {
    	*{$callpkg.'::declare'} =
    	    sub {return $class->declare(shift) }
    	  unless defined(&{$callpkg.'::declare'});
        }
    
        if (exists($args{qv})) {
    	*{$callpkg.'::qv'} =
    	    sub {return $class->qv(shift) }
    	  unless defined(&{$callpkg.'::qv'});
        }
    
        if (exists($args{'UNIVERSAL::VERSION'})) {
    	local $^W;
    	*UNIVERSAL::VERSION
    		= \&{$CLASS.'::_VERSION'};
        }
    
        if (exists($args{'VERSION'})) {
    	*{$callpkg.'::VERSION'} = \&{$CLASS.'::_VERSION'};
        }
    
        if (exists($args{'is_strict'})) {
    	*{$callpkg.'::is_strict'} = \&{$CLASS.'::is_strict'}
    	  unless defined(&{$callpkg.'::is_strict'});
        }
    
        if (exists($args{'is_lax'})) {
    	*{$callpkg.'::is_lax'} = \&{$CLASS.'::is_lax'}
    	  unless defined(&{$callpkg.'::is_lax'});
        }
    }
    
    
    1;
  VERSION
  
  $fatpacked{"version/regex.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VERSION_REGEX';
    package version::regex;
    
    use strict;
    
    use vars qw($VERSION $CLASS $STRICT $LAX);
    
    $VERSION = 0.9912;
    
    #--------------------------------------------------------------------------#
    # Version regexp components
    #--------------------------------------------------------------------------#
    
    # Fraction part of a decimal version number.  This is a common part of
    # both strict and lax decimal versions
    
    my $FRACTION_PART = qr/\.[0-9]+/;
    
    # First part of either decimal or dotted-decimal strict version number.
    # Unsigned integer with no leading zeroes (except for zero itself) to
    # avoid confusion with octal.
    
    my $STRICT_INTEGER_PART = qr/0|[1-9][0-9]*/;
    
    # First part of either decimal or dotted-decimal lax version number.
    # Unsigned integer, but allowing leading zeros.  Always interpreted
    # as decimal.  However, some forms of the resulting syntax give odd
    # results if used as ordinary Perl expressions, due to how perl treats
    # octals.  E.g.
    #   version->new("010" ) == 10
    #   version->new( 010  ) == 8
    #   version->new( 010.2) == 82  # "8" . "2"
    
    my $LAX_INTEGER_PART = qr/[0-9]+/;
    
    # Second and subsequent part of a strict dotted-decimal version number.
    # Leading zeroes are permitted, and the number is always decimal.
    # Limited to three digits to avoid overflow when converting to decimal
    # form and also avoid problematic style with excessive leading zeroes.
    
    my $STRICT_DOTTED_DECIMAL_PART = qr/\.[0-9]{1,3}/;
    
    # Second and subsequent part of a lax dotted-decimal version number.
    # Leading zeroes are permitted, and the number is always decimal.  No
    # limit on the numerical value or number of digits, so there is the
    # possibility of overflow when converting to decimal form.
    
    my $LAX_DOTTED_DECIMAL_PART = qr/\.[0-9]+/;
    
    # Alpha suffix part of lax version number syntax.  Acts like a
    # dotted-decimal part.
    
    my $LAX_ALPHA_PART = qr/_[0-9]+/;
    
    #--------------------------------------------------------------------------#
    # Strict version regexp definitions
    #--------------------------------------------------------------------------#
    
    # Strict decimal version number.
    
    my $STRICT_DECIMAL_VERSION =
        qr/ $STRICT_INTEGER_PART $FRACTION_PART? /x;
    
    # Strict dotted-decimal version number.  Must have both leading "v" and
    # at least three parts, to avoid confusion with decimal syntax.
    
    my $STRICT_DOTTED_DECIMAL_VERSION =
        qr/ v $STRICT_INTEGER_PART $STRICT_DOTTED_DECIMAL_PART{2,} /x;
    
    # Complete strict version number syntax -- should generally be used
    # anchored: qr/ \A $STRICT \z /x
    
    $STRICT =
        qr/ $STRICT_DECIMAL_VERSION | $STRICT_DOTTED_DECIMAL_VERSION /x;
    
    #--------------------------------------------------------------------------#
    # Lax version regexp definitions
    #--------------------------------------------------------------------------#
    
    # Lax decimal version number.  Just like the strict one except for
    # allowing an alpha suffix or allowing a leading or trailing
    # decimal-point
    
    my $LAX_DECIMAL_VERSION =
        qr/ $LAX_INTEGER_PART (?: \. | $FRACTION_PART $LAX_ALPHA_PART? )?
    	|
    	$FRACTION_PART $LAX_ALPHA_PART?
        /x;
    
    # Lax dotted-decimal version number.  Distinguished by having either
    # leading "v" or at least three non-alpha parts.  Alpha part is only
    # permitted if there are at least two non-alpha parts. Strangely
    # enough, without the leading "v", Perl takes .1.2 to mean v0.1.2,
    # so when there is no "v", the leading part is optional
    
    my $LAX_DOTTED_DECIMAL_VERSION =
        qr/
    	v $LAX_INTEGER_PART (?: $LAX_DOTTED_DECIMAL_PART+ $LAX_ALPHA_PART? )?
    	|
    	$LAX_INTEGER_PART? $LAX_DOTTED_DECIMAL_PART{2,} $LAX_ALPHA_PART?
        /x;
    
    # Complete lax version number syntax -- should generally be used
    # anchored: qr/ \A $LAX \z /x
    #
    # The string 'undef' is a special case to make for easier handling
    # of return values from ExtUtils::MM->parse_version
    
    $LAX =
        qr/ undef | $LAX_DECIMAL_VERSION | $LAX_DOTTED_DECIMAL_VERSION /x;
    
    #--------------------------------------------------------------------------#
    
    # Preloaded methods go here.
    sub is_strict	{ defined $_[0] && $_[0] =~ qr/ \A $STRICT \z /x }
    sub is_lax	{ defined $_[0] && $_[0] =~ qr/ \A $LAX \z /x }
    
    1;
  VERSION_REGEX
  
  $fatpacked{"version/vpp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VERSION_VPP';
    package charstar;
    # a little helper class to emulate C char* semantics in Perl
    # so that prescan_version can use the same code as in C
    
    use overload (
        '""'	=> \&thischar,
        '0+'	=> \&thischar,
        '++'	=> \&increment,
        '--'	=> \&decrement,
        '+'		=> \&plus,
        '-'		=> \&minus,
        '*'		=> \&multiply,
        'cmp'	=> \&cmp,
        '<=>'	=> \&spaceship,
        'bool'	=> \&thischar,
        '='		=> \&clone,
    );
    
    sub new {
        my ($self, $string) = @_;
        my $class = ref($self) || $self;
    
        my $obj = {
    	string  => [split(//,$string)],
    	current => 0,
        };
        return bless $obj, $class;
    }
    
    sub thischar {
        my ($self) = @_;
        my $last = $#{$self->{string}};
        my $curr = $self->{current};
        if ($curr >= 0 && $curr <= $last) {
    	return $self->{string}->[$curr];
        }
        else {
    	return '';
        }
    }
    
    sub increment {
        my ($self) = @_;
        $self->{current}++;
    }
    
    sub decrement {
        my ($self) = @_;
        $self->{current}--;
    }
    
    sub plus {
        my ($self, $offset) = @_;
        my $rself = $self->clone;
        $rself->{current} += $offset;
        return $rself;
    }
    
    sub minus {
        my ($self, $offset) = @_;
        my $rself = $self->clone;
        $rself->{current} -= $offset;
        return $rself;
    }
    
    sub multiply {
        my ($left, $right, $swapped) = @_;
        my $char = $left->thischar();
        return $char * $right;
    }
    
    sub spaceship {
        my ($left, $right, $swapped) = @_;
        unless (ref($right)) { # not an object already
    	$right = $left->new($right);
        }
        return $left->{current} <=> $right->{current};
    }
    
    sub cmp {
        my ($left, $right, $swapped) = @_;
        unless (ref($right)) { # not an object already
    	if (length($right) == 1) { # comparing single character only
    	    return $left->thischar cmp $right;
    	}
    	$right = $left->new($right);
        }
        return $left->currstr cmp $right->currstr;
    }
    
    sub bool {
        my ($self) = @_;
        my $char = $self->thischar;
        return ($char ne '');
    }
    
    sub clone {
        my ($left, $right, $swapped) = @_;
        $right = {
    	string  => [@{$left->{string}}],
    	current => $left->{current},
        };
        return bless $right, ref($left);
    }
    
    sub currstr {
        my ($self, $s) = @_;
        my $curr = $self->{current};
        my $last = $#{$self->{string}};
        if (defined($s) && $s->{current} < $last) {
    	$last = $s->{current};
        }
    
        my $string = join('', @{$self->{string}}[$curr..$last]);
        return $string;
    }
    
    package version::vpp;
    
    use 5.006002;
    use strict;
    use warnings::register;
    
    use Config;
    use vars qw($VERSION $CLASS @ISA $LAX $STRICT $WARN_CATEGORY);
    $VERSION = 0.9912;
    $CLASS = 'version::vpp';
    if ($] > 5.015) {
        warnings::register_categories(qw/version/);
        $WARN_CATEGORY = 'version';
    } else {
        $WARN_CATEGORY = 'numeric';
    }
    
    require version::regex;
    *version::vpp::is_strict = \&version::regex::is_strict;
    *version::vpp::is_lax = \&version::regex::is_lax;
    *LAX = \$version::regex::LAX;
    *STRICT = \$version::regex::STRICT;
    
    use overload (
        '""'       => \&stringify,
        '0+'       => \&numify,
        'cmp'      => \&vcmp,
        '<=>'      => \&vcmp,
        'bool'     => \&vbool,
        '+'        => \&vnoop,
        '-'        => \&vnoop,
        '*'        => \&vnoop,
        '/'        => \&vnoop,
        '+='        => \&vnoop,
        '-='        => \&vnoop,
        '*='        => \&vnoop,
        '/='        => \&vnoop,
        'abs'      => \&vnoop,
    );
    
    sub import {
        no strict 'refs';
        my ($class) = shift;
    
        # Set up any derived class
        unless ($class eq $CLASS) {
    	local $^W;
    	*{$class.'::declare'} =  \&{$CLASS.'::declare'};
    	*{$class.'::qv'} = \&{$CLASS.'::qv'};
        }
    
        my %args;
        if (@_) { # any remaining terms are arguments
    	map { $args{$_} = 1 } @_
        }
        else { # no parameters at all on use line
    	%args =
    	(
    	    qv => 1,
    	    'UNIVERSAL::VERSION' => 1,
    	);
        }
    
        my $callpkg = caller();
    
        if (exists($args{declare})) {
    	*{$callpkg.'::declare'} =
    	    sub {return $class->declare(shift) }
    	  unless defined(&{$callpkg.'::declare'});
        }
    
        if (exists($args{qv})) {
    	*{$callpkg.'::qv'} =
    	    sub {return $class->qv(shift) }
    	  unless defined(&{$callpkg.'::qv'});
        }
    
        if (exists($args{'UNIVERSAL::VERSION'})) {
    	no warnings qw/redefine/;
    	*UNIVERSAL::VERSION
    		= \&{$CLASS.'::_VERSION'};
        }
    
        if (exists($args{'VERSION'})) {
    	*{$callpkg.'::VERSION'} = \&{$CLASS.'::_VERSION'};
        }
    
        if (exists($args{'is_strict'})) {
    	*{$callpkg.'::is_strict'} = \&{$CLASS.'::is_strict'}
    	  unless defined(&{$callpkg.'::is_strict'});
        }
    
        if (exists($args{'is_lax'})) {
    	*{$callpkg.'::is_lax'} = \&{$CLASS.'::is_lax'}
    	  unless defined(&{$callpkg.'::is_lax'});
        }
    }
    
    my $VERSION_MAX = 0x7FFFFFFF;
    
    # implement prescan_version as closely to the C version as possible
    use constant TRUE  => 1;
    use constant FALSE => 0;
    
    sub isDIGIT {
        my ($char) = shift->thischar();
        return ($char =~ /\d/);
    }
    
    sub isALPHA {
        my ($char) = shift->thischar();
        return ($char =~ /[a-zA-Z]/);
    }
    
    sub isSPACE {
        my ($char) = shift->thischar();
        return ($char =~ /\s/);
    }
    
    sub BADVERSION {
        my ($s, $errstr, $error) = @_;
        if ($errstr) {
    	$$errstr = $error;
        }
        return $s;
    }
    
    sub prescan_version {
        my ($s, $strict, $errstr, $sqv, $ssaw_decimal, $swidth, $salpha) = @_;
        my $qv          = defined $sqv          ? $$sqv          : FALSE;
        my $saw_decimal = defined $ssaw_decimal ? $$ssaw_decimal : 0;
        my $width       = defined $swidth       ? $$swidth       : 3;
        my $alpha       = defined $salpha       ? $$salpha       : FALSE;
    
        my $d = $s;
    
        if ($qv && isDIGIT($d)) {
    	goto dotted_decimal_version;
        }
    
        if ($d eq 'v') { # explicit v-string
    	$d++;
    	if (isDIGIT($d)) {
    	    $qv = TRUE;
    	}
    	else { # degenerate v-string
    	    # requires v1.2.3
    	    return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
    	}
    
    dotted_decimal_version:
    	if ($strict && $d eq '0' && isDIGIT($d+1)) {
    	    # no leading zeros allowed
    	    return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)");
    	}
    
    	while (isDIGIT($d)) { 	# integer part
    	    $d++;
    	}
    
    	if ($d eq '.')
    	{
    	    $saw_decimal++;
    	    $d++; 		# decimal point
    	}
    	else
    	{
    	    if ($strict) {
    		# require v1.2.3
    		return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
    	    }
    	    else {
    		goto version_prescan_finish;
    	    }
    	}
    
    	{
    	    my $i = 0;
    	    my $j = 0;
    	    while (isDIGIT($d)) {	# just keep reading
    		$i++;
    		while (isDIGIT($d)) {
    		    $d++; $j++;
    		    # maximum 3 digits between decimal
    		    if ($strict && $j > 3) {
    			return BADVERSION($s,$errstr,"Invalid version format (maximum 3 digits between decimals)");
    		    }
    		}
    		if ($d eq '_') {
    		    if ($strict) {
    			return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
    		    }
    		    if ( $alpha ) {
    			return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)");
    		    }
    		    $d++;
    		    $alpha = TRUE;
    		}
    		elsif ($d eq '.') {
    		    if ($alpha) {
    			return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)");
    		    }
    		    $saw_decimal++;
    		    $d++;
    		}
    		elsif (!isDIGIT($d)) {
    		    last;
    		}
    		$j = 0;
    	    }
    
    	    if ($strict && $i < 2) {
    		# requires v1.2.3
    		return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
    	    }
    	}
        } 					# end if dotted-decimal
        else
        {					# decimal versions
    	my $j = 0;
    	# special $strict case for leading '.' or '0'
    	if ($strict) {
    	    if ($d eq '.') {
    		return BADVERSION($s,$errstr,"Invalid version format (0 before decimal required)");
    	    }
    	    if ($d eq '0' && isDIGIT($d+1)) {
    		return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)");
    	    }
    	}
    
    	# and we never support negative version numbers
    	if ($d eq '-') {
    	    return BADVERSION($s,$errstr,"Invalid version format (negative version number)");
    	}
    
    	# consume all of the integer part
    	while (isDIGIT($d)) {
    	    $d++;
    	}
    
    	# look for a fractional part
    	if ($d eq '.') {
    	    # we found it, so consume it
    	    $saw_decimal++;
    	    $d++;
    	}
    	elsif (!$d || $d eq ';' || isSPACE($d) || $d eq '}') {
    	    if ( $d == $s ) {
    		# found nothing
    		return BADVERSION($s,$errstr,"Invalid version format (version required)");
    	    }
    	    # found just an integer
    	    goto version_prescan_finish;
    	}
    	elsif ( $d == $s ) {
    	    # didn't find either integer or period
    	    return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
    	}
    	elsif ($d eq '_') {
    	    # underscore can't come after integer part
    	    if ($strict) {
    		return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
    	    }
    	    elsif (isDIGIT($d+1)) {
    		return BADVERSION($s,$errstr,"Invalid version format (alpha without decimal)");
    	    }
    	    else {
    		return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)");
    	    }
    	}
    	elsif ($d) {
    	    # anything else after integer part is just invalid data
    	    return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
    	}
    
    	# scan the fractional part after the decimal point
    	if ($d && !isDIGIT($d) && ($strict || ! ($d eq ';' || isSPACE($d) || $d eq '}') )) {
    		# $strict or lax-but-not-the-end
    		return BADVERSION($s,$errstr,"Invalid version format (fractional part required)");
    	}
    
    	while (isDIGIT($d)) {
    	    $d++; $j++;
    	    if ($d eq '.' && isDIGIT($d-1)) {
    		if ($alpha) {
    		    return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)");
    		}
    		if ($strict) {
    		    return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions must begin with 'v')");
    		}
    		$d = $s; # start all over again
    		$qv = TRUE;
    		goto dotted_decimal_version;
    	    }
    	    if ($d eq '_') {
    		if ($strict) {
    		    return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
    		}
    		if ( $alpha ) {
    		    return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)");
    		}
    		if ( ! isDIGIT($d+1) ) {
    		    return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)");
    		}
    		$width = $j;
    		$d++;
    		$alpha = TRUE;
    	    }
    	}
        }
    
    version_prescan_finish:
        while (isSPACE($d)) {
    	$d++;
        }
    
        if ($d && !isDIGIT($d) && (! ($d eq ';' || $d eq '}') )) {
    	# trailing non-numeric data
    	return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
        }
        if ($saw_decimal > 1 && ($d-1) eq '.') {
    	# no trailing period allowed
    	return BADVERSION($s,$errstr,"Invalid version format (trailing decimal)");
        }
    
        if (defined $sqv) {
    	$$sqv = $qv;
        }
        if (defined $swidth) {
    	$$swidth = $width;
        }
        if (defined $ssaw_decimal) {
    	$$ssaw_decimal = $saw_decimal;
        }
        if (defined $salpha) {
    	$$salpha = $alpha;
        }
        return $d;
    }
    
    sub scan_version {
        my ($s, $rv, $qv) = @_;
        my $start;
        my $pos;
        my $last;
        my $errstr;
        my $saw_decimal = 0;
        my $width = 3;
        my $alpha = FALSE;
        my $vinf = FALSE;
        my @av;
    
        $s = new charstar $s;
    
        while (isSPACE($s)) { # leading whitespace is OK
    	$s++;
        }
    
        $last = prescan_version($s, FALSE, \$errstr, \$qv, \$saw_decimal,
    	\$width, \$alpha);
    
        if ($errstr) {
    	# 'undef' is a special case and not an error
    	if ( $s ne 'undef') {
    	    require Carp;
    	    Carp::croak($errstr);
    	}
        }
    
        $start = $s;
        if ($s eq 'v') {
    	$s++;
        }
        $pos = $s;
    
        if ( $qv ) {
    	$$rv->{qv} = $qv;
        }
        if ( $alpha ) {
    	$$rv->{alpha} = $alpha;
        }
        if ( !$qv && $width < 3 ) {
    	$$rv->{width} = $width;
        }
    
        while (isDIGIT($pos)) {
    	$pos++;
        }
        if (!isALPHA($pos)) {
    	my $rev;
    
    	for (;;) {
    	    $rev = 0;
    	    {
      		# this is atoi() that delimits on underscores
      		my $end = $pos;
      		my $mult = 1;
    		my $orev;
    
    		#  the following if() will only be true after the decimal
    		#  point of a version originally created with a bare
    		#  floating point number, i.e. not quoted in any way
    		#
     		if ( !$qv && $s > $start && $saw_decimal == 1 ) {
    		    $mult *= 100;
     		    while ( $s < $end ) {
    			$orev = $rev;
     			$rev += $s * $mult;
     			$mult /= 10;
    			if (   (abs($orev) > abs($rev))
    			    || (abs($rev) > $VERSION_MAX )) {
    			    warn("Integer overflow in version %d",
    					   $VERSION_MAX);
    			    $s = $end - 1;
    			    $rev = $VERSION_MAX;
    			    $vinf = 1;
    			}
     			$s++;
    			if ( $s eq '_' ) {
    			    $s++;
    			}
     		    }
      		}
     		else {
     		    while (--$end >= $s) {
    			$orev = $rev;
     			$rev += $end * $mult;
     			$mult *= 10;
    			if (   (abs($orev) > abs($rev))
    			    || (abs($rev) > $VERSION_MAX )) {
    			    warn("Integer overflow in version");
    			    $end = $s - 1;
    			    $rev = $VERSION_MAX;
    			    $vinf = 1;
    			}
     		    }
     		}
      	    }
    
      	    # Append revision
    	    push @av, $rev;
    	    if ( $vinf ) {
    		$s = $last;
    		last;
    	    }
    	    elsif ( $pos eq '.' ) {
    		$pos++;
    		if ($qv) {
    		    # skip leading zeros
    		    while ($pos eq '0') {
    			$pos++;
    		    }
    		}
    		$s = $pos;
    	    }
    	    elsif ( $pos eq '_' && isDIGIT($pos+1) ) {
    		$s = ++$pos;
    	    }
    	    elsif ( $pos eq ',' && isDIGIT($pos+1) ) {
    		$s = ++$pos;
    	    }
    	    elsif ( isDIGIT($pos) ) {
    		$s = $pos;
    	    }
    	    else {
    		$s = $pos;
    		last;
    	    }
    	    if ( $qv ) {
    		while ( isDIGIT($pos) ) {
    		    $pos++;
    		}
    	    }
    	    else {
    		my $digits = 0;
    		while ( ( isDIGIT($pos) || $pos eq '_' ) && $digits < 3 ) {
    		    if ( $pos ne '_' ) {
    			$digits++;
    		    }
    		    $pos++;
    		}
    	    }
    	}
        }
        if ( $qv ) { # quoted versions always get at least three terms
    	my $len = $#av;
    	#  This for loop appears to trigger a compiler bug on OS X, as it
    	#  loops infinitely. Yes, len is negative. No, it makes no sense.
    	#  Compiler in question is:
    	#  gcc version 3.3 20030304 (Apple Computer, Inc. build 1640)
    	#  for ( len = 2 - len; len > 0; len-- )
    	#  av_push(MUTABLE_AV(sv), newSViv(0));
    	#
    	$len = 2 - $len;
    	while ($len-- > 0) {
    	    push @av, 0;
    	}
        }
    
        # need to save off the current version string for later
        if ( $vinf ) {
    	$$rv->{original} = "v.Inf";
    	$$rv->{vinf} = 1;
        }
        elsif ( $s > $start ) {
    	$$rv->{original} = $start->currstr($s);
    	if ( $qv && $saw_decimal == 1 && $start ne 'v' ) {
    	    # need to insert a v to be consistent
    	    $$rv->{original} = 'v' . $$rv->{original};
    	}
        }
        else {
    	$$rv->{original} = '0';
    	push(@av, 0);
        }
    
        # And finally, store the AV in the hash
        $$rv->{version} = \@av;
    
        # fix RT#19517 - special case 'undef' as string
        if ($s eq 'undef') {
    	$s += 5;
        }
    
        return $s;
    }
    
    sub new {
        my $class = shift;
        unless (defined $class or $#_ > 1) {
    	require Carp;
    	Carp::croak('Usage: version::new(class, version)');
        }
    
        my $self = bless ({}, ref ($class) || $class);
        my $qv = FALSE;
    
        if ( $#_ == 1 ) { # must be CVS-style
    	$qv = TRUE;
        }
        my $value = pop; # always going to be the last element
    
        if ( ref($value) && eval('$value->isa("version")') ) {
    	# Can copy the elements directly
    	$self->{version} = [ @{$value->{version} } ];
    	$self->{qv} = 1 if $value->{qv};
    	$self->{alpha} = 1 if $value->{alpha};
    	$self->{original} = ''.$value->{original};
    	return $self;
        }
    
        if ( not defined $value or $value =~ /^undef$/ ) {
    	# RT #19517 - special case for undef comparison
    	# or someone forgot to pass a value
    	push @{$self->{version}}, 0;
    	$self->{original} = "0";
    	return ($self);
        }
    
    
        if (ref($value) =~ m/ARRAY|HASH/) {
    	require Carp;
    	Carp::croak("Invalid version format (non-numeric data)");
        }
    
        $value = _un_vstring($value);
    
        if ($Config{d_setlocale}) {
    	use POSIX qw/locale_h/;
    	use if $Config{d_setlocale}, 'locale';
    	my $currlocale = setlocale(LC_ALL);
    
    	# if the current locale uses commas for decimal points, we
    	# just replace commas with decimal places, rather than changing
    	# locales
    	if ( localeconv()->{decimal_point} eq ',' ) {
    	    $value =~ tr/,/./;
    	}
        }
    
        # exponential notation
        if ( $value =~ /\d+.?\d*e[-+]?\d+/ ) {
    	$value = sprintf("%.9f",$value);
    	$value =~ s/(0+)$//; # trim trailing zeros
        }
    
        my $s = scan_version($value, \$self, $qv);
    
        if ($s) { # must be something left over
    	warn("Version string '%s' contains invalid data; "
    		   ."ignoring: '%s'", $value, $s);
        }
    
        return ($self);
    }
    
    *parse = \&new;
    
    sub numify {
        my ($self) = @_;
        unless (_verify($self)) {
    	require Carp;
    	Carp::croak("Invalid version object");
        }
        my $width = $self->{width} || 3;
        my $alpha = $self->{alpha} || "";
        my $len = $#{$self->{version}};
        my $digit = $self->{version}[0];
        my $string = sprintf("%d.", $digit );
    
        if ($alpha and warnings::enabled()) {
    	warnings::warn($WARN_CATEGORY, 'alpha->numify() is lossy');
        }
    
        for ( my $i = 1 ; $i < $len ; $i++ ) {
    	$digit = $self->{version}[$i];
    	if ( $width < 3 ) {
    	    my $denom = 10**(3-$width);
    	    my $quot = int($digit/$denom);
    	    my $rem = $digit - ($quot * $denom);
    	    $string .= sprintf("%0".$width."d_%d", $quot, $rem);
    	}
    	else {
    	    $string .= sprintf("%03d", $digit);
    	}
        }
    
        if ( $len > 0 ) {
    	$digit = $self->{version}[$len];
    	if ( $alpha && $width == 3 ) {
    	    $string .= "_";
    	}
    	$string .= sprintf("%0".$width."d", $digit);
        }
        else # $len = 0
        {
    	$string .= sprintf("000");
        }
    
        return $string;
    }
    
    sub normal {
        my ($self) = @_;
        unless (_verify($self)) {
    	require Carp;
    	Carp::croak("Invalid version object");
        }
        my $alpha = $self->{alpha} || "";
        my $qv = $self->{qv} || "";
    
        my $len = $#{$self->{version}};
        my $digit = $self->{version}[0];
        my $string = sprintf("v%d", $digit );
    
        for ( my $i = 1 ; $i < $len ; $i++ ) {
    	$digit = $self->{version}[$i];
    	$string .= sprintf(".%d", $digit);
        }
    
        if ( $len > 0 ) {
    	$digit = $self->{version}[$len];
    	if ( $alpha ) {
    	    $string .= sprintf("_%0d", $digit);
    	}
    	else {
    	    $string .= sprintf(".%0d", $digit);
    	}
        }
    
        if ( $len <= 2 ) {
    	for ( $len = 2 - $len; $len != 0; $len-- ) {
    	    $string .= sprintf(".%0d", 0);
    	}
        }
    
        return $string;
    }
    
    sub stringify {
        my ($self) = @_;
        unless (_verify($self)) {
    	require Carp;
    	Carp::croak("Invalid version object");
        }
        return exists $self->{original}
        	? $self->{original}
    	: exists $self->{qv}
    	    ? $self->normal
    	    : $self->numify;
    }
    
    sub vcmp {
        require UNIVERSAL;
        my ($left,$right,$swap) = @_;
        my $class = ref($left);
        unless ( UNIVERSAL::isa($right, $class) ) {
    	$right = $class->new($right);
        }
    
        if ( $swap ) {
    	($left, $right) = ($right, $left);
        }
        unless (_verify($left)) {
    	require Carp;
    	Carp::croak("Invalid version object");
        }
        unless (_verify($right)) {
    	require Carp;
    	Carp::croak("Invalid version format");
        }
        my $l = $#{$left->{version}};
        my $r = $#{$right->{version}};
        my $m = $l < $r ? $l : $r;
        my $lalpha = $left->is_alpha;
        my $ralpha = $right->is_alpha;
        my $retval = 0;
        my $i = 0;
        while ( $i <= $m && $retval == 0 ) {
    	$retval = $left->{version}[$i] <=> $right->{version}[$i];
    	$i++;
        }
    
        # tiebreaker for alpha with identical terms
        if ( $retval == 0
    	&& $l == $r
    	&& $left->{version}[$m] == $right->{version}[$m]
    	&& ( $lalpha || $ralpha ) ) {
    
    	if ( $lalpha && !$ralpha ) {
    	    $retval = -1;
    	}
    	elsif ( $ralpha && !$lalpha) {
    	    $retval = +1;
    	}
        }
    
        # possible match except for trailing 0's
        if ( $retval == 0 && $l != $r ) {
    	if ( $l < $r ) {
    	    while ( $i <= $r && $retval == 0 ) {
    		if ( $right->{version}[$i] != 0 ) {
    		    $retval = -1; # not a match after all
    		}
    		$i++;
    	    }
    	}
    	else {
    	    while ( $i <= $l && $retval == 0 ) {
    		if ( $left->{version}[$i] != 0 ) {
    		    $retval = +1; # not a match after all
    		}
    		$i++;
    	    }
    	}
        }
    
        return $retval;
    }
    
    sub vbool {
        my ($self) = @_;
        return vcmp($self,$self->new("0"),1);
    }
    
    sub vnoop {
        require Carp;
        Carp::croak("operation not supported with version object");
    }
    
    sub is_alpha {
        my ($self) = @_;
        return (exists $self->{alpha});
    }
    
    sub qv {
        my $value = shift;
        my $class = $CLASS;
        if (@_) {
    	$class = ref($value) || $value;
    	$value = shift;
        }
    
        $value = _un_vstring($value);
        $value = 'v'.$value unless $value =~ /(^v|\d+\.\d+\.\d)/;
        my $obj = $CLASS->new($value);
        return bless $obj, $class;
    }
    
    *declare = \&qv;
    
    sub is_qv {
        my ($self) = @_;
        return (exists $self->{qv});
    }
    
    
    sub _verify {
        my ($self) = @_;
        if ( ref($self)
    	&& eval { exists $self->{version} }
    	&& ref($self->{version}) eq 'ARRAY'
    	) {
    	return 1;
        }
        else {
    	return 0;
        }
    }
    
    sub _is_non_alphanumeric {
        my $s = shift;
        $s = new charstar $s;
        while ($s) {
    	return 0 if isSPACE($s); # early out
    	return 1 unless (isALPHA($s) || isDIGIT($s) || $s =~ /[.-]/);
    	$s++;
        }
        return 0;
    }
    
    sub _un_vstring {
        my $value = shift;
        # may be a v-string
        if ( length($value) >= 1 && $value !~ /[,._]/
    	&& _is_non_alphanumeric($value)) {
    	my $tvalue;
    	if ( $] >= 5.008_001 ) {
    	    $tvalue = _find_magic_vstring($value);
    	    $value = $tvalue if length $tvalue;
    	}
    	elsif ( $] >= 5.006_000 ) {
    	    $tvalue = sprintf("v%vd",$value);
    	    if ( $tvalue =~ /^v\d+(\.\d+)*$/ ) {
    		# must be a v-string
    		$value = $tvalue;
    	    }
    	}
        }
        return $value;
    }
    
    sub _find_magic_vstring {
        my $value = shift;
        my $tvalue = '';
        require B;
        my $sv = B::svref_2object(\$value);
        my $magic = ref($sv) eq 'B::PVMG' ? $sv->MAGIC : undef;
        while ( $magic ) {
    	if ( $magic->TYPE eq 'V' ) {
    	    $tvalue = $magic->PTR;
    	    $tvalue =~ s/^v?(.+)$/v$1/;
    	    last;
    	}
    	else {
    	    $magic = $magic->MOREMAGIC;
    	}
        }
        return $tvalue;
    }
    
    sub _VERSION {
        my ($obj, $req) = @_;
        my $class = ref($obj) || $obj;
    
        no strict 'refs';
        if ( exists $INC{"$class.pm"} and not %{"$class\::"} and $] >= 5.008) {
    	 # file but no package
    	require Carp;
    	Carp::croak( "$class defines neither package nor VERSION"
    	    ."--version check failed");
        }
    
        my $version = eval "\$$class\::VERSION";
        if ( defined $version ) {
    	local $^W if $] <= 5.008;
    	$version = version::vpp->new($version);
        }
    
        if ( defined $req ) {
    	unless ( defined $version ) {
    	    require Carp;
    	    my $msg =  $] < 5.006
    	    ? "$class version $req required--this is only version "
    	    : "$class does not define \$$class\::VERSION"
    	      ."--version check failed";
    
    	    if ( $ENV{VERSION_DEBUG} ) {
    		Carp::confess($msg);
    	    }
    	    else {
    		Carp::croak($msg);
    	    }
    	}
    
    	$req = version::vpp->new($req);
    
    	if ( $req > $version ) {
    	    require Carp;
    	    if ( $req->is_qv ) {
    		Carp::croak(
    		    sprintf ("%s version %s required--".
    			"this is only version %s", $class,
    			$req->normal, $version->normal)
    		);
    	    }
    	    else {
    		Carp::croak(
    		    sprintf ("%s version %s required--".
    			"this is only version %s", $class,
    			$req->stringify, $version->stringify)
    		);
    	    }
    	}
        }
    
        return defined $version ? $version->stringify : undef;
    }
    
    1; #this line is important and will help the module return a true value
  VERSION_VPP
  
  s/^  //mg for values %fatpacked;
  
  my $class = 'FatPacked::'.(0+\%fatpacked);
  no strict 'refs';
  *{"${class}::files"} = sub { keys %{$_[0]} };
  
  if ($] < 5.008) {
    *{"${class}::INC"} = sub {
      if (my $fat = $_[0]{$_[1]}) {
        my $pos = 0;
        my $last = length $fat;
        return (sub {
          return 0 if $pos == $last;
          my $next = (1 + index $fat, "\n", $pos) || $last;
          $_ .= substr $fat, $pos, $next - $pos;
          $pos = $next;
          return 1;
        });
      }
    };
  }
  
  else {
    *{"${class}::INC"} = sub {
      if (my $fat = $_[0]{$_[1]}) {
        open my $fh, '<', \$fat
          or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
        return $fh;
      }
      return;
    };
  }
  
  unshift @INC, bless \%fatpacked, $class;
    } # END OF FATPACK CODE
  
  
  
  use strict;
  use App::cpanminus::script;
  
  
  unless (caller) {
      my $app = App::cpanminus::script->new;
      $app->parse_options(@ARGV);
      exit $app->doit;
  }
  
  __END__
  
  =head1 NAME
  
  cpanm - get, unpack build and install modules from CPAN
  
  =head1 SYNOPSIS
  
    cpanm Test::More                                 # install Test::More
    cpanm MIYAGAWA/Plack-0.99_05.tar.gz              # full distribution path
    cpanm http://example.org/LDS/CGI.pm-3.20.tar.gz  # install from URL
    cpanm ~/dists/MyCompany-Enterprise-1.00.tar.gz   # install from a local file
    cpanm --interactive Task::Kensho                 # Configure interactively
    cpanm .                                          # install from local directory
    cpanm --installdeps .                            # install all the deps for the current directory
    cpanm -L extlib Plack                            # install Plack and all non-core deps into extlib
    cpanm --mirror http://cpan.cpantesters.org/ DBI  # use the fast-syncing mirror
    cpanm --from https://cpan.metacpan.org/ Plack    # use only the HTTPS mirror
  
  =head1 COMMANDS
  
  =over 4
  
  =item (arguments)
  
  Command line arguments can be either a module name, distribution file,
  local file path, HTTP URL or git repository URL. Following commands
  will all work as you expect.
  
      cpanm Plack
      cpanm Plack/Request.pm
      cpanm MIYAGAWA/Plack-1.0000.tar.gz
      cpanm /path/to/Plack-1.0000.tar.gz
      cpanm http://cpan.metacpan.org/authors/id/M/MI/MIYAGAWA/Plack-0.9990.tar.gz
      cpanm git://github.com/plack/Plack.git
  
  Additionally, you can use the notation using C<~> and C<@> to specify
  version for a given module. C<~> specifies the version requirement in
  the L<CPAN::Meta::Spec> format, while C<@> pins the exact version, and
  is a shortcut for C<~"== VERSION">.
  
      cpanm Plack~1.0000                 # 1.0000 or later
      cpanm Plack~">= 1.0000, < 2.0000"  # latest of 1.xxxx
      cpanm Plack@0.9990                 # specific version. same as Plack~"== 0.9990"
  
  The version query including specific version or range will be sent to
  L<MetaCPAN> to search for previous releases. The query will search for
  BackPAN archives by default, unless you specify C<--dev> option, in
  which case, archived versions will be filtered out.
  
  For a git repository, you can specify a branch, tag, or commit SHA to
  build. The default is C<master>
  
      cpanm git://github.com/plack/Plack.git@1.0000        # tag
      cpanm git://github.com/plack/Plack.git@devel         # branch
  
  =item -i, --install
  
  Installs the modules. This is a default behavior and this is just a
  compatibility option to make it work like L<cpan> or L<cpanp>.
  
  =item --self-upgrade
  
  Upgrades itself. It's just an alias for:
  
    cpanm App::cpanminus
  
  =item --info
  
  Displays the distribution information in
  C<AUTHOR/Dist-Name-ver.tar.gz> format in the standard out.
  
  =item --installdeps
  
  Installs the dependencies of the target distribution but won't build
  itself. Handy if you want to try the application from a version
  controlled repository such as git.
  
    cpanm --installdeps .
  
  =item --look
  
  Download and unpack the distribution and then open the directory with
  your shell. Handy to poke around the source code or do manual
  testing.
  
  =item -h, --help
  
  Displays the help message.
  
  =item -V, --version
  
  Displays the version number.
  
  =back
  
  =head1 OPTIONS
  
  You can specify the default options in C<PERL_CPANM_OPT> environment variable.
  
  =over 4
  
  =item -f, --force
  
  Force install modules even when testing failed.
  
  =item -n, --notest
  
  Skip the testing of modules. Use this only when you just want to save
  time for installing hundreds of distributions to the same perl and
  architecture you've already tested to make sure it builds fine.
  
  Defaults to false, and you can say C<--no-notest> to override when it
  is set in the default options in C<PERL_CPANM_OPT>.
  
  =item --test-only
  
  Run the tests only, and do not install the specified module or
  distributions. Handy if you want to verify the new (or even old)
  releases pass its unit tests without installing the module.
  
  Note that if you specify this option with a module or distribution
  that has dependencies, these dependencies will be installed if you
  don't currently have them.
  
  =item -S, --sudo
  
  Switch to the root user with C<sudo> when installing modules. Use this
  if you want to install modules to the system perl include path.
  
  Defaults to false, and you can say C<--no-sudo> to override when it is
  set in the default options in C<PERL_CPANM_OPT>.
  
  =item -v, --verbose
  
  Makes the output verbose. It also enables the interactive
  configuration. (See --interactive)
  
  =item -q, --quiet
  
  Makes the output even more quiet than the default. It only shows the
  successful/failed dependencies to the output.
  
  =item -l, --local-lib
  
  Sets the L<local::lib> compatible path to install modules to. You
  don't need to set this if you already configure the shell environment
  variables using L<local::lib>, but this can be used to override that
  as well.
  
  =item -L, --local-lib-contained
  
  Same with C<--local-lib> but with L<--self-contained> set.  All
  non-core dependencies will be installed even if they're already
  installed.
  
  For instance,
  
    cpanm -L extlib Plack
  
  would install Plack and all of its non-core dependencies into the
  directory C<extlib>, which can be loaded from your application with:
  
    use local::lib '/path/to/extlib';
  
  Note that this option does B<NOT> reliably work with perl installations
  supplied by operating system vendors that strips standard modules from perl,
  such as RHEL, Fedora and CentOS, B<UNLESS> you also install packages supplying
  all the modules that have been stripped.  For these systems you will probably
  want to install the C<perl-core> meta-package which does just that.
  
  =item --self-contained
  
  When examining the dependencies, assume no non-core modules are
  installed on the system. Handy if you want to bundle application
  dependencies in one directory so you can distribute to other machines.
  
  =item --exclude-vendor
  
  Don't include modules installed under the 'vendor' paths when searching for
  core modules when the C<--self-contained> flag is in effect.  This restores
  the behaviour from before version 1.7023
  
  =item --mirror
  
  Specifies the base URL for the CPAN mirror to use, such as
  C<http://cpan.cpantesters.org/> (you can omit the trailing slash). You
  can specify multiple mirror URLs by repeating the command line option.
  
  You can use a local directory that has a CPAN mirror structure
  (created by tools such as L<OrePAN> or L<Pinto>) by using a special
  URL scheme C<file://>. If the given URL begins with `/` (without any
  scheme), it is considered as a file scheme as well.
  
    cpanm --mirror file:///path/to/mirror
    cpanm --mirror ~/minicpan      # Because shell expands ~ to /home/user
  
  Defaults to C<http://www.cpan.org/>.
  
  =item --mirror-only
  
  Download the mirror's 02packages.details.txt.gz index file instead of
  querying the CPAN Meta DB. This will also effectively opt out sending
  your local perl versions to backend database servers such as CPAN Meta
  DB and MetaCPAN.
  
  Select this option if you are using a local mirror of CPAN, such as
  minicpan when you're offline, or your own CPAN index (a.k.a darkpan).
  
  =item --from, -M
  
    cpanm -M https://cpan.metacpan.org/
    cpanm --from https://cpan.metacpan.org/
  
  Use the given mirror URL and its index as the I<only> source to search
  and download modules from.
  
  It works similar to C<--mirror> and C<--mirror-only> combined, with a
  small difference: unlike C<--mirror> which I<appends> the URL to the
  list of mirrors, C<--from> (or C<-M> for short) uses the specified URL
  as its I<only> source to download index and modules from. This makes
  the option always override the default mirror, which might have been
  set via global options such as the one set by C<PERL_CPANM_OPT>
  environment variable.
  
  B<Tip:> It might be useful if you name these options with your shell
  aliases, like:
  
    alias minicpanm='cpanm --from ~/minicpan'
    alias darkpan='cpanm --from http://mycompany.example.com/DPAN'
  
  =item --mirror-index
  
  B<EXPERIMENTAL>: Specifies the file path to C<02packages.details.txt>
  for module search index.
  
  =item --cpanmetadb
  
  B<EXPERIMENTAL>: Specifies an alternate URI for CPAN MetaDB index lookups.
  
  =item --metacpan
  
  Prefers MetaCPAN API over CPAN MetaDB.
  
  =item --cpanfile
  
  B<EXPERIMENTAL>: Specified an alternate path for cpanfile to search for,
  when C<--installdeps> command is in use. Defaults to C<cpanfile>.
  
  =item --prompt
  
  Prompts when a test fails so that you can skip, force install, retry
  or look in the shell to see what's going wrong. It also prompts when
  one of the dependency failed if you want to proceed the installation.
  
  Defaults to false, and you can say C<--no-prompt> to override if it's
  set in the default options in C<PERL_CPANM_OPT>.
  
  =item --dev
  
  B<EXPERIMENTAL>: search for a newer developer release as well. Defaults to false.
  
  =item --reinstall
  
  cpanm, when given a module name in the command line (i.e. C<cpanm
  Plack>), checks the locally installed version first and skips if it is
  already installed. This option makes it skip the check, so:
  
    cpanm --reinstall Plack
  
  would reinstall L<Plack> even if your locally installed version is
  latest, or even newer (which would happen if you install a developer
  release from version control repositories).
  
  Defaults to false.
  
  =item --interactive
  
  Makes the configuration (such as C<Makefile.PL> and C<Build.PL>)
  interactive, so you can answer questions in the distribution that
  requires custom configuration or Task:: distributions.
  
  Defaults to false, and you can say C<--no-interactive> to override
  when it's set in the default options in C<PERL_CPANM_OPT>.
  
  =item --pp, --pureperl
  
  Prefer Pure perl build of modules by setting C<PUREPERL_ONLY=1> for
  MakeMaker and C<--pureperl-only> for Build.PL based
  distributions. Note that not all of the CPAN modules support this
  convention yet.
  
  =item --with-recommends, --with-suggests
  
  B<EXPERIMENTAL>: Installs dependencies declared as C<recommends> and
  C<suggests> respectively, per META spec. When these dependencies fail
  to install, cpanm continues the installation, since they're just
  recommendation/suggestion.
  
  Enabling this could potentially make a circular dependency for a few
  modules on CPAN, when C<recommends> adds a module that C<recommends>
  back the module in return.
  
  There's also C<--without-recommend> and C<--without-suggests> to
  override the default decision made earlier in C<PERL_CPANM_OPT>.
  
  Defaults to false for both.
  
  =item --with-develop
  
  B<EXPERIMENTAL>: Installs develop phase dependencies in META files or
  C<cpanfile> when used with C<--installdeps>. Defaults to false.
  
  =item --with-feature, --without-feature, --with-all-features
  
  B<EXPERIMENTAL>: Specifies the feature to enable, if a module supports
  optional features per META spec 2.0.
  
      cpanm --with-feature=opt_csv Spreadsheet::Read
  
  the features can also be interactively chosen when C<--interactive>
  option is enabled.
  
  C<--with-all-features> enables all the optional features, and
  C<--without-feature> can select a feature to disable.
  
  =item --configure-timeout, --build-timeout, --test-timeout
  
  Specify the timeout length (in seconds) to wait for the configure,
  build and test process. Current default values are: 60 for configure,
  3600 for build and 1800 for test.
  
  =item --configure-args, --build-args, --test-args, --install-args
  
  B<EXPERIMENTAL>: Pass arguments for configure/build/test/install
  commands respectively, for a given module to install.
  
      cpanm DBD::mysql --configure-args="--cflags=... --libs=..."
  
  The argument is only enabled for the module passed as a command line
  argument, not dependencies.
  
  =item --scandeps
  
  B<DEPRECATED>: Scans the depencencies of given modules and output the
  tree in a text format. (See C<--format> below for more options)
  
  Because this command doesn't actually install any distributions, it
  will be useful that by typing:
  
    cpanm --scandeps Catalyst::Runtime
  
  you can make sure what modules will be installed.
  
  This command takes into account which modules you already have
  installed in your system. If you want to see what modules will be
  installed against a vanilla perl installation, you might want to
  combine it with C<-L> option.
  
  =item --format
  
  B<DEPRECATED>: Determines what format to display the scanned
  dependency tree. Available options are C<tree>, C<json>, C<yaml> and
  C<dists>.
  
  =over 8
  
  =item tree
  
  Displays the tree in a plain text format. This is the default value.
  
  =item json, yaml
  
  Outputs the tree in a JSON or YAML format. L<JSON> and L<YAML> modules
  need to be installed respectively. The output tree is represented as a
  recursive tuple of:
  
    [ distribution, dependencies ]
  
  and the container is an array containing the root elements. Note that
  there may be multiple root nodes, since you can give multiple modules
  to the C<--scandeps> command.
  
  =item dists
  
  C<dists> is a special output format, where it prints the distribution
  filename in the I<depth first order> after the dependency resolution,
  like:
  
    GAAS/MIME-Base64-3.13.tar.gz
    GAAS/URI-1.58.tar.gz
    PETDANCE/HTML-Tagset-3.20.tar.gz
    GAAS/HTML-Parser-3.68.tar.gz
    GAAS/libwww-perl-5.837.tar.gz
  
  which means you can install these distributions in this order without
  extra dependencies. When combined with C<-L> option, it will be useful
  to replay installations on other machines.
  
  =back
  
  =item --save-dists
  
  Specifies the optional directory path to copy downloaded tarballs in
  the CPAN mirror compatible directory structure
  i.e. I<authors/id/A/AU/AUTHORS/Foo-Bar-version.tar.gz>
  
  If the distro tarball did not come from CPAN, for example from a local
  file or from GitHub, then it will be saved under
  I<vendor/Foo-Bar-version.tar.gz>.
  
  =item --uninst-shadows
  
  Uninstalls the shadow files of the distribution that you're
  installing. This eliminates the confusion if you're trying to install
  core (dual-life) modules from CPAN against perl 5.10 or older, or
  modules that used to be XS-based but switched to pure perl at some
  version.
  
  If you run cpanm as root and use C<INSTALL_BASE> or equivalent to
  specify custom installation path, you SHOULD disable this option so
  you won't accidentally uninstall dual-life modules from the core
  include path.
  
  Defaults to true if your perl version is smaller than 5.12, and you
  can disable that with C<--no-uninst-shadows>.
  
  B<NOTE>: Since version 1.3000 this flag is turned off by default for
  perl newer than 5.12, since with 5.12 @INC contains site_perl directory
  I<before> the perl core library path, and uninstalling shadows is not
  necessary anymore and does more harm by deleting files from the core
  library path.
  
  =item --uninstall, -U
  
  Uninstalls a module from the library path. It finds a packlist for
  given modules, and removes all the files included in the same
  distribution.
  
  If you enable local::lib, it only removes files from the local::lib
  directory.
  
  If you try to uninstall a module in C<perl> directory (i.e. core
  module), an error will be thrown.
  
  A dialog will be prompted to confirm the files to be deleted. If you pass
  C<-f> option as well, the dialog will be skipped and uninstallation
  will be forced.
  
  =item --cascade-search
  
  B<EXPERIMENTAL>: Specifies whether to cascade search when you specify
  multiple mirrors and a mirror doesn't have a module or has a lower
  version of the module than requested. Defaults to false.
  
  =item --skip-installed
  
  Specifies whether a module given in the command line is skipped if its latest
  version is already installed. Defaults to true.
  
  B<NOTE>: The C<PERL5LIB> environment variable have to be correctly set
  for this to work with modules installed using L<local::lib>, unless
  you always use the C<-l> option.
  
  =item --skip-satisfied
  
  B<EXPERIMENTAL>: Specifies whether a module (and version) given in the
  command line is skipped if it's already installed.
  
  If you run:
  
    cpanm --skip-satisfied CGI DBI~1.2
  
  cpanm won't install them if you already have CGI (for whatever
  versions) or have DBI with version higher than 1.2. It is similar to
  C<--skip-installed> but while C<--skip-installed> checks if the
  I<latest> version of CPAN is installed, C<--skip-satisfied> checks if
  a requested version (or not, which means any version) is installed.
  
  Defaults to false.
  
  =item --verify
  
  Verify the integrity of distribution files retrieved from PAUSE using
  CHECKSUMS and SIGNATURES (if found). Defaults to false.
  
  =item --report-perl-version
  
  Whether it reports the locally installed perl version to the various
  web server as part of User-Agent. Defaults to true unless CI related
  environment variables such as C<TRAVIS>, C<CI> or C<AUTOMATED_TESTING>
  is enabled. You can disable it by using C<--no-report-perl-version>.
  
  =item --auto-cleanup
  
  Specifies the number of days in which cpanm's work directories
  expire. Defaults to 7, which means old work directories will be
  cleaned up in one week.
  
  You can set the value to C<0> to make cpan never cleanup those
  directories.
  
  =item --man-pages
  
  Generates man pages for executables (man1) and libraries (man3).
  
  Defaults to true (man pages generated) unless C<-L|--local-lib-contained>
  option is supplied in which case it's set to false. You can disable
  it with C<--no-man-pages>.
  
  =item --lwp
  
  Uses L<LWP> module to download stuff over HTTP. Defaults to true, and
  you can say C<--no-lwp> to disable using LWP, when you want to upgrade
  LWP from CPAN on some broken perl systems.
  
  =item --wget
  
  Uses GNU Wget (if available) to download stuff. Defaults to true, and
  you can say C<--no-wget> to disable using Wget (versions of Wget older
  than 1.9 don't support the C<--retry-connrefused> option used by cpanm).
  
  =item --curl
  
  Uses cURL (if available) to download stuff. Defaults to true, and
  you can say C<--no-curl> to disable using cURL.
  
  Normally with C<--lwp>, C<--wget> and C<--curl> options set to true
  (which is the default) cpanm tries L<LWP>, Wget, cURL and L<HTTP::Tiny>
  (in that order) and uses the first one available.
  
  =back
  
  =head1 SEE ALSO
  
  L<App::cpanminus>
  
  =head1 COPYRIGHT
  
  Copyright 2010- Tatsuhiko Miyagawa.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
PERL5_APP_CPANMINUS_FATSCRIPT

$fatpacked{"perl5/ExtUtils/Command.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_EXTUTILS_COMMAND';
  package ExtUtils::Command;
  
  use 5.00503;
  use strict;
  require Exporter;
  use vars qw(@ISA @EXPORT @EXPORT_OK $VERSION);
  @ISA       = qw(Exporter);
  @EXPORT    = qw(cp rm_f rm_rf mv cat eqtime mkpath touch test_f test_d chmod
                  dos2unix);
  $VERSION = '7.10';
  $VERSION = eval $VERSION;
  
  my $Is_VMS   = $^O eq 'VMS';
  my $Is_VMS_mode = $Is_VMS;
  my $Is_VMS_noefs = $Is_VMS;
  my $Is_Win32 = $^O eq 'MSWin32';
  
  if( $Is_VMS ) {
      my $vms_unix_rpt;
      my $vms_efs;
      my $vms_case;
  
      if (eval { local $SIG{__DIE__}; require VMS::Feature; }) {
          $vms_unix_rpt = VMS::Feature::current("filename_unix_report");
          $vms_efs = VMS::Feature::current("efs_charset");
          $vms_case = VMS::Feature::current("efs_case_preserve");
      } else {
          my $unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
          my $efs_charset = $ENV{'DECC$EFS_CHARSET'} || '';
          my $efs_case = $ENV{'DECC$EFS_CASE_PRESERVE'} || '';
          $vms_unix_rpt = $unix_rpt =~ /^[ET1]/i;
          $vms_efs = $efs_charset =~ /^[ET1]/i;
          $vms_case = $efs_case =~ /^[ET1]/i;
      }
      $Is_VMS_mode = 0 if $vms_unix_rpt;
      $Is_VMS_noefs = 0 if ($vms_efs);
  }
  
  
  =head1 NAME
  
  ExtUtils::Command - utilities to replace common UNIX commands in Makefiles etc.
  
  =head1 SYNOPSIS
  
    perl -MExtUtils::Command -e cat files... > destination
    perl -MExtUtils::Command -e mv source... destination
    perl -MExtUtils::Command -e cp source... destination
    perl -MExtUtils::Command -e touch files...
    perl -MExtUtils::Command -e rm_f files...
    perl -MExtUtils::Command -e rm_rf directories...
    perl -MExtUtils::Command -e mkpath directories...
    perl -MExtUtils::Command -e eqtime source destination
    perl -MExtUtils::Command -e test_f file
    perl -MExtUtils::Command -e test_d directory
    perl -MExtUtils::Command -e chmod mode files...
    ...
  
  =head1 DESCRIPTION
  
  The module is used to replace common UNIX commands.  In all cases the
  functions work from @ARGV rather than taking arguments.  This makes
  them easier to deal with in Makefiles.  Call them like this:
  
    perl -MExtUtils::Command -e some_command some files to work on
  
  and I<NOT> like this:
  
    perl -MExtUtils::Command -e 'some_command qw(some files to work on)'
  
  For that use L<Shell::Command>.
  
  Filenames with * and ? will be glob expanded.
  
  
  =head2 FUNCTIONS
  
  =over 4
  
  =cut
  
  # VMS uses % instead of ? to mean "one character"
  my $wild_regex = $Is_VMS ? '*%' : '*?';
  sub expand_wildcards
  {
   @ARGV = map(/[$wild_regex]/o ? glob($_) : $_,@ARGV);
  }
  
  
  =item cat
  
      cat file ...
  
  Concatenates all files mentioned on command line to STDOUT.
  
  =cut
  
  sub cat ()
  {
   expand_wildcards();
   print while (<>);
  }
  
  =item eqtime
  
      eqtime source destination
  
  Sets modified time of destination to that of source.
  
  =cut
  
  sub eqtime
  {
   my ($src,$dst) = @ARGV;
   local @ARGV = ($dst);  touch();  # in case $dst doesn't exist
   utime((stat($src))[8,9],$dst);
  }
  
  =item rm_rf
  
      rm_rf files or directories ...
  
  Removes files and directories - recursively (even if readonly)
  
  =cut
  
  sub rm_rf
  {
   expand_wildcards();
   require File::Path;
   File::Path::rmtree([grep -e $_,@ARGV],0,0);
  }
  
  =item rm_f
  
      rm_f file ...
  
  Removes files (even if readonly)
  
  =cut
  
  sub rm_f {
      expand_wildcards();
  
      foreach my $file (@ARGV) {
          next unless -f $file;
  
          next if _unlink($file);
  
          chmod(0777, $file);
  
          next if _unlink($file);
  
          require Carp;
          Carp::carp("Cannot delete $file: $!");
      }
  }
  
  sub _unlink {
      my $files_unlinked = 0;
      foreach my $file (@_) {
          my $delete_count = 0;
          $delete_count++ while unlink $file;
          $files_unlinked++ if $delete_count;
      }
      return $files_unlinked;
  }
  
  
  =item touch
  
      touch file ...
  
  Makes files exist, with current timestamp
  
  =cut
  
  sub touch {
      my $t    = time;
      expand_wildcards();
      foreach my $file (@ARGV) {
          open(FILE,">>$file") || die "Cannot write $file:$!";
          close(FILE);
          utime($t,$t,$file);
      }
  }
  
  =item mv
  
      mv source_file destination_file
      mv source_file source_file destination_dir
  
  Moves source to destination.  Multiple sources are allowed if
  destination is an existing directory.
  
  Returns true if all moves succeeded, false otherwise.
  
  =cut
  
  sub mv {
      expand_wildcards();
      my @src = @ARGV;
      my $dst = pop @src;
  
      if (@src > 1 && ! -d $dst) {
          require Carp;
          Carp::croak("Too many arguments");
      }
  
      require File::Copy;
      my $nok = 0;
      foreach my $src (@src) {
          $nok ||= !File::Copy::move($src,$dst);
      }
      return !$nok;
  }
  
  =item cp
  
      cp source_file destination_file
      cp source_file source_file destination_dir
  
  Copies sources to the destination.  Multiple sources are allowed if
  destination is an existing directory.
  
  Returns true if all copies succeeded, false otherwise.
  
  =cut
  
  sub cp {
      expand_wildcards();
      my @src = @ARGV;
      my $dst = pop @src;
  
      if (@src > 1 && ! -d $dst) {
          require Carp;
          Carp::croak("Too many arguments");
      }
  
      require File::Copy;
      my $nok = 0;
      foreach my $src (@src) {
          $nok ||= !File::Copy::copy($src,$dst);
  
          # Win32 does not update the mod time of a copied file, just the
          # created time which make does not look at.
          utime(time, time, $dst) if $Is_Win32;
      }
      return $nok;
  }
  
  =item chmod
  
      chmod mode files ...
  
  Sets UNIX like permissions 'mode' on all the files.  e.g. 0666
  
  =cut
  
  sub chmod {
      local @ARGV = @ARGV;
      my $mode = shift(@ARGV);
      expand_wildcards();
  
      if( $Is_VMS_mode && $Is_VMS_noefs) {
          require File::Spec;
          foreach my $idx (0..$#ARGV) {
              my $path = $ARGV[$idx];
              next unless -d $path;
  
              # chmod 0777, [.foo.bar] doesn't work on VMS, you have to do
              # chmod 0777, [.foo]bar.dir
              my @dirs = File::Spec->splitdir( $path );
              $dirs[-1] .= '.dir';
              $path = File::Spec->catfile(@dirs);
  
              $ARGV[$idx] = $path;
          }
      }
  
      chmod(oct $mode,@ARGV) || die "Cannot chmod ".join(' ',$mode,@ARGV).":$!";
  }
  
  =item mkpath
  
      mkpath directory ...
  
  Creates directories, including any parent directories.
  
  =cut
  
  sub mkpath
  {
   expand_wildcards();
   require File::Path;
   File::Path::mkpath([@ARGV],0,0777);
  }
  
  =item test_f
  
      test_f file
  
  Tests if a file exists.  I<Exits> with 0 if it does, 1 if it does not (ie.
  shell's idea of true and false).
  
  =cut
  
  sub test_f
  {
   exit(-f $ARGV[0] ? 0 : 1);
  }
  
  =item test_d
  
      test_d directory
  
  Tests if a directory exists.  I<Exits> with 0 if it does, 1 if it does
  not (ie. shell's idea of true and false).
  
  =cut
  
  sub test_d
  {
   exit(-d $ARGV[0] ? 0 : 1);
  }
  
  =item dos2unix
  
      dos2unix files or dirs ...
  
  Converts DOS and OS/2 linefeeds to Unix style recursively.
  
  =cut
  
  sub dos2unix {
      require File::Find;
      File::Find::find(sub {
          return if -d;
          return unless -w _;
          return unless -r _;
          return if -B _;
  
          local $\;
  
  	my $orig = $_;
  	my $temp = '.dos2unix_tmp';
  	open ORIG, $_ or do { warn "dos2unix can't open $_: $!"; return };
  	open TEMP, ">$temp" or
  	    do { warn "dos2unix can't create .dos2unix_tmp: $!"; return };
          while (my $line = <ORIG>) {
              $line =~ s/\015\012/\012/g;
              print TEMP $line;
          }
  	close ORIG;
  	close TEMP;
  	rename $temp, $orig;
  
      }, @ARGV);
  }
  
  =back
  
  =head1 SEE ALSO
  
  Shell::Command which is these same functions but take arguments normally.
  
  
  =head1 AUTHOR
  
  Nick Ing-Simmons C<ni-s@cpan.org>
  
  Maintained by Michael G Schwern C<schwern@pobox.com> within the
  ExtUtils-MakeMaker package and, as a separate CPAN package, by
  Randy Kobes C<r.kobes@uwinnipeg.ca>.
  
  =cut
  
PERL5_EXTUTILS_COMMAND

$fatpacked{"perl5/ExtUtils/Command/MM.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_EXTUTILS_COMMAND_MM';
  package ExtUtils::Command::MM;
  
  require 5.006;
  
  use strict;
  use warnings;
  
  require Exporter;
  our @ISA = qw(Exporter);
  
  our @EXPORT  = qw(test_harness pod2man perllocal_install uninstall
                    warn_if_old_packlist test_s cp_nonempty);
  our $VERSION = '7.10';
  
  my $Is_VMS = $^O eq 'VMS';
  
  eval {  require Time::HiRes; die unless Time::HiRes->can("stat"); };
  *mtime = $@ ?
   sub { [             stat($_[0])]->[9] } :
   sub { [Time::HiRes::stat($_[0])]->[9] } ;
  
  =head1 NAME
  
  ExtUtils::Command::MM - Commands for the MM's to use in Makefiles
  
  =head1 SYNOPSIS
  
    perl "-MExtUtils::Command::MM" -e "function" "--" arguments...
  
  
  =head1 DESCRIPTION
  
  B<FOR INTERNAL USE ONLY!>  The interface is not stable.
  
  ExtUtils::Command::MM encapsulates code which would otherwise have to
  be done with large "one" liners.
  
  Any $(FOO) used in the examples are make variables, not Perl.
  
  =over 4
  
  =item B<test_harness>
  
    test_harness($verbose, @test_libs);
  
  Runs the tests on @ARGV via Test::Harness passing through the $verbose
  flag.  Any @test_libs will be unshifted onto the test's @INC.
  
  @test_libs are run in alphabetical order.
  
  =cut
  
  sub test_harness {
      require Test::Harness;
      require File::Spec;
  
      $Test::Harness::verbose = shift;
  
      # Because Windows doesn't do this for us and listing all the *.t files
      # out on the command line can blow over its exec limit.
      require ExtUtils::Command;
      my @argv = ExtUtils::Command::expand_wildcards(@ARGV);
  
      local @INC = @INC;
      unshift @INC, map { File::Spec->rel2abs($_) } @_;
      Test::Harness::runtests(sort { lc $a cmp lc $b } @argv);
  }
  
  
  
  =item B<pod2man>
  
    pod2man( '--option=value',
             $podfile1 => $manpage1,
             $podfile2 => $manpage2,
             ...
           );
  
    # or args on @ARGV
  
  pod2man() is a function performing most of the duties of the pod2man
  program.  Its arguments are exactly the same as pod2man as of 5.8.0
  with the addition of:
  
      --perm_rw   octal permission to set the resulting manpage to
  
  And the removal of:
  
      --verbose/-v
      --help/-h
  
  If no arguments are given to pod2man it will read from @ARGV.
  
  If Pod::Man is unavailable, this function will warn and return undef.
  
  =cut
  
  sub pod2man {
      local @ARGV = @_ ? @_ : @ARGV;
  
      {
          local $@;
          if( !eval { require Pod::Man } ) {
              warn "Pod::Man is not available: $@".
                   "Man pages will not be generated during this install.\n";
              return 0;
          }
      }
      require Getopt::Long;
  
      # We will cheat and just use Getopt::Long.  We fool it by putting
      # our arguments into @ARGV.  Should be safe.
      my %options = ();
      Getopt::Long::config ('bundling_override');
      Getopt::Long::GetOptions (\%options,
                  'section|s=s', 'release|r=s', 'center|c=s',
                  'date|d=s', 'fixed=s', 'fixedbold=s', 'fixeditalic=s',
                  'fixedbolditalic=s', 'official|o', 'quotes|q=s', 'lax|l',
                  'name|n=s', 'perm_rw=i', 'utf8|u'
      );
      delete $options{utf8} unless $Pod::Man::VERSION >= 2.17;
  
      # If there's no files, don't bother going further.
      return 0 unless @ARGV;
  
      # Official sets --center, but don't override things explicitly set.
      if ($options{official} && !defined $options{center}) {
          $options{center} = q[Perl Programmer's Reference Guide];
      }
  
      # This isn't a valid Pod::Man option and is only accepted for backwards
      # compatibility.
      delete $options{lax};
      my $count = scalar @ARGV / 2;
      my $plural = $count == 1 ? 'document' : 'documents';
      print "Manifying $count pod $plural\n";
  
      do {{  # so 'next' works
          my ($pod, $man) = splice(@ARGV, 0, 2);
  
          next if ((-e $man) &&
                   (mtime($man) > mtime($pod)) &&
                   (mtime($man) > mtime("Makefile")));
  
          my $parser = Pod::Man->new(%options);
          $parser->parse_from_file($pod, $man)
            or do { warn("Could not install $man\n");  next };
  
          if (exists $options{perm_rw}) {
              chmod(oct($options{perm_rw}), $man)
                or do { warn("chmod $options{perm_rw} $man: $!\n"); next };
          }
      }} while @ARGV;
  
      return 1;
  }
  
  
  =item B<warn_if_old_packlist>
  
    perl "-MExtUtils::Command::MM" -e warn_if_old_packlist <somefile>
  
  Displays a warning that an old packlist file was found.  Reads the
  filename from @ARGV.
  
  =cut
  
  sub warn_if_old_packlist {
      my $packlist = $ARGV[0];
  
      return unless -f $packlist;
      print <<"PACKLIST_WARNING";
  WARNING: I have found an old package in
      $packlist.
  Please make sure the two installations are not conflicting
  PACKLIST_WARNING
  
  }
  
  
  =item B<perllocal_install>
  
      perl "-MExtUtils::Command::MM" -e perllocal_install
          <type> <module name> <key> <value> ...
  
      # VMS only, key|value pairs come on STDIN
      perl "-MExtUtils::Command::MM" -e perllocal_install
          <type> <module name> < <key>|<value> ...
  
  Prints a fragment of POD suitable for appending to perllocal.pod.
  Arguments are read from @ARGV.
  
  'type' is the type of what you're installing.  Usually 'Module'.
  
  'module name' is simply the name of your module.  (Foo::Bar)
  
  Key/value pairs are extra information about the module.  Fields include:
  
      installed into      which directory your module was out into
      LINKTYPE            dynamic or static linking
      VERSION             module version number
      EXE_FILES           any executables installed in a space seperated
                          list
  
  =cut
  
  sub perllocal_install {
      my($type, $name) = splice(@ARGV, 0, 2);
  
      # VMS feeds args as a piped file on STDIN since it usually can't
      # fit all the args on a single command line.
      my @mod_info = $Is_VMS ? split /\|/, <STDIN>
                             : @ARGV;
  
      my $pod;
      $pod = sprintf <<POD, scalar localtime;
   =head2 %s: C<$type> L<$name|$name>
  
   =over 4
  
  POD
  
      do {
          my($key, $val) = splice(@mod_info, 0, 2);
  
          $pod .= <<POD
   =item *
  
   C<$key: $val>
  
  POD
  
      } while(@mod_info);
  
      $pod .= "=back\n\n";
      $pod =~ s/^ //mg;
      print $pod;
  
      return 1;
  }
  
  =item B<uninstall>
  
      perl "-MExtUtils::Command::MM" -e uninstall <packlist>
  
  A wrapper around ExtUtils::Install::uninstall().  Warns that
  uninstallation is deprecated and doesn't actually perform the
  uninstallation.
  
  =cut
  
  sub uninstall {
      my($packlist) = shift @ARGV;
  
      require ExtUtils::Install;
  
      print <<'WARNING';
  
  Uninstall is unsafe and deprecated, the uninstallation was not performed.
  We will show what would have been done.
  
  WARNING
  
      ExtUtils::Install::uninstall($packlist, 1, 1);
  
      print <<'WARNING';
  
  Uninstall is unsafe and deprecated, the uninstallation was not performed.
  Please check the list above carefully, there may be errors.
  Remove the appropriate files manually.
  Sorry for the inconvenience.
  
  WARNING
  
  }
  
  =item B<test_s>
  
     perl "-MExtUtils::Command::MM" -e test_s <file>
  
  Tests if a file exists and is not empty (size > 0).
  I<Exits> with 0 if it does, 1 if it does not.
  
  =cut
  
  sub test_s {
    exit(-s $ARGV[0] ? 0 : 1);
  }
  
  =item B<cp_nonempty>
  
    perl "-MExtUtils::Command::MM" -e cp_nonempty <srcfile> <dstfile> <perm>
  
  Tests if the source file exists and is not empty (size > 0). If it is not empty
  it copies it to the given destination with the given permissions.
  
  =back
  
  =cut
  
  sub cp_nonempty {
    my @args = @ARGV;
    return 0 unless -s $args[0];
    require ExtUtils::Command;
    {
      local @ARGV = @args[0,1];
      ExtUtils::Command::cp(@ARGV);
    }
    {
      local @ARGV = @args[2,1];
      ExtUtils::Command::chmod(@ARGV);
    }
  }
  
  
  1;
PERL5_EXTUTILS_COMMAND_MM

$fatpacked{"perl5/ExtUtils/Liblist.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_EXTUTILS_LIBLIST';
  package ExtUtils::Liblist;
  
  use strict;
  
  our $VERSION = '7.10';
  
  use File::Spec;
  require ExtUtils::Liblist::Kid;
  our @ISA = qw(ExtUtils::Liblist::Kid File::Spec);
  
  # Backwards compatibility with old interface.
  sub ext {
      goto &ExtUtils::Liblist::Kid::ext;
  }
  
  sub lsdir {
    shift;
    my $rex = qr/$_[1]/;
    opendir DIR, $_[0];
    my @out = grep /$rex/, readdir DIR;
    closedir DIR;
    return @out;
  }
  
  __END__
  
  =head1 NAME
  
  ExtUtils::Liblist - determine libraries to use and how to use them
  
  =head1 SYNOPSIS
  
    require ExtUtils::Liblist;
  
    $MM->ext($potential_libs, $verbose, $need_names);
  
    # Usually you can get away with:
    ExtUtils::Liblist->ext($potential_libs, $verbose, $need_names)
  
  =head1 DESCRIPTION
  
  This utility takes a list of libraries in the form C<-llib1 -llib2
  -llib3> and returns lines suitable for inclusion in an extension
  Makefile.  Extra library paths may be included with the form
  C<-L/another/path> this will affect the searches for all subsequent
  libraries.
  
  It returns an array of four or five scalar values: EXTRALIBS,
  BSLOADLIBS, LDLOADLIBS, LD_RUN_PATH, and, optionally, a reference to
  the array of the filenames of actual libraries.  Some of these don't
  mean anything unless on Unix.  See the details about those platform
  specifics below.  The list of the filenames is returned only if
  $need_names argument is true.
  
  Dependent libraries can be linked in one of three ways:
  
  =over 2
  
  =item * For static extensions
  
  by the ld command when the perl binary is linked with the extension
  library. See EXTRALIBS below.
  
  =item * For dynamic extensions at build/link time
  
  by the ld command when the shared object is built/linked. See
  LDLOADLIBS below.
  
  =item * For dynamic extensions at load time
  
  by the DynaLoader when the shared object is loaded. See BSLOADLIBS
  below.
  
  =back
  
  =head2 EXTRALIBS
  
  List of libraries that need to be linked with when linking a perl
  binary which includes this extension. Only those libraries that
  actually exist are included.  These are written to a file and used
  when linking perl.
  
  =head2 LDLOADLIBS and LD_RUN_PATH
  
  List of those libraries which can or must be linked into the shared
  library when created using ld. These may be static or dynamic
  libraries.  LD_RUN_PATH is a colon separated list of the directories
  in LDLOADLIBS. It is passed as an environment variable to the process
  that links the shared library.
  
  =head2 BSLOADLIBS
  
  List of those libraries that are needed but can be linked in
  dynamically at run time on this platform.  SunOS/Solaris does not need
  this because ld records the information (from LDLOADLIBS) into the
  object file.  This list is used to create a .bs (bootstrap) file.
  
  =head1 PORTABILITY
  
  This module deals with a lot of system dependencies and has quite a
  few architecture specific C<if>s in the code.
  
  =head2 VMS implementation
  
  The version of ext() which is executed under VMS differs from the
  Unix-OS/2 version in several respects:
  
  =over 2
  
  =item *
  
  Input library and path specifications are accepted with or without the
  C<-l> and C<-L> prefixes used by Unix linkers.  If neither prefix is
  present, a token is considered a directory to search if it is in fact
  a directory, and a library to search for otherwise.  Authors who wish
  their extensions to be portable to Unix or OS/2 should use the Unix
  prefixes, since the Unix-OS/2 version of ext() requires them.
  
  =item *
  
  Wherever possible, shareable images are preferred to object libraries,
  and object libraries to plain object files.  In accordance with VMS
  naming conventions, ext() looks for files named I<lib>shr and I<lib>rtl;
  it also looks for I<lib>lib and libI<lib> to accommodate Unix conventions
  used in some ported software.
  
  =item *
  
  For each library that is found, an appropriate directive for a linker options
  file is generated.  The return values are space-separated strings of
  these directives, rather than elements used on the linker command line.
  
  =item *
  
  LDLOADLIBS contains both the libraries found based on C<$potential_libs> and
  the CRTLs, if any, specified in Config.pm.  EXTRALIBS contains just those
  libraries found based on C<$potential_libs>.  BSLOADLIBS and LD_RUN_PATH
  are always empty.
  
  =back
  
  In addition, an attempt is made to recognize several common Unix library
  names, and filter them out or convert them to their VMS equivalents, as
  appropriate.
  
  In general, the VMS version of ext() should properly handle input from
  extensions originally designed for a Unix or VMS environment.  If you
  encounter problems, or discover cases where the search could be improved,
  please let us know.
  
  =head2 Win32 implementation
  
  The version of ext() which is executed under Win32 differs from the
  Unix-OS/2 version in several respects:
  
  =over 2
  
  =item *
  
  If C<$potential_libs> is empty, the return value will be empty.
  Otherwise, the libraries specified by C<$Config{perllibs}> (see Config.pm)
  will be appended to the list of C<$potential_libs>.  The libraries
  will be searched for in the directories specified in C<$potential_libs>,
  C<$Config{libpth}>, and in C<$Config{installarchlib}/CORE>.
  For each library that is found,  a space-separated list of fully qualified
  library pathnames is generated.
  
  =item *
  
  Input library and path specifications are accepted with or without the
  C<-l> and C<-L> prefixes used by Unix linkers.
  
  An entry of the form C<-La:\foo> specifies the C<a:\foo> directory to look
  for the libraries that follow.
  
  An entry of the form C<-lfoo> specifies the library C<foo>, which may be
  spelled differently depending on what kind of compiler you are using.  If
  you are using GCC, it gets translated to C<libfoo.a>, but for other win32
  compilers, it becomes C<foo.lib>.  If no files are found by those translated
  names, one more attempt is made to find them using either C<foo.a> or
  C<libfoo.lib>, depending on whether GCC or some other win32 compiler is
  being used, respectively.
  
  If neither the C<-L> or C<-l> prefix is present in an entry, the entry is
  considered a directory to search if it is in fact a directory, and a
  library to search for otherwise.  The C<$Config{lib_ext}> suffix will
  be appended to any entries that are not directories and don't already have
  the suffix.
  
  Note that the C<-L> and C<-l> prefixes are B<not required>, but authors
  who wish their extensions to be portable to Unix or OS/2 should use the
  prefixes, since the Unix-OS/2 version of ext() requires them.
  
  =item *
  
  Entries cannot be plain object files, as many Win32 compilers will
  not handle object files in the place of libraries.
  
  =item *
  
  Entries in C<$potential_libs> beginning with a colon and followed by
  alphanumeric characters are treated as flags.  Unknown flags will be ignored.
  
  An entry that matches C</:nodefault/i> disables the appending of default
  libraries found in C<$Config{perllibs}> (this should be only needed very rarely).
  
  An entry that matches C</:nosearch/i> disables all searching for
  the libraries specified after it.  Translation of C<-Lfoo> and
  C<-lfoo> still happens as appropriate (depending on compiler being used,
  as reflected by C<$Config{cc}>), but the entries are not verified to be
  valid files or directories.
  
  An entry that matches C</:search/i> reenables searching for
  the libraries specified after it.  You can put it at the end to
  enable searching for default libraries specified by C<$Config{perllibs}>.
  
  =item *
  
  The libraries specified may be a mixture of static libraries and
  import libraries (to link with DLLs).  Since both kinds are used
  pretty transparently on the Win32 platform, we do not attempt to
  distinguish between them.
  
  =item *
  
  LDLOADLIBS and EXTRALIBS are always identical under Win32, and BSLOADLIBS
  and LD_RUN_PATH are always empty (this may change in future).
  
  =item *
  
  You must make sure that any paths and path components are properly
  surrounded with double-quotes if they contain spaces. For example,
  C<$potential_libs> could be (literally):
  
  	"-Lc:\Program Files\vc\lib" msvcrt.lib "la test\foo bar.lib"
  
  Note how the first and last entries are protected by quotes in order
  to protect the spaces.
  
  =item *
  
  Since this module is most often used only indirectly from extension
  C<Makefile.PL> files, here is an example C<Makefile.PL> entry to add
  a library to the build process for an extension:
  
          LIBS => ['-lgl']
  
  When using GCC, that entry specifies that MakeMaker should first look
  for C<libgl.a> (followed by C<gl.a>) in all the locations specified by
  C<$Config{libpth}>.
  
  When using a compiler other than GCC, the above entry will search for
  C<gl.lib> (followed by C<libgl.lib>).
  
  If the library happens to be in a location not in C<$Config{libpth}>,
  you need:
  
          LIBS => ['-Lc:\gllibs -lgl']
  
  Here is a less often used example:
  
          LIBS => ['-lgl', ':nosearch -Ld:\mesalibs -lmesa -luser32']
  
  This specifies a search for library C<gl> as before.  If that search
  fails to find the library, it looks at the next item in the list. The
  C<:nosearch> flag will prevent searching for the libraries that follow,
  so it simply returns the value as C<-Ld:\mesalibs -lmesa -luser32>,
  since GCC can use that value as is with its linker.
  
  When using the Visual C compiler, the second item is returned as
  C<-libpath:d:\mesalibs mesa.lib user32.lib>.
  
  When using the Borland compiler, the second item is returned as
  C<-Ld:\mesalibs mesa.lib user32.lib>, and MakeMaker takes care of
  moving the C<-Ld:\mesalibs> to the correct place in the linker
  command line.
  
  =back
  
  
  =head1 SEE ALSO
  
  L<ExtUtils::MakeMaker>
  
  =cut
  
PERL5_EXTUTILS_LIBLIST

$fatpacked{"perl5/ExtUtils/Liblist/Kid.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_EXTUTILS_LIBLIST_KID';
  package ExtUtils::Liblist::Kid;
  
  # XXX Splitting this out into its own .pm is a temporary solution.
  
  # This kid package is to be used by MakeMaker.  It will not work if
  # $self is not a Makemaker.
  
  use 5.006;
  
  # Broken out of MakeMaker from version 4.11
  
  use strict;
  use warnings;
  our $VERSION = '7.10';
  
  use ExtUtils::MakeMaker::Config;
  use Cwd 'cwd';
  use File::Basename;
  use File::Spec;
  
  sub ext {
      if    ( $^O eq 'VMS' )     { return &_vms_ext; }
      elsif ( $^O eq 'MSWin32' ) { return &_win32_ext; }
      else                       { return &_unix_os2_ext; }
  }
  
  sub _unix_os2_ext {
      my ( $self, $potential_libs, $verbose, $give_libs ) = @_;
      $verbose ||= 0;
  
      if ( $^O =~ /os2|android/ and $Config{perllibs} ) {
  
          # Dynamic libraries are not transitive, so we may need including
          # the libraries linked against perl.dll/libperl.so again.
  
          $potential_libs .= " " if $potential_libs;
          $potential_libs .= $Config{perllibs};
      }
      return ( "", "", "", "", ( $give_libs ? [] : () ) ) unless $potential_libs;
      warn "Potential libraries are '$potential_libs':\n" if $verbose;
  
      my ( $so ) = $Config{so};
      my ( $libs ) = defined $Config{perllibs} ? $Config{perllibs} : $Config{libs};
      my $Config_libext = $Config{lib_ext} || ".a";
      my $Config_dlext = $Config{dlext};
  
      # compute $extralibs, $bsloadlibs and $ldloadlibs from
      # $potential_libs
      # this is a rewrite of Andy Dougherty's extliblist in perl
  
      my ( @searchpath );    # from "-L/path" entries in $potential_libs
      my ( @libpath ) = split " ", $Config{'libpth'} || '';
      my ( @ldloadlibs, @bsloadlibs, @extralibs, @ld_run_path, %ld_run_path_seen );
      my ( @libs,       %libs_seen );
      my ( $fullname,   @fullname );
      my ( $pwd )   = cwd();    # from Cwd.pm
      my ( $found ) = 0;
  
      foreach my $thislib ( split ' ', $potential_libs ) {
          my ( $custom_name ) = '';
  
          # Handle possible linker path arguments.
          if ( $thislib =~ s/^(-[LR]|-Wl,-R|-Wl,-rpath,)// ) {    # save path flag type
              my ( $ptype ) = $1;
              unless ( -d $thislib ) {
                  warn "$ptype$thislib ignored, directory does not exist\n"
                    if $verbose;
                  next;
              }
              my ( $rtype ) = $ptype;
              if ( ( $ptype eq '-R' ) or ( $ptype =~ m!^-Wl,-[Rr]! ) ) {
                  if ( $Config{'lddlflags'} =~ /-Wl,-[Rr]/ ) {
                      $rtype = '-Wl,-R';
                  }
                  elsif ( $Config{'lddlflags'} =~ /-R/ ) {
                      $rtype = '-R';
                  }
              }
              unless ( File::Spec->file_name_is_absolute( $thislib ) ) {
                  warn "Warning: $ptype$thislib changed to $ptype$pwd/$thislib\n";
                  $thislib = $self->catdir( $pwd, $thislib );
              }
              push( @searchpath, $thislib );
              push( @extralibs,  "$ptype$thislib" );
              push( @ldloadlibs, "$rtype$thislib" );
              next;
          }
  
          if ( $thislib =~ m!^-Wl,! ) {
              push( @extralibs,  $thislib );
              push( @ldloadlibs, $thislib );
              next;
          }
  
          # Handle possible library arguments.
          if ( $thislib =~ s/^-l(:)?// ) {
              # Handle -l:foo.so, which means that the library will
              # actually be called foo.so, not libfoo.so.  This
              # is used in Android by ExtUtils::Depends to allow one XS
              # module to link to another.
              $custom_name = $1 || '';
          }
          else {
              warn "Unrecognized argument in LIBS ignored: '$thislib'\n";
              next;
          }
  
          my ( $found_lib ) = 0;
          foreach my $thispth ( @searchpath, @libpath ) {
  
              # Try to find the full name of the library.  We need this to
              # determine whether it's a dynamically-loadable library or not.
              # This tends to be subject to various os-specific quirks.
              # For gcc-2.6.2 on linux (March 1995), DLD can not load
              # .sa libraries, with the exception of libm.sa, so we
              # deliberately skip them.
              if ((@fullname =
                   $self->lsdir($thispth, "^\Qlib$thislib.$so.\E[0-9]+")) ||
                  (@fullname =
                   $self->lsdir($thispth, "^\Qlib$thislib.\E[0-9]+\Q\.$so"))) {
                  # Take care that libfoo.so.10 wins against libfoo.so.9.
                  # Compare two libraries to find the most recent version
                  # number.  E.g.  if you have libfoo.so.9.0.7 and
                  # libfoo.so.10.1, first convert all digits into two
                  # decimal places.  Then we'll add ".00" to the shorter
                  # strings so that we're comparing strings of equal length
                  # Thus we'll compare libfoo.so.09.07.00 with
                  # libfoo.so.10.01.00.  Some libraries might have letters
                  # in the version.  We don't know what they mean, but will
                  # try to skip them gracefully -- we'll set any letter to
                  # '0'.  Finally, sort in reverse so we can take the
                  # first element.
  
                  #TODO: iterate through the directory instead of sorting
  
                  $fullname = "$thispth/" . (
                      sort {
                          my ( $ma ) = $a;
                          my ( $mb ) = $b;
                          $ma =~ tr/A-Za-z/0/s;
                          $ma =~ s/\b(\d)\b/0$1/g;
                          $mb =~ tr/A-Za-z/0/s;
                          $mb =~ s/\b(\d)\b/0$1/g;
                          while ( length( $ma ) < length( $mb ) ) { $ma .= ".00"; }
                          while ( length( $mb ) < length( $ma ) ) { $mb .= ".00"; }
  
                          # Comparison deliberately backwards
                          $mb cmp $ma;
                        } @fullname
                  )[0];
              }
              elsif ( -f ( $fullname = "$thispth/lib$thislib.$so" )
                  && ( ( $Config{'dlsrc'} ne "dl_dld.xs" ) || ( $thislib eq "m" ) ) )
              {
              }
              elsif (-f ( $fullname = "$thispth/lib${thislib}_s$Config_libext" )
                  && ( $Config{'archname'} !~ /RM\d\d\d-svr4/ )
                  && ( $thislib .= "_s" ) )
              {    # we must explicitly use _s version
              }
              elsif ( -f ( $fullname = "$thispth/lib$thislib$Config_libext" ) ) {
              }
              elsif ( defined( $Config_dlext )
                  && -f ( $fullname = "$thispth/lib$thislib.$Config_dlext" ) )
              {
              }
              elsif ( -f ( $fullname = "$thispth/$thislib$Config_libext" ) ) {
              }
              elsif ( -f ( $fullname = "$thispth/lib$thislib.dll$Config_libext" ) ) {
              }
              elsif ( $^O eq 'cygwin' && -f ( $fullname = "$thispth/$thislib.dll" ) ) {
              }
              elsif ( -f ( $fullname = "$thispth/Slib$thislib$Config_libext" ) ) {
              }
              elsif ($^O eq 'dgux'
                  && -l ( $fullname = "$thispth/lib$thislib$Config_libext" )
                  && readlink( $fullname ) =~ /^elink:/s )
              {
  
                  # Some of DG's libraries look like misconnected symbolic
                  # links, but development tools can follow them.  (They
                  # look like this:
                  #
                  #    libm.a -> elink:${SDE_PATH:-/usr}/sde/\
                  #    ${TARGET_BINARY_INTERFACE:-m88kdgux}/usr/lib/libm.a
                  #
                  # , the compilation tools expand the environment variables.)
              }
              elsif ( $custom_name && -f ( $fullname = "$thispth/$thislib" ) ) {
              }
              else {
                  warn "$thislib not found in $thispth\n" if $verbose;
                  next;
              }
              warn "'-l$thislib' found at $fullname\n" if $verbose;
              push @libs, $fullname unless $libs_seen{$fullname}++;
              $found++;
              $found_lib++;
  
              # Now update library lists
  
              # what do we know about this library...
              my $is_dyna = ( $fullname !~ /\Q$Config_libext\E\z/ );
              my $in_perl = ( $libs =~ /\B-l:?\Q${thislib}\E\b/s );
  
              # include the path to the lib once in the dynamic linker path
              # but only if it is a dynamic lib and not in Perl itself
              my ( $fullnamedir ) = dirname( $fullname );
              push @ld_run_path, $fullnamedir
                if $is_dyna
                    && !$in_perl
                    && !$ld_run_path_seen{$fullnamedir}++;
  
              # Do not add it into the list if it is already linked in
              # with the main perl executable.
              # We have to special-case the NeXT, because math and ndbm
              # are both in libsys_s
              unless (
                  $in_perl
                  || ( $Config{'osname'} eq 'next'
                      && ( $thislib eq 'm' || $thislib eq 'ndbm' ) )
                )
              {
                  push( @extralibs, "-l$custom_name$thislib" );
              }
  
              # We might be able to load this archive file dynamically
              if (   ( $Config{'dlsrc'} =~ /dl_next/ && $Config{'osvers'} lt '4_0' )
                  || ( $Config{'dlsrc'} =~ /dl_dld/ ) )
              {
  
                  # We push -l$thislib instead of $fullname because
                  # it avoids hardwiring a fixed path into the .bs file.
                  # Mkbootstrap will automatically add dl_findfile() to
                  # the .bs file if it sees a name in the -l format.
                  # USE THIS, when dl_findfile() is fixed:
                  # push(@bsloadlibs, "-l$thislib");
                  # OLD USE WAS while checking results against old_extliblist
                  push( @bsloadlibs, "$fullname" );
              }
              else {
                  if ( $is_dyna ) {
  
                      # For SunOS4, do not add in this shared library if
                      # it is already linked in the main perl executable
                      push( @ldloadlibs, "-l$custom_name$thislib" )
                        unless ( $in_perl and $^O eq 'sunos' );
                  }
                  else {
                      push( @ldloadlibs, "-l$custom_name$thislib" );
                  }
              }
              last;    # found one here so don't bother looking further
          }
          warn "Warning (mostly harmless): " . "No library found for -l$thislib\n"
            unless $found_lib > 0;
      }
  
      unless ( $found ) {
          return ( '', '', '', '', ( $give_libs ? \@libs : () ) );
      }
      else {
          return ( "@extralibs", "@bsloadlibs", "@ldloadlibs", join( ":", @ld_run_path ), ( $give_libs ? \@libs : () ) );
      }
  }
  
  sub _win32_ext {
  
      require Text::ParseWords;
  
      my ( $self, $potential_libs, $verbose, $give_libs ) = @_;
      $verbose ||= 0;
  
      # If user did not supply a list, we punt.
      # (caller should probably use the list in $Config{libs})
      return ( "", "", "", "", ( $give_libs ? [] : () ) ) unless $potential_libs;
  
      # TODO: make this use MM_Win32.pm's compiler detection
      my %libs_seen;
      my @extralibs;
      my $cc = $Config{cc} || '';
      my $VC = $cc =~ /\bcl\b/i;
      my $GC = $cc =~ /\bgcc\b/i;
  
      my $libext     = _win32_lib_extensions();
      my @searchpath = ( '' );                                    # from "-L/path" entries in $potential_libs
      my @libpath    = _win32_default_search_paths( $VC, $GC );
      my $pwd        = cwd();                                     # from Cwd.pm
      my $search     = 1;
  
      # compute @extralibs from $potential_libs
      my @lib_search_list = _win32_make_lib_search_list( $potential_libs, $verbose );
      for ( @lib_search_list ) {
  
          my $thislib = $_;
  
          # see if entry is a flag
          if ( /^:\w+$/ ) {
              $search = 0 if lc eq ':nosearch';
              $search = 1 if lc eq ':search';
              _debug( "Ignoring unknown flag '$thislib'\n", $verbose ) if !/^:(no)?(search|default)$/i;
              next;
          }
  
          # if searching is disabled, do compiler-specific translations
          unless ( $search ) {
              s/^-l(.+)$/$1.lib/ unless $GC;
              s/^-L/-libpath:/ if $VC;
              push( @extralibs, $_ );
              next;
          }
  
          # handle possible linker path arguments
          if ( s/^-L// and not -d ) {
              _debug( "$thislib ignored, directory does not exist\n", $verbose );
              next;
          }
          elsif ( -d ) {
              unless ( File::Spec->file_name_is_absolute( $_ ) ) {
                  warn "Warning: '$thislib' changed to '-L$pwd/$_'\n";
                  $_ = $self->catdir( $pwd, $_ );
              }
              push( @searchpath, $_ );
              next;
          }
  
          my @paths = ( @searchpath, @libpath );
          my ( $fullname, $path ) = _win32_search_file( $thislib, $libext, \@paths, $verbose, $GC );
  
          if ( !$fullname ) {
              warn "Warning (mostly harmless): No library found for $thislib\n";
              next;
          }
  
          _debug( "'$thislib' found as '$fullname'\n", $verbose );
          push( @extralibs, $fullname );
          $libs_seen{$fullname} = 1 if $path;    # why is this a special case?
      }
  
      my @libs = keys %libs_seen;
  
      return ( '', '', '', '', ( $give_libs ? \@libs : () ) ) unless @extralibs;
  
      # make sure paths with spaces are properly quoted
      @extralibs = map { qq["$_"] } @extralibs;
      @libs      = map { qq["$_"] } @libs;
  
      my $lib = join( ' ', @extralibs );
  
      # normalize back to backward slashes (to help braindead tools)
      # XXX this may break equally braindead GNU tools that don't understand
      # backslashes, either.  Seems like one can't win here.  Cursed be CP/M.
      $lib =~ s,/,\\,g;
  
      _debug( "Result: $lib\n", $verbose );
      wantarray ? ( $lib, '', $lib, '', ( $give_libs ? \@libs : () ) ) : $lib;
  }
  
  sub _win32_make_lib_search_list {
      my ( $potential_libs, $verbose ) = @_;
  
      # If Config.pm defines a set of default libs, we always
      # tack them on to the user-supplied list, unless the user
      # specified :nodefault
      my $libs = $Config{'perllibs'};
      $potential_libs = join( ' ', $potential_libs, $libs ) if $libs and $potential_libs !~ /:nodefault/i;
      _debug( "Potential libraries are '$potential_libs':\n", $verbose );
  
      $potential_libs =~ s,\\,/,g;    # normalize to forward slashes
  
      my @list = Text::ParseWords::quotewords( '\s+', 0, $potential_libs );
  
      return @list;
  }
  
  sub _win32_default_search_paths {
      my ( $VC, $GC ) = @_;
  
      my $libpth = $Config{'libpth'} || '';
      $libpth =~ s,\\,/,g;            # normalize to forward slashes
  
      my @libpath = Text::ParseWords::quotewords( '\s+', 0, $libpth );
      push @libpath, "$Config{installarchlib}/CORE";    # add "$Config{installarchlib}/CORE" to default search path
  
      push @libpath, split /;/, $ENV{LIB}          if $VC and $ENV{LIB};
      push @libpath, split /;/, $ENV{LIBRARY_PATH} if $GC and $ENV{LIBRARY_PATH};
  
      return @libpath;
  }
  
  sub _win32_search_file {
      my ( $thislib, $libext, $paths, $verbose, $GC ) = @_;
  
      my @file_list = _win32_build_file_list( $thislib, $GC, $libext );
  
      for my $lib_file ( @file_list ) {
          for my $path ( @{$paths} ) {
              my $fullname = $lib_file;
              $fullname = "$path\\$fullname" if $path;
  
              return ( $fullname, $path ) if -f $fullname;
  
              _debug( "'$thislib' not found as '$fullname'\n", $verbose );
          }
      }
  
      return;
  }
  
  sub _win32_build_file_list {
      my ( $lib, $GC, $extensions ) = @_;
  
      my @pre_fixed = _win32_build_prefixed_list( $lib, $GC );
      return map _win32_attach_extensions( $_, $extensions ), @pre_fixed;
  }
  
  sub _win32_build_prefixed_list {
      my ( $lib, $GC ) = @_;
  
      return $lib if $lib !~ s/^-l//;
      return $lib if $lib =~ /^lib/ and !$GC;
  
      ( my $no_prefix = $lib ) =~ s/^lib//i;
      $lib = "lib$lib" if $no_prefix eq $lib;
  
      return ( $lib, $no_prefix ) if $GC;
      return ( $no_prefix, $lib );
  }
  
  sub _win32_attach_extensions {
      my ( $lib, $extensions ) = @_;
      return map _win32_try_attach_extension( $lib, $_ ), @{$extensions};
  }
  
  sub _win32_try_attach_extension {
      my ( $lib, $extension ) = @_;
  
      return $lib if $lib =~ /\Q$extension\E$/i;
      return "$lib$extension";
  }
  
  sub _win32_lib_extensions {
      my @extensions;
      push @extensions, $Config{'lib_ext'} if $Config{'lib_ext'};
      push @extensions, '.dll.a' if grep { m!^\.a$! } @extensions;
      push @extensions, '.lib' unless grep { m!^\.lib$! } @extensions;
      return \@extensions;
  }
  
  sub _debug {
      my ( $message, $verbose ) = @_;
      return if !$verbose;
      warn $message;
      return;
  }
  
  sub _vms_ext {
      my ( $self, $potential_libs, $verbose, $give_libs ) = @_;
      $verbose ||= 0;
  
      my ( @crtls, $crtlstr );
      @crtls = ( ( $Config{'ldflags'} =~ m-/Debug-i ? $Config{'dbgprefix'} : '' ) . 'PerlShr/Share' );
      push( @crtls, grep { not /\(/ } split /\s+/, $Config{'perllibs'} );
      push( @crtls, grep { not /\(/ } split /\s+/, $Config{'libc'} );
  
      # In general, we pass through the basic libraries from %Config unchanged.
      # The one exception is that if we're building in the Perl source tree, and
      # a library spec could be resolved via a logical name, we go to some trouble
      # to insure that the copy in the local tree is used, rather than one to
      # which a system-wide logical may point.
      if ( $self->{PERL_SRC} ) {
          my ( $locspec, $type );
          foreach my $lib ( @crtls ) {
              if ( ( $locspec, $type ) = $lib =~ m{^([\w\$-]+)(/\w+)?} and $locspec =~ /perl/i ) {
                  if    ( lc $type eq '/share' )   { $locspec .= $Config{'exe_ext'}; }
                  elsif ( lc $type eq '/library' ) { $locspec .= $Config{'lib_ext'}; }
                  else                             { $locspec .= $Config{'obj_ext'}; }
                  $locspec = $self->catfile( $self->{PERL_SRC}, $locspec );
                  $lib = "$locspec$type" if -e $locspec;
              }
          }
      }
      $crtlstr = @crtls ? join( ' ', @crtls ) : '';
  
      unless ( $potential_libs ) {
          warn "Result:\n\tEXTRALIBS: \n\tLDLOADLIBS: $crtlstr\n" if $verbose;
          return ( '', '', $crtlstr, '', ( $give_libs ? [] : () ) );
      }
  
      my ( %found, @fndlibs, $ldlib );
      my $cwd = cwd();
      my ( $so, $lib_ext, $obj_ext ) = @Config{ 'so', 'lib_ext', 'obj_ext' };
  
      # List of common Unix library names and their VMS equivalents
      # (VMS equivalent of '' indicates that the library is automatically
      # searched by the linker, and should be skipped here.)
      my ( @flibs, %libs_seen );
      my %libmap = (
          'm'      => '',
          'f77'    => '',
          'F77'    => '',
          'V77'    => '',
          'c'      => '',
          'malloc' => '',
          'crypt'  => '',
          'resolv' => '',
          'c_s'    => '',
          'socket' => '',
          'X11'    => 'DECW$XLIBSHR',
          'Xt'     => 'DECW$XTSHR',
          'Xm'     => 'DECW$XMLIBSHR',
          'Xmu'    => 'DECW$XMULIBSHR'
      );
  
      warn "Potential libraries are '$potential_libs'\n" if $verbose;
  
      # First, sort out directories and library names in the input
      my ( @dirs, @libs );
      foreach my $lib ( split ' ', $potential_libs ) {
          push( @dirs, $1 ),   next if $lib =~ /^-L(.*)/;
          push( @dirs, $lib ), next if $lib =~ /[:>\]]$/;
          push( @dirs, $lib ), next if -d $lib;
          push( @libs, $1 ),   next if $lib =~ /^-l(.*)/;
          push( @libs, $lib );
      }
      push( @dirs, split( ' ', $Config{'libpth'} ) );
  
      # Now make sure we've got VMS-syntax absolute directory specs
      # (We don't, however, check whether someone's hidden a relative
      # path in a logical name.)
      foreach my $dir ( @dirs ) {
          unless ( -d $dir ) {
              warn "Skipping nonexistent Directory $dir\n" if $verbose > 1;
              $dir = '';
              next;
          }
          warn "Resolving directory $dir\n" if $verbose;
          if ( File::Spec->file_name_is_absolute( $dir ) ) {
              $dir = VMS::Filespec::vmspath( $dir );
          }
          else {
              $dir = $self->catdir( $cwd, $dir );
          }
      }
      @dirs = grep { length( $_ ) } @dirs;
      unshift( @dirs, '' );    # Check each $lib without additions first
  
    LIB: foreach my $lib ( @libs ) {
          if ( exists $libmap{$lib} ) {
              next unless length $libmap{$lib};
              $lib = $libmap{$lib};
          }
  
          my ( @variants, $cand );
          my ( $ctype ) = '';
  
          # If we don't have a file type, consider it a possibly abbreviated name and
          # check for common variants.  We try these first to grab libraries before
          # a like-named executable image (e.g. -lperl resolves to perlshr.exe
          # before perl.exe).
          if ( $lib !~ /\.[^:>\]]*$/ ) {
              push( @variants, "${lib}shr", "${lib}rtl", "${lib}lib" );
              push( @variants, "lib$lib" ) if $lib !~ /[:>\]]/;
          }
          push( @variants, $lib );
          warn "Looking for $lib\n" if $verbose;
          foreach my $variant ( @variants ) {
              my ( $fullname, $name );
  
              foreach my $dir ( @dirs ) {
                  my ( $type );
  
                  $name = "$dir$variant";
                  warn "\tChecking $name\n" if $verbose > 2;
                  $fullname = VMS::Filespec::rmsexpand( $name );
                  if ( defined $fullname and -f $fullname ) {
  
                      # It's got its own suffix, so we'll have to figure out the type
                      if    ( $fullname =~ /(?:$so|exe)$/i )      { $type = 'SHR'; }
                      elsif ( $fullname =~ /(?:$lib_ext|olb)$/i ) { $type = 'OLB'; }
                      elsif ( $fullname =~ /(?:$obj_ext|obj)$/i ) {
                          warn "Warning (mostly harmless): " . "Plain object file $fullname found in library list\n";
                          $type = 'OBJ';
                      }
                      else {
                          warn "Warning (mostly harmless): " . "Unknown library type for $fullname; assuming shared\n";
                          $type = 'SHR';
                      }
                  }
                  elsif (-f ( $fullname = VMS::Filespec::rmsexpand( $name, $so ) )
                      or -f ( $fullname = VMS::Filespec::rmsexpand( $name, '.exe' ) ) )
                  {
                      $type = 'SHR';
                      $name = $fullname unless $fullname =~ /exe;?\d*$/i;
                  }
                  elsif (
                      not length( $ctype ) and    # If we've got a lib already,
                                                  # don't bother
                      ( -f ( $fullname = VMS::Filespec::rmsexpand( $name, $lib_ext ) ) or -f ( $fullname = VMS::Filespec::rmsexpand( $name, '.olb' ) ) )
                    )
                  {
                      $type = 'OLB';
                      $name = $fullname unless $fullname =~ /olb;?\d*$/i;
                  }
                  elsif (
                      not length( $ctype ) and    # If we've got a lib already,
                                                  # don't bother
                      ( -f ( $fullname = VMS::Filespec::rmsexpand( $name, $obj_ext ) ) or -f ( $fullname = VMS::Filespec::rmsexpand( $name, '.obj' ) ) )
                    )
                  {
                      warn "Warning (mostly harmless): " . "Plain object file $fullname found in library list\n";
                      $type = 'OBJ';
                      $name = $fullname unless $fullname =~ /obj;?\d*$/i;
                  }
                  if ( defined $type ) {
                      $ctype = $type;
                      $cand  = $name;
                      last if $ctype eq 'SHR';
                  }
              }
              if ( $ctype ) {
  
                  push @{ $found{$ctype} }, $cand;
                  warn "\tFound as $cand (really $fullname), type $ctype\n"
                    if $verbose > 1;
                  push @flibs, $name unless $libs_seen{$fullname}++;
                  next LIB;
              }
          }
          warn "Warning (mostly harmless): " . "No library found for $lib\n";
      }
  
      push @fndlibs, @{ $found{OBJ} } if exists $found{OBJ};
      push @fndlibs, map { "$_/Library" } @{ $found{OLB} } if exists $found{OLB};
      push @fndlibs, map { "$_/Share" } @{ $found{SHR} }   if exists $found{SHR};
      my $lib = join( ' ', @fndlibs );
  
      $ldlib = $crtlstr ? "$lib $crtlstr" : $lib;
      $ldlib =~ s/^\s+|\s+$//g;
      warn "Result:\n\tEXTRALIBS: $lib\n\tLDLOADLIBS: $ldlib\n" if $verbose;
      wantarray ? ( $lib, '', $ldlib, '', ( $give_libs ? \@flibs : () ) ) : $lib;
  }
  
  1;
PERL5_EXTUTILS_LIBLIST_KID

$fatpacked{"perl5/ExtUtils/MM.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_EXTUTILS_MM';
  package ExtUtils::MM;
  
  use strict;
  use ExtUtils::MakeMaker::Config;
  
  our $VERSION = '7.10';
  
  require ExtUtils::Liblist;
  require ExtUtils::MakeMaker;
  our @ISA = qw(ExtUtils::Liblist ExtUtils::MakeMaker);
  
  =head1 NAME
  
  ExtUtils::MM - OS adjusted ExtUtils::MakeMaker subclass
  
  =head1 SYNOPSIS
  
    require ExtUtils::MM;
    my $mm = MM->new(...);
  
  =head1 DESCRIPTION
  
  B<FOR INTERNAL USE ONLY>
  
  ExtUtils::MM is a subclass of ExtUtils::MakeMaker which automatically
  chooses the appropriate OS specific subclass for you
  (ie. ExtUils::MM_Unix, etc...).
  
  It also provides a convenient alias via the MM class (I didn't want
  MakeMaker modules outside of ExtUtils/).
  
  This class might turn out to be a temporary solution, but MM won't go
  away.
  
  =cut
  
  {
      # Convenient alias.
      package MM;
      our @ISA = qw(ExtUtils::MM);
      sub DESTROY {}
  }
  
  sub _is_win95 {
      # miniperl might not have the Win32 functions available and we need
      # to run in miniperl.
      my $have_win32 = eval { require Win32 };
      return $have_win32 && defined &Win32::IsWin95 ? Win32::IsWin95()
                                                    : ! defined $ENV{SYSTEMROOT};
  }
  
  my %Is = ();
  $Is{VMS}    = $^O eq 'VMS';
  $Is{OS2}    = $^O eq 'os2';
  $Is{MacOS}  = $^O eq 'MacOS';
  if( $^O eq 'MSWin32' ) {
      _is_win95() ? $Is{Win95} = 1 : $Is{Win32} = 1;
  }
  $Is{UWIN}   = $^O =~ /^uwin(-nt)?$/;
  $Is{Cygwin} = $^O eq 'cygwin';
  $Is{NW5}    = $Config{osname} eq 'NetWare';  # intentional
  $Is{BeOS}   = ($^O =~ /beos/i or $^O eq 'haiku');
  $Is{DOS}    = $^O eq 'dos';
  if( $Is{NW5} ) {
      $^O = 'NetWare';
      delete $Is{Win32};
  }
  $Is{VOS}    = $^O eq 'vos';
  $Is{QNX}    = $^O eq 'qnx';
  $Is{AIX}    = $^O eq 'aix';
  $Is{Darwin} = $^O eq 'darwin';
  
  $Is{Unix}   = !grep { $_ } values %Is;
  
  map { delete $Is{$_} unless $Is{$_} } keys %Is;
  _assert( keys %Is == 1 );
  my($OS) = keys %Is;
  
  
  my $class = "ExtUtils::MM_$OS";
  eval "require $class" unless $INC{"ExtUtils/MM_$OS.pm"}; ## no critic
  die $@ if $@;
  unshift @ISA, $class;
  
  
  sub _assert {
      my $sanity = shift;
      die sprintf "Assert failed at %s line %d\n", (caller)[1,2] unless $sanity;
      return;
  }
PERL5_EXTUTILS_MM

$fatpacked{"perl5/ExtUtils/MM_AIX.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_EXTUTILS_MM_AIX';
  package ExtUtils::MM_AIX;
  
  use strict;
  our $VERSION = '7.10';
  
  require ExtUtils::MM_Unix;
  our @ISA = qw(ExtUtils::MM_Unix);
  
  use ExtUtils::MakeMaker qw(neatvalue);
  
  
  =head1 NAME
  
  ExtUtils::MM_AIX - AIX specific subclass of ExtUtils::MM_Unix
  
  =head1 SYNOPSIS
  
    Don't use this module directly.
    Use ExtUtils::MM and let it choose.
  
  =head1 DESCRIPTION
  
  This is a subclass of ExtUtils::MM_Unix which contains functionality for
  AIX.
  
  Unless otherwise stated it works just like ExtUtils::MM_Unix
  
  =head2 Overridden methods
  
  =head3 dlsyms
  
  Define DL_FUNCS and DL_VARS and write the *.exp files.
  
  =cut
  
  sub dlsyms {
      my($self,%attribs) = @_;
  
      return '' unless $self->needs_linking();
  
      my($funcs) = $attribs{DL_FUNCS} || $self->{DL_FUNCS} || {};
      my($vars)  = $attribs{DL_VARS} || $self->{DL_VARS} || [];
      my($funclist)  = $attribs{FUNCLIST} || $self->{FUNCLIST} || [];
      my(@m);
  
      push(@m,"
  dynamic :: $self->{BASEEXT}.exp
  
  ") unless $self->{SKIPHASH}{'dynamic'}; # dynamic and static are subs, so...
  
      push(@m,"
  static :: $self->{BASEEXT}.exp
  
  ") unless $self->{SKIPHASH}{'static'};  # we avoid a warning if we tick them
  
      push(@m,"
  $self->{BASEEXT}.exp: Makefile.PL
  ",'	$(PERLRUN) -e \'use ExtUtils::Mksymlists; \\
  	Mksymlists("NAME" => "',$self->{NAME},'", "DL_FUNCS" => ',
  	neatvalue($funcs), ', "FUNCLIST" => ', neatvalue($funclist),
  	', "DL_VARS" => ', neatvalue($vars), ');\'
  ');
  
      join('',@m);
  }
  
  
  =head1 AUTHOR
  
  Michael G Schwern <schwern@pobox.com> with code from ExtUtils::MM_Unix
  
  =head1 SEE ALSO
  
  L<ExtUtils::MakeMaker>
  
  =cut
  
  
  1;
PERL5_EXTUTILS_MM_AIX

$fatpacked{"perl5/ExtUtils/MM_Any.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_EXTUTILS_MM_ANY';
  package ExtUtils::MM_Any;
  
  use strict;
  our $VERSION = '7.10';
  
  use Carp;
  use File::Spec;
  use File::Basename;
  BEGIN { our @ISA = qw(File::Spec); }
  
  # We need $Verbose
  use ExtUtils::MakeMaker qw($Verbose);
  
  use ExtUtils::MakeMaker::Config;
  
  
  # So we don't have to keep calling the methods over and over again,
  # we have these globals to cache the values.  Faster and shrtr.
  my $Curdir  = __PACKAGE__->curdir;
  my $Rootdir = __PACKAGE__->rootdir;
  my $Updir   = __PACKAGE__->updir;
  
  
  =head1 NAME
  
  ExtUtils::MM_Any - Platform-agnostic MM methods
  
  =head1 SYNOPSIS
  
    FOR INTERNAL USE ONLY!
  
    package ExtUtils::MM_SomeOS;
  
    # Temporarily, you have to subclass both.  Put MM_Any first.
    require ExtUtils::MM_Any;
    require ExtUtils::MM_Unix;
    @ISA = qw(ExtUtils::MM_Any ExtUtils::Unix);
  
  =head1 DESCRIPTION
  
  B<FOR INTERNAL USE ONLY!>
  
  ExtUtils::MM_Any is a superclass for the ExtUtils::MM_* set of
  modules.  It contains methods which are either inherently
  cross-platform or are written in a cross-platform manner.
  
  Subclass off of ExtUtils::MM_Any I<and> ExtUtils::MM_Unix.  This is a
  temporary solution.
  
  B<THIS MAY BE TEMPORARY!>
  
  
  =head1 METHODS
  
  Any methods marked I<Abstract> must be implemented by subclasses.
  
  
  =head2 Cross-platform helper methods
  
  These are methods which help writing cross-platform code.
  
  
  
  =head3 os_flavor  I<Abstract>
  
      my @os_flavor = $mm->os_flavor;
  
  @os_flavor is the style of operating system this is, usually
  corresponding to the MM_*.pm file we're using.
  
  The first element of @os_flavor is the major family (ie. Unix,
  Windows, VMS, OS/2, etc...) and the rest are sub families.
  
  Some examples:
  
      Cygwin98       ('Unix',  'Cygwin', 'Cygwin9x')
      Windows        ('Win32')
      Win98          ('Win32', 'Win9x')
      Linux          ('Unix',  'Linux')
      MacOS X        ('Unix',  'Darwin', 'MacOS', 'MacOS X')
      OS/2           ('OS/2')
  
  This is used to write code for styles of operating system.
  See os_flavor_is() for use.
  
  
  =head3 os_flavor_is
  
      my $is_this_flavor = $mm->os_flavor_is($this_flavor);
      my $is_this_flavor = $mm->os_flavor_is(@one_of_these_flavors);
  
  Checks to see if the current operating system is one of the given flavors.
  
  This is useful for code like:
  
      if( $mm->os_flavor_is('Unix') ) {
          $out = `foo 2>&1`;
      }
      else {
          $out = `foo`;
      }
  
  =cut
  
  sub os_flavor_is {
      my $self = shift;
      my %flavors = map { ($_ => 1) } $self->os_flavor;
      return (grep { $flavors{$_} } @_) ? 1 : 0;
  }
  
  
  =head3 can_load_xs
  
      my $can_load_xs = $self->can_load_xs;
  
  Returns true if we have the ability to load XS.
  
  This is important because miniperl, used to build XS modules in the
  core, can not load XS.
  
  =cut
  
  sub can_load_xs {
      return defined &DynaLoader::boot_DynaLoader ? 1 : 0;
  }
  
  
  =head3 can_run
  
    use ExtUtils::MM;
    my $runnable = MM->can_run($Config{make});
  
  If called in a scalar context it will return the full path to the binary
  you asked for if it was found, or C<undef> if it was not.
  
  If called in a list context, it will return a list of the full paths to instances
  of the binary where found in C<PATH>, or an empty list if it was not found.
  
  Copied from L<IPC::Cmd|IPC::Cmd/"$path = can_run( PROGRAM );">, but modified into
  a method (and removed C<$INSTANCES> capability).
  
  =cut
  
  sub can_run {
      my ($self, $command) = @_;
  
      # a lot of VMS executables have a symbol defined
      # check those first
      if ( $^O eq 'VMS' ) {
          require VMS::DCLsym;
          my $syms = VMS::DCLsym->new;
          return $command if scalar $syms->getsym( uc $command );
      }
  
      my @possibles;
  
      if( File::Spec->file_name_is_absolute($command) ) {
          return $self->maybe_command($command);
  
      } else {
          for my $dir (
              File::Spec->path,
              File::Spec->curdir
          ) {
              next if ! $dir || ! -d $dir;
              my $abs = File::Spec->catfile($self->os_flavor_is('Win32') ? Win32::GetShortPathName( $dir ) : $dir, $command);
              push @possibles, $abs if $abs = $self->maybe_command($abs);
          }
      }
      return @possibles if wantarray;
      return shift @possibles;
  }
  
  
  =head3 can_redirect_error
  
    $useredirect = MM->can_redirect_error;
  
  True if on an OS where qx operator (or backticks) can redirect C<STDERR>
  onto C<STDOUT>.
  
  =cut
  
  sub can_redirect_error {
    my $self = shift;
    $self->os_flavor_is('Unix')
        or ($self->os_flavor_is('Win32') and !$self->os_flavor_is('Win9x'))
        or $self->os_flavor_is('OS/2')
  }
  
  
  =head3 is_make_type
  
      my $is_dmake = $self->is_make_type('dmake');
  
  Returns true if C<<$self->make>> is the given type; possibilities are:
  
    gmake    GNU make
    dmake
    nmake
    bsdmake  BSD pmake-derived
  
  =cut
  
  sub is_make_type {
      my($self, $type) = @_;
      (undef, undef, my $make_basename) = $self->splitpath($self->make);
      return 1 if $make_basename =~ /\b$type\b/i; # executable's filename
      return 0 if $make_basename =~ /\b(dmake|nmake)\b/i; # Never fall through for dmake/nmake
      # now have to run with "-v" and guess
      my $redirect = $self->can_redirect_error ? '2>&1' : '';
      my $make = $self->make || $self->{MAKE};
      my $minus_v = `"$make" -v $redirect`;
      return 1 if $type eq 'gmake' and $minus_v =~ /GNU make/i;
      return 1 if $type eq 'bsdmake'
        and $minus_v =~ /^usage: make \[-BeikNnqrstWwX\]/im;
      0; # it wasn't whatever you asked
  }
  
  
  =head3 can_dep_space
  
      my $can_dep_space = $self->can_dep_space;
  
  Returns true if C<make> can handle (probably by quoting)
  dependencies that contain a space. Currently known true for GNU make,
  false for BSD pmake derivative.
  
  =cut
  
  my $cached_dep_space;
  sub can_dep_space {
      my $self = shift;
      return $cached_dep_space if defined $cached_dep_space;
      return $cached_dep_space = 1 if $self->is_make_type('gmake');
      return $cached_dep_space = 0 if $self->is_make_type('dmake'); # only on W32
      return $cached_dep_space = 0 if $self->is_make_type('bsdmake');
      return $cached_dep_space = 0; # assume no
  }
  
  
  =head3 quote_dep
  
    $text = $mm->quote_dep($text);
  
  Method that protects Makefile single-value constants (mainly filenames),
  so that make will still treat them as single values even if they
  inconveniently have spaces in. If the make program being used cannot
  achieve such protection and the given text would need it, throws an
  exception.
  
  =cut
  
  sub quote_dep {
      my ($self, $arg) = @_;
      die <<EOF if $arg =~ / / and not $self->can_dep_space;
  Tried to use make dependency with space for make that can't:
    '$arg'
  EOF
      $arg =~ s/( )/\\$1/g; # how GNU make does it
      return $arg;
  }
  
  
  =head3 split_command
  
      my @cmds = $MM->split_command($cmd, @args);
  
  Most OS have a maximum command length they can execute at once.  Large
  modules can easily generate commands well past that limit.  Its
  necessary to split long commands up into a series of shorter commands.
  
  C<split_command> will return a series of @cmds each processing part of
  the args.  Collectively they will process all the arguments.  Each
  individual line in @cmds will not be longer than the
  $self->max_exec_len being careful to take into account macro expansion.
  
  $cmd should include any switches and repeated initial arguments.
  
  If no @args are given, no @cmds will be returned.
  
  Pairs of arguments will always be preserved in a single command, this
  is a heuristic for things like pm_to_blib and pod2man which work on
  pairs of arguments.  This makes things like this safe:
  
      $self->split_command($cmd, %pod2man);
  
  
  =cut
  
  sub split_command {
      my($self, $cmd, @args) = @_;
  
      my @cmds = ();
      return(@cmds) unless @args;
  
      # If the command was given as a here-doc, there's probably a trailing
      # newline.
      chomp $cmd;
  
      # set aside 30% for macro expansion.
      my $len_left = int($self->max_exec_len * 0.70);
      $len_left -= length $self->_expand_macros($cmd);
  
      do {
          my $arg_str = '';
          my @next_args;
          while( @next_args = splice(@args, 0, 2) ) {
              # Two at a time to preserve pairs.
              my $next_arg_str = "\t  ". join ' ', @next_args, "\n";
  
              if( !length $arg_str ) {
                  $arg_str .= $next_arg_str
              }
              elsif( length($arg_str) + length($next_arg_str) > $len_left ) {
                  unshift @args, @next_args;
                  last;
              }
              else {
                  $arg_str .= $next_arg_str;
              }
          }
          chop $arg_str;
  
          push @cmds, $self->escape_newlines("$cmd \n$arg_str");
      } while @args;
  
      return @cmds;
  }
  
  
  sub _expand_macros {
      my($self, $cmd) = @_;
  
      $cmd =~ s{\$\((\w+)\)}{
          defined $self->{$1} ? $self->{$1} : "\$($1)"
      }e;
      return $cmd;
  }
  
  
  =head3 echo
  
      my @commands = $MM->echo($text);
      my @commands = $MM->echo($text, $file);
      my @commands = $MM->echo($text, $file, \%opts);
  
  Generates a set of @commands which print the $text to a $file.
  
  If $file is not given, output goes to STDOUT.
  
  If $opts{append} is true the $file will be appended to rather than
  overwritten.  Default is to overwrite.
  
  If $opts{allow_variables} is true, make variables of the form
  C<$(...)> will not be escaped.  Other C<$> will.  Default is to escape
  all C<$>.
  
  Example of use:
  
      my $make = map "\t$_\n", $MM->echo($text, $file);
  
  =cut
  
  sub echo {
      my($self, $text, $file, $opts) = @_;
  
      # Compatibility with old options
      if( !ref $opts ) {
          my $append = $opts;
          $opts = { append => $append || 0 };
      }
      $opts->{allow_variables} = 0 unless defined $opts->{allow_variables};
  
      my $ql_opts = { allow_variables => $opts->{allow_variables} };
      my @cmds = map { '$(NOECHO) $(ECHO) '.$self->quote_literal($_, $ql_opts) }
                 split /\n/, $text;
      if( $file ) {
          my $redirect = $opts->{append} ? '>>' : '>';
          $cmds[0] .= " $redirect $file";
          $_ .= " >> $file" foreach @cmds[1..$#cmds];
      }
  
      return @cmds;
  }
  
  
  =head3 wraplist
  
    my $args = $mm->wraplist(@list);
  
  Takes an array of items and turns them into a well-formatted list of
  arguments.  In most cases this is simply something like:
  
      FOO \
      BAR \
      BAZ
  
  =cut
  
  sub wraplist {
      my $self = shift;
      return join " \\\n\t", @_;
  }
  
  
  =head3 maketext_filter
  
      my $filter_make_text = $mm->maketext_filter($make_text);
  
  The text of the Makefile is run through this method before writing to
  disk.  It allows systems a chance to make portability fixes to the
  Makefile.
  
  By default it does nothing.
  
  This method is protected and not intended to be called outside of
  MakeMaker.
  
  =cut
  
  sub maketext_filter { return $_[1] }
  
  
  =head3 cd  I<Abstract>
  
    my $subdir_cmd = $MM->cd($subdir, @cmds);
  
  This will generate a make fragment which runs the @cmds in the given
  $dir.  The rough equivalent to this, except cross platform.
  
    cd $subdir && $cmd
  
  Currently $dir can only go down one level.  "foo" is fine.  "foo/bar" is
  not.  "../foo" is right out.
  
  The resulting $subdir_cmd has no leading tab nor trailing newline.  This
  makes it easier to embed in a make string.  For example.
  
        my $make = sprintf <<'CODE', $subdir_cmd;
    foo :
        $(ECHO) what
        %s
        $(ECHO) mouche
    CODE
  
  
  =head3 oneliner  I<Abstract>
  
    my $oneliner = $MM->oneliner($perl_code);
    my $oneliner = $MM->oneliner($perl_code, \@switches);
  
  This will generate a perl one-liner safe for the particular platform
  you're on based on the given $perl_code and @switches (a -e is
  assumed) suitable for using in a make target.  It will use the proper
  shell quoting and escapes.
  
  $(PERLRUN) will be used as perl.
  
  Any newlines in $perl_code will be escaped.  Leading and trailing
  newlines will be stripped.  Makes this idiom much easier:
  
      my $code = $MM->oneliner(<<'CODE', [...switches...]);
  some code here
  another line here
  CODE
  
  Usage might be something like:
  
      # an echo emulation
      $oneliner = $MM->oneliner('print "Foo\n"');
      $make = '$oneliner > somefile';
  
  All dollar signs must be doubled in the $perl_code if you expect them
  to be interpreted normally, otherwise it will be considered a make
  macro.  Also remember to quote make macros else it might be used as a
  bareword.  For example:
  
      # Assign the value of the $(VERSION_FROM) make macro to $vf.
      $oneliner = $MM->oneliner('$$vf = "$(VERSION_FROM)"');
  
  Its currently very simple and may be expanded sometime in the figure
  to include more flexible code and switches.
  
  
  =head3 quote_literal  I<Abstract>
  
      my $safe_text = $MM->quote_literal($text);
      my $safe_text = $MM->quote_literal($text, \%options);
  
  This will quote $text so it is interpreted literally in the shell.
  
  For example, on Unix this would escape any single-quotes in $text and
  put single-quotes around the whole thing.
  
  If $options{allow_variables} is true it will leave C<'$(FOO)'> make
  variables untouched.  If false they will be escaped like any other
  C<$>.  Defaults to true.
  
  =head3 escape_dollarsigns
  
      my $escaped_text = $MM->escape_dollarsigns($text);
  
  Escapes stray C<$> so they are not interpreted as make variables.
  
  It lets by C<$(...)>.
  
  =cut
  
  sub escape_dollarsigns {
      my($self, $text) = @_;
  
      # Escape dollar signs which are not starting a variable
      $text =~ s{\$ (?!\() }{\$\$}gx;
  
      return $text;
  }
  
  
  =head3 escape_all_dollarsigns
  
      my $escaped_text = $MM->escape_all_dollarsigns($text);
  
  Escapes all C<$> so they are not interpreted as make variables.
  
  =cut
  
  sub escape_all_dollarsigns {
      my($self, $text) = @_;
  
      # Escape dollar signs
      $text =~ s{\$}{\$\$}gx;
  
      return $text;
  }
  
  
  =head3 escape_newlines  I<Abstract>
  
      my $escaped_text = $MM->escape_newlines($text);
  
  Shell escapes newlines in $text.
  
  
  =head3 max_exec_len  I<Abstract>
  
      my $max_exec_len = $MM->max_exec_len;
  
  Calculates the maximum command size the OS can exec.  Effectively,
  this is the max size of a shell command line.
  
  =for _private
  $self->{_MAX_EXEC_LEN} is set by this method, but only for testing purposes.
  
  
  =head3 make
  
      my $make = $MM->make;
  
  Returns the make variant we're generating the Makefile for.  This attempts
  to do some normalization on the information from %Config or the user.
  
  =cut
  
  sub make {
      my $self = shift;
  
      my $make = lc $self->{MAKE};
  
      # Truncate anything like foomake6 to just foomake.
      $make =~ s/^(\w+make).*/$1/;
  
      # Turn gnumake into gmake.
      $make =~ s/^gnu/g/;
  
      return $make;
  }
  
  
  =head2 Targets
  
  These are methods which produce make targets.
  
  
  =head3 all_target
  
  Generate the default target 'all'.
  
  =cut
  
  sub all_target {
      my $self = shift;
  
      return <<'MAKE_EXT';
  all :: pure_all
  	$(NOECHO) $(NOOP)
  MAKE_EXT
  
  }
  
  
  =head3 blibdirs_target
  
      my $make_frag = $mm->blibdirs_target;
  
  Creates the blibdirs target which creates all the directories we use
  in blib/.
  
  The blibdirs.ts target is deprecated.  Depend on blibdirs instead.
  
  
  =cut
  
  sub blibdirs_target {
      my $self = shift;
  
      my @dirs = map { uc "\$(INST_$_)" } qw(libdir archlib
                                             autodir archautodir
                                             bin script
                                             man1dir man3dir
                                            );
  
      my @exists = map { $_.'$(DFSEP).exists' } @dirs;
  
      my $make = sprintf <<'MAKE', join(' ', @exists);
  blibdirs : %s
  	$(NOECHO) $(NOOP)
  
  # Backwards compat with 6.18 through 6.25
  blibdirs.ts : blibdirs
  	$(NOECHO) $(NOOP)
  
  MAKE
  
      $make .= $self->dir_target(@dirs);
  
      return $make;
  }
  
  
  =head3 clean (o)
  
  Defines the clean target.
  
  =cut
  
  sub clean {
  # --- Cleanup and Distribution Sections ---
  
      my($self, %attribs) = @_;
      my @m;
      push(@m, '
  # Delete temporary files but do not touch installed files. We don\'t delete
  # the Makefile here so a later make realclean still has a makefile to use.
  
  clean :: clean_subdirs
  ');
  
      my @files = sort values %{$self->{XS}}; # .c files from *.xs files
      my @dirs  = qw(blib);
  
      # Normally these are all under blib but they might have been
      # redefined.
      # XXX normally this would be a good idea, but the Perl core sets
      # INST_LIB = ../../lib rather than actually installing the files.
      # So a "make clean" in an ext/ directory would blow away lib.
      # Until the core is adjusted let's leave this out.
  #     push @dirs, qw($(INST_ARCHLIB) $(INST_LIB)
  #                    $(INST_BIN) $(INST_SCRIPT)
  #                    $(INST_MAN1DIR) $(INST_MAN3DIR)
  #                    $(INST_LIBDIR) $(INST_ARCHLIBDIR) $(INST_AUTODIR)
  #                    $(INST_STATIC) $(INST_DYNAMIC)
  #                 );
  
  
      if( $attribs{FILES} ) {
          # Use @dirs because we don't know what's in here.
          push @dirs, ref $attribs{FILES}                ?
                          @{$attribs{FILES}}             :
                          split /\s+/, $attribs{FILES}   ;
      }
  
      push(@files, qw[$(MAKE_APERL_FILE)
                      MYMETA.json MYMETA.yml perlmain.c tmon.out mon.out so_locations
                      blibdirs.ts pm_to_blib pm_to_blib.ts
                      *$(OBJ_EXT) *$(LIB_EXT) perl.exe perl perl$(EXE_EXT)
                      $(BOOTSTRAP) $(BASEEXT).bso
                      $(BASEEXT).def lib$(BASEEXT).def
                      $(BASEEXT).exp $(BASEEXT).x
                     ]);
  
      push(@files, $self->catfile('$(INST_ARCHAUTODIR)','extralibs.all'));
      push(@files, $self->catfile('$(INST_ARCHAUTODIR)','extralibs.ld'));
  
      # core files
      if ($^O eq 'vos') {
          push(@files, qw[perl*.kp]);
      }
      else {
          push(@files, qw[core core.*perl.*.? *perl.core]);
      }
  
      push(@files, map { "core." . "[0-9]"x$_ } (1..5));
  
      # OS specific things to clean up.  Use @dirs since we don't know
      # what might be in here.
      push @dirs, $self->extra_clean_files;
  
      # Occasionally files are repeated several times from different sources
      { my(%f) = map { ($_ => 1) } @files; @files = sort keys %f; }
      { my(%d) = map { ($_ => 1) } @dirs;  @dirs  = sort keys %d; }
  
      push @m, map "\t$_\n", $self->split_command('- $(RM_F)',  @files);
      push @m, map "\t$_\n", $self->split_command('- $(RM_RF)', @dirs);
  
      # Leave Makefile.old around for realclean
      push @m, <<'MAKE';
  	  $(NOECHO) $(RM_F) $(MAKEFILE_OLD)
  	- $(MV) $(FIRST_MAKEFILE) $(MAKEFILE_OLD) $(DEV_NULL)
  MAKE
  
      push(@m, "\t$attribs{POSTOP}\n")   if $attribs{POSTOP};
  
      join("", @m);
  }
  
  
  =head3 clean_subdirs_target
  
    my $make_frag = $MM->clean_subdirs_target;
  
  Returns the clean_subdirs target.  This is used by the clean target to
  call clean on any subdirectories which contain Makefiles.
  
  =cut
  
  sub clean_subdirs_target {
      my($self) = shift;
  
      # No subdirectories, no cleaning.
      return <<'NOOP_FRAG' unless @{$self->{DIR}};
  clean_subdirs :
  	$(NOECHO) $(NOOP)
  NOOP_FRAG
  
  
      my $clean = "clean_subdirs :\n";
  
      for my $dir (@{$self->{DIR}}) {
          my $subclean = $self->oneliner(sprintf <<'CODE', $dir);
  exit 0 unless chdir '%s';  system '$(MAKE) clean' if -f '$(FIRST_MAKEFILE)';
  CODE
  
          $clean .= "\t$subclean\n";
      }
  
      return $clean;
  }
  
  
  =head3 dir_target
  
      my $make_frag = $mm->dir_target(@directories);
  
  Generates targets to create the specified directories and set its
  permission to PERM_DIR.
  
  Because depending on a directory to just ensure it exists doesn't work
  too well (the modified time changes too often) dir_target() creates a
  .exists file in the created directory.  It is this you should depend on.
  For portability purposes you should use the $(DIRFILESEP) macro rather
  than a '/' to separate the directory from the file.
  
      yourdirectory$(DIRFILESEP).exists
  
  =cut
  
  sub dir_target {
      my($self, @dirs) = @_;
  
      my $make = '';
      foreach my $dir (@dirs) {
          $make .= sprintf <<'MAKE', ($dir) x 4;
  %s$(DFSEP).exists :: Makefile.PL
  	$(NOECHO) $(MKPATH) %s
  	$(NOECHO) $(CHMOD) $(PERM_DIR) %s
  	$(NOECHO) $(TOUCH) %s$(DFSEP).exists
  
  MAKE
  
      }
  
      return $make;
  }
  
  
  =head3 distdir
  
  Defines the scratch directory target that will hold the distribution
  before tar-ing (or shar-ing).
  
  =cut
  
  # For backwards compatibility.
  *dist_dir = *distdir;
  
  sub distdir {
      my($self) = shift;
  
      my $meta_target = $self->{NO_META} ? '' : 'distmeta';
      my $sign_target = !$self->{SIGN}   ? '' : 'distsignature';
  
      return sprintf <<'MAKE_FRAG', $meta_target, $sign_target;
  create_distdir :
  	$(RM_RF) $(DISTVNAME)
  	$(PERLRUN) "-MExtUtils::Manifest=manicopy,maniread" \
  		-e "manicopy(maniread(),'$(DISTVNAME)', '$(DIST_CP)');"
  
  distdir : create_distdir %s %s
  	$(NOECHO) $(NOOP)
  
  MAKE_FRAG
  
  }
  
  
  =head3 dist_test
  
  Defines a target that produces the distribution in the
  scratch directory, and runs 'perl Makefile.PL; make ;make test' in that
  subdirectory.
  
  =cut
  
  sub dist_test {
      my($self) = shift;
  
      my $mpl_args = join " ", map qq["$_"], @ARGV;
  
      my $test = $self->cd('$(DISTVNAME)',
                           '$(ABSPERLRUN) Makefile.PL '.$mpl_args,
                           '$(MAKE) $(PASTHRU)',
                           '$(MAKE) test $(PASTHRU)'
                          );
  
      return sprintf <<'MAKE_FRAG', $test;
  disttest : distdir
  	%s
  
  MAKE_FRAG
  
  
  }
  
  
  =head3 dynamic (o)
  
  Defines the dynamic target.
  
  =cut
  
  sub dynamic {
  # --- Dynamic Loading Sections ---
  
      my($self) = shift;
      '
  dynamic :: $(FIRST_MAKEFILE) $(BOOTSTRAP) $(INST_DYNAMIC)
  	$(NOECHO) $(NOOP)
  ';
  }
  
  
  =head3 makemakerdflt_target
  
    my $make_frag = $mm->makemakerdflt_target
  
  Returns a make fragment with the makemakerdeflt_target specified.
  This target is the first target in the Makefile, is the default target
  and simply points off to 'all' just in case any make variant gets
  confused or something gets snuck in before the real 'all' target.
  
  =cut
  
  sub makemakerdflt_target {
      return <<'MAKE_FRAG';
  makemakerdflt : all
  	$(NOECHO) $(NOOP)
  MAKE_FRAG
  
  }
  
  
  =head3 manifypods_target
  
    my $manifypods_target = $self->manifypods_target;
  
  Generates the manifypods target.  This target generates man pages from
  all POD files in MAN1PODS and MAN3PODS.
  
  =cut
  
  sub manifypods_target {
      my($self) = shift;
  
      my $man1pods      = '';
      my $man3pods      = '';
      my $dependencies  = '';
  
      # populate manXpods & dependencies:
      foreach my $name (sort keys %{$self->{MAN1PODS}}, sort keys %{$self->{MAN3PODS}}) {
          $dependencies .= " \\\n\t$name";
      }
  
      my $manify = <<END;
  manifypods : pure_all $dependencies
  END
  
      my @man_cmds;
      foreach my $section (qw(1 3)) {
          my $pods = $self->{"MAN${section}PODS"};
          my $p2m = sprintf <<CMD, $] > 5.008 ? " -u" : "";
  	\$(NOECHO) \$(POD2MAN) --section=$section --perm_rw=\$(PERM_RW)%s
  CMD
          push @man_cmds, $self->split_command($p2m, map {($_,$pods->{$_})} sort keys %$pods);
      }
  
      $manify .= "\t\$(NOECHO) \$(NOOP)\n" unless @man_cmds;
      $manify .= join '', map { "$_\n" } @man_cmds;
  
      return $manify;
  }
  
  sub _has_cpan_meta {
      return eval {
        require CPAN::Meta;
        CPAN::Meta->VERSION(2.112150);
        1;
      };
  }
  
  =head3 metafile_target
  
      my $target = $mm->metafile_target;
  
  Generate the metafile target.
  
  Writes the file META.yml (YAML encoded meta-data) and META.json
  (JSON encoded meta-data) about the module in the distdir.
  The format follows Module::Build's as closely as possible.
  
  =cut
  
  sub metafile_target {
      my $self = shift;
      return <<'MAKE_FRAG' if $self->{NO_META} or ! _has_cpan_meta();
  metafile :
  	$(NOECHO) $(NOOP)
  MAKE_FRAG
  
      my %metadata   = $self->metafile_data(
          $self->{META_ADD}   || {},
          $self->{META_MERGE} || {},
      );
  
      _fix_metadata_before_conversion( \%metadata );
  
      # paper over validation issues, but still complain, necessary because
      # there's no guarantee that the above will fix ALL errors
      my $meta = eval { CPAN::Meta->create( \%metadata, { lazy_validation => 1 } ) };
      warn $@ if $@ and
                 $@ !~ /encountered CODE.*, but JSON can only represent references to arrays or hashes/;
  
      # use the original metadata straight if the conversion failed
      # or if it can't be stringified.
      if( !$meta                                                  ||
          !eval { $meta->as_string( { version => "1.4" } ) }      ||
          !eval { $meta->as_string }
      )
      {
          $meta = bless \%metadata, 'CPAN::Meta';
      }
  
      my @write_metayml = $self->echo(
        $meta->as_string({version => "1.4"}), 'META_new.yml'
      );
      my @write_metajson = $self->echo(
        $meta->as_string(), 'META_new.json'
      );
  
      my $metayml = join("\n\t", @write_metayml);
      my $metajson = join("\n\t", @write_metajson);
      return sprintf <<'MAKE_FRAG', $metayml, $metajson;
  metafile : create_distdir
  	$(NOECHO) $(ECHO) Generating META.yml
  	%s
  	-$(NOECHO) $(MV) META_new.yml $(DISTVNAME)/META.yml
  	$(NOECHO) $(ECHO) Generating META.json
  	%s
  	-$(NOECHO) $(MV) META_new.json $(DISTVNAME)/META.json
  MAKE_FRAG
  
  }
  
  =begin private
  
  =head3 _fix_metadata_before_conversion
  
      _fix_metadata_before_conversion( \%metadata );
  
  Fixes errors in the metadata before it's handed off to CPAN::Meta for
  conversion. This hopefully results in something that can be used further
  on, no guarantee is made though.
  
  =end private
  
  =cut
  
  sub _fix_metadata_before_conversion {
      my ( $metadata ) = @_;
  
      # we should never be called unless this already passed but
      # prefer to be defensive in case somebody else calls this
  
      return unless _has_cpan_meta;
  
      my $bad_version = $metadata->{version} &&
                        !CPAN::Meta::Validator->new->version( 'version', $metadata->{version} );
  
      # just delete all invalid versions
      if( $bad_version ) {
          warn "Can't parse version '$metadata->{version}'\n";
          $metadata->{version} = '';
      }
  
      my $validator = CPAN::Meta::Validator->new( $metadata );
      return if $validator->is_valid;
  
      # fix non-camelcase custom resource keys (only other trick we know)
      for my $error ( $validator->errors ) {
          my ( $key ) = ( $error =~ /Custom resource '(.*)' must be in CamelCase./ );
          next if !$key;
  
          # first try to remove all non-alphabetic chars
          ( my $new_key = $key ) =~ s/[^_a-zA-Z]//g;
  
          # if that doesn't work, uppercase first one
          $new_key = ucfirst $new_key if !$validator->custom_1( $new_key );
  
          # copy to new key if that worked
          $metadata->{resources}{$new_key} = $metadata->{resources}{$key}
            if $validator->custom_1( $new_key );
  
          # and delete old one in any case
          delete $metadata->{resources}{$key};
      }
  
      return;
  }
  
  
  =begin private
  
  =head3 _sort_pairs
  
      my @pairs = _sort_pairs($sort_sub, \%hash);
  
  Sorts the pairs of a hash based on keys ordered according
  to C<$sort_sub>.
  
  =end private
  
  =cut
  
  sub _sort_pairs {
      my $sort  = shift;
      my $pairs = shift;
      return map  { $_ => $pairs->{$_} }
             sort $sort
             keys %$pairs;
  }
  
  
  # Taken from Module::Build::Base
  sub _hash_merge {
      my ($self, $h, $k, $v) = @_;
      if (ref $h->{$k} eq 'ARRAY') {
          push @{$h->{$k}}, ref $v ? @$v : $v;
      } elsif (ref $h->{$k} eq 'HASH') {
          $self->_hash_merge($h->{$k}, $_, $v->{$_}) foreach keys %$v;
      } else {
          $h->{$k} = $v;
      }
  }
  
  
  =head3 metafile_data
  
      my @metadata_pairs = $mm->metafile_data(\%meta_add, \%meta_merge);
  
  Returns the data which MakeMaker turns into the META.yml file 
  and the META.json file.
  
  Values of %meta_add will overwrite any existing metadata in those
  keys.  %meta_merge will be merged with them.
  
  =cut
  
  sub metafile_data {
      my $self = shift;
      my($meta_add, $meta_merge) = @_;
  
      my %meta = (
          # required
          name         => $self->{DISTNAME},
          version      => _normalize_version($self->{VERSION}),
          abstract     => $self->{ABSTRACT} || 'unknown',
          license      => $self->{LICENSE} || 'unknown',
          dynamic_config => 1,
  
          # optional
          distribution_type => $self->{PM} ? 'module' : 'script',
  
          no_index     => {
              directory   => [qw(t inc)]
          },
  
          generated_by => "ExtUtils::MakeMaker version $ExtUtils::MakeMaker::VERSION",
          'meta-spec'  => {
              url         => 'http://module-build.sourceforge.net/META-spec-v1.4.html',
              version     => 1.4
          },
      );
  
      # The author key is required and it takes a list.
      $meta{author}   = defined $self->{AUTHOR}    ? $self->{AUTHOR} : [];
  
      {
        my $vers = _metaspec_version( $meta_add, $meta_merge );
        my $method = $vers =~ m!^2!
                 ? '_add_requirements_to_meta_v2'
                 : '_add_requirements_to_meta_v1_4';
        %meta = $self->$method( %meta );
      }
  
      while( my($key, $val) = each %$meta_add ) {
          $meta{$key} = $val;
      }
  
      while( my($key, $val) = each %$meta_merge ) {
          $self->_hash_merge(\%meta, $key, $val);
      }
  
      return %meta;
  }
  
  
  =begin private
  
  =cut
  
  sub _metaspec_version {
    my ( $meta_add, $meta_merge ) = @_;
    return $meta_add->{'meta-spec'}->{version}
      if defined $meta_add->{'meta-spec'}
         and defined $meta_add->{'meta-spec'}->{version};
    return $meta_merge->{'meta-spec'}->{version}
      if defined $meta_merge->{'meta-spec'}
         and  defined $meta_merge->{'meta-spec'}->{version};
    return '1.4';
  }
  
  sub _add_requirements_to_meta_v1_4 {
      my ( $self, %meta ) = @_;
  
      # Check the original args so we can tell between the user setting it
      # to an empty hash and it just being initialized.
      if( $self->{ARGS}{CONFIGURE_REQUIRES} ) {
          $meta{configure_requires} = $self->{CONFIGURE_REQUIRES};
      } else {
          $meta{configure_requires} = {
              'ExtUtils::MakeMaker'       => 0,
          };
      }
  
      if( $self->{ARGS}{BUILD_REQUIRES} ) {
          $meta{build_requires} = $self->{BUILD_REQUIRES};
      } else {
          $meta{build_requires} = {
              'ExtUtils::MakeMaker'       => 0,
          };
      }
  
      if( $self->{ARGS}{TEST_REQUIRES} ) {
          $meta{build_requires} = {
            %{ $meta{build_requires} },
            %{ $self->{TEST_REQUIRES} },
          };
      }
  
      $meta{requires} = $self->{PREREQ_PM}
          if defined $self->{PREREQ_PM};
      $meta{requires}{perl} = _normalize_version($self->{MIN_PERL_VERSION})
          if $self->{MIN_PERL_VERSION};
  
      return %meta;
  }
  
  sub _add_requirements_to_meta_v2 {
      my ( $self, %meta ) = @_;
  
      # Check the original args so we can tell between the user setting it
      # to an empty hash and it just being initialized.
      if( $self->{ARGS}{CONFIGURE_REQUIRES} ) {
          $meta{prereqs}{configure}{requires} = $self->{CONFIGURE_REQUIRES};
      } else {
          $meta{prereqs}{configure}{requires} = {
              'ExtUtils::MakeMaker'       => 0,
          };
      }
  
      if( $self->{ARGS}{BUILD_REQUIRES} ) {
          $meta{prereqs}{build}{requires} = $self->{BUILD_REQUIRES};
      } else {
          $meta{prereqs}{build}{requires} = {
              'ExtUtils::MakeMaker'       => 0,
          };
      }
  
      if( $self->{ARGS}{TEST_REQUIRES} ) {
          $meta{prereqs}{test}{requires} = $self->{TEST_REQUIRES};
      }
  
      $meta{prereqs}{runtime}{requires} = $self->{PREREQ_PM}
          if $self->{ARGS}{PREREQ_PM};
      $meta{prereqs}{runtime}{requires}{perl} = _normalize_version($self->{MIN_PERL_VERSION})
          if $self->{MIN_PERL_VERSION};
  
      return %meta;
  }
  
  # Adapted from Module::Build::Base
  sub _normalize_version {
    my ($version) = @_;
    $version = 0 unless defined $version;
  
    if ( ref $version eq 'version' ) { # version objects
      $version = $version->is_qv ? $version->normal : $version->stringify;
    }
    elsif ( $version =~ /^[^v][^.]*\.[^.]+\./ ) { # no leading v, multiple dots
      # normalize string tuples without "v": "1.2.3" -> "v1.2.3"
      $version = "v$version";
    }
    else {
      # leave alone
    }
    return $version;
  }
  
  =head3 _dump_hash
  
      $yaml = _dump_hash(\%options, %hash);
  
  Implements a fake YAML dumper for a hash given
  as a list of pairs. No quoting/escaping is done. Keys
  are supposed to be strings. Values are undef, strings,
  hash refs or array refs of strings.
  
  Supported options are:
  
      delta => STR - indentation delta
      use_header => BOOL - whether to include a YAML header
      indent => STR - a string of spaces
            default: ''
  
      max_key_length => INT - maximum key length used to align
          keys and values of the same hash
          default: 20
      key_sort => CODE - a sort sub
              It may be undef, which means no sorting by keys
          default: sub { lc $a cmp lc $b }
  
      customs => HASH - special options for certain keys
             (whose values are hashes themselves)
          may contain: max_key_length, key_sort, customs
  
  =end private
  
  =cut
  
  sub _dump_hash {
      croak "first argument should be a hash ref" unless ref $_[0] eq 'HASH';
      my $options = shift;
      my %hash = @_;
  
      # Use a list to preserve order.
      my @pairs;
  
      my $k_sort
          = exists $options->{key_sort} ? $options->{key_sort}
                                        : sub { lc $a cmp lc $b };
      if ($k_sort) {
          croak "'key_sort' should be a coderef" unless ref $k_sort eq 'CODE';
          @pairs = _sort_pairs($k_sort, \%hash);
      } else { # list of pairs, no sorting
          @pairs = @_;
      }
  
      my $yaml     = $options->{use_header} ? "--- #YAML:1.0\n" : '';
      my $indent   = $options->{indent} || '';
      my $k_length = min(
          ($options->{max_key_length} || 20),
          max(map { length($_) + 1 } grep { !ref $hash{$_} } keys %hash)
      );
      my $customs  = $options->{customs} || {};
  
      # printf format for key
      my $k_format = "%-${k_length}s";
  
      while( @pairs ) {
          my($key, $val) = splice @pairs, 0, 2;
          $val = '~' unless defined $val;
          if(ref $val eq 'HASH') {
              if ( keys %$val ) {
                  my %k_options = ( # options for recursive call
                      delta => $options->{delta},
                      use_header => 0,
                      indent => $indent . $options->{delta},
                  );
                  if (exists $customs->{$key}) {
                      my %k_custom = %{$customs->{$key}};
                      foreach my $k (qw(key_sort max_key_length customs)) {
                          $k_options{$k} = $k_custom{$k} if exists $k_custom{$k};
                      }
                  }
                  $yaml .= $indent . "$key:\n"
                    . _dump_hash(\%k_options, %$val);
              }
              else {
                  $yaml .= $indent . "$key:  {}\n";
              }
          }
          elsif (ref $val eq 'ARRAY') {
              if( @$val ) {
                  $yaml .= $indent . "$key:\n";
  
                  for (@$val) {
                      croak "only nested arrays of non-refs are supported" if ref $_;
                      $yaml .= $indent . $options->{delta} . "- $_\n";
                  }
              }
              else {
                  $yaml .= $indent . "$key:  []\n";
              }
          }
          elsif( ref $val and !blessed($val) ) {
              croak "only nested hashes, arrays and objects are supported";
          }
          else {  # if it's an object, just stringify it
              $yaml .= $indent . sprintf "$k_format  %s\n", "$key:", $val;
          }
      };
  
      return $yaml;
  
  }
  
  sub blessed {
      return eval { $_[0]->isa("UNIVERSAL"); };
  }
  
  sub max {
      return (sort { $b <=> $a } @_)[0];
  }
  
  sub min {
      return (sort { $a <=> $b } @_)[0];
  }
  
  =head3 metafile_file
  
      my $meta_yml = $mm->metafile_file(@metadata_pairs);
  
  Turns the @metadata_pairs into YAML.
  
  This method does not implement a complete YAML dumper, being limited
  to dump a hash with values which are strings, undef's or nested hashes
  and arrays of strings. No quoting/escaping is done.
  
  =cut
  
  sub metafile_file {
      my $self = shift;
  
      my %dump_options = (
          use_header => 1,
          delta      => ' ' x 4,
          key_sort   => undef,
      );
      return _dump_hash(\%dump_options, @_);
  
  }
  
  
  =head3 distmeta_target
  
      my $make_frag = $mm->distmeta_target;
  
  Generates the distmeta target to add META.yml and META.json to the MANIFEST
  in the distdir.
  
  =cut
  
  sub distmeta_target {
      my $self = shift;
  
      my @add_meta = (
        $self->oneliner(<<'CODE', ['-MExtUtils::Manifest=maniadd']),
  exit unless -e q{META.yml};
  eval { maniadd({q{META.yml} => q{Module YAML meta-data (added by MakeMaker)}}) }
      or print "Could not add META.yml to MANIFEST: $${'@'}\n"
  CODE
        $self->oneliner(<<'CODE', ['-MExtUtils::Manifest=maniadd'])
  exit unless -f q{META.json};
  eval { maniadd({q{META.json} => q{Module JSON meta-data (added by MakeMaker)}}) }
      or print "Could not add META.json to MANIFEST: $${'@'}\n"
  CODE
      );
  
      my @add_meta_to_distdir = map { $self->cd('$(DISTVNAME)', $_) } @add_meta;
  
      return sprintf <<'MAKE', @add_meta_to_distdir;
  distmeta : create_distdir metafile
  	$(NOECHO) %s
  	$(NOECHO) %s
  
  MAKE
  
  }
  
  
  =head3 mymeta
  
      my $mymeta = $mm->mymeta;
  
  Generate MYMETA information as a hash either from an existing CPAN Meta file
  (META.json or META.yml) or from internal data.
  
  =cut
  
  sub mymeta {
      my $self = shift;
      my $file = shift || ''; # for testing
  
      my $mymeta = $self->_mymeta_from_meta($file);
      my $v2 = 1;
  
      unless ( $mymeta ) {
          my @metadata = $self->metafile_data(
              $self->{META_ADD}   || {},
              $self->{META_MERGE} || {},
          );
          $mymeta = {@metadata};
          $v2 = 0;
      }
  
      # Overwrite the non-configure dependency hashes
  
      my $method = $v2
                 ? '_add_requirements_to_meta_v2'
                 : '_add_requirements_to_meta_v1_4';
  
      $mymeta = { $self->$method( %$mymeta ) };
  
      $mymeta->{dynamic_config} = 0;
  
      return $mymeta;
  }
  
  
  sub _mymeta_from_meta {
      my $self = shift;
      my $metafile = shift || ''; # for testing
  
      return unless _has_cpan_meta();
  
      my $meta;
      for my $file ( $metafile, "META.json", "META.yml" ) {
        next unless -e $file;
        eval {
            $meta = CPAN::Meta->load_file($file)->as_struct( { version => 2 } );
        };
        last if $meta;
      }
      return unless $meta;
  
      # META.yml before 6.25_01 cannot be trusted.  META.yml lived in the source directory.
      # There was a good chance the author accidentally uploaded a stale META.yml if they
      # rolled their own tarball rather than using "make dist".
      if ($meta->{generated_by} &&
          $meta->{generated_by} =~ /ExtUtils::MakeMaker version ([\d\._]+)/) {
          my $eummv = do { local $^W = 0; $1+0; };
          if ($eummv < 6.2501) {
              return;
          }
      }
  
      return $meta;
  }
  
  =head3 write_mymeta
  
      $self->write_mymeta( $mymeta );
  
  Write MYMETA information to MYMETA.json and MYMETA.yml.
  
  =cut
  
  sub write_mymeta {
      my $self = shift;
      my $mymeta = shift;
  
      return unless _has_cpan_meta();
  
      _fix_metadata_before_conversion( $mymeta );
  
      # this can still blow up
      # not sure if i should just eval this and skip file creation if it
      # blows up
      my $meta_obj = CPAN::Meta->new( $mymeta, { lazy_validation => 1 } );
      $meta_obj->save( 'MYMETA.json' );
      $meta_obj->save( 'MYMETA.yml', { version => "1.4" } );
      return 1;
  }
  
  =head3 realclean (o)
  
  Defines the realclean target.
  
  =cut
  
  sub realclean {
      my($self, %attribs) = @_;
  
      my @dirs  = qw($(DISTVNAME));
      my @files = qw($(FIRST_MAKEFILE) $(MAKEFILE_OLD));
  
      # Special exception for the perl core where INST_* is not in blib.
      # This cleans up the files built from the ext/ directory (all XS).
      if( $self->{PERL_CORE} ) {
          push @dirs, qw($(INST_AUTODIR) $(INST_ARCHAUTODIR));
          push @files, values %{$self->{PM}};
      }
  
      if( $self->has_link_code ){
          push @files, qw($(OBJECT));
      }
  
      if( $attribs{FILES} ) {
          if( ref $attribs{FILES} ) {
              push @dirs, @{ $attribs{FILES} };
          }
          else {
              push @dirs, split /\s+/, $attribs{FILES};
          }
      }
  
      # Occasionally files are repeated several times from different sources
      { my(%f) = map { ($_ => 1) } @files;  @files = keys %f; }
      { my(%d) = map { ($_ => 1) } @dirs;   @dirs  = keys %d; }
  
      my $rm_cmd  = join "\n\t", map { "$_" }
                      $self->split_command('- $(RM_F)',  @files);
      my $rmf_cmd = join "\n\t", map { "$_" }
                      $self->split_command('- $(RM_RF)', @dirs);
  
      my $m = sprintf <<'MAKE', $rm_cmd, $rmf_cmd;
  # Delete temporary files (via clean) and also delete dist files
  realclean purge ::  clean realclean_subdirs
  	%s
  	%s
  MAKE
  
      $m .= "\t$attribs{POSTOP}\n" if $attribs{POSTOP};
  
      return $m;
  }
  
  
  =head3 realclean_subdirs_target
  
    my $make_frag = $MM->realclean_subdirs_target;
  
  Returns the realclean_subdirs target.  This is used by the realclean
  target to call realclean on any subdirectories which contain Makefiles.
  
  =cut
  
  sub realclean_subdirs_target {
      my $self = shift;
  
      return <<'NOOP_FRAG' unless @{$self->{DIR}};
  realclean_subdirs :
  	$(NOECHO) $(NOOP)
  NOOP_FRAG
  
      my $rclean = "realclean_subdirs :\n";
  
      foreach my $dir (@{$self->{DIR}}) {
          foreach my $makefile ('$(MAKEFILE_OLD)', '$(FIRST_MAKEFILE)' ) {
              my $subrclean .= $self->oneliner(sprintf <<'CODE', $dir, ($makefile) x 2);
  chdir '%s';  system '$(MAKE) $(USEMAKEFILE) %s realclean' if -f '%s';
  CODE
  
              $rclean .= sprintf <<'RCLEAN', $subrclean;
  	- %s
  RCLEAN
  
          }
      }
  
      return $rclean;
  }
  
  
  =head3 signature_target
  
      my $target = $mm->signature_target;
  
  Generate the signature target.
  
  Writes the file SIGNATURE with "cpansign -s".
  
  =cut
  
  sub signature_target {
      my $self = shift;
  
      return <<'MAKE_FRAG';
  signature :
  	cpansign -s
  MAKE_FRAG
  
  }
  
  
  =head3 distsignature_target
  
      my $make_frag = $mm->distsignature_target;
  
  Generates the distsignature target to add SIGNATURE to the MANIFEST in the
  distdir.
  
  =cut
  
  sub distsignature_target {
      my $self = shift;
  
      my $add_sign = $self->oneliner(<<'CODE', ['-MExtUtils::Manifest=maniadd']);
  eval { maniadd({q{SIGNATURE} => q{Public-key signature (added by MakeMaker)}}) }
      or print "Could not add SIGNATURE to MANIFEST: $${'@'}\n"
  CODE
  
      my $sign_dist        = $self->cd('$(DISTVNAME)' => 'cpansign -s');
  
      # cpansign -s complains if SIGNATURE is in the MANIFEST yet does not
      # exist
      my $touch_sig        = $self->cd('$(DISTVNAME)' => '$(TOUCH) SIGNATURE');
      my $add_sign_to_dist = $self->cd('$(DISTVNAME)' => $add_sign );
  
      return sprintf <<'MAKE', $add_sign_to_dist, $touch_sig, $sign_dist
  distsignature : distmeta
  	$(NOECHO) %s
  	$(NOECHO) %s
  	%s
  
  MAKE
  
  }
  
  
  =head3 special_targets
  
    my $make_frag = $mm->special_targets
  
  Returns a make fragment containing any targets which have special
  meaning to make.  For example, .SUFFIXES and .PHONY.
  
  =cut
  
  sub special_targets {
      my $make_frag = <<'MAKE_FRAG';
  .SUFFIXES : .xs .c .C .cpp .i .s .cxx .cc $(OBJ_EXT)
  
  .PHONY: all config static dynamic test linkext manifest blibdirs clean realclean disttest distdir
  
  MAKE_FRAG
  
      $make_frag .= <<'MAKE_FRAG' if $ENV{CLEARCASE_ROOT};
  .NO_CONFIG_REC: Makefile
  
  MAKE_FRAG
  
      return $make_frag;
  }
  
  
  
  
  =head2 Init methods
  
  Methods which help initialize the MakeMaker object and macros.
  
  
  =head3 init_ABSTRACT
  
      $mm->init_ABSTRACT
  
  =cut
  
  sub init_ABSTRACT {
      my $self = shift;
  
      if( $self->{ABSTRACT_FROM} and $self->{ABSTRACT} ) {
          warn "Both ABSTRACT_FROM and ABSTRACT are set.  ".
               "Ignoring ABSTRACT_FROM.\n";
          return;
      }
  
      if ($self->{ABSTRACT_FROM}){
          $self->{ABSTRACT} = $self->parse_abstract($self->{ABSTRACT_FROM}) or
              carp "WARNING: Setting ABSTRACT via file ".
                   "'$self->{ABSTRACT_FROM}' failed\n";
      }
  
      if ($self->{ABSTRACT} && $self->{ABSTRACT} =~ m![[:cntrl:]]+!) {
              warn "WARNING: ABSTRACT contains control character(s),".
                   " they will be removed\n";
              $self->{ABSTRACT} =~ s![[:cntrl:]]+!!g;
              return;
      }
  }
  
  =head3 init_INST
  
      $mm->init_INST;
  
  Called by init_main.  Sets up all INST_* variables except those related
  to XS code.  Those are handled in init_xs.
  
  =cut
  
  sub init_INST {
      my($self) = shift;
  
      $self->{INST_ARCHLIB} ||= $self->catdir($Curdir,"blib","arch");
      $self->{INST_BIN}     ||= $self->catdir($Curdir,'blib','bin');
  
      # INST_LIB typically pre-set if building an extension after
      # perl has been built and installed. Setting INST_LIB allows
      # you to build directly into, say $Config{privlibexp}.
      unless ($self->{INST_LIB}){
          if ($self->{PERL_CORE}) {
              $self->{INST_LIB} = $self->{INST_ARCHLIB} = $self->{PERL_LIB};
          } else {
              $self->{INST_LIB} = $self->catdir($Curdir,"blib","lib");
          }
      }
  
      my @parentdir = split(/::/, $self->{PARENT_NAME});
      $self->{INST_LIBDIR}      = $self->catdir('$(INST_LIB)',     @parentdir);
      $self->{INST_ARCHLIBDIR}  = $self->catdir('$(INST_ARCHLIB)', @parentdir);
      $self->{INST_AUTODIR}     = $self->catdir('$(INST_LIB)', 'auto',
                                                '$(FULLEXT)');
      $self->{INST_ARCHAUTODIR} = $self->catdir('$(INST_ARCHLIB)', 'auto',
                                                '$(FULLEXT)');
  
      $self->{INST_SCRIPT}  ||= $self->catdir($Curdir,'blib','script');
  
      $self->{INST_MAN1DIR} ||= $self->catdir($Curdir,'blib','man1');
      $self->{INST_MAN3DIR} ||= $self->catdir($Curdir,'blib','man3');
  
      return 1;
  }
  
  
  =head3 init_INSTALL
  
      $mm->init_INSTALL;
  
  Called by init_main.  Sets up all INSTALL_* variables (except
  INSTALLDIRS) and *PREFIX.
  
  =cut
  
  sub init_INSTALL {
      my($self) = shift;
  
      if( $self->{ARGS}{INSTALL_BASE} and $self->{ARGS}{PREFIX} ) {
          die "Only one of PREFIX or INSTALL_BASE can be given.  Not both.\n";
      }
  
      if( $self->{ARGS}{INSTALL_BASE} ) {
          $self->init_INSTALL_from_INSTALL_BASE;
      }
      else {
          $self->init_INSTALL_from_PREFIX;
      }
  }
  
  
  =head3 init_INSTALL_from_PREFIX
  
    $mm->init_INSTALL_from_PREFIX;
  
  =cut
  
  sub init_INSTALL_from_PREFIX {
      my $self = shift;
  
      $self->init_lib2arch;
  
      # There are often no Config.pm defaults for these new man variables so
      # we fall back to the old behavior which is to use installman*dir
      foreach my $num (1, 3) {
          my $k = 'installsiteman'.$num.'dir';
  
          $self->{uc $k} ||= uc "\$(installman${num}dir)"
            unless $Config{$k};
      }
  
      foreach my $num (1, 3) {
          my $k = 'installvendorman'.$num.'dir';
  
          unless( $Config{$k} ) {
              $self->{uc $k}  ||= $Config{usevendorprefix}
                                ? uc "\$(installman${num}dir)"
                                : '';
          }
      }
  
      $self->{INSTALLSITEBIN} ||= '$(INSTALLBIN)'
        unless $Config{installsitebin};
      $self->{INSTALLSITESCRIPT} ||= '$(INSTALLSCRIPT)'
        unless $Config{installsitescript};
  
      unless( $Config{installvendorbin} ) {
          $self->{INSTALLVENDORBIN} ||= $Config{usevendorprefix}
                                      ? $Config{installbin}
                                      : '';
      }
      unless( $Config{installvendorscript} ) {
          $self->{INSTALLVENDORSCRIPT} ||= $Config{usevendorprefix}
                                         ? $Config{installscript}
                                         : '';
      }
  
  
      my $iprefix = $Config{installprefixexp} || $Config{installprefix} ||
                    $Config{prefixexp}        || $Config{prefix} || '';
      my $vprefix = $Config{usevendorprefix}  ? $Config{vendorprefixexp} : '';
      my $sprefix = $Config{siteprefixexp}    || '';
  
      # 5.005_03 doesn't have a siteprefix.
      $sprefix = $iprefix unless $sprefix;
  
  
      $self->{PREFIX}       ||= '';
  
      if( $self->{PREFIX} ) {
          @{$self}{qw(PERLPREFIX SITEPREFIX VENDORPREFIX)} =
            ('$(PREFIX)') x 3;
      }
      else {
          $self->{PERLPREFIX}   ||= $iprefix;
          $self->{SITEPREFIX}   ||= $sprefix;
          $self->{VENDORPREFIX} ||= $vprefix;
  
          # Lots of MM extension authors like to use $(PREFIX) so we
          # put something sensible in there no matter what.
          $self->{PREFIX} = '$('.uc $self->{INSTALLDIRS}.'PREFIX)';
      }
  
      my $arch    = $Config{archname};
      my $version = $Config{version};
  
      # default style
      my $libstyle = $Config{installstyle} || 'lib/perl5';
      my $manstyle = '';
  
      if( $self->{LIBSTYLE} ) {
          $libstyle = $self->{LIBSTYLE};
          $manstyle = $self->{LIBSTYLE} eq 'lib/perl5' ? 'lib/perl5' : '';
      }
  
      # Some systems, like VOS, set installman*dir to '' if they can't
      # read man pages.
      for my $num (1, 3) {
          $self->{'INSTALLMAN'.$num.'DIR'} ||= 'none'
            unless $Config{'installman'.$num.'dir'};
      }
  
      my %bin_layouts =
      (
          bin         => { s => $iprefix,
                           t => 'perl',
                           d => 'bin' },
          vendorbin   => { s => $vprefix,
                           t => 'vendor',
                           d => 'bin' },
          sitebin     => { s => $sprefix,
                           t => 'site',
                           d => 'bin' },
          script      => { s => $iprefix,
                           t => 'perl',
                           d => 'bin' },
          vendorscript=> { s => $vprefix,
                           t => 'vendor',
                           d => 'bin' },
          sitescript  => { s => $sprefix,
                           t => 'site',
                           d => 'bin' },
      );
  
      my %man_layouts =
      (
          man1dir         => { s => $iprefix,
                               t => 'perl',
                               d => 'man/man1',
                               style => $manstyle, },
          siteman1dir     => { s => $sprefix,
                               t => 'site',
                               d => 'man/man1',
                               style => $manstyle, },
          vendorman1dir   => { s => $vprefix,
                               t => 'vendor',
                               d => 'man/man1',
                               style => $manstyle, },
  
          man3dir         => { s => $iprefix,
                               t => 'perl',
                               d => 'man/man3',
                               style => $manstyle, },
          siteman3dir     => { s => $sprefix,
                               t => 'site',
                               d => 'man/man3',
                               style => $manstyle, },
          vendorman3dir   => { s => $vprefix,
                               t => 'vendor',
                               d => 'man/man3',
                               style => $manstyle, },
      );
  
      my %lib_layouts =
      (
          privlib     => { s => $iprefix,
                           t => 'perl',
                           d => '',
                           style => $libstyle, },
          vendorlib   => { s => $vprefix,
                           t => 'vendor',
                           d => '',
                           style => $libstyle, },
          sitelib     => { s => $sprefix,
                           t => 'site',
                           d => 'site_perl',
                           style => $libstyle, },
  
          archlib     => { s => $iprefix,
                           t => 'perl',
                           d => "$version/$arch",
                           style => $libstyle },
          vendorarch  => { s => $vprefix,
                           t => 'vendor',
                           d => "$version/$arch",
                           style => $libstyle },
          sitearch    => { s => $sprefix,
                           t => 'site',
                           d => "site_perl/$version/$arch",
                           style => $libstyle },
      );
  
  
      # Special case for LIB.
      if( $self->{LIB} ) {
          foreach my $var (keys %lib_layouts) {
              my $Installvar = uc "install$var";
  
              if( $var =~ /arch/ ) {
                  $self->{$Installvar} ||=
                    $self->catdir($self->{LIB}, $Config{archname});
              }
              else {
                  $self->{$Installvar} ||= $self->{LIB};
              }
          }
      }
  
      my %type2prefix = ( perl    => 'PERLPREFIX',
                          site    => 'SITEPREFIX',
                          vendor  => 'VENDORPREFIX'
                        );
  
      my %layouts = (%bin_layouts, %man_layouts, %lib_layouts);
      while( my($var, $layout) = each(%layouts) ) {
          my($s, $t, $d, $style) = @{$layout}{qw(s t d style)};
          my $r = '$('.$type2prefix{$t}.')';
  
          warn "Prefixing $var\n" if $Verbose >= 2;
  
          my $installvar = "install$var";
          my $Installvar = uc $installvar;
          next if $self->{$Installvar};
  
          $d = "$style/$d" if $style;
          $self->prefixify($installvar, $s, $r, $d);
  
          warn "  $Installvar == $self->{$Installvar}\n"
            if $Verbose >= 2;
      }
  
      # Generate these if they weren't figured out.
      $self->{VENDORARCHEXP} ||= $self->{INSTALLVENDORARCH};
      $self->{VENDORLIBEXP}  ||= $self->{INSTALLVENDORLIB};
  
      return 1;
  }
  
  
  =head3 init_from_INSTALL_BASE
  
      $mm->init_from_INSTALL_BASE
  
  =cut
  
  my %map = (
             lib      => [qw(lib perl5)],
             arch     => [('lib', 'perl5', $Config{archname})],
             bin      => [qw(bin)],
             man1dir  => [qw(man man1)],
             man3dir  => [qw(man man3)]
            );
  $map{script} = $map{bin};
  
  sub init_INSTALL_from_INSTALL_BASE {
      my $self = shift;
  
      @{$self}{qw(PREFIX VENDORPREFIX SITEPREFIX PERLPREFIX)} =
                                                           '$(INSTALL_BASE)';
  
      my %install;
      foreach my $thing (keys %map) {
          foreach my $dir (('', 'SITE', 'VENDOR')) {
              my $uc_thing = uc $thing;
              my $key = "INSTALL".$dir.$uc_thing;
  
              $install{$key} ||=
                $self->catdir('$(INSTALL_BASE)', @{$map{$thing}});
          }
      }
  
      # Adjust for variable quirks.
      $install{INSTALLARCHLIB} ||= delete $install{INSTALLARCH};
      $install{INSTALLPRIVLIB} ||= delete $install{INSTALLLIB};
  
      foreach my $key (keys %install) {
          $self->{$key} ||= $install{$key};
      }
  
      return 1;
  }
  
  
  =head3 init_VERSION  I<Abstract>
  
      $mm->init_VERSION
  
  Initialize macros representing versions of MakeMaker and other tools
  
  MAKEMAKER: path to the MakeMaker module.
  
  MM_VERSION: ExtUtils::MakeMaker Version
  
  MM_REVISION: ExtUtils::MakeMaker version control revision (for backwards
               compat)
  
  VERSION: version of your module
  
  VERSION_MACRO: which macro represents the version (usually 'VERSION')
  
  VERSION_SYM: like version but safe for use as an RCS revision number
  
  DEFINE_VERSION: -D line to set the module version when compiling
  
  XS_VERSION: version in your .xs file.  Defaults to $(VERSION)
  
  XS_VERSION_MACRO: which macro represents the XS version.
  
  XS_DEFINE_VERSION: -D line to set the xs version when compiling.
  
  Called by init_main.
  
  =cut
  
  sub init_VERSION {
      my($self) = shift;
  
      $self->{MAKEMAKER}  = $ExtUtils::MakeMaker::Filename;
      $self->{MM_VERSION} = $ExtUtils::MakeMaker::VERSION;
      $self->{MM_REVISION}= $ExtUtils::MakeMaker::Revision;
      $self->{VERSION_FROM} ||= '';
  
      if ($self->{VERSION_FROM}){
          $self->{VERSION} = $self->parse_version($self->{VERSION_FROM});
          if( $self->{VERSION} eq 'undef' ) {
              carp("WARNING: Setting VERSION via file ".
                   "'$self->{VERSION_FROM}' failed\n");
          }
      }
  
      if (defined $self->{VERSION}) {
          if ( $self->{VERSION} !~ /^\s*v?[\d_\.]+\s*$/ ) {
            require version;
            my $normal = eval { version->new( $self->{VERSION} ) };
            $self->{VERSION} = $normal if defined $normal;
          }
          $self->{VERSION} =~ s/^\s+//;
          $self->{VERSION} =~ s/\s+$//;
      }
      else {
          $self->{VERSION} = '';
      }
  
  
      $self->{VERSION_MACRO}  = 'VERSION';
      ($self->{VERSION_SYM} = $self->{VERSION}) =~ s/\W/_/g;
      $self->{DEFINE_VERSION} = '-D$(VERSION_MACRO)=\"$(VERSION)\"';
  
  
      # Graham Barr and Paul Marquess had some ideas how to ensure
      # version compatibility between the *.pm file and the
      # corresponding *.xs file. The bottom line was, that we need an
      # XS_VERSION macro that defaults to VERSION:
      $self->{XS_VERSION} ||= $self->{VERSION};
  
      $self->{XS_VERSION_MACRO}  = 'XS_VERSION';
      $self->{XS_DEFINE_VERSION} = '-D$(XS_VERSION_MACRO)=\"$(XS_VERSION)\"';
  
  }
  
  
  =head3 init_tools
  
      $MM->init_tools();
  
  Initializes the simple macro definitions used by tools_other() and
  places them in the $MM object.  These use conservative cross platform
  versions and should be overridden with platform specific versions for
  performance.
  
  Defines at least these macros.
  
    Macro             Description
  
    NOOP              Do nothing
    NOECHO            Tell make not to display the command itself
  
    SHELL             Program used to run shell commands
  
    ECHO              Print text adding a newline on the end
    RM_F              Remove a file
    RM_RF             Remove a directory
    TOUCH             Update a file's timestamp
    TEST_F            Test for a file's existence
    TEST_S            Test the size of a file
    CP                Copy a file
    CP_NONEMPTY       Copy a file if it is not empty
    MV                Move a file
    CHMOD             Change permissions on a file
    FALSE             Exit with non-zero
    TRUE              Exit with zero
  
    UMASK_NULL        Nullify umask
    DEV_NULL          Suppress all command output
  
  =cut
  
  sub init_tools {
      my $self = shift;
  
      $self->{ECHO}     ||= $self->oneliner('binmode STDOUT, qq{:raw}; print qq{@ARGV}', ['-l']);
      $self->{ECHO_N}   ||= $self->oneliner('print qq{@ARGV}');
  
      $self->{TOUCH}    ||= $self->oneliner('touch', ["-MExtUtils::Command"]);
      $self->{CHMOD}    ||= $self->oneliner('chmod', ["-MExtUtils::Command"]);
      $self->{RM_F}     ||= $self->oneliner('rm_f',  ["-MExtUtils::Command"]);
      $self->{RM_RF}    ||= $self->oneliner('rm_rf', ["-MExtUtils::Command"]);
      $self->{TEST_F}   ||= $self->oneliner('test_f', ["-MExtUtils::Command"]);
      $self->{TEST_S}   ||= $self->oneliner('test_s', ["-MExtUtils::Command::MM"]);
      $self->{CP_NONEMPTY} ||= $self->oneliner('cp_nonempty', ["-MExtUtils::Command::MM"]);
      $self->{FALSE}    ||= $self->oneliner('exit 1');
      $self->{TRUE}     ||= $self->oneliner('exit 0');
  
      $self->{MKPATH}   ||= $self->oneliner('mkpath', ["-MExtUtils::Command"]);
  
      $self->{CP}       ||= $self->oneliner('cp', ["-MExtUtils::Command"]);
      $self->{MV}       ||= $self->oneliner('mv', ["-MExtUtils::Command"]);
  
      $self->{MOD_INSTALL} ||=
        $self->oneliner(<<'CODE', ['-MExtUtils::Install']);
  install([ from_to => {@ARGV}, verbose => '$(VERBINST)', uninstall_shadows => '$(UNINST)', dir_mode => '$(PERM_DIR)' ]);
  CODE
      $self->{DOC_INSTALL} ||= $self->oneliner('perllocal_install', ["-MExtUtils::Command::MM"]);
      $self->{UNINSTALL}   ||= $self->oneliner('uninstall', ["-MExtUtils::Command::MM"]);
      $self->{WARN_IF_OLD_PACKLIST} ||=
        $self->oneliner('warn_if_old_packlist', ["-MExtUtils::Command::MM"]);
      $self->{FIXIN}       ||= $self->oneliner('MY->fixin(shift)', ["-MExtUtils::MY"]);
      $self->{EQUALIZE_TIMESTAMP} ||= $self->oneliner('eqtime', ["-MExtUtils::Command"]);
  
      $self->{UNINST}     ||= 0;
      $self->{VERBINST}   ||= 0;
  
      $self->{SHELL}              ||= $Config{sh};
  
      # UMASK_NULL is not used by MakeMaker but some CPAN modules
      # make use of it.
      $self->{UMASK_NULL}         ||= "umask 0";
  
      # Not the greatest default, but its something.
      $self->{DEV_NULL}           ||= "> /dev/null 2>&1";
  
      $self->{NOOP}               ||= '$(TRUE)';
      $self->{NOECHO}             = '@' unless defined $self->{NOECHO};
  
      $self->{FIRST_MAKEFILE}     ||= $self->{MAKEFILE} || 'Makefile';
      $self->{MAKEFILE}           ||= $self->{FIRST_MAKEFILE};
      $self->{MAKEFILE_OLD}       ||= $self->{MAKEFILE}.'.old';
      $self->{MAKE_APERL_FILE}    ||= $self->{MAKEFILE}.'.aperl';
  
      # Not everybody uses -f to indicate "use this Makefile instead"
      $self->{USEMAKEFILE}        ||= '-f';
  
      # Some makes require a wrapper around macros passed in on the command
      # line.
      $self->{MACROSTART}         ||= '';
      $self->{MACROEND}           ||= '';
  
      return;
  }
  
  
  =head3 init_others
  
      $MM->init_others();
  
  Initializes the macro definitions having to do with compiling and
  linking used by tools_other() and places them in the $MM object.
  
  If there is no description, its the same as the parameter to
  WriteMakefile() documented in ExtUtils::MakeMaker.
  
  =cut
  
  sub init_others {
      my $self = shift;
  
      $self->{LD_RUN_PATH} = "";
  
      $self->{LIBS} = $self->_fix_libs($self->{LIBS});
  
      # Compute EXTRALIBS, BSLOADLIBS and LDLOADLIBS from $self->{LIBS}
      foreach my $libs ( @{$self->{LIBS}} ){
          $libs =~ s/^\s*(.*\S)\s*$/$1/; # remove leading and trailing whitespace
          my(@libs) = $self->extliblist($libs);
          if ($libs[0] or $libs[1] or $libs[2]){
              # LD_RUN_PATH now computed by ExtUtils::Liblist
              ($self->{EXTRALIBS},  $self->{BSLOADLIBS},
               $self->{LDLOADLIBS}, $self->{LD_RUN_PATH}) = @libs;
              last;
          }
      }
  
      if ( $self->{OBJECT} ) {
          $self->{OBJECT} = join(" ", @{$self->{OBJECT}}) if ref $self->{OBJECT};
          $self->{OBJECT} =~ s!\.o(bj)?\b!\$(OBJ_EXT)!g;
      } elsif ( $self->{MAGICXS} && @{$self->{O_FILES}||[]} ) {
          $self->{OBJECT} = join(" ", @{$self->{O_FILES}});
          $self->{OBJECT} =~ s!\.o(bj)?\b!\$(OBJ_EXT)!g;
      } else {
          # init_dirscan should have found out, if we have C files
          $self->{OBJECT} = "";
          $self->{OBJECT} = '$(BASEEXT)$(OBJ_EXT)' if @{$self->{C}||[]};
      }
      $self->{OBJECT} =~ s/\n+/ \\\n\t/g;
  
      $self->{BOOTDEP}  = (-f "$self->{BASEEXT}_BS") ? "$self->{BASEEXT}_BS" : "";
      $self->{PERLMAINCC} ||= '$(CC)';
      $self->{LDFROM} = '$(OBJECT)' unless $self->{LDFROM};
  
      # Sanity check: don't define LINKTYPE = dynamic if we're skipping
      # the 'dynamic' section of MM.  We don't have this problem with
      # 'static', since we either must use it (%Config says we can't
      # use dynamic loading) or the caller asked for it explicitly.
      if (!$self->{LINKTYPE}) {
         $self->{LINKTYPE} = $self->{SKIPHASH}{'dynamic'}
                          ? 'static'
                          : ($Config{usedl} ? 'dynamic' : 'static');
      }
  
      return;
  }
  
  
  # Lets look at $self->{LIBS} carefully: It may be an anon array, a string or
  # undefined. In any case we turn it into an anon array
  sub _fix_libs {
      my($self, $libs) = @_;
  
      return !defined $libs       ? ['']          :
             !ref $libs           ? [$libs]       :
             !defined $libs->[0]  ? ['']          :
                                    $libs         ;
  }
  
  
  =head3 tools_other
  
      my $make_frag = $MM->tools_other;
  
  Returns a make fragment containing definitions for the macros init_others()
  initializes.
  
  =cut
  
  sub tools_other {
      my($self) = shift;
      my @m;
  
      # We set PM_FILTER as late as possible so it can see all the earlier
      # on macro-order sensitive makes such as nmake.
      for my $tool (qw{ SHELL CHMOD CP MV NOOP NOECHO RM_F RM_RF TEST_F TOUCH
                        UMASK_NULL DEV_NULL MKPATH EQUALIZE_TIMESTAMP
                        FALSE TRUE
                        ECHO ECHO_N
                        UNINST VERBINST
                        MOD_INSTALL DOC_INSTALL UNINSTALL
                        WARN_IF_OLD_PACKLIST
                        MACROSTART MACROEND
                        USEMAKEFILE
                        PM_FILTER
                        FIXIN
                        CP_NONEMPTY
                      } )
      {
          next unless defined $self->{$tool};
          push @m, "$tool = $self->{$tool}\n";
      }
  
      return join "", @m;
  }
  
  
  =head3 init_DIRFILESEP  I<Abstract>
  
    $MM->init_DIRFILESEP;
    my $dirfilesep = $MM->{DIRFILESEP};
  
  Initializes the DIRFILESEP macro which is the separator between the
  directory and filename in a filepath.  ie. / on Unix, \ on Win32 and
  nothing on VMS.
  
  For example:
  
      # instead of $(INST_ARCHAUTODIR)/extralibs.ld
      $(INST_ARCHAUTODIR)$(DIRFILESEP)extralibs.ld
  
  Something of a hack but it prevents a lot of code duplication between
  MM_* variants.
  
  Do not use this as a separator between directories.  Some operating
  systems use different separators between subdirectories as between
  directories and filenames (for example:  VOLUME:[dir1.dir2]file on VMS).
  
  =head3 init_linker  I<Abstract>
  
      $mm->init_linker;
  
  Initialize macros which have to do with linking.
  
  PERL_ARCHIVE: path to libperl.a equivalent to be linked to dynamic
  extensions.
  
  PERL_ARCHIVE_AFTER: path to a library which should be put on the
  linker command line I<after> the external libraries to be linked to
  dynamic extensions.  This may be needed if the linker is one-pass, and
  Perl includes some overrides for C RTL functions, such as malloc().
  
  EXPORT_LIST: name of a file that is passed to linker to define symbols
  to be exported.
  
  Some OSes do not need these in which case leave it blank.
  
  
  =head3 init_platform
  
      $mm->init_platform
  
  Initialize any macros which are for platform specific use only.
  
  A typical one is the version number of your OS specific module.
  (ie. MM_Unix_VERSION or MM_VMS_VERSION).
  
  =cut
  
  sub init_platform {
      return '';
  }
  
  
  =head3 init_MAKE
  
      $mm->init_MAKE
  
  Initialize MAKE from either a MAKE environment variable or $Config{make}.
  
  =cut
  
  sub init_MAKE {
      my $self = shift;
  
      $self->{MAKE} ||= $ENV{MAKE} || $Config{make};
  }
  
  
  =head2 Tools
  
  A grab bag of methods to generate specific macros and commands.
  
  
  
  =head3 manifypods
  
  Defines targets and routines to translate the pods into manpages and
  put them into the INST_* directories.
  
  =cut
  
  sub manifypods {
      my $self          = shift;
  
      my $POD2MAN_macro = $self->POD2MAN_macro();
      my $manifypods_target = $self->manifypods_target();
  
      return <<END_OF_TARGET;
  
  $POD2MAN_macro
  
  $manifypods_target
  
  END_OF_TARGET
  
  }
  
  
  =head3 POD2MAN_macro
  
    my $pod2man_macro = $self->POD2MAN_macro
  
  Returns a definition for the POD2MAN macro.  This is a program
  which emulates the pod2man utility.  You can add more switches to the
  command by simply appending them on the macro.
  
  Typical usage:
  
      $(POD2MAN) --section=3 --perm_rw=$(PERM_RW) podfile1 man_page1 ...
  
  =cut
  
  sub POD2MAN_macro {
      my $self = shift;
  
  # Need the trailing '--' so perl stops gobbling arguments and - happens
  # to be an alternative end of line separator on VMS so we quote it
      return <<'END_OF_DEF';
  POD2MAN_EXE = $(PERLRUN) "-MExtUtils::Command::MM" -e pod2man "--"
  POD2MAN = $(POD2MAN_EXE)
  END_OF_DEF
  }
  
  
  =head3 test_via_harness
  
    my $command = $mm->test_via_harness($perl, $tests);
  
  Returns a $command line which runs the given set of $tests with
  Test::Harness and the given $perl.
  
  Used on the t/*.t files.
  
  =cut
  
  sub test_via_harness {
      my($self, $perl, $tests) = @_;
  
      return qq{\t$perl "-MExtUtils::Command::MM" "-MTest::Harness" }.
             qq{"-e" "undef *Test::Harness::Switches; test_harness(\$(TEST_VERBOSE), '\$(INST_LIB)', '\$(INST_ARCHLIB)')" $tests\n};
  }
  
  =head3 test_via_script
  
    my $command = $mm->test_via_script($perl, $script);
  
  Returns a $command line which just runs a single test without
  Test::Harness.  No checks are done on the results, they're just
  printed.
  
  Used for test.pl, since they don't always follow Test::Harness
  formatting.
  
  =cut
  
  sub test_via_script {
      my($self, $perl, $script) = @_;
      return qq{\t$perl "-I\$(INST_LIB)" "-I\$(INST_ARCHLIB)" $script\n};
  }
  
  
  =head3 tool_autosplit
  
  Defines a simple perl call that runs autosplit. May be deprecated by
  pm_to_blib soon.
  
  =cut
  
  sub tool_autosplit {
      my($self, %attribs) = @_;
  
      my $maxlen = $attribs{MAXLEN} ? '$$AutoSplit::Maxlen=$attribs{MAXLEN};'
                                    : '';
  
      my $asplit = $self->oneliner(sprintf <<'PERL_CODE', $maxlen);
  use AutoSplit; %s autosplit($$ARGV[0], $$ARGV[1], 0, 1, 1)
  PERL_CODE
  
      return sprintf <<'MAKE_FRAG', $asplit;
  # Usage: $(AUTOSPLITFILE) FileToSplit AutoDirToSplitInto
  AUTOSPLITFILE = %s
  
  MAKE_FRAG
  
  }
  
  
  =head3 arch_check
  
      my $arch_ok = $mm->arch_check(
          $INC{"Config.pm"},
          File::Spec->catfile($Config{archlibexp}, "Config.pm")
      );
  
  A sanity check that what Perl thinks the architecture is and what
  Config thinks the architecture is are the same.  If they're not it
  will return false and show a diagnostic message.
  
  When building Perl it will always return true, as nothing is installed
  yet.
  
  The interface is a bit odd because this is the result of a
  quick refactoring.  Don't rely on it.
  
  =cut
  
  sub arch_check {
      my $self = shift;
      my($pconfig, $cconfig) = @_;
  
      return 1 if $self->{PERL_SRC};
  
      my($pvol, $pthinks) = $self->splitpath($pconfig);
      my($cvol, $cthinks) = $self->splitpath($cconfig);
  
      $pthinks = $self->canonpath($pthinks);
      $cthinks = $self->canonpath($cthinks);
  
      my $ret = 1;
      if ($pthinks ne $cthinks) {
          print "Have $pthinks\n";
          print "Want $cthinks\n";
  
          $ret = 0;
  
          my $arch = (grep length, $self->splitdir($pthinks))[-1];
  
          print <<END unless $self->{UNINSTALLED_PERL};
  Your perl and your Config.pm seem to have different ideas about the
  architecture they are running on.
  Perl thinks: [$arch]
  Config says: [$Config{archname}]
  This may or may not cause problems. Please check your installation of perl
  if you have problems building this extension.
  END
      }
  
      return $ret;
  }
  
  
  
  =head2 File::Spec wrappers
  
  ExtUtils::MM_Any is a subclass of File::Spec.  The methods noted here
  override File::Spec.
  
  
  
  =head3 catfile
  
  File::Spec <= 0.83 has a bug where the file part of catfile is not
  canonicalized.  This override fixes that bug.
  
  =cut
  
  sub catfile {
      my $self = shift;
      return $self->canonpath($self->SUPER::catfile(@_));
  }
  
  
  
  =head2 Misc
  
  Methods I can't really figure out where they should go yet.
  
  
  =head3 find_tests
  
    my $test = $mm->find_tests;
  
  Returns a string suitable for feeding to the shell to return all
  tests in t/*.t.
  
  =cut
  
  sub find_tests {
      my($self) = shift;
      return -d 't' ? 't/*.t' : '';
  }
  
  =head3 find_tests_recursive
  
    my $tests = $mm->find_tests_recursive;
  
  Returns a string suitable for feeding to the shell to return all
  tests in t/ but recursively.
  
  =cut
  
  sub find_tests_recursive {
      my($self) = shift;
      return '' unless -d 't';
  
      require File::Find;
  
      my %testfiles;
  
      my $wanted = sub {
          return unless m!\.t$!;
          my ($volume,$directories,$file) =
              File::Spec->splitpath( $File::Find::name  );
          my @dirs = File::Spec->splitdir( $directories );
          for ( @dirs ) {
            next if $_ eq 't';
            unless ( $_ ) {
              $_ = '*.t';
              next;
            }
            $_ = '*';
          }
          my $testfile = join '/', @dirs;
          $testfiles{ $testfile } = 1;
      };
  
      File::Find::find( $wanted, 't' );
  
      return join ' ', sort keys %testfiles;
  }
  
  =head3 extra_clean_files
  
      my @files_to_clean = $MM->extra_clean_files;
  
  Returns a list of OS specific files to be removed in the clean target in
  addition to the usual set.
  
  =cut
  
  # An empty method here tickled a perl 5.8.1 bug and would return its object.
  sub extra_clean_files {
      return;
  }
  
  
  =head3 installvars
  
      my @installvars = $mm->installvars;
  
  A list of all the INSTALL* variables without the INSTALL prefix.  Useful
  for iteration or building related variable sets.
  
  =cut
  
  sub installvars {
      return qw(PRIVLIB SITELIB  VENDORLIB
                ARCHLIB SITEARCH VENDORARCH
                BIN     SITEBIN  VENDORBIN
                SCRIPT  SITESCRIPT  VENDORSCRIPT
                MAN1DIR SITEMAN1DIR VENDORMAN1DIR
                MAN3DIR SITEMAN3DIR VENDORMAN3DIR
               );
  }
  
  
  =head3 libscan
  
    my $wanted = $self->libscan($path);
  
  Takes a path to a file or dir and returns an empty string if we don't
  want to include this file in the library.  Otherwise it returns the
  the $path unchanged.
  
  Mainly used to exclude version control administrative directories from
  installation.
  
  =cut
  
  sub libscan {
      my($self,$path) = @_;
      my($dirs,$file) = ($self->splitpath($path))[1,2];
      return '' if grep /^(?:RCS|CVS|SCCS|\.svn|_darcs)$/,
                       $self->splitdir($dirs), $file;
  
      return $path;
  }
  
  
  =head3 platform_constants
  
      my $make_frag = $mm->platform_constants
  
  Returns a make fragment defining all the macros initialized in
  init_platform() rather than put them in constants().
  
  =cut
  
  sub platform_constants {
      return '';
  }
  
  =begin private
  
  =head3 _PREREQ_PRINT
  
      $self->_PREREQ_PRINT;
  
  Implements PREREQ_PRINT.
  
  Refactored out of MakeMaker->new().
  
  =end private
  
  =cut
  
  sub _PREREQ_PRINT {
      my $self = shift;
  
      require Data::Dumper;
      my @what = ('PREREQ_PM');
      push @what, 'MIN_PERL_VERSION' if $self->{MIN_PERL_VERSION};
      push @what, 'BUILD_REQUIRES'   if $self->{BUILD_REQUIRES};
      print Data::Dumper->Dump([@{$self}{@what}], \@what);
      exit 0;
  }
  
  
  =begin private
  
  =head3 _PRINT_PREREQ
  
    $mm->_PRINT_PREREQ;
  
  Implements PRINT_PREREQ, a slightly different version of PREREQ_PRINT
  added by Redhat to, I think, support generating RPMs from Perl modules.
  
  Should not include BUILD_REQUIRES as RPMs do not incluide them.
  
  Refactored out of MakeMaker->new().
  
  =end private
  
  =cut
  
  sub _PRINT_PREREQ {
      my $self = shift;
  
      my $prereqs= $self->{PREREQ_PM};
      my @prereq = map { [$_, $prereqs->{$_}] } keys %$prereqs;
  
      if ( $self->{MIN_PERL_VERSION} ) {
          push @prereq, ['perl' => $self->{MIN_PERL_VERSION}];
      }
  
      print join(" ", map { "perl($_->[0])>=$_->[1] " }
                   sort { $a->[0] cmp $b->[0] } @prereq), "\n";
      exit 0;
  }
  
  
  =begin private
  
  =head3 _all_prereqs
  
    my $prereqs = $self->_all_prereqs;
  
  Returns a hash ref of both PREREQ_PM and BUILD_REQUIRES.
  
  =end private
  
  =cut
  
  sub _all_prereqs {
      my $self = shift;
  
      return { %{$self->{PREREQ_PM}}, %{$self->{BUILD_REQUIRES}} };
  }
  
  =begin private
  
  =head3 _perl_header_files
  
    my $perl_header_files= $self->_perl_header_files;
  
  returns a sorted list of header files as found in PERL_SRC or $archlibexp/CORE.
  
  Used by perldepend() in MM_Unix and MM_VMS via _perl_header_files_fragment()
  
  =end private
  
  =cut
  
  sub _perl_header_files {
      my $self = shift;
  
      my $header_dir = $self->{PERL_SRC} || $ENV{PERL_SRC} || $self->catdir($Config{archlibexp}, 'CORE');
      opendir my $dh, $header_dir
          or die "Failed to opendir '$header_dir' to find header files: $!";
  
      # we need to use a temporary here as the sort in scalar context would have undefined results.
      my @perl_headers= sort grep { /\.h\z/ } readdir($dh);
  
      closedir $dh;
  
      return @perl_headers;
  }
  
  =begin private
  
  =head3 _perl_header_files_fragment ($o, $separator)
  
    my $perl_header_files_fragment= $self->_perl_header_files_fragment("/");
  
  return a Makefile fragment which holds the list of perl header files which
  XS code depends on $(PERL_INC), and sets up the dependency for the $(OBJECT) file.
  
  The $separator argument defaults to "". MM_VMS will set it to "" and MM_UNIX to "/"
  in perldepend(). This reason child subclasses need to control this is that in
  VMS the $(PERL_INC) directory will already have delimiters in it, but in
  UNIX $(PERL_INC) will need a slash between it an the filename. Hypothetically
  win32 could use "\\" (but it doesn't need to).
  
  =end private
  
  =cut
  
  sub _perl_header_files_fragment {
      my ($self, $separator)= @_;
      $separator ||= "";
      return join("\\\n",
                  "PERL_HDRS = ",
                  map {
                      sprintf( "        \$(PERL_INCDEP)%s%s            ", $separator, $_ )
                  } $self->_perl_header_files()
             ) . "\n\n"
             . "\$(OBJECT) : \$(PERL_HDRS)\n";
  }
  
  
  =head1 AUTHOR
  
  Michael G Schwern <schwern@pobox.com> and the denizens of
  makemaker@perl.org with code from ExtUtils::MM_Unix and
  ExtUtils::MM_Win32.
  
  
  =cut
  
  1;
PERL5_EXTUTILS_MM_ANY

$fatpacked{"perl5/ExtUtils/MM_BeOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_EXTUTILS_MM_BEOS';
  package ExtUtils::MM_BeOS;
  
  use strict;
  
  =head1 NAME
  
  ExtUtils::MM_BeOS - methods to override UN*X behaviour in ExtUtils::MakeMaker
  
  =head1 SYNOPSIS
  
   use ExtUtils::MM_BeOS;	# Done internally by ExtUtils::MakeMaker if needed
  
  =head1 DESCRIPTION
  
  See ExtUtils::MM_Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  =over 4
  
  =cut
  
  use ExtUtils::MakeMaker::Config;
  use File::Spec;
  require ExtUtils::MM_Any;
  require ExtUtils::MM_Unix;
  
  our @ISA = qw( ExtUtils::MM_Any ExtUtils::MM_Unix );
  our $VERSION = '7.10';
  
  
  =item os_flavor
  
  BeOS is BeOS.
  
  =cut
  
  sub os_flavor {
      return('BeOS');
  }
  
  =item init_linker
  
  libperl.a equivalent to be linked to dynamic extensions.
  
  =cut
  
  sub init_linker {
      my($self) = shift;
  
      $self->{PERL_ARCHIVE} ||=
        File::Spec->catdir('$(PERL_INC)',$Config{libperl});
      $self->{PERL_ARCHIVEDEP} ||= '';
      $self->{PERL_ARCHIVE_AFTER} ||= '';
      $self->{EXPORT_LIST}  ||= '';
  }
  
  =back
  
  1;
  __END__
  
PERL5_EXTUTILS_MM_BEOS

$fatpacked{"perl5/ExtUtils/MM_Cygwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_EXTUTILS_MM_CYGWIN';
  package ExtUtils::MM_Cygwin;
  
  use strict;
  
  use ExtUtils::MakeMaker::Config;
  use File::Spec;
  
  require ExtUtils::MM_Unix;
  require ExtUtils::MM_Win32;
  our @ISA = qw( ExtUtils::MM_Unix );
  
  our $VERSION = '7.10';
  
  
  =head1 NAME
  
  ExtUtils::MM_Cygwin - methods to override UN*X behaviour in ExtUtils::MakeMaker
  
  =head1 SYNOPSIS
  
   use ExtUtils::MM_Cygwin; # Done internally by ExtUtils::MakeMaker if needed
  
  =head1 DESCRIPTION
  
  See ExtUtils::MM_Unix for a documentation of the methods provided there.
  
  =over 4
  
  =item os_flavor
  
  We're Unix and Cygwin.
  
  =cut
  
  sub os_flavor {
      return('Unix', 'Cygwin');
  }
  
  =item cflags
  
  if configured for dynamic loading, triggers #define EXT in EXTERN.h
  
  =cut
  
  sub cflags {
      my($self,$libperl)=@_;
      return $self->{CFLAGS} if $self->{CFLAGS};
      return '' unless $self->needs_linking();
  
      my $base = $self->SUPER::cflags($libperl);
      foreach (split /\n/, $base) {
          /^(\S*)\s*=\s*(\S*)$/ and $self->{$1} = $2;
      };
      $self->{CCFLAGS} .= " -DUSEIMPORTLIB" if ($Config{useshrplib} eq 'true');
  
      return $self->{CFLAGS} = qq{
  CCFLAGS = $self->{CCFLAGS}
  OPTIMIZE = $self->{OPTIMIZE}
  PERLTYPE = $self->{PERLTYPE}
  };
  
  }
  
  
  =item replace_manpage_separator
  
  replaces strings '::' with '.' in MAN*POD man page names
  
  =cut
  
  sub replace_manpage_separator {
      my($self, $man) = @_;
      $man =~ s{/+}{.}g;
      return $man;
  }
  
  =item init_linker
  
  points to libperl.a
  
  =cut
  
  sub init_linker {
      my $self = shift;
  
      if ($Config{useshrplib} eq 'true') {
          my $libperl = '$(PERL_INC)' .'/'. "$Config{libperl}";
          if( $] >= 5.006002 ) {
              $libperl =~ s/a$/dll.a/;
          }
          $self->{PERL_ARCHIVE} = $libperl;
      } else {
          $self->{PERL_ARCHIVE} =
            '$(PERL_INC)' .'/'. ("$Config{libperl}" or "libperl.a");
      }
  
      $self->{PERL_ARCHIVEDEP} ||= '';
      $self->{PERL_ARCHIVE_AFTER} ||= '';
      $self->{EXPORT_LIST}  ||= '';
  }
  
  =item maybe_command
  
  Determine whether a file is native to Cygwin by checking whether it
  resides inside the Cygwin installation (using Windows paths). If so,
  use C<ExtUtils::MM_Unix> to determine if it may be a command.
  Otherwise use the tests from C<ExtUtils::MM_Win32>.
  
  =cut
  
  sub maybe_command {
      my ($self, $file) = @_;
  
      my $cygpath = Cygwin::posix_to_win_path('/', 1);
      my $filepath = Cygwin::posix_to_win_path($file, 1);
  
      return (substr($filepath,0,length($cygpath)) eq $cygpath)
      ? $self->SUPER::maybe_command($file) # Unix
      : ExtUtils::MM_Win32->maybe_command($file); # Win32
  }
  
  =item dynamic_lib
  
  Use the default to produce the *.dll's.
  But for new archdir dll's use the same rebase address if the old exists.
  
  =cut
  
  sub dynamic_lib {
      my($self, %attribs) = @_;
      my $s = ExtUtils::MM_Unix::dynamic_lib($self, %attribs);
      my $ori = "$self->{INSTALLARCHLIB}/auto/$self->{FULLEXT}/$self->{BASEEXT}.$self->{DLEXT}";
      if (-e $ori) {
          my $imagebase = `/bin/objdump -p $ori | /bin/grep ImageBase | /bin/cut -c12-`;
          chomp $imagebase;
          if ($imagebase gt "40000000") {
              my $LDDLFLAGS = $self->{LDDLFLAGS};
              $LDDLFLAGS =~ s/-Wl,--enable-auto-image-base/-Wl,--image-base=0x$imagebase/;
              $s =~ s/ \$\(LDDLFLAGS\) / $LDDLFLAGS /m;
          }
      }
      $s;
  }
  
  =item all_target
  
  Build man pages, too
  
  =cut
  
  sub all_target {
      ExtUtils::MM_Unix::all_target(shift);
  }
  
  =back
  
  =cut
  
  1;
PERL5_EXTUTILS_MM_CYGWIN

$fatpacked{"perl5/ExtUtils/MM_DOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_EXTUTILS_MM_DOS';
  package ExtUtils::MM_DOS;
  
  use strict;
  
  our $VERSION = '7.10';
  
  require ExtUtils::MM_Any;
  require ExtUtils::MM_Unix;
  our @ISA = qw( ExtUtils::MM_Any ExtUtils::MM_Unix );
  
  
  =head1 NAME
  
  ExtUtils::MM_DOS - DOS specific subclass of ExtUtils::MM_Unix
  
  =head1 SYNOPSIS
  
    Don't use this module directly.
    Use ExtUtils::MM and let it choose.
  
  =head1 DESCRIPTION
  
  This is a subclass of ExtUtils::MM_Unix which contains functionality
  for DOS.
  
  Unless otherwise stated, it works just like ExtUtils::MM_Unix
  
  =head2 Overridden methods
  
  =over 4
  
  =item os_flavor
  
  =cut
  
  sub os_flavor {
      return('DOS');
  }
  
  =item B<replace_manpage_separator>
  
  Generates Foo__Bar.3 style man page names
  
  =cut
  
  sub replace_manpage_separator {
      my($self, $man) = @_;
  
      $man =~ s,/+,__,g;
      return $man;
  }
  
  =back
  
  =head1 AUTHOR
  
  Michael G Schwern <schwern@pobox.com> with code from ExtUtils::MM_Unix
  
  =head1 SEE ALSO
  
  L<ExtUtils::MM_Unix>, L<ExtUtils::MakeMaker>
  
  =cut
  
  1;
PERL5_EXTUTILS_MM_DOS

$fatpacked{"perl5/ExtUtils/MM_Darwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_EXTUTILS_MM_DARWIN';
  package ExtUtils::MM_Darwin;
  
  use strict;
  
  BEGIN {
      require ExtUtils::MM_Unix;
      our @ISA = qw( ExtUtils::MM_Unix );
  }
  
  our $VERSION = '7.10';
  
  
  =head1 NAME
  
  ExtUtils::MM_Darwin - special behaviors for OS X
  
  =head1 SYNOPSIS
  
      For internal MakeMaker use only
  
  =head1 DESCRIPTION
  
  See L<ExtUtils::MM_Unix> for L<ExtUtils::MM_Any> for documentation on the
  methods overridden here.
  
  =head2 Overriden Methods
  
  =head3 init_dist
  
  Turn off Apple tar's tendency to copy resource forks as "._foo" files.
  
  =cut
  
  sub init_dist {
      my $self = shift;
  
      # Thank you, Apple, for breaking tar and then breaking the work around.
      # 10.4 wants COPY_EXTENDED_ATTRIBUTES_DISABLE while 10.5 wants
      # COPYFILE_DISABLE.  I'm not going to push my luck and instead just
      # set both.
      $self->{TAR} ||=
          'COPY_EXTENDED_ATTRIBUTES_DISABLE=1 COPYFILE_DISABLE=1 tar';
  
      $self->SUPER::init_dist(@_);
  }
  
  1;
PERL5_EXTUTILS_MM_DARWIN

$fatpacked{"perl5/ExtUtils/MM_MacOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_EXTUTILS_MM_MACOS';
  package ExtUtils::MM_MacOS;
  
  use strict;
  
  our $VERSION = '7.10';
  
  sub new {
      die 'MacOS Classic (MacPerl) is no longer supported by MakeMaker';
  }
  
  =head1 NAME
  
  ExtUtils::MM_MacOS - once produced Makefiles for MacOS Classic
  
  =head1 SYNOPSIS
  
    # MM_MacOS no longer contains any code.  This is just a stub.
  
  =head1 DESCRIPTION
  
  Once upon a time, MakeMaker could produce an approximation of a correct
  Makefile on MacOS Classic (MacPerl).  Due to a lack of maintainers, this
  fell out of sync with the rest of MakeMaker and hadn't worked in years.
  Since there's little chance of it being repaired, MacOS Classic is fading
  away, and the code was icky to begin with, the code has been deleted to
  make maintenance easier.
  
  Anyone interested in resurrecting this file should pull the old version
  from the MakeMaker CVS repository and contact makemaker@perl.org.
  
  =cut
  
  1;
PERL5_EXTUTILS_MM_MACOS

$fatpacked{"perl5/ExtUtils/MM_NW5.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_EXTUTILS_MM_NW5';
  package ExtUtils::MM_NW5;
  
  =head1 NAME
  
  ExtUtils::MM_NW5 - methods to override UN*X behaviour in ExtUtils::MakeMaker
  
  =head1 SYNOPSIS
  
   use ExtUtils::MM_NW5; # Done internally by ExtUtils::MakeMaker if needed
  
  =head1 DESCRIPTION
  
  See ExtUtils::MM_Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  =over
  
  =cut
  
  use strict;
  use ExtUtils::MakeMaker::Config;
  use File::Basename;
  
  our $VERSION = '7.10';
  
  require ExtUtils::MM_Win32;
  our @ISA = qw(ExtUtils::MM_Win32);
  
  use ExtUtils::MakeMaker qw( &neatvalue );
  
  $ENV{EMXSHELL} = 'sh'; # to run `commands`
  
  my $BORLAND  = $Config{'cc'} =~ /^bcc/i;
  my $GCC      = $Config{'cc'} =~ /^gcc/i;
  
  
  =item os_flavor
  
  We're Netware in addition to being Windows.
  
  =cut
  
  sub os_flavor {
      my $self = shift;
      return ($self->SUPER::os_flavor, 'Netware');
  }
  
  =item init_platform
  
  Add Netware macros.
  
  LIBPTH, BASE_IMPORT, NLM_VERSION, MPKTOOL, TOOLPATH, BOOT_SYMBOL,
  NLM_SHORT_NAME, INCLUDE, PATH, MM_NW5_REVISION
  
  
  =item platform_constants
  
  Add Netware macros initialized above to the Makefile.
  
  =cut
  
  sub init_platform {
      my($self) = shift;
  
      # To get Win32's setup.
      $self->SUPER::init_platform;
  
      # incpath is copied to makefile var INCLUDE in constants sub, here just
      # make it empty
      my $libpth = $Config{'libpth'};
      $libpth =~ s( )(;);
      $self->{'LIBPTH'} = $libpth;
  
      $self->{'BASE_IMPORT'} = $Config{'base_import'};
  
      # Additional import file specified from Makefile.pl
      if($self->{'base_import'}) {
          $self->{'BASE_IMPORT'} .= ', ' . $self->{'base_import'};
      }
  
      $self->{'NLM_VERSION'} = $Config{'nlm_version'};
      $self->{'MPKTOOL'}	= $Config{'mpktool'};
      $self->{'TOOLPATH'}	= $Config{'toolpath'};
  
      (my $boot = $self->{'NAME'}) =~ s/:/_/g;
      $self->{'BOOT_SYMBOL'}=$boot;
  
      # If the final binary name is greater than 8 chars,
      # truncate it here.
      if(length($self->{'BASEEXT'}) > 8) {
          $self->{'NLM_SHORT_NAME'} = substr($self->{'BASEEXT'},0,8);
      }
  
      # Get the include path and replace the spaces with ;
      # Copy this to makefile as INCLUDE = d:\...;d:\;
      ($self->{INCLUDE} = $Config{'incpath'}) =~ s/([ ]*)-I/;/g;
  
      # Set the path to CodeWarrior binaries which might not have been set in
      # any other place
      $self->{PATH} = '$(PATH);$(TOOLPATH)';
  
      $self->{MM_NW5_VERSION} = $VERSION;
  }
  
  sub platform_constants {
      my($self) = shift;
      my $make_frag = '';
  
      # Setup Win32's constants.
      $make_frag .= $self->SUPER::platform_constants;
  
      foreach my $macro (qw(LIBPTH BASE_IMPORT NLM_VERSION MPKTOOL
                            TOOLPATH BOOT_SYMBOL NLM_SHORT_NAME INCLUDE PATH
                            MM_NW5_VERSION
                        ))
      {
          next unless defined $self->{$macro};
          $make_frag .= "$macro = $self->{$macro}\n";
      }
  
      return $make_frag;
  }
  
  
  =item const_cccmd
  
  =cut
  
  sub const_cccmd {
      my($self,$libperl)=@_;
      return $self->{CONST_CCCMD} if $self->{CONST_CCCMD};
      return '' unless $self->needs_linking();
      return $self->{CONST_CCCMD} = <<'MAKE_FRAG';
  CCCMD = $(CC) $(CCFLAGS) $(INC) $(OPTIMIZE) \
  	$(PERLTYPE) $(MPOLLUTE) -o $@ \
  	-DVERSION=\"$(VERSION)\" -DXS_VERSION=\"$(XS_VERSION)\"
  MAKE_FRAG
  
  }
  
  
  =item static_lib
  
  =cut
  
  sub static_lib {
      my($self) = @_;
  
      return '' unless $self->has_link_code;
  
      my $m = <<'END';
  $(INST_STATIC): $(OBJECT) $(MYEXTLIB) $(INST_ARCHAUTODIR)$(DFSEP).exists
  	$(RM_RF) $@
  END
  
      # If this extension has it's own library (eg SDBM_File)
      # then copy that to $(INST_STATIC) and add $(OBJECT) into it.
      $m .= <<'END'  if $self->{MYEXTLIB};
  	$self->{CP} $(MYEXTLIB) $@
  END
  
      my $ar_arg;
      if( $BORLAND ) {
          $ar_arg = '$@ $(OBJECT:^"+")';
      }
      elsif( $GCC ) {
          $ar_arg = '-ru $@ $(OBJECT)';
      }
      else {
          $ar_arg = '-type library -o $@ $(OBJECT)';
      }
  
      $m .= sprintf <<'END', $ar_arg;
  	$(AR) %s
  	$(NOECHO) $(ECHO) "$(EXTRALIBS)" > $(INST_ARCHAUTODIR)\extralibs.ld
  	$(CHMOD) 755 $@
  END
  
      $m .= <<'END' if $self->{PERL_SRC};
  	$(NOECHO) $(ECHO) "$(EXTRALIBS)" >> $(PERL_SRC)\ext.libs
  
  
  END
      return $m;
  }
  
  =item dynamic_lib
  
  Defines how to produce the *.so (or equivalent) files.
  
  =cut
  
  sub dynamic_lib {
      my($self, %attribs) = @_;
      return '' unless $self->needs_linking(); #might be because of a subdir
  
      return '' unless $self->has_link_code;
  
      my($otherldflags) = $attribs{OTHERLDFLAGS} || ($BORLAND ? 'c0d32.obj': '');
      my($inst_dynamic_dep) = $attribs{INST_DYNAMIC_DEP} || "";
      my($ldfrom) = '$(LDFROM)';
  
      (my $boot = $self->{NAME}) =~ s/:/_/g;
  
      my $m = <<'MAKE_FRAG';
  # This section creates the dynamically loadable $(INST_DYNAMIC)
  # from $(OBJECT) and possibly $(MYEXTLIB).
  OTHERLDFLAGS = '.$otherldflags.'
  INST_DYNAMIC_DEP = '.$inst_dynamic_dep.'
  
  # Create xdc data for an MT safe NLM in case of mpk build
  $(INST_DYNAMIC): $(OBJECT) $(MYEXTLIB) $(BOOTSTRAP) $(INST_ARCHAUTODIR)$(DFSEP).exists
  	$(NOECHO) $(ECHO) Export boot_$(BOOT_SYMBOL) > $(BASEEXT).def
  	$(NOECHO) $(ECHO) $(BASE_IMPORT) >> $(BASEEXT).def
  	$(NOECHO) $(ECHO) Import @$(PERL_INC)\perl.imp >> $(BASEEXT).def
  MAKE_FRAG
  
  
      if ( $self->{CCFLAGS} =~ m/ -DMPK_ON /) {
          $m .= <<'MAKE_FRAG';
  	$(MPKTOOL) $(XDCFLAGS) $(BASEEXT).xdc
  	$(NOECHO) $(ECHO) xdcdata $(BASEEXT).xdc >> $(BASEEXT).def
  MAKE_FRAG
      }
  
      # Reconstruct the X.Y.Z version.
      my $version = join '.', map { sprintf "%d", $_ }
                                $] =~ /(\d)\.(\d{3})(\d{2})/;
      $m .= sprintf '	$(LD) $(LDFLAGS) $(OBJECT:.obj=.obj) -desc "Perl %s Extension ($(BASEEXT))  XS_VERSION: $(XS_VERSION)" -nlmversion $(NLM_VERSION)', $version;
  
      # Taking care of long names like FileHandle, ByteLoader, SDBM_File etc
      if($self->{NLM_SHORT_NAME}) {
          # In case of nlms with names exceeding 8 chars, build nlm in the
          # current dir, rename and move to auto\lib.
          $m .= q{ -o $(NLM_SHORT_NAME).$(DLEXT)}
      } else {
          $m .= q{ -o $(INST_AUTODIR)\\$(BASEEXT).$(DLEXT)}
      }
  
      # Add additional lib files if any (SDBM_File)
      $m .= q{ $(MYEXTLIB) } if $self->{MYEXTLIB};
  
      $m .= q{ $(PERL_INC)\Main.lib -commandfile $(BASEEXT).def}."\n";
  
      if($self->{NLM_SHORT_NAME}) {
          $m .= <<'MAKE_FRAG';
  	if exist $(INST_AUTODIR)\$(NLM_SHORT_NAME).$(DLEXT) del $(INST_AUTODIR)\$(NLM_SHORT_NAME).$(DLEXT)
  	move $(NLM_SHORT_NAME).$(DLEXT) $(INST_AUTODIR)
  MAKE_FRAG
      }
  
      $m .= <<'MAKE_FRAG';
  
  	$(CHMOD) 755 $@
  MAKE_FRAG
  
      return $m;
  }
  
  
  1;
  __END__
  
  =back
  
  =cut
  
  
PERL5_EXTUTILS_MM_NW5

$fatpacked{"perl5/ExtUtils/MM_OS2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_EXTUTILS_MM_OS2';
  package ExtUtils::MM_OS2;
  
  use strict;
  
  use ExtUtils::MakeMaker qw(neatvalue);
  use File::Spec;
  
  our $VERSION = '7.10';
  
  require ExtUtils::MM_Any;
  require ExtUtils::MM_Unix;
  our @ISA = qw(ExtUtils::MM_Any ExtUtils::MM_Unix);
  
  =pod
  
  =head1 NAME
  
  ExtUtils::MM_OS2 - methods to override UN*X behaviour in ExtUtils::MakeMaker
  
  =head1 SYNOPSIS
  
   use ExtUtils::MM_OS2; # Done internally by ExtUtils::MakeMaker if needed
  
  =head1 DESCRIPTION
  
  See ExtUtils::MM_Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  =head1 METHODS
  
  =over 4
  
  =item init_dist
  
  Define TO_UNIX to convert OS2 linefeeds to Unix style.
  
  =cut
  
  sub init_dist {
      my($self) = @_;
  
      $self->{TO_UNIX} ||= <<'MAKE_TEXT';
  $(NOECHO) $(TEST_F) tmp.zip && $(RM_F) tmp.zip; $(ZIP) -ll -mr tmp.zip $(DISTVNAME) && unzip -o tmp.zip && $(RM_F) tmp.zip
  MAKE_TEXT
  
      $self->SUPER::init_dist;
  }
  
  sub dlsyms {
      my($self,%attribs) = @_;
  
      my($funcs) = $attribs{DL_FUNCS} || $self->{DL_FUNCS} || {};
      my($vars)  = $attribs{DL_VARS} || $self->{DL_VARS} || [];
      my($funclist) = $attribs{FUNCLIST} || $self->{FUNCLIST} || [];
      my($imports)  = $attribs{IMPORTS} || $self->{IMPORTS} || {};
      my(@m);
      (my $boot = $self->{NAME}) =~ s/:/_/g;
  
      if (not $self->{SKIPHASH}{'dynamic'}) {
  	push(@m,"
  $self->{BASEEXT}.def: Makefile.PL
  ",
       '	$(PERL) "-I$(PERL_ARCHLIB)" "-I$(PERL_LIB)" -e \'use ExtUtils::Mksymlists; \\
       Mksymlists("NAME" => "$(NAME)", "DLBASE" => "$(DLBASE)", ',
       '"VERSION" => "$(VERSION)", "DISTNAME" => "$(DISTNAME)", ',
       '"INSTALLDIRS" => "$(INSTALLDIRS)", ',
       '"DL_FUNCS" => ',neatvalue($funcs),
       ', "FUNCLIST" => ',neatvalue($funclist),
       ', "IMPORTS" => ',neatvalue($imports),
       ', "DL_VARS" => ', neatvalue($vars), ');\'
  ');
      }
      if ($self->{IMPORTS} && %{$self->{IMPORTS}}) {
  	# Make import files (needed for static build)
  	-d 'tmp_imp' or mkdir 'tmp_imp', 0777 or die "Can't mkdir tmp_imp";
  	open my $imp, '>', 'tmpimp.imp' or die "Can't open tmpimp.imp";
  	while (my($name, $exp) = each %{$self->{IMPORTS}}) {
  	    my ($lib, $id) = ($exp =~ /(.*)\.(.*)/) or die "Malformed IMPORT `$exp'";
  	    print $imp "$name $lib $id ?\n";
  	}
  	close $imp or die "Can't close tmpimp.imp";
  	# print "emximp -o tmpimp$Config::Config{lib_ext} tmpimp.imp\n";
  	system "emximp -o tmpimp$Config::Config{lib_ext} tmpimp.imp"
  	    and die "Cannot make import library: $!, \$?=$?";
  	# May be running under miniperl, so have no glob...
  	eval { unlink <tmp_imp/*>; 1 } or system "rm tmp_imp/*";
  	system "cd tmp_imp; $Config::Config{ar} x ../tmpimp$Config::Config{lib_ext}"
  	    and die "Cannot extract import objects: $!, \$?=$?";
      }
      join('',@m);
  }
  
  sub static_lib {
      my($self) = @_;
      my $old = $self->ExtUtils::MM_Unix::static_lib();
      return $old unless $self->{IMPORTS} && %{$self->{IMPORTS}};
  
      my @chunks = split /\n{2,}/, $old;
      shift @chunks unless length $chunks[0]; # Empty lines at the start
      $chunks[0] .= <<'EOC';
  
  	$(AR) $(AR_STATIC_ARGS) $@ tmp_imp/* && $(RANLIB) $@
  EOC
      return join "\n\n". '', @chunks;
  }
  
  sub replace_manpage_separator {
      my($self,$man) = @_;
      $man =~ s,/+,.,g;
      $man;
  }
  
  sub maybe_command {
      my($self,$file) = @_;
      $file =~ s,[/\\]+,/,g;
      return $file if -x $file && ! -d _;
      return "$file.exe" if -x "$file.exe" && ! -d _;
      return "$file.cmd" if -x "$file.cmd" && ! -d _;
      return;
  }
  
  =item init_linker
  
  =cut
  
  sub init_linker {
      my $self = shift;
  
      $self->{PERL_ARCHIVE} = "\$(PERL_INC)/libperl\$(LIB_EXT)";
  
      $self->{PERL_ARCHIVEDEP} ||= '';
      $self->{PERL_ARCHIVE_AFTER} = $OS2::is_aout
        ? ''
        : '$(PERL_INC)/libperl_override$(LIB_EXT)';
      $self->{EXPORT_LIST} = '$(BASEEXT).def';
  }
  
  =item os_flavor
  
  OS/2 is OS/2
  
  =cut
  
  sub os_flavor {
      return('OS/2');
  }
  
  =back
  
  =cut
  
  1;
PERL5_EXTUTILS_MM_OS2

$fatpacked{"perl5/ExtUtils/MM_QNX.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_EXTUTILS_MM_QNX';
  package ExtUtils::MM_QNX;
  
  use strict;
  our $VERSION = '7.10';
  
  require ExtUtils::MM_Unix;
  our @ISA = qw(ExtUtils::MM_Unix);
  
  
  =head1 NAME
  
  ExtUtils::MM_QNX - QNX specific subclass of ExtUtils::MM_Unix
  
  =head1 SYNOPSIS
  
    Don't use this module directly.
    Use ExtUtils::MM and let it choose.
  
  =head1 DESCRIPTION
  
  This is a subclass of ExtUtils::MM_Unix which contains functionality for
  QNX.
  
  Unless otherwise stated it works just like ExtUtils::MM_Unix
  
  =head2 Overridden methods
  
  =head3 extra_clean_files
  
  Add .err files corresponding to each .c file.
  
  =cut
  
  sub extra_clean_files {
      my $self = shift;
  
      my @errfiles = @{$self->{C}};
      for ( @errfiles ) {
  	s/.c$/.err/;
      }
  
      return( @errfiles, 'perlmain.err' );
  }
  
  
  =head1 AUTHOR
  
  Michael G Schwern <schwern@pobox.com> with code from ExtUtils::MM_Unix
  
  =head1 SEE ALSO
  
  L<ExtUtils::MakeMaker>
  
  =cut
  
  
  1;
PERL5_EXTUTILS_MM_QNX

$fatpacked{"perl5/ExtUtils/MM_UWIN.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_EXTUTILS_MM_UWIN';
  package ExtUtils::MM_UWIN;
  
  use strict;
  our $VERSION = '7.10';
  
  require ExtUtils::MM_Unix;
  our @ISA = qw(ExtUtils::MM_Unix);
  
  
  =head1 NAME
  
  ExtUtils::MM_UWIN - U/WIN specific subclass of ExtUtils::MM_Unix
  
  =head1 SYNOPSIS
  
    Don't use this module directly.
    Use ExtUtils::MM and let it choose.
  
  =head1 DESCRIPTION
  
  This is a subclass of ExtUtils::MM_Unix which contains functionality for
  the AT&T U/WIN UNIX on Windows environment.
  
  Unless otherwise stated it works just like ExtUtils::MM_Unix
  
  =head2 Overridden methods
  
  =over 4
  
  =item os_flavor
  
  In addition to being Unix, we're U/WIN.
  
  =cut
  
  sub os_flavor {
      return('Unix', 'U/WIN');
  }
  
  
  =item B<replace_manpage_separator>
  
  =cut
  
  sub replace_manpage_separator {
      my($self, $man) = @_;
  
      $man =~ s,/+,.,g;
      return $man;
  }
  
  =back
  
  =head1 AUTHOR
  
  Michael G Schwern <schwern@pobox.com> with code from ExtUtils::MM_Unix
  
  =head1 SEE ALSO
  
  L<ExtUtils::MM_Win32>, L<ExtUtils::MakeMaker>
  
  =cut
  
  1;
PERL5_EXTUTILS_MM_UWIN

$fatpacked{"perl5/ExtUtils/MM_Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_EXTUTILS_MM_UNIX';
  package ExtUtils::MM_Unix;
  
  require 5.006;
  
  use strict;
  
  use Carp;
  use ExtUtils::MakeMaker::Config;
  use File::Basename qw(basename dirname);
  use DirHandle;
  
  our %Config_Override;
  
  use ExtUtils::MakeMaker qw($Verbose neatvalue);
  
  # If we make $VERSION an our variable parse_version() breaks
  use vars qw($VERSION);
  $VERSION = '7.10';
  $VERSION = eval $VERSION;  ## no critic [BuiltinFunctions::ProhibitStringyEval]
  
  require ExtUtils::MM_Any;
  our @ISA = qw(ExtUtils::MM_Any);
  
  my %Is;
  BEGIN {
      $Is{OS2}     = $^O eq 'os2';
      $Is{Win32}   = $^O eq 'MSWin32' || $Config{osname} eq 'NetWare';
      $Is{Dos}     = $^O eq 'dos';
      $Is{VMS}     = $^O eq 'VMS';
      $Is{OSF}     = $^O eq 'dec_osf';
      $Is{IRIX}    = $^O eq 'irix';
      $Is{NetBSD}  = $^O eq 'netbsd';
      $Is{Interix} = $^O eq 'interix';
      $Is{SunOS4}  = $^O eq 'sunos';
      $Is{Solaris} = $^O eq 'solaris';
      $Is{SunOS}   = $Is{SunOS4} || $Is{Solaris};
      $Is{BSD}     = ($^O =~ /^(?:free|net|open)bsd$/ or
                     grep( $^O eq $_, qw(bsdos interix dragonfly) )
                    );
      $Is{Android} = $^O =~ /android/;
  }
  
  BEGIN {
      if( $Is{VMS} ) {
          # For things like vmsify()
          require VMS::Filespec;
          VMS::Filespec->import;
      }
  }
  
  
  =head1 NAME
  
  ExtUtils::MM_Unix - methods used by ExtUtils::MakeMaker
  
  =head1 SYNOPSIS
  
  C<require ExtUtils::MM_Unix;>
  
  =head1 DESCRIPTION
  
  The methods provided by this package are designed to be used in
  conjunction with ExtUtils::MakeMaker. When MakeMaker writes a
  Makefile, it creates one or more objects that inherit their methods
  from a package C<MM>. MM itself doesn't provide any methods, but it
  ISA ExtUtils::MM_Unix class. The inheritance tree of MM lets operating
  specific packages take the responsibility for all the methods provided
  by MM_Unix. We are trying to reduce the number of the necessary
  overrides by defining rather primitive operations within
  ExtUtils::MM_Unix.
  
  If you are going to write a platform specific MM package, please try
  to limit the necessary overrides to primitive methods, and if it is not
  possible to do so, let's work out how to achieve that gain.
  
  If you are overriding any of these methods in your Makefile.PL (in the
  MY class), please report that to the makemaker mailing list. We are
  trying to minimize the necessary method overrides and switch to data
  driven Makefile.PLs wherever possible. In the long run less methods
  will be overridable via the MY class.
  
  =head1 METHODS
  
  The following description of methods is still under
  development. Please refer to the code for not suitably documented
  sections and complain loudly to the makemaker@perl.org mailing list.
  Better yet, provide a patch.
  
  Not all of the methods below are overridable in a
  Makefile.PL. Overridable methods are marked as (o). All methods are
  overridable by a platform specific MM_*.pm file.
  
  Cross-platform methods are being moved into MM_Any.  If you can't find
  something that used to be in here, look in MM_Any.
  
  =cut
  
  # So we don't have to keep calling the methods over and over again,
  # we have these globals to cache the values.  Faster and shrtr.
  my $Curdir  = __PACKAGE__->curdir;
  my $Rootdir = __PACKAGE__->rootdir;
  my $Updir   = __PACKAGE__->updir;
  
  
  =head2 Methods
  
  =over 4
  
  =item os_flavor
  
  Simply says that we're Unix.
  
  =cut
  
  sub os_flavor {
      return('Unix');
  }
  
  
  =item c_o (o)
  
  Defines the suffix rules to compile different flavors of C files to
  object files.
  
  =cut
  
  sub c_o {
  # --- Translation Sections ---
  
      my($self) = shift;
      return '' unless $self->needs_linking();
      my(@m);
  
      my $command = '$(CCCMD)';
      my $flags   = '$(CCCDLFLAGS) "-I$(PERL_INC)" $(PASTHRU_DEFINE) $(DEFINE)';
  
      if (my $cpp = $Config{cpprun}) {
          my $cpp_cmd = $self->const_cccmd;
          $cpp_cmd =~ s/^CCCMD\s*=\s*\$\(CC\)/$cpp/;
          push @m, qq{
  .c.i:
  	$cpp_cmd $flags \$*.c > \$*.i
  };
      }
  
      push @m, qq{
  .c.s:
  	$command -S $flags \$*.c
  
  .c\$(OBJ_EXT):
  	$command $flags \$*.c
  
  .cpp\$(OBJ_EXT):
  	$command $flags \$*.cpp
  
  .cxx\$(OBJ_EXT):
  	$command $flags \$*.cxx
  
  .cc\$(OBJ_EXT):
  	$command $flags \$*.cc
  };
  
      push @m, qq{
  .C\$(OBJ_EXT):
  	$command $flags \$*.C
  } if !$Is{OS2} and !$Is{Win32} and !$Is{Dos}; #Case-specific
  
      return join "", @m;
  }
  
  =item cflags (o)
  
  Does very much the same as the cflags script in the perl
  distribution. It doesn't return the whole compiler command line, but
  initializes all of its parts. The const_cccmd method then actually
  returns the definition of the CCCMD macro which uses these parts.
  
  =cut
  
  #'
  
  sub cflags {
      my($self,$libperl)=@_;
      return $self->{CFLAGS} if $self->{CFLAGS};
      return '' unless $self->needs_linking();
  
      my($prog, $uc, $perltype, %cflags);
      $libperl ||= $self->{LIBPERL_A} || "libperl$self->{LIB_EXT}" ;
      $libperl =~ s/\.\$\(A\)$/$self->{LIB_EXT}/;
  
      @cflags{qw(cc ccflags optimize shellflags)}
  	= @Config{qw(cc ccflags optimize shellflags)};
  
      # Perl 5.21.4 adds the (gcc) warning (-Wall ...) and std (-std=c89)
      # flags to the %Config, and the modules in the core should be built
      # with the warning flags, but NOT the -std=c89 flags (the latter
      # would break using any system header files that are strict C99).
      my @ccextraflags = qw(ccwarnflags);
      if ($ENV{PERL_CORE}) {
        for my $x (@ccextraflags) {
          if (exists $Config{$x}) {
            $cflags{$x} = $Config{$x};
          }
        }
      }
  
      my($optdebug) = "";
  
      $cflags{shellflags} ||= '';
  
      my(%map) =  (
  		D =>   '-DDEBUGGING',
  		E =>   '-DEMBED',
  		DE =>  '-DDEBUGGING -DEMBED',
  		M =>   '-DEMBED -DMULTIPLICITY',
  		DM =>  '-DDEBUGGING -DEMBED -DMULTIPLICITY',
  		);
  
      if ($libperl =~ /libperl(\w*)\Q$self->{LIB_EXT}/){
  	$uc = uc($1);
      } else {
  	$uc = ""; # avoid warning
      }
      $perltype = $map{$uc} ? $map{$uc} : "";
  
      if ($uc =~ /^D/) {
  	$optdebug = "-g";
      }
  
  
      my($name);
      ( $name = $self->{NAME} . "_cflags" ) =~ s/:/_/g ;
      if ($prog = $Config{$name}) {
  	# Expand hints for this extension via the shell
  	print "Processing $name hint:\n" if $Verbose;
  	my(@o)=`cc=\"$cflags{cc}\"
  	  ccflags=\"$cflags{ccflags}\"
  	  optimize=\"$cflags{optimize}\"
  	  perltype=\"$cflags{perltype}\"
  	  optdebug=\"$cflags{optdebug}\"
  	  eval '$prog'
  	  echo cc=\$cc
  	  echo ccflags=\$ccflags
  	  echo optimize=\$optimize
  	  echo perltype=\$perltype
  	  echo optdebug=\$optdebug
  	  `;
  	foreach my $line (@o){
  	    chomp $line;
  	    if ($line =~ /(.*?)=\s*(.*)\s*$/){
  		$cflags{$1} = $2;
  		print "	$1 = $2\n" if $Verbose;
  	    } else {
  		print "Unrecognised result from hint: '$line'\n";
  	    }
  	}
      }
  
      if ($optdebug) {
  	$cflags{optimize} = $optdebug;
      }
  
      for (qw(ccflags optimize perltype)) {
          $cflags{$_} ||= '';
  	$cflags{$_} =~ s/^\s+//;
  	$cflags{$_} =~ s/\s+/ /g;
  	$cflags{$_} =~ s/\s+$//;
  	$self->{uc $_} ||= $cflags{$_};
      }
  
      if ($self->{POLLUTE}) {
  	$self->{CCFLAGS} .= ' -DPERL_POLLUTE ';
      }
  
      for my $x (@ccextraflags) {
        next unless exists $cflags{$x};
        $self->{CCFLAGS} .= $cflags{$x} =~ m!^\s! ? $cflags{$x} : ' ' . $cflags{$x};
      }
  
      my $pollute = '';
      if ($Config{usemymalloc} and not $Config{bincompat5005}
  	and not $Config{ccflags} =~ /-DPERL_POLLUTE_MALLOC\b/
  	and $self->{PERL_MALLOC_OK}) {
  	$pollute = '$(PERL_MALLOC_DEF)';
      }
  
      $self->{CCFLAGS}  = quote_paren($self->{CCFLAGS});
      $self->{OPTIMIZE} = quote_paren($self->{OPTIMIZE});
  
      return $self->{CFLAGS} = qq{
  CCFLAGS = $self->{CCFLAGS}
  OPTIMIZE = $self->{OPTIMIZE}
  PERLTYPE = $self->{PERLTYPE}
  MPOLLUTE = $pollute
  };
  
  }
  
  
  =item const_cccmd (o)
  
  Returns the full compiler call for C programs and stores the
  definition in CONST_CCCMD.
  
  =cut
  
  sub const_cccmd {
      my($self,$libperl)=@_;
      return $self->{CONST_CCCMD} if $self->{CONST_CCCMD};
      return '' unless $self->needs_linking();
      return $self->{CONST_CCCMD} =
  	q{CCCMD = $(CC) -c $(PASTHRU_INC) $(INC) \\
  	$(CCFLAGS) $(OPTIMIZE) \\
  	$(PERLTYPE) $(MPOLLUTE) $(DEFINE_VERSION) \\
  	$(XS_DEFINE_VERSION)};
  }
  
  =item const_config (o)
  
  Defines a couple of constants in the Makefile that are imported from
  %Config.
  
  =cut
  
  sub const_config {
  # --- Constants Sections ---
  
      my($self) = shift;
      my @m = <<"END";
  
  # These definitions are from config.sh (via $INC{'Config.pm'}).
  # They may have been overridden via Makefile.PL or on the command line.
  END
  
      my(%once_only);
      foreach my $key (@{$self->{CONFIG}}){
          # SITE*EXP macros are defined in &constants; avoid duplicates here
          next if $once_only{$key};
          $self->{uc $key} = quote_paren($self->{uc $key});
          push @m, uc($key) , ' = ' , $self->{uc $key}, "\n";
          $once_only{$key} = 1;
      }
      join('', @m);
  }
  
  =item const_loadlibs (o)
  
  Defines EXTRALIBS, LDLOADLIBS, BSLOADLIBS, LD_RUN_PATH. See
  L<ExtUtils::Liblist> for details.
  
  =cut
  
  sub const_loadlibs {
      my($self) = shift;
      return "" unless $self->needs_linking;
      my @m;
      push @m, qq{
  # $self->{NAME} might depend on some other libraries:
  # See ExtUtils::Liblist for details
  #
  };
      for my $tmp (qw/
           EXTRALIBS LDLOADLIBS BSLOADLIBS
           /) {
          next unless defined $self->{$tmp};
          push @m, "$tmp = $self->{$tmp}\n";
      }
      # don't set LD_RUN_PATH if empty
      for my $tmp (qw/
           LD_RUN_PATH
           /) {
          next unless $self->{$tmp};
          push @m, "$tmp = $self->{$tmp}\n";
      }
      return join "", @m;
  }
  
  =item constants (o)
  
    my $make_frag = $mm->constants;
  
  Prints out macros for lots of constants.
  
  =cut
  
  sub constants {
      my($self) = @_;
      my @m = ();
  
      $self->{DFSEP} = '$(DIRFILESEP)';  # alias for internal use
  
      for my $macro (qw(
  
                AR_STATIC_ARGS DIRFILESEP DFSEP
                NAME NAME_SYM
                VERSION    VERSION_MACRO    VERSION_SYM DEFINE_VERSION
                XS_VERSION XS_VERSION_MACRO             XS_DEFINE_VERSION
                INST_ARCHLIB INST_SCRIPT INST_BIN INST_LIB
                INST_MAN1DIR INST_MAN3DIR
                MAN1EXT      MAN3EXT
                INSTALLDIRS INSTALL_BASE DESTDIR PREFIX
                PERLPREFIX      SITEPREFIX      VENDORPREFIX
                     ),
                     (map { ("INSTALL".$_,
                            "DESTINSTALL".$_)
                          } $self->installvars),
                     qw(
                PERL_LIB
                PERL_ARCHLIB PERL_ARCHLIBDEP
                LIBPERL_A MYEXTLIB
                FIRST_MAKEFILE MAKEFILE_OLD MAKE_APERL_FILE
                PERLMAINCC PERL_SRC PERL_INC PERL_INCDEP
                PERL            FULLPERL          ABSPERL
                PERLRUN         FULLPERLRUN       ABSPERLRUN
                PERLRUNINST     FULLPERLRUNINST   ABSPERLRUNINST
                PERL_CORE
                PERM_DIR PERM_RW PERM_RWX
  
  	      ) )
      {
  	next unless defined $self->{$macro};
  
          # pathnames can have sharp signs in them; escape them so
          # make doesn't think it is a comment-start character.
          $self->{$macro} =~ s/#/\\#/g;
  	$self->{$macro} = $self->quote_dep($self->{$macro})
  	  if $ExtUtils::MakeMaker::macro_dep{$macro};
  	push @m, "$macro = $self->{$macro}\n";
      }
  
      push @m, qq{
  MAKEMAKER   = $self->{MAKEMAKER}
  MM_VERSION  = $self->{MM_VERSION}
  MM_REVISION = $self->{MM_REVISION}
  };
  
      push @m, q{
  # FULLEXT = Pathname for extension directory (eg Foo/Bar/Oracle).
  # BASEEXT = Basename part of FULLEXT. May be just equal FULLEXT. (eg Oracle)
  # PARENT_NAME = NAME without BASEEXT and no trailing :: (eg Foo::Bar)
  # DLBASE  = Basename part of dynamic library. May be just equal BASEEXT.
  };
  
      for my $macro (qw/
                MAKE
  	      FULLEXT BASEEXT PARENT_NAME DLBASE VERSION_FROM INC DEFINE OBJECT
  	      LDFROM LINKTYPE BOOTDEP
  	      /	)
      {
  	next unless defined $self->{$macro};
  	push @m, "$macro = $self->{$macro}\n";
      }
  
      push @m, "
  # Handy lists of source code files:
  XS_FILES = ".$self->wraplist(sort keys %{$self->{XS}})."
  C_FILES  = ".$self->wraplist(@{$self->{C}})."
  O_FILES  = ".$self->wraplist(@{$self->{O_FILES}})."
  H_FILES  = ".$self->wraplist(@{$self->{H}})."
  MAN1PODS = ".$self->wraplist(sort keys %{$self->{MAN1PODS}})."
  MAN3PODS = ".$self->wraplist(sort keys %{$self->{MAN3PODS}})."
  ";
  
  
      push @m, q{
  # Where is the Config information that we are using/depend on
  CONFIGDEP = $(PERL_ARCHLIBDEP)$(DFSEP)Config.pm $(PERL_INCDEP)$(DFSEP)config.h
  } if -e File::Spec->catfile( $self->{PERL_INC}, 'config.h' );
  
  
      push @m, qq{
  # Where to build things
  INST_LIBDIR      = $self->{INST_LIBDIR}
  INST_ARCHLIBDIR  = $self->{INST_ARCHLIBDIR}
  
  INST_AUTODIR     = $self->{INST_AUTODIR}
  INST_ARCHAUTODIR = $self->{INST_ARCHAUTODIR}
  
  INST_STATIC      = $self->{INST_STATIC}
  INST_DYNAMIC     = $self->{INST_DYNAMIC}
  INST_BOOT        = $self->{INST_BOOT}
  };
  
      push @m, qq{
  # Extra linker info
  EXPORT_LIST        = $self->{EXPORT_LIST}
  PERL_ARCHIVE       = $self->{PERL_ARCHIVE}
  PERL_ARCHIVEDEP    = $self->{PERL_ARCHIVEDEP}
  PERL_ARCHIVE_AFTER = $self->{PERL_ARCHIVE_AFTER}
  };
  
      push @m, "
  
  TO_INST_PM = ".$self->wraplist(sort keys %{$self->{PM}})."
  
  PM_TO_BLIB = ".$self->wraplist(map { ($_ => $self->{PM}->{$_}) } sort keys %{$self->{PM}})."
  ";
  
      join('',@m);
  }
  
  
  =item depend (o)
  
  Same as macro for the depend attribute.
  
  =cut
  
  sub depend {
      my($self,%attribs) = @_;
      my(@m,$key,$val);
      while (($key,$val) = each %attribs){
  	last unless defined $key;
  	push @m, "$key : $val\n";
      }
      join "", @m;
  }
  
  
  =item init_DEST
  
    $mm->init_DEST
  
  Defines the DESTDIR and DEST* variables paralleling the INSTALL*.
  
  =cut
  
  sub init_DEST {
      my $self = shift;
  
      # Initialize DESTDIR
      $self->{DESTDIR} ||= '';
  
      # Make DEST variables.
      foreach my $var ($self->installvars) {
          my $destvar = 'DESTINSTALL'.$var;
          $self->{$destvar} ||= '$(DESTDIR)$(INSTALL'.$var.')';
      }
  }
  
  
  =item init_dist
  
    $mm->init_dist;
  
  Defines a lot of macros for distribution support.
  
    macro         description                     default
  
    TAR           tar command to use              tar
    TARFLAGS      flags to pass to TAR            cvf
  
    ZIP           zip command to use              zip
    ZIPFLAGS      flags to pass to ZIP            -r
  
    COMPRESS      compression command to          gzip --best
                  use for tarfiles
    SUFFIX        suffix to put on                .gz
                  compressed files
  
    SHAR          shar command to use             shar
  
    PREOP         extra commands to run before
                  making the archive
    POSTOP        extra commands to run after
                  making the archive
  
    TO_UNIX       a command to convert linefeeds
                  to Unix style in your archive
  
    CI            command to checkin your         ci -u
                  sources to version control
    RCS_LABEL     command to label your sources   rcs -Nv$(VERSION_SYM): -q
                  just after CI is run
  
    DIST_CP       $how argument to manicopy()     best
                  when the distdir is created
  
    DIST_DEFAULT  default target to use to        tardist
                  create a distribution
  
    DISTVNAME     name of the resulting archive   $(DISTNAME)-$(VERSION)
                  (minus suffixes)
  
  =cut
  
  sub init_dist {
      my $self = shift;
  
      $self->{TAR}      ||= 'tar';
      $self->{TARFLAGS} ||= 'cvf';
      $self->{ZIP}      ||= 'zip';
      $self->{ZIPFLAGS} ||= '-r';
      $self->{COMPRESS} ||= 'gzip --best';
      $self->{SUFFIX}   ||= '.gz';
      $self->{SHAR}     ||= 'shar';
      $self->{PREOP}    ||= '$(NOECHO) $(NOOP)'; # eg update MANIFEST
      $self->{POSTOP}   ||= '$(NOECHO) $(NOOP)'; # eg remove the distdir
      $self->{TO_UNIX}  ||= '$(NOECHO) $(NOOP)';
  
      $self->{CI}       ||= 'ci -u';
      $self->{RCS_LABEL}||= 'rcs -Nv$(VERSION_SYM): -q';
      $self->{DIST_CP}  ||= 'best';
      $self->{DIST_DEFAULT} ||= 'tardist';
  
      ($self->{DISTNAME} = $self->{NAME}) =~ s{::}{-}g unless $self->{DISTNAME};
      $self->{DISTVNAME} ||= $self->{DISTNAME}.'-'.$self->{VERSION};
  }
  
  =item dist (o)
  
    my $dist_macros = $mm->dist(%overrides);
  
  Generates a make fragment defining all the macros initialized in
  init_dist.
  
  %overrides can be used to override any of the above.
  
  =cut
  
  sub dist {
      my($self, %attribs) = @_;
  
      my $make = '';
      if ( $attribs{SUFFIX} && $attribs{SUFFIX} !~ m!^\.! ) {
        $attribs{SUFFIX} = '.' . $attribs{SUFFIX};
      }
      foreach my $key (qw(
              TAR TARFLAGS ZIP ZIPFLAGS COMPRESS SUFFIX SHAR
              PREOP POSTOP TO_UNIX
              CI RCS_LABEL DIST_CP DIST_DEFAULT
              DISTNAME DISTVNAME
             ))
      {
          my $value = $attribs{$key} || $self->{$key};
          $make .= "$key = $value\n";
      }
  
      return $make;
  }
  
  =item dist_basics (o)
  
  Defines the targets distclean, distcheck, skipcheck, manifest, veryclean.
  
  =cut
  
  sub dist_basics {
      my($self) = shift;
  
      return <<'MAKE_FRAG';
  distclean :: realclean distcheck
  	$(NOECHO) $(NOOP)
  
  distcheck :
  	$(PERLRUN) "-MExtUtils::Manifest=fullcheck" -e fullcheck
  
  skipcheck :
  	$(PERLRUN) "-MExtUtils::Manifest=skipcheck" -e skipcheck
  
  manifest :
  	$(PERLRUN) "-MExtUtils::Manifest=mkmanifest" -e mkmanifest
  
  veryclean : realclean
  	$(RM_F) *~ */*~ *.orig */*.orig *.bak */*.bak *.old */*.old
  
  MAKE_FRAG
  
  }
  
  =item dist_ci (o)
  
  Defines a check in target for RCS.
  
  =cut
  
  sub dist_ci {
      my($self) = shift;
      return sprintf "ci :\n\t%s\n", $self->oneliner(<<'EOF', [qw(-MExtUtils::Manifest=maniread)]);
  @all = sort keys %{ maniread() };
  print(qq{Executing $(CI) @all\n});
  system(qq{$(CI) @all}) == 0 or die $!;
  print(qq{Executing $(RCS_LABEL) ...\n});
  system(qq{$(RCS_LABEL) @all}) == 0 or die $!;
  EOF
  }
  
  =item dist_core (o)
  
    my $dist_make_fragment = $MM->dist_core;
  
  Puts the targets necessary for 'make dist' together into one make
  fragment.
  
  =cut
  
  sub dist_core {
      my($self) = shift;
  
      my $make_frag = '';
      foreach my $target (qw(dist tardist uutardist tarfile zipdist zipfile
                             shdist))
      {
          my $method = $target.'_target';
          $make_frag .= "\n";
          $make_frag .= $self->$method();
      }
  
      return $make_frag;
  }
  
  
  =item B<dist_target>
  
    my $make_frag = $MM->dist_target;
  
  Returns the 'dist' target to make an archive for distribution.  This
  target simply checks to make sure the Makefile is up-to-date and
  depends on $(DIST_DEFAULT).
  
  =cut
  
  sub dist_target {
      my($self) = shift;
  
      my $date_check = $self->oneliner(<<'CODE', ['-l']);
  print 'Warning: Makefile possibly out of date with $(VERSION_FROM)'
      if -e '$(VERSION_FROM)' and -M '$(VERSION_FROM)' < -M '$(FIRST_MAKEFILE)';
  CODE
  
      return sprintf <<'MAKE_FRAG', $date_check;
  dist : $(DIST_DEFAULT) $(FIRST_MAKEFILE)
  	$(NOECHO) %s
  MAKE_FRAG
  }
  
  =item B<tardist_target>
  
    my $make_frag = $MM->tardist_target;
  
  Returns the 'tardist' target which is simply so 'make tardist' works.
  The real work is done by the dynamically named tardistfile_target()
  method, tardist should have that as a dependency.
  
  =cut
  
  sub tardist_target {
      my($self) = shift;
  
      return <<'MAKE_FRAG';
  tardist : $(DISTVNAME).tar$(SUFFIX)
  	$(NOECHO) $(NOOP)
  MAKE_FRAG
  }
  
  =item B<zipdist_target>
  
    my $make_frag = $MM->zipdist_target;
  
  Returns the 'zipdist' target which is simply so 'make zipdist' works.
  The real work is done by the dynamically named zipdistfile_target()
  method, zipdist should have that as a dependency.
  
  =cut
  
  sub zipdist_target {
      my($self) = shift;
  
      return <<'MAKE_FRAG';
  zipdist : $(DISTVNAME).zip
  	$(NOECHO) $(NOOP)
  MAKE_FRAG
  }
  
  =item B<tarfile_target>
  
    my $make_frag = $MM->tarfile_target;
  
  The name of this target is the name of the tarball generated by
  tardist.  This target does the actual work of turning the distdir into
  a tarball.
  
  =cut
  
  sub tarfile_target {
      my($self) = shift;
  
      return <<'MAKE_FRAG';
  $(DISTVNAME).tar$(SUFFIX) : distdir
  	$(PREOP)
  	$(TO_UNIX)
  	$(TAR) $(TARFLAGS) $(DISTVNAME).tar $(DISTVNAME)
  	$(RM_RF) $(DISTVNAME)
  	$(COMPRESS) $(DISTVNAME).tar
  	$(NOECHO) $(ECHO) 'Created $(DISTVNAME).tar$(SUFFIX)'
  	$(POSTOP)
  MAKE_FRAG
  }
  
  =item zipfile_target
  
    my $make_frag = $MM->zipfile_target;
  
  The name of this target is the name of the zip file generated by
  zipdist.  This target does the actual work of turning the distdir into
  a zip file.
  
  =cut
  
  sub zipfile_target {
      my($self) = shift;
  
      return <<'MAKE_FRAG';
  $(DISTVNAME).zip : distdir
  	$(PREOP)
  	$(ZIP) $(ZIPFLAGS) $(DISTVNAME).zip $(DISTVNAME)
  	$(RM_RF) $(DISTVNAME)
  	$(NOECHO) $(ECHO) 'Created $(DISTVNAME).zip'
  	$(POSTOP)
  MAKE_FRAG
  }
  
  =item uutardist_target
  
    my $make_frag = $MM->uutardist_target;
  
  Converts the tarfile into a uuencoded file
  
  =cut
  
  sub uutardist_target {
      my($self) = shift;
  
      return <<'MAKE_FRAG';
  uutardist : $(DISTVNAME).tar$(SUFFIX)
  	uuencode $(DISTVNAME).tar$(SUFFIX) $(DISTVNAME).tar$(SUFFIX) > $(DISTVNAME).tar$(SUFFIX)_uu
  	$(NOECHO) $(ECHO) 'Created $(DISTVNAME).tar$(SUFFIX)_uu'
  MAKE_FRAG
  }
  
  
  =item shdist_target
  
    my $make_frag = $MM->shdist_target;
  
  Converts the distdir into a shell archive.
  
  =cut
  
  sub shdist_target {
      my($self) = shift;
  
      return <<'MAKE_FRAG';
  shdist : distdir
  	$(PREOP)
  	$(SHAR) $(DISTVNAME) > $(DISTVNAME).shar
  	$(RM_RF) $(DISTVNAME)
  	$(NOECHO) $(ECHO) 'Created $(DISTVNAME).shar'
  	$(POSTOP)
  MAKE_FRAG
  }
  
  
  =item dlsyms (o)
  
  Used by some OS' to define DL_FUNCS and DL_VARS and write the *.exp files.
  
  Normally just returns an empty string.
  
  =cut
  
  sub dlsyms {
      return '';
  }
  
  
  =item dynamic_bs (o)
  
  Defines targets for bootstrap files.
  
  =cut
  
  sub dynamic_bs {
      my($self, %attribs) = @_;
      return '
  BOOTSTRAP =
  ' unless $self->has_link_code();
  
      my $target = $Is{VMS} ? '$(MMS$TARGET)' : '$@';
  
      return sprintf <<'MAKE_FRAG', ($target) x 2;
  BOOTSTRAP = $(BASEEXT).bs
  
  # As Mkbootstrap might not write a file (if none is required)
  # we use touch to prevent make continually trying to remake it.
  # The DynaLoader only reads a non-empty file.
  $(BOOTSTRAP) : $(FIRST_MAKEFILE) $(BOOTDEP) $(INST_ARCHAUTODIR)$(DFSEP).exists
  	$(NOECHO) $(ECHO) "Running Mkbootstrap for $(NAME) ($(BSLOADLIBS))"
  	$(NOECHO) $(PERLRUN) \
  		"-MExtUtils::Mkbootstrap" \
  		-e "Mkbootstrap('$(BASEEXT)','$(BSLOADLIBS)');"
  	$(NOECHO) $(TOUCH) "%s"
  	$(CHMOD) $(PERM_RW) "%s"
  MAKE_FRAG
  }
  
  =item dynamic_lib (o)
  
  Defines how to produce the *.so (or equivalent) files.
  
  =cut
  
  sub dynamic_lib {
      my($self, %attribs) = @_;
      return '' unless $self->needs_linking(); #might be because of a subdir
  
      return '' unless $self->has_link_code;
  
      my($otherldflags) = $attribs{OTHERLDFLAGS} || "";
      my($inst_dynamic_dep) = $attribs{INST_DYNAMIC_DEP} || "";
      my($armaybe) = $attribs{ARMAYBE} || $self->{ARMAYBE} || ":";
      my($ldfrom) = '$(LDFROM)';
      $armaybe = 'ar' if ($Is{OSF} and $armaybe eq ':');
      my(@m);
      my $ld_opt = $Is{OS2} ? '$(OPTIMIZE) ' : '';	# Useful on other systems too?
      my $ld_fix = $Is{OS2} ? '|| ( $(RM_F) $@ && sh -c false )' : '';
      push(@m,'
  # This section creates the dynamically loadable $(INST_DYNAMIC)
  # from $(OBJECT) and possibly $(MYEXTLIB).
  ARMAYBE = '.$armaybe.'
  OTHERLDFLAGS = '.$ld_opt.$otherldflags.'
  INST_DYNAMIC_DEP = '.$inst_dynamic_dep.'
  INST_DYNAMIC_FIX = '.$ld_fix.'
  
  $(INST_DYNAMIC): $(OBJECT) $(MYEXTLIB) $(INST_ARCHAUTODIR)$(DFSEP).exists $(EXPORT_LIST) $(PERL_ARCHIVEDEP) $(PERL_ARCHIVE_AFTER) $(INST_DYNAMIC_DEP)
  ');
      if ($armaybe ne ':'){
  	$ldfrom = 'tmp$(LIB_EXT)';
  	push(@m,'	$(ARMAYBE) cr '.$ldfrom.' $(OBJECT)'."\n");
  	push(@m,'	$(RANLIB) '."$ldfrom\n");
      }
      $ldfrom = "-all $ldfrom -none" if $Is{OSF};
  
      # The IRIX linker doesn't use LD_RUN_PATH
      my $ldrun = $Is{IRIX} && $self->{LD_RUN_PATH} ?
                         qq{-rpath "$self->{LD_RUN_PATH}"} : '';
  
      # For example in AIX the shared objects/libraries from previous builds
      # linger quite a while in the shared dynalinker cache even when nobody
      # is using them.  This is painful if one for instance tries to restart
      # a failed build because the link command will fail unnecessarily 'cos
      # the shared object/library is 'busy'.
      push(@m,'	$(RM_F) $@
  ');
  
      my $libs = '$(LDLOADLIBS)';
  
      if (($Is{NetBSD} || $Is{Interix} || $Is{Android}) && $Config{'useshrplib'} eq 'true') {
  	# Use nothing on static perl platforms, and to the flags needed
  	# to link against the shared libperl library on shared perl
  	# platforms.  We peek at lddlflags to see if we need -Wl,-R
  	# or -R to add paths to the run-time library search path.
          if ($Config{'lddlflags'} =~ /-Wl,-R/) {
              $libs .= ' "-L$(PERL_INC)" "-Wl,-R$(INSTALLARCHLIB)/CORE" "-Wl,-R$(PERL_ARCHLIB)/CORE" -lperl';
          } elsif ($Config{'lddlflags'} =~ /-R/) {
              $libs .= ' "-L$(PERL_INC)" "-R$(INSTALLARCHLIB)/CORE" "-R$(PERL_ARCHLIB)/CORE" -lperl';
          } elsif ( $Is{Android} ) {
              # The Android linker will not recognize symbols from
              # libperl unless the module explicitly depends on it.
              $libs .= ' "-L$(PERL_INC)" -lperl';
          }
      }
  
      my $ld_run_path_shell = "";
      if ($self->{LD_RUN_PATH} ne "") {
  	$ld_run_path_shell = 'LD_RUN_PATH="$(LD_RUN_PATH)" ';
      }
  
      push @m, sprintf <<'MAKE', $ld_run_path_shell, $ldrun, $ldfrom, $libs;
  	%s$(LD) %s $(LDDLFLAGS) %s $(OTHERLDFLAGS) -o $@ $(MYEXTLIB)	\
  	  $(PERL_ARCHIVE) %s $(PERL_ARCHIVE_AFTER) $(EXPORT_LIST)	\
  	  $(INST_DYNAMIC_FIX)
  MAKE
  
      push @m, <<'MAKE';
  	$(CHMOD) $(PERM_RWX) $@
  	$(NOECHO) $(RM_RF) $(BOOTSTRAP)
  	- $(CP_NONEMPTY) $(BOOTSTRAP) $(INST_BOOT) $(PERM_RW)
  MAKE
  
      return join('',@m);
  }
  
  =item exescan
  
  Deprecated method. Use libscan instead.
  
  =cut
  
  sub exescan {
      my($self,$path) = @_;
      $path;
  }
  
  =item extliblist
  
  Called by init_others, and calls ext ExtUtils::Liblist. See
  L<ExtUtils::Liblist> for details.
  
  =cut
  
  sub extliblist {
      my($self,$libs) = @_;
      require ExtUtils::Liblist;
      $self->ext($libs, $Verbose);
  }
  
  =item find_perl
  
  Finds the executables PERL and FULLPERL
  
  =cut
  
  sub find_perl {
      my($self, $ver, $names, $dirs, $trace) = @_;
  
      if ($trace >= 2){
          print "Looking for perl $ver by these names:
  @$names
  in these dirs:
  @$dirs
  ";
      }
  
      my $stderr_duped = 0;
      local *STDERR_COPY;
  
      unless ($Is{BSD}) {
          # >& and lexical filehandles together give 5.6.2 indigestion
          if( open(STDERR_COPY, '>&STDERR') ) {  ## no critic
              $stderr_duped = 1;
          }
          else {
              warn <<WARNING;
  find_perl() can't dup STDERR: $!
  You might see some garbage while we search for Perl
  WARNING
          }
      }
  
      foreach my $name (@$names){
          foreach my $dir (@$dirs){
              next unless defined $dir; # $self->{PERL_SRC} may be undefined
              my ($abs, $val);
              if ($self->file_name_is_absolute($name)) {     # /foo/bar
                  $abs = $name;
              } elsif ($self->canonpath($name) eq
                       $self->canonpath(basename($name))) {  # foo
                  $abs = $self->catfile($dir, $name);
              } else {                                            # foo/bar
                  $abs = $self->catfile($Curdir, $name);
              }
              print "Checking $abs\n" if ($trace >= 2);
              next unless $self->maybe_command($abs);
              print "Executing $abs\n" if ($trace >= 2);
  
              my $version_check = qq{"$abs" -le "require $ver; print qq{VER_OK}"};
  
              # To avoid using the unportable 2>&1 to suppress STDERR,
              # we close it before running the command.
              # However, thanks to a thread library bug in many BSDs
              # ( http://www.freebsd.org/cgi/query-pr.cgi?pr=51535 )
              # we cannot use the fancier more portable way in here
              # but instead need to use the traditional 2>&1 construct.
              if ($Is{BSD}) {
                  $val = `$version_check 2>&1`;
              } else {
                  close STDERR if $stderr_duped;
                  $val = `$version_check`;
  
                  # 5.6.2's 3-arg open doesn't work with >&
                  open STDERR, ">&STDERR_COPY"  ## no critic
                          if $stderr_duped;
              }
  
              if ($val =~ /^VER_OK/m) {
                  print "Using PERL=$abs\n" if $trace;
                  return $abs;
              } elsif ($trace >= 2) {
                  print "Result: '$val' ".($? >> 8)."\n";
              }
          }
      }
      print "Unable to find a perl $ver (by these names: @$names, in these dirs: @$dirs)\n";
      0; # false and not empty
  }
  
  
  =item fixin
  
    $mm->fixin(@files);
  
  Inserts the sharpbang or equivalent magic number to a set of @files.
  
  =cut
  
  sub fixin {    # stolen from the pink Camel book, more or less
      my ( $self, @files ) = @_;
  
      for my $file (@files) {
          my $file_new = "$file.new";
          my $file_bak = "$file.bak";
  
          open( my $fixin, '<', $file ) or croak "Can't process '$file': $!";
          local $/ = "\n";
          chomp( my $line = <$fixin> );
          next unless $line =~ s/^\s*\#!\s*//;    # Not a shebang file.
  
          my $shb = $self->_fixin_replace_shebang( $file, $line );
          next unless defined $shb;
  
          open( my $fixout, ">", "$file_new" ) or do {
              warn "Can't create new $file: $!\n";
              next;
          };
  
          # Print out the new #! line (or equivalent).
          local $\;
          local $/;
          print $fixout $shb, <$fixin>;
          close $fixin;
          close $fixout;
  
          chmod 0666, $file_bak;
          unlink $file_bak;
          unless ( _rename( $file, $file_bak ) ) {
              warn "Can't rename $file to $file_bak: $!";
              next;
          }
          unless ( _rename( $file_new, $file ) ) {
              warn "Can't rename $file_new to $file: $!";
              unless ( _rename( $file_bak, $file ) ) {
                  warn "Can't rename $file_bak back to $file either: $!";
                  warn "Leaving $file renamed as $file_bak\n";
              }
              next;
          }
          unlink $file_bak;
      }
      continue {
          system("$Config{'eunicefix'} $file") if $Config{'eunicefix'} ne ':';
      }
  }
  
  
  sub _rename {
      my($old, $new) = @_;
  
      foreach my $file ($old, $new) {
          if( $Is{VMS} and basename($file) !~ /\./ ) {
              # rename() in 5.8.0 on VMS will not rename a file if it
              # does not contain a dot yet it returns success.
              $file = "$file.";
          }
      }
  
      return rename($old, $new);
  }
  
  sub _fixin_replace_shebang {
      my ( $self, $file, $line ) = @_;
  
      # Now figure out the interpreter name.
      my ( $cmd, $arg ) = split ' ', $line, 2;
      $cmd =~ s!^.*/!!;
  
      # Now look (in reverse) for interpreter in absolute PATH (unless perl).
      my $interpreter;
      if ( $cmd =~ m{^perl(?:\z|[^a-z])} ) {
          if ( $Config{startperl} =~ m,^\#!.*/perl, ) {
              $interpreter = $Config{startperl};
              $interpreter =~ s,^\#!,,;
          }
          else {
              $interpreter = $Config{perlpath};
          }
      }
      else {
          my (@absdirs)
              = reverse grep { $self->file_name_is_absolute($_) } $self->path;
          $interpreter = '';
  
           foreach my $dir (@absdirs) {
              if ( $self->maybe_command($cmd) ) {
                  warn "Ignoring $interpreter in $file\n"
                      if $Verbose && $interpreter;
                  $interpreter = $self->catfile( $dir, $cmd );
              }
          }
      }
  
      # Figure out how to invoke interpreter on this machine.
  
      my ($does_shbang) = $Config{'sharpbang'} =~ /^\s*\#\!/;
      my ($shb) = "";
      if ($interpreter) {
          print "Changing sharpbang in $file to $interpreter"
              if $Verbose;
           # this is probably value-free on DOSISH platforms
          if ($does_shbang) {
              $shb .= "$Config{'sharpbang'}$interpreter";
              $shb .= ' ' . $arg if defined $arg;
              $shb .= "\n";
          }
      }
      else {
          warn "Can't find $cmd in PATH, $file unchanged"
              if $Verbose;
          return;
      }
      return $shb
  }
  
  =item force (o)
  
  Writes an empty FORCE: target.
  
  =cut
  
  sub force {
      my($self) = shift;
      '# Phony target to force checking subdirectories.
  FORCE :
  	$(NOECHO) $(NOOP)
  ';
  }
  
  =item guess_name
  
  Guess the name of this package by examining the working directory's
  name. MakeMaker calls this only if the developer has not supplied a
  NAME attribute.
  
  =cut
  
  # ';
  
  sub guess_name {
      my($self) = @_;
      use Cwd 'cwd';
      my $name = basename(cwd());
      $name =~ s|[\-_][\d\.\-]+\z||;  # this is new with MM 5.00, we
                                      # strip minus or underline
                                      # followed by a float or some such
      print "Warning: Guessing NAME [$name] from current directory name.\n";
      $name;
  }
  
  =item has_link_code
  
  Returns true if C, XS, MYEXTLIB or similar objects exist within this
  object that need a compiler. Does not descend into subdirectories as
  needs_linking() does.
  
  =cut
  
  sub has_link_code {
      my($self) = shift;
      return $self->{HAS_LINK_CODE} if defined $self->{HAS_LINK_CODE};
      if ($self->{OBJECT} or @{$self->{C} || []} or $self->{MYEXTLIB}){
  	$self->{HAS_LINK_CODE} = 1;
  	return 1;
      }
      return $self->{HAS_LINK_CODE} = 0;
  }
  
  
  =item init_dirscan
  
  Scans the directory structure and initializes DIR, XS, XS_FILES,
  C, C_FILES, O_FILES, H, H_FILES, PL_FILES, EXE_FILES.
  
  Called by init_main.
  
  =cut
  
  sub init_dirscan {	# --- File and Directory Lists (.xs .pm .pod etc)
      my($self) = @_;
      my(%dir, %xs, %c, %o, %h, %pl_files, %pm);
  
      my %ignore = map {( $_ => 1 )} qw(Makefile.PL Build.PL test.pl t);
  
      # ignore the distdir
      $Is{VMS} ? $ignore{"$self->{DISTVNAME}.dir"} = 1
              : $ignore{$self->{DISTVNAME}} = 1;
  
      my $distprefix = $Is{VMS} ? qr/^\Q$self->{DISTNAME}\E-v?[\d\.]+\.dir$/i
                                : qr/^\Q$self->{DISTNAME}\E-v?[\d\.]+$/;
  
      @ignore{map lc, keys %ignore} = values %ignore if $Is{VMS};
  
      if ( defined $self->{XS} and !defined $self->{C} ) {
  	my @c_files = grep { m/\.c(pp|xx)?\z/i } values %{$self->{XS}};
  	my @o_files = grep { m/(?:.(?:o(?:bj)?)|\$\(OBJ_EXT\))\z/i } values %{$self->{XS}};
  	%c = map { $_ => 1 } @c_files;
  	%o = map { $_ => 1 } @o_files;
      }
  
      foreach my $name ($self->lsdir($Curdir)){
  	next if $name =~ /\#/;
  	next if $name =~ $distprefix && -d $name;
  	$name = lc($name) if $Is{VMS};
  	next if $name eq $Curdir or $name eq $Updir or $ignore{$name};
  	next unless $self->libscan($name);
  	if (-d $name){
  	    next if -l $name; # We do not support symlinks at all
              next if $self->{NORECURS};
  	    $dir{$name} = $name if (-f $self->catfile($name,"Makefile.PL"));
  	} elsif ($name =~ /\.xs\z/){
  	    my($c); ($c = $name) =~ s/\.xs\z/.c/;
  	    $xs{$name} = $c;
  	    $c{$c} = 1;
  	} elsif ($name =~ /\.c(pp|xx|c)?\z/i){  # .c .C .cpp .cxx .cc
  	    $c{$name} = 1
  		unless $name =~ m/perlmain\.c/; # See MAP_TARGET
  	} elsif ($name =~ /\.h\z/i){
  	    $h{$name} = 1;
  	} elsif ($name =~ /\.PL\z/) {
  	    ($pl_files{$name} = $name) =~ s/\.PL\z// ;
  	} elsif (($Is{VMS} || $Is{Dos}) && $name =~ /[._]pl$/i) {
  	    # case-insensitive filesystem, one dot per name, so foo.h.PL
  	    # under Unix appears as foo.h_pl under VMS or fooh.pl on Dos
  	    local($/); open(my $pl, '<', $name); my $txt = <$pl>; close $pl;
  	    if ($txt =~ /Extracting \S+ \(with variable substitutions/) {
  		($pl_files{$name} = $name) =~ s/[._]pl\z//i ;
  	    }
  	    else {
                  $pm{$name} = $self->catfile($self->{INST_LIBDIR},$name);
              }
  	} elsif ($name =~ /\.(p[ml]|pod)\z/){
  	    $pm{$name} = $self->catfile($self->{INST_LIBDIR},$name);
  	}
      }
  
      $self->{PL_FILES}   ||= \%pl_files;
      $self->{DIR}        ||= [sort keys %dir];
      $self->{XS}         ||= \%xs;
      $self->{C}          ||= [sort keys %c];
      $self->{H}          ||= [sort keys %h];
      $self->{PM}         ||= \%pm;
  
      my @o_files = @{$self->{C}};
      %o = (%o, map { $_ => 1 } grep s/\.c(pp|xx|c)?\z/$self->{OBJ_EXT}/i, @o_files);
      $self->{O_FILES} = [sort keys %o];
  }
  
  
  =item init_MANPODS
  
  Determines if man pages should be generated and initializes MAN1PODS
  and MAN3PODS as appropriate.
  
  =cut
  
  sub init_MANPODS {
      my $self = shift;
  
      # Set up names of manual pages to generate from pods
      foreach my $man (qw(MAN1 MAN3)) {
          if ( $self->{"${man}PODS"}
               or $self->{"INSTALL${man}DIR"} =~ /^(none|\s*)$/
          ) {
              $self->{"${man}PODS"} ||= {};
          }
          else {
              my $init_method = "init_${man}PODS";
              $self->$init_method();
          }
      }
  }
  
  
  sub _has_pod {
      my($self, $file) = @_;
  
      my($ispod)=0;
      if (open( my $fh, '<', $file )) {
          while (<$fh>) {
              if (/^=(?:head\d+|item|pod)\b/) {
                  $ispod=1;
                  last;
              }
          }
          close $fh;
      } else {
          # If it doesn't exist yet, we assume, it has pods in it
          $ispod = 1;
      }
  
      return $ispod;
  }
  
  
  =item init_MAN1PODS
  
  Initializes MAN1PODS from the list of EXE_FILES.
  
  =cut
  
  sub init_MAN1PODS {
      my($self) = @_;
  
      if ( exists $self->{EXE_FILES} ) {
  	foreach my $name (@{$self->{EXE_FILES}}) {
  	    next unless $self->_has_pod($name);
  
  	    $self->{MAN1PODS}->{$name} =
  		$self->catfile("\$(INST_MAN1DIR)",
  			       basename($name).".\$(MAN1EXT)");
  	}
      }
  }
  
  
  =item init_MAN3PODS
  
  Initializes MAN3PODS from the list of PM files.
  
  =cut
  
  sub init_MAN3PODS {
      my $self = shift;
  
      my %manifypods = (); # we collect the keys first, i.e. the files
                           # we have to convert to pod
  
      foreach my $name (keys %{$self->{PM}}) {
  	if ($name =~ /\.pod\z/ ) {
  	    $manifypods{$name} = $self->{PM}{$name};
  	} elsif ($name =~ /\.p[ml]\z/ ) {
  	    if( $self->_has_pod($name) ) {
  		$manifypods{$name} = $self->{PM}{$name};
  	    }
  	}
      }
  
      my $parentlibs_re = join '|', @{$self->{PMLIBPARENTDIRS}};
  
      # Remove "Configure.pm" and similar, if it's not the only pod listed
      # To force inclusion, just name it "Configure.pod", or override
      # MAN3PODS
      foreach my $name (keys %manifypods) {
  	if ($self->{PERL_CORE} and $name =~ /(config|setup).*\.pm/is) {
  	    delete $manifypods{$name};
  	    next;
  	}
  	my($manpagename) = $name;
  	$manpagename =~ s/\.p(od|m|l)\z//;
  	# everything below lib is ok
  	unless($manpagename =~ s!^\W*($parentlibs_re)\W+!!s) {
  	    $manpagename = $self->catfile(
  	        split(/::/,$self->{PARENT_NAME}),$manpagename
  	    );
  	}
  	$manpagename = $self->replace_manpage_separator($manpagename);
  	$self->{MAN3PODS}->{$name} =
  	    $self->catfile("\$(INST_MAN3DIR)", "$manpagename.\$(MAN3EXT)");
      }
  }
  
  
  =item init_PM
  
  Initializes PMLIBDIRS and PM from PMLIBDIRS.
  
  =cut
  
  sub init_PM {
      my $self = shift;
  
      # Some larger extensions often wish to install a number of *.pm/pl
      # files into the library in various locations.
  
      # The attribute PMLIBDIRS holds an array reference which lists
      # subdirectories which we should search for library files to
      # install. PMLIBDIRS defaults to [ 'lib', $self->{BASEEXT} ].  We
      # recursively search through the named directories (skipping any
      # which don't exist or contain Makefile.PL files).
  
      # For each *.pm or *.pl file found $self->libscan() is called with
      # the default installation path in $_[1]. The return value of
      # libscan defines the actual installation location.  The default
      # libscan function simply returns the path.  The file is skipped
      # if libscan returns false.
  
      # The default installation location passed to libscan in $_[1] is:
      #
      #  ./*.pm		=> $(INST_LIBDIR)/*.pm
      #  ./xyz/...	=> $(INST_LIBDIR)/xyz/...
      #  ./lib/...	=> $(INST_LIB)/...
      #
      # In this way the 'lib' directory is seen as the root of the actual
      # perl library whereas the others are relative to INST_LIBDIR
      # (which includes PARENT_NAME). This is a subtle distinction but one
      # that's important for nested modules.
  
      unless( $self->{PMLIBDIRS} ) {
          if( $Is{VMS} ) {
              # Avoid logical name vs directory collisions
              $self->{PMLIBDIRS} = ['./lib', "./$self->{BASEEXT}"];
          }
          else {
              $self->{PMLIBDIRS} = ['lib', $self->{BASEEXT}];
          }
      }
  
      #only existing directories that aren't in $dir are allowed
  
      # Avoid $_ wherever possible:
      # @{$self->{PMLIBDIRS}} = grep -d && !$dir{$_}, @{$self->{PMLIBDIRS}};
      my (@pmlibdirs) = @{$self->{PMLIBDIRS}};
      @{$self->{PMLIBDIRS}} = ();
      my %dir = map { ($_ => $_) } @{$self->{DIR}};
      foreach my $pmlibdir (@pmlibdirs) {
  	-d $pmlibdir && !$dir{$pmlibdir} && push @{$self->{PMLIBDIRS}}, $pmlibdir;
      }
  
      unless( $self->{PMLIBPARENTDIRS} ) {
  	@{$self->{PMLIBPARENTDIRS}} = ('lib');
      }
  
      return if $self->{PM} and $self->{ARGS}{PM};
  
      if (@{$self->{PMLIBDIRS}}){
  	print "Searching PMLIBDIRS: @{$self->{PMLIBDIRS}}\n"
  	    if ($Verbose >= 2);
  	require File::Find;
          File::Find::find(sub {
              if (-d $_){
                  unless ($self->libscan($_)){
                      $File::Find::prune = 1;
                  }
                  return;
              }
              return if /\#/;
              return if /~$/;             # emacs temp files
              return if /,v$/;            # RCS files
              return if m{\.swp$};        # vim swap files
  
  	    my $path   = $File::Find::name;
              my $prefix = $self->{INST_LIBDIR};
              my $striplibpath;
  
  	    my $parentlibs_re = join '|', @{$self->{PMLIBPARENTDIRS}};
  	    $prefix =  $self->{INST_LIB}
                  if ($striplibpath = $path) =~ s{^(\W*)($parentlibs_re)\W}
  	                                       {$1}i;
  
  	    my($inst) = $self->catfile($prefix,$striplibpath);
  	    local($_) = $inst; # for backwards compatibility
  	    $inst = $self->libscan($inst);
  	    print "libscan($path) => '$inst'\n" if ($Verbose >= 2);
  	    return unless $inst;
  	    $self->{PM}{$path} = $inst;
  	}, @{$self->{PMLIBDIRS}});
      }
  }
  
  
  =item init_DIRFILESEP
  
  Using / for Unix.  Called by init_main.
  
  =cut
  
  sub init_DIRFILESEP {
      my($self) = shift;
  
      $self->{DIRFILESEP} = '/';
  }
  
  
  =item init_main
  
  Initializes AR, AR_STATIC_ARGS, BASEEXT, CONFIG, DISTNAME, DLBASE,
  EXE_EXT, FULLEXT, FULLPERL, FULLPERLRUN, FULLPERLRUNINST, INST_*,
  INSTALL*, INSTALLDIRS, LIB_EXT, LIBPERL_A, MAP_TARGET, NAME,
  OBJ_EXT, PARENT_NAME, PERL, PERL_ARCHLIB, PERL_INC, PERL_LIB,
  PERL_SRC, PERLRUN, PERLRUNINST, PREFIX, VERSION,
  VERSION_SYM, XS_VERSION.
  
  =cut
  
  sub init_main {
      my($self) = @_;
  
      # --- Initialize Module Name and Paths
  
      # NAME    = Foo::Bar::Oracle
      # FULLEXT = Foo/Bar/Oracle
      # BASEEXT = Oracle
      # PARENT_NAME = Foo::Bar
  ### Only UNIX:
  ###    ($self->{FULLEXT} =
  ###     $self->{NAME}) =~ s!::!/!g ; #eg. BSD/Foo/Socket
      $self->{FULLEXT} = $self->catdir(split /::/, $self->{NAME});
  
  
      # Copied from DynaLoader:
  
      my(@modparts) = split(/::/,$self->{NAME});
      my($modfname) = $modparts[-1];
  
      # Some systems have restrictions on files names for DLL's etc.
      # mod2fname returns appropriate file base name (typically truncated)
      # It may also edit @modparts if required.
      # We require DynaLoader to make sure that mod2fname is loaded
      eval { require DynaLoader };
      if (defined &DynaLoader::mod2fname) {
          $modfname = &DynaLoader::mod2fname(\@modparts);
      }
  
      ($self->{PARENT_NAME}, $self->{BASEEXT}) = $self->{NAME} =~ m!(?:([\w:]+)::)?(\w+)\z! ;
      $self->{PARENT_NAME} ||= '';
  
      if (defined &DynaLoader::mod2fname) {
  	# As of 5.001m, dl_os2 appends '_'
  	$self->{DLBASE} = $modfname;
      } else {
  	$self->{DLBASE} = '$(BASEEXT)';
      }
  
  
      # --- Initialize PERL_LIB, PERL_SRC
  
      # *Real* information: where did we get these two from? ...
      my $inc_config_dir = dirname($INC{'Config.pm'});
      my $inc_carp_dir   = dirname($INC{'Carp.pm'});
  
      unless ($self->{PERL_SRC}){
          foreach my $dir_count (1..8) { # 8 is the VMS limit for nesting
              my $dir = $self->catdir(($Updir) x $dir_count);
  
              if (-f $self->catfile($dir,"config_h.SH")   &&
                  -f $self->catfile($dir,"perl.h")        &&
                  -f $self->catfile($dir,"lib","strict.pm")
              ) {
                  $self->{PERL_SRC}=$dir ;
                  last;
              }
          }
      }
  
      warn "PERL_CORE is set but I can't find your PERL_SRC!\n" if
        $self->{PERL_CORE} and !$self->{PERL_SRC};
  
      if ($self->{PERL_SRC}){
  	$self->{PERL_LIB}     ||= $self->catdir("$self->{PERL_SRC}","lib");
  
          $self->{PERL_ARCHLIB} = $self->{PERL_LIB};
          $self->{PERL_INC}     = ($Is{Win32}) ?
              $self->catdir($self->{PERL_LIB},"CORE") : $self->{PERL_SRC};
  
  	# catch a situation that has occurred a few times in the past:
  	unless (
  		-s $self->catfile($self->{PERL_SRC},'cflags')
  		or
  		$Is{VMS}
  		&&
  		-s $self->catfile($self->{PERL_SRC},'vmsish.h')
  		or
  		$Is{Win32}
  	       ){
  	    warn qq{
  You cannot build extensions below the perl source tree after executing
  a 'make clean' in the perl source tree.
  
  To rebuild extensions distributed with the perl source you should
  simply Configure (to include those extensions) and then build perl as
  normal. After installing perl the source tree can be deleted. It is
  not needed for building extensions by running 'perl Makefile.PL'
  usually without extra arguments.
  
  It is recommended that you unpack and build additional extensions away
  from the perl source tree.
  };
  	}
      } else {
  	# we should also consider $ENV{PERL5LIB} here
          my $old = $self->{PERL_LIB} || $self->{PERL_ARCHLIB} || $self->{PERL_INC};
  	$self->{PERL_LIB}     ||= $Config{privlibexp};
  	$self->{PERL_ARCHLIB} ||= $Config{archlibexp};
  	$self->{PERL_INC}     = $self->catdir("$self->{PERL_ARCHLIB}","CORE"); # wild guess for now
  	my $perl_h;
  
  	if (not -f ($perl_h = $self->catfile($self->{PERL_INC},"perl.h"))
  	    and not $old){
  	    # Maybe somebody tries to build an extension with an
  	    # uninstalled Perl outside of Perl build tree
  	    my $lib;
  	    for my $dir (@INC) {
  	      $lib = $dir, last if -e $self->catfile($dir, "Config.pm");
  	    }
  	    if ($lib) {
                # Win32 puts its header files in /perl/src/lib/CORE.
                # Unix leaves them in /perl/src.
  	      my $inc = $Is{Win32} ? $self->catdir($lib, "CORE" )
                                    : dirname $lib;
  	      if (-e $self->catfile($inc, "perl.h")) {
  		$self->{PERL_LIB}	   = $lib;
  		$self->{PERL_ARCHLIB}	   = $lib;
  		$self->{PERL_INC}	   = $inc;
  		$self->{UNINSTALLED_PERL}  = 1;
  		print <<EOP;
  ... Detected uninstalled Perl.  Trying to continue.
  EOP
  	      }
  	    }
  	}
      }
  
      if ($Is{Android}) {
      	# Android fun times!
      	# ../../perl -I../../lib -MFile::Glob -e1 works
      	# ../../../perl -I../../../lib -MFile::Glob -e1 fails to find
      	# the .so for File::Glob.
      	# This always affects core perl, but may also affect an installed
      	# perl built with -Duserelocatableinc.
      	$self->{PERL_LIB} = File::Spec->rel2abs($self->{PERL_LIB});
      	$self->{PERL_ARCHLIB} = File::Spec->rel2abs($self->{PERL_ARCHLIB});
      }
      $self->{PERL_INCDEP} = $self->{PERL_INC};
      $self->{PERL_ARCHLIBDEP} = $self->{PERL_ARCHLIB};
  
      # We get SITELIBEXP and SITEARCHEXP directly via
      # Get_from_Config. When we are running standard modules, these
      # won't matter, we will set INSTALLDIRS to "perl". Otherwise we
      # set it to "site". I prefer that INSTALLDIRS be set from outside
      # MakeMaker.
      $self->{INSTALLDIRS} ||= "site";
  
      $self->{MAN1EXT} ||= $Config{man1ext};
      $self->{MAN3EXT} ||= $Config{man3ext};
  
      # Get some stuff out of %Config if we haven't yet done so
      print "CONFIG must be an array ref\n"
          if ($self->{CONFIG} and ref $self->{CONFIG} ne 'ARRAY');
      $self->{CONFIG} = [] unless (ref $self->{CONFIG});
      push(@{$self->{CONFIG}}, @ExtUtils::MakeMaker::Get_from_Config);
      push(@{$self->{CONFIG}}, 'shellflags') if $Config{shellflags};
      my(%once_only);
      foreach my $m (@{$self->{CONFIG}}){
          next if $once_only{$m};
          print "CONFIG key '$m' does not exist in Config.pm\n"
                  unless exists $Config{$m};
          $self->{uc $m} ||= $Config{$m};
          $once_only{$m} = 1;
      }
  
  # This is too dangerous:
  #    if ($^O eq "next") {
  #	$self->{AR} = "libtool";
  #	$self->{AR_STATIC_ARGS} = "-o";
  #    }
  # But I leave it as a placeholder
  
      $self->{AR_STATIC_ARGS} ||= "cr";
  
      # These should never be needed
      $self->{OBJ_EXT} ||= '.o';
      $self->{LIB_EXT} ||= '.a';
  
      $self->{MAP_TARGET} ||= "perl";
  
      $self->{LIBPERL_A} ||= "libperl$self->{LIB_EXT}";
  
      # make a simple check if we find strict
      warn "Warning: PERL_LIB ($self->{PERL_LIB}) seems not to be a perl library directory
          (strict.pm not found)"
          unless -f $self->catfile("$self->{PERL_LIB}","strict.pm") ||
                 $self->{NAME} eq "ExtUtils::MakeMaker";
  }
  
  =item init_tools
  
  Initializes tools to use their common (and faster) Unix commands.
  
  =cut
  
  sub init_tools {
      my $self = shift;
  
      $self->{ECHO}       ||= 'echo';
      $self->{ECHO_N}     ||= 'echo -n';
      $self->{RM_F}       ||= "rm -f";
      $self->{RM_RF}      ||= "rm -rf";
      $self->{TOUCH}      ||= "touch";
      $self->{TEST_F}     ||= "test -f";
      $self->{TEST_S}     ||= "test -s";
      $self->{CP}         ||= "cp";
      $self->{MV}         ||= "mv";
      $self->{CHMOD}      ||= "chmod";
      $self->{FALSE}      ||= 'false';
      $self->{TRUE}       ||= 'true';
  
      $self->{LD}         ||= 'ld';
  
      return $self->SUPER::init_tools(@_);
  
      # After SUPER::init_tools so $Config{shell} has a
      # chance to get set.
      $self->{SHELL}      ||= '/bin/sh';
  
      return;
  }
  
  
  =item init_linker
  
  Unix has no need of special linker flags.
  
  =cut
  
  sub init_linker {
      my($self) = shift;
      $self->{PERL_ARCHIVE} ||= '';
      $self->{PERL_ARCHIVEDEP} ||= '';
      $self->{PERL_ARCHIVE_AFTER} ||= '';
      $self->{EXPORT_LIST}  ||= '';
  }
  
  
  =begin _protected
  
  =item init_lib2arch
  
      $mm->init_lib2arch
  
  =end _protected
  
  =cut
  
  sub init_lib2arch {
      my($self) = shift;
  
      # The user who requests an installation directory explicitly
      # should not have to tell us an architecture installation directory
      # as well. We look if a directory exists that is named after the
      # architecture. If not we take it as a sign that it should be the
      # same as the requested installation directory. Otherwise we take
      # the found one.
      for my $libpair ({l=>"privlib",   a=>"archlib"},
                       {l=>"sitelib",   a=>"sitearch"},
                       {l=>"vendorlib", a=>"vendorarch"},
                      )
      {
          my $lib = "install$libpair->{l}";
          my $Lib = uc $lib;
          my $Arch = uc "install$libpair->{a}";
          if( $self->{$Lib} && ! $self->{$Arch} ){
              my($ilib) = $Config{$lib};
  
              $self->prefixify($Arch,$ilib,$self->{$Lib});
  
              unless (-d $self->{$Arch}) {
                  print "Directory $self->{$Arch} not found\n"
                    if $Verbose;
                  $self->{$Arch} = $self->{$Lib};
              }
              print "Defaulting $Arch to $self->{$Arch}\n" if $Verbose;
          }
      }
  }
  
  
  =item init_PERL
  
      $mm->init_PERL;
  
  Called by init_main.  Sets up ABSPERL, PERL, FULLPERL and all the
  *PERLRUN* permutations.
  
      PERL is allowed to be miniperl
      FULLPERL must be a complete perl
  
      ABSPERL is PERL converted to an absolute path
  
      *PERLRUN contains everything necessary to run perl, find it's
           libraries, etc...
  
      *PERLRUNINST is *PERLRUN + everything necessary to find the
           modules being built.
  
  =cut
  
  sub init_PERL {
      my($self) = shift;
  
      my @defpath = ();
      foreach my $component ($self->{PERL_SRC}, $self->path(),
                             $Config{binexp})
      {
  	push @defpath, $component if defined $component;
      }
  
      # Build up a set of file names (not command names).
      my $thisperl = $self->canonpath($^X);
      $thisperl .= $Config{exe_ext} unless
                  # VMS might have a file version # at the end
        $Is{VMS} ? $thisperl =~ m/$Config{exe_ext}(;\d+)?$/i
                : $thisperl =~ m/$Config{exe_ext}$/i;
  
      # We need a relative path to perl when in the core.
      $thisperl = $self->abs2rel($thisperl) if $self->{PERL_CORE};
  
      my @perls = ($thisperl);
      push @perls, map { "$_$Config{exe_ext}" }
                       ("perl$Config{version}", 'perl5', 'perl');
  
      # miniperl has priority over all but the canonical perl when in the
      # core.  Otherwise its a last resort.
      my $miniperl = "miniperl$Config{exe_ext}";
      if( $self->{PERL_CORE} ) {
          splice @perls, 1, 0, $miniperl;
      }
      else {
          push @perls, $miniperl;
      }
  
      $self->{PERL} ||=
          $self->find_perl(5.0, \@perls, \@defpath, $Verbose );
  
      my $perl = $self->{PERL};
      $perl =~ s/^"//;
      my $has_mcr = $perl =~ s/^MCR\s*//;
      my $perlflags = '';
      my $stripped_perl;
      while ($perl) {
  	($stripped_perl = $perl) =~ s/"$//;
  	last if -x $stripped_perl;
  	last unless $perl =~ s/(\s+\S+)$//;
  	$perlflags = $1.$perlflags;
      }
      $self->{PERL} = $stripped_perl;
      $self->{PERL} = 'MCR '.$self->{PERL} if $has_mcr || $Is{VMS};
  
      # When built for debugging, VMS doesn't create perl.exe but ndbgperl.exe.
      my $perl_name = 'perl';
      $perl_name = 'ndbgperl' if $Is{VMS} &&
        defined $Config{usevmsdebug} && $Config{usevmsdebug} eq 'define';
  
      # XXX This logic is flawed.  If "miniperl" is anywhere in the path
      # it will get confused.  It should be fixed to work only on the filename.
      # Define 'FULLPERL' to be a non-miniperl (used in test: target)
      unless ($self->{FULLPERL}) {
        ($self->{FULLPERL} = $self->{PERL}) =~ s/\Q$miniperl\E$/$perl_name$Config{exe_ext}/i;
        $self->{FULLPERL} = qq{"$self->{FULLPERL}"}.$perlflags;
      }
      # Can't have an image name with quotes, and findperl will have
      # already escaped spaces.
      $self->{FULLPERL} =~ tr/"//d if $Is{VMS};
  
      # Little hack to get around VMS's find_perl putting "MCR" in front
      # sometimes.
      $self->{ABSPERL} = $self->{PERL};
      $has_mcr = $self->{ABSPERL} =~ s/^MCR\s*//;
      if( $self->file_name_is_absolute($self->{ABSPERL}) ) {
          $self->{ABSPERL} = '$(PERL)';
      }
      else {
          $self->{ABSPERL} = $self->rel2abs($self->{ABSPERL});
  
          # Quote the perl command if it contains whitespace
          $self->{ABSPERL} = $self->quote_literal($self->{ABSPERL})
            if $self->{ABSPERL} =~ /\s/;
  
          $self->{ABSPERL} = 'MCR '.$self->{ABSPERL} if $has_mcr;
      }
      $self->{PERL} = qq{"$self->{PERL}"}.$perlflags;
  
      # Can't have an image name with quotes, and findperl will have
      # already escaped spaces.
      $self->{PERL} =~ tr/"//d if $Is{VMS};
  
      # Are we building the core?
      $self->{PERL_CORE} = $ENV{PERL_CORE} unless exists $self->{PERL_CORE};
      $self->{PERL_CORE} = 0               unless defined $self->{PERL_CORE};
  
      # How do we run perl?
      foreach my $perl (qw(PERL FULLPERL ABSPERL)) {
          my $run  = $perl.'RUN';
  
          $self->{$run}  = qq{\$($perl)};
  
          # Make sure perl can find itself before it's installed.
          $self->{$run} .= q{ "-I$(PERL_LIB)" "-I$(PERL_ARCHLIB)"}
            if $self->{UNINSTALLED_PERL} || $self->{PERL_CORE};
  
          $self->{$perl.'RUNINST'} =
            sprintf q{$(%sRUN)%s "-I$(INST_ARCHLIB)" "-I$(INST_LIB)"},
  	    $perl, $perlflags;
      }
  
      return 1;
  }
  
  
  =item init_platform
  
  =item platform_constants
  
  Add MM_Unix_VERSION.
  
  =cut
  
  sub init_platform {
      my($self) = shift;
  
      $self->{MM_Unix_VERSION} = $VERSION;
      $self->{PERL_MALLOC_DEF} = '-DPERL_EXTMALLOC_DEF -Dmalloc=Perl_malloc '.
                                 '-Dfree=Perl_mfree -Drealloc=Perl_realloc '.
                                 '-Dcalloc=Perl_calloc';
  
  }
  
  sub platform_constants {
      my($self) = shift;
      my $make_frag = '';
  
      foreach my $macro (qw(MM_Unix_VERSION PERL_MALLOC_DEF))
      {
          next unless defined $self->{$macro};
          $make_frag .= "$macro = $self->{$macro}\n";
      }
  
      return $make_frag;
  }
  
  
  =item init_PERM
  
    $mm->init_PERM
  
  Called by init_main.  Initializes PERL_*
  
  =cut
  
  sub init_PERM {
      my($self) = shift;
  
      $self->{PERM_DIR} = 755  unless defined $self->{PERM_DIR};
      $self->{PERM_RW}  = 644  unless defined $self->{PERM_RW};
      $self->{PERM_RWX} = 755  unless defined $self->{PERM_RWX};
  
      return 1;
  }
  
  
  =item init_xs
  
      $mm->init_xs
  
  Sets up macros having to do with XS code.  Currently just INST_STATIC,
  INST_DYNAMIC and INST_BOOT.
  
  =cut
  
  sub init_xs {
      my $self = shift;
  
      if ($self->has_link_code()) {
          $self->{INST_STATIC}  =
            $self->catfile('$(INST_ARCHAUTODIR)', '$(BASEEXT)$(LIB_EXT)');
          $self->{INST_DYNAMIC} =
            $self->catfile('$(INST_ARCHAUTODIR)', '$(DLBASE).$(DLEXT)');
          $self->{INST_BOOT}    =
            $self->catfile('$(INST_ARCHAUTODIR)', '$(BASEEXT).bs');
      } else {
          $self->{INST_STATIC}  = '';
          $self->{INST_DYNAMIC} = '';
          $self->{INST_BOOT}    = '';
      }
  }
  
  =item install (o)
  
  Defines the install target.
  
  =cut
  
  sub install {
      my($self, %attribs) = @_;
      my(@m);
  
      push @m, q{
  install :: pure_install doc_install
  	$(NOECHO) $(NOOP)
  
  install_perl :: pure_perl_install doc_perl_install
  	$(NOECHO) $(NOOP)
  
  install_site :: pure_site_install doc_site_install
  	$(NOECHO) $(NOOP)
  
  install_vendor :: pure_vendor_install doc_vendor_install
  	$(NOECHO) $(NOOP)
  
  pure_install :: pure_$(INSTALLDIRS)_install
  	$(NOECHO) $(NOOP)
  
  doc_install :: doc_$(INSTALLDIRS)_install
  	$(NOECHO) $(NOOP)
  
  pure__install : pure_site_install
  	$(NOECHO) $(ECHO) INSTALLDIRS not defined, defaulting to INSTALLDIRS=site
  
  doc__install : doc_site_install
  	$(NOECHO) $(ECHO) INSTALLDIRS not defined, defaulting to INSTALLDIRS=site
  
  pure_perl_install :: all
  	$(NOECHO) $(MOD_INSTALL) \
  };
  
      push @m,
  q{		read "}.$self->catfile('$(PERL_ARCHLIB)','auto','$(FULLEXT)','.packlist').q{" \
  		write "}.$self->catfile('$(DESTINSTALLARCHLIB)','auto','$(FULLEXT)','.packlist').q{" \
  } unless $self->{NO_PACKLIST};
  
      push @m,
  q{		"$(INST_LIB)" "$(DESTINSTALLPRIVLIB)" \
  		"$(INST_ARCHLIB)" "$(DESTINSTALLARCHLIB)" \
  		"$(INST_BIN)" "$(DESTINSTALLBIN)" \
  		"$(INST_SCRIPT)" "$(DESTINSTALLSCRIPT)" \
  		"$(INST_MAN1DIR)" "$(DESTINSTALLMAN1DIR)" \
  		"$(INST_MAN3DIR)" "$(DESTINSTALLMAN3DIR)"
  	$(NOECHO) $(WARN_IF_OLD_PACKLIST) \
  		"}.$self->catdir('$(SITEARCHEXP)','auto','$(FULLEXT)').q{"
  
  
  pure_site_install :: all
  	$(NOECHO) $(MOD_INSTALL) \
  };
      push @m,
  q{		read "}.$self->catfile('$(SITEARCHEXP)','auto','$(FULLEXT)','.packlist').q{" \
  		write "}.$self->catfile('$(DESTINSTALLSITEARCH)','auto','$(FULLEXT)','.packlist').q{" \
  } unless $self->{NO_PACKLIST};
  
      push @m,
  q{		"$(INST_LIB)" "$(DESTINSTALLSITELIB)" \
  		"$(INST_ARCHLIB)" "$(DESTINSTALLSITEARCH)" \
  		"$(INST_BIN)" "$(DESTINSTALLSITEBIN)" \
  		"$(INST_SCRIPT)" "$(DESTINSTALLSITESCRIPT)" \
  		"$(INST_MAN1DIR)" "$(DESTINSTALLSITEMAN1DIR)" \
  		"$(INST_MAN3DIR)" "$(DESTINSTALLSITEMAN3DIR)"
  	$(NOECHO) $(WARN_IF_OLD_PACKLIST) \
  		"}.$self->catdir('$(PERL_ARCHLIB)','auto','$(FULLEXT)').q{"
  
  pure_vendor_install :: all
  	$(NOECHO) $(MOD_INSTALL) \
  };
      push @m,
  q{		read "}.$self->catfile('$(VENDORARCHEXP)','auto','$(FULLEXT)','.packlist').q{" \
  		write "}.$self->catfile('$(DESTINSTALLVENDORARCH)','auto','$(FULLEXT)','.packlist').q{" \
  } unless $self->{NO_PACKLIST};
  
      push @m,
  q{		"$(INST_LIB)" "$(DESTINSTALLVENDORLIB)" \
  		"$(INST_ARCHLIB)" "$(DESTINSTALLVENDORARCH)" \
  		"$(INST_BIN)" "$(DESTINSTALLVENDORBIN)" \
  		"$(INST_SCRIPT)" "$(DESTINSTALLVENDORSCRIPT)" \
  		"$(INST_MAN1DIR)" "$(DESTINSTALLVENDORMAN1DIR)" \
  		"$(INST_MAN3DIR)" "$(DESTINSTALLVENDORMAN3DIR)"
  
  };
  
      push @m, q{
  doc_perl_install :: all
  	$(NOECHO) $(NOOP)
  
  doc_site_install :: all
  	$(NOECHO) $(NOOP)
  
  doc_vendor_install :: all
  	$(NOECHO) $(NOOP)
  
  } if $self->{NO_PERLLOCAL};
  
      push @m, q{
  doc_perl_install :: all
  	$(NOECHO) $(ECHO) Appending installation info to "$(DESTINSTALLARCHLIB)/perllocal.pod"
  	-$(NOECHO) $(MKPATH) "$(DESTINSTALLARCHLIB)"
  	-$(NOECHO) $(DOC_INSTALL) \
  		"Module" "$(NAME)" \
  		"installed into" $(INSTALLPRIVLIB) \
  		LINKTYPE "$(LINKTYPE)" \
  		VERSION "$(VERSION)" \
  		EXE_FILES "$(EXE_FILES)" \
  		>> "}.$self->catfile('$(DESTINSTALLARCHLIB)','perllocal.pod').q{"
  
  doc_site_install :: all
  	$(NOECHO) $(ECHO) Appending installation info to "$(DESTINSTALLARCHLIB)/perllocal.pod"
  	-$(NOECHO) $(MKPATH) "$(DESTINSTALLARCHLIB)"
  	-$(NOECHO) $(DOC_INSTALL) \
  		"Module" "$(NAME)" \
  		"installed into" $(INSTALLSITELIB) \
  		LINKTYPE "$(LINKTYPE)" \
  		VERSION "$(VERSION)" \
  		EXE_FILES "$(EXE_FILES)" \
  		>> "}.$self->catfile('$(DESTINSTALLARCHLIB)','perllocal.pod').q{"
  
  doc_vendor_install :: all
  	$(NOECHO) $(ECHO) Appending installation info to "$(DESTINSTALLARCHLIB)/perllocal.pod"
  	-$(NOECHO) $(MKPATH) "$(DESTINSTALLARCHLIB)"
  	-$(NOECHO) $(DOC_INSTALL) \
  		"Module" "$(NAME)" \
  		"installed into" $(INSTALLVENDORLIB) \
  		LINKTYPE "$(LINKTYPE)" \
  		VERSION "$(VERSION)" \
  		EXE_FILES "$(EXE_FILES)" \
  		>> "}.$self->catfile('$(DESTINSTALLARCHLIB)','perllocal.pod').q{"
  
  } unless $self->{NO_PERLLOCAL};
  
      push @m, q{
  uninstall :: uninstall_from_$(INSTALLDIRS)dirs
  	$(NOECHO) $(NOOP)
  
  uninstall_from_perldirs ::
  	$(NOECHO) $(UNINSTALL) "}.$self->catfile('$(PERL_ARCHLIB)','auto','$(FULLEXT)','.packlist').q{"
  
  uninstall_from_sitedirs ::
  	$(NOECHO) $(UNINSTALL) "}.$self->catfile('$(SITEARCHEXP)','auto','$(FULLEXT)','.packlist').q{"
  
  uninstall_from_vendordirs ::
  	$(NOECHO) $(UNINSTALL) "}.$self->catfile('$(VENDORARCHEXP)','auto','$(FULLEXT)','.packlist').q{"
  };
  
      join("",@m);
  }
  
  =item installbin (o)
  
  Defines targets to make and to install EXE_FILES.
  
  =cut
  
  sub installbin {
      my($self) = shift;
  
      return "" unless $self->{EXE_FILES} && ref $self->{EXE_FILES} eq "ARRAY";
      my @exefiles = @{$self->{EXE_FILES}};
      return "" unless @exefiles;
  
      @exefiles = map vmsify($_), @exefiles if $Is{VMS};
  
      my %fromto;
      for my $from (@exefiles) {
  	my($path)= $self->catfile('$(INST_SCRIPT)', basename($from));
  
  	local($_) = $path; # for backwards compatibility
  	my $to = $self->libscan($path);
  	print "libscan($from) => '$to'\n" if ($Verbose >=2);
  
          $to = vmsify($to) if $Is{VMS};
  	$fromto{$from} = $to;
      }
      my @to   = values %fromto;
  
      my @m;
      push(@m, qq{
  EXE_FILES = @exefiles
  
  pure_all :: @to
  	\$(NOECHO) \$(NOOP)
  
  realclean ::
  });
  
      # realclean can get rather large.
      push @m, map "\t$_\n", $self->split_command('$(RM_F)', @to);
      push @m, "\n";
  
  
      # A target for each exe file.
      while (my($from,$to) = each %fromto) {
  	last unless defined $from;
  
  	push @m, sprintf <<'MAKE', $to, $from, $to, $from, $to, $to, $to;
  %s : %s $(FIRST_MAKEFILE) $(INST_SCRIPT)$(DFSEP).exists $(INST_BIN)$(DFSEP).exists
  	$(NOECHO) $(RM_F) %s
  	$(CP) %s %s
  	$(FIXIN) %s
  	-$(NOECHO) $(CHMOD) $(PERM_RWX) %s
  
  MAKE
  
      }
  
      join "", @m;
  }
  
  
  =item linkext (o)
  
  Defines the linkext target which in turn defines the LINKTYPE.
  
  =cut
  
  sub linkext {
      my($self, %attribs) = @_;
      # LINKTYPE => static or dynamic or ''
      my($linktype) = defined $attribs{LINKTYPE} ?
        $attribs{LINKTYPE} : '$(LINKTYPE)';
      "
  linkext :: $linktype
  	\$(NOECHO) \$(NOOP)
  ";
  }
  
  =item lsdir
  
  Takes as arguments a directory name and a regular expression. Returns
  all entries in the directory that match the regular expression.
  
  =cut
  
  sub lsdir {
      my($self) = shift;
      my($dir, $regex) = @_;
      my(@ls);
      my $dh = new DirHandle;
      $dh->open($dir || ".") or return ();
      @ls = $dh->read;
      $dh->close;
      @ls = grep(/$regex/, @ls) if $regex;
      @ls;
  }
  
  =item macro (o)
  
  Simple subroutine to insert the macros defined by the macro attribute
  into the Makefile.
  
  =cut
  
  sub macro {
      my($self,%attribs) = @_;
      my(@m,$key,$val);
      while (($key,$val) = each %attribs){
  	last unless defined $key;
  	push @m, "$key = $val\n";
      }
      join "", @m;
  }
  
  =item makeaperl (o)
  
  Called by staticmake. Defines how to write the Makefile to produce a
  static new perl.
  
  By default the Makefile produced includes all the static extensions in
  the perl library. (Purified versions of library files, e.g.,
  DynaLoader_pure_p1_c0_032.a are automatically ignored to avoid link errors.)
  
  =cut
  
  sub makeaperl {
      my($self, %attribs) = @_;
      my($makefilename, $searchdirs, $static, $extra, $perlinc, $target, $tmp, $libperl) =
  	@attribs{qw(MAKE DIRS STAT EXTRA INCL TARGET TMP LIBPERL)};
      my(@m);
      push @m, "
  # --- MakeMaker makeaperl section ---
  MAP_TARGET    = $target
  FULLPERL      = $self->{FULLPERL}
  ";
      return join '', @m if $self->{PARENT};
  
      my($dir) = join ":", @{$self->{DIR}};
  
      unless ($self->{MAKEAPERL}) {
  	push @m, q{
  $(MAP_TARGET) :: static $(MAKE_APERL_FILE)
  	$(MAKE) $(USEMAKEFILE) $(MAKE_APERL_FILE) $@
  
  $(MAKE_APERL_FILE) : $(FIRST_MAKEFILE) pm_to_blib
  	$(NOECHO) $(ECHO) Writing \"$(MAKE_APERL_FILE)\" for this $(MAP_TARGET)
  	$(NOECHO) $(PERLRUNINST) \
  		Makefile.PL DIR="}, $dir, q{" \
  		MAKEFILE=$(MAKE_APERL_FILE) LINKTYPE=static \
  		MAKEAPERL=1 NORECURS=1 CCCDLFLAGS=};
  
  	foreach (@ARGV){
  		if( /\s/ ){
  			s/=(.*)/='$1'/;
  		}
  		push @m, " \\\n\t\t$_";
  	}
  #	push @m, map( " \\\n\t\t$_", @ARGV );
  	push @m, "\n";
  
  	return join '', @m;
      }
  
  
  
      my($cccmd, $linkcmd, $lperl);
  
  
      $cccmd = $self->const_cccmd($libperl);
      $cccmd =~ s/^CCCMD\s*=\s*//;
      $cccmd =~ s/\$\(INC\)/ "-I$self->{PERL_INC}" /;
      $cccmd .= " $Config{cccdlflags}"
  	if ($Config{useshrplib} eq 'true');
      $cccmd =~ s/\(CC\)/\(PERLMAINCC\)/;
  
      # The front matter of the linkcommand...
      $linkcmd = join ' ', "\$(CC)",
  	    grep($_, @Config{qw(ldflags ccdlflags)});
      $linkcmd =~ s/\s+/ /g;
      $linkcmd =~ s,(perl\.exp),\$(PERL_INC)/$1,;
  
      # Which *.a files could we make use of...
      my %static;
      require File::Find;
      File::Find::find(sub {
  	return unless m/\Q$self->{LIB_EXT}\E$/;
  
          # Skip perl's libraries.
          return if m/^libperl/ or m/^perl\Q$self->{LIB_EXT}\E$/;
  
  	# Skip purified versions of libraries
          # (e.g., DynaLoader_pure_p1_c0_032.a)
  	return if m/_pure_\w+_\w+_\w+\.\w+$/ and -f "$File::Find::dir/.pure";
  
  	if( exists $self->{INCLUDE_EXT} ){
  		my $found = 0;
  
  		(my $xx = $File::Find::name) =~ s,.*?/auto/,,s;
  		$xx =~ s,/?$_,,;
  		$xx =~ s,/,::,g;
  
  		# Throw away anything not explicitly marked for inclusion.
  		# DynaLoader is implied.
  		foreach my $incl ((@{$self->{INCLUDE_EXT}},'DynaLoader')){
  			if( $xx eq $incl ){
  				$found++;
  				last;
  			}
  		}
  		return unless $found;
  	}
  	elsif( exists $self->{EXCLUDE_EXT} ){
  		(my $xx = $File::Find::name) =~ s,.*?/auto/,,s;
  		$xx =~ s,/?$_,,;
  		$xx =~ s,/,::,g;
  
  		# Throw away anything explicitly marked for exclusion
  		foreach my $excl (@{$self->{EXCLUDE_EXT}}){
  			return if( $xx eq $excl );
  		}
  	}
  
  	# don't include the installed version of this extension. I
  	# leave this line here, although it is not necessary anymore:
  	# I patched minimod.PL instead, so that Miniperl.pm won't
  	# include duplicates
  
  	# Once the patch to minimod.PL is in the distribution, I can
  	# drop it
  	return if $File::Find::name =~ m:auto/$self->{FULLEXT}/$self->{BASEEXT}$self->{LIB_EXT}\z:;
  	use Cwd 'cwd';
  	$static{cwd() . "/" . $_}++;
      }, grep( -d $_, @{$searchdirs || []}) );
  
      # We trust that what has been handed in as argument, will be buildable
      $static = [] unless $static;
      @static{@{$static}} = (1) x @{$static};
  
      $extra = [] unless $extra && ref $extra eq 'ARRAY';
      for (sort keys %static) {
  	next unless /\Q$self->{LIB_EXT}\E\z/;
  	$_ = dirname($_) . "/extralibs.ld";
  	push @$extra, $_;
      }
  
      s/^(.*)/"-I$1"/ for @{$perlinc || []};
  
      $target ||= "perl";
      $tmp    ||= ".";
  
  # MAP_STATIC doesn't look into subdirs yet. Once "all" is made and we
  # regenerate the Makefiles, MAP_STATIC and the dependencies for
  # extralibs.all are computed correctly
      push @m, "
  MAP_LINKCMD   = $linkcmd
  MAP_PERLINC   = @{$perlinc || []}
  MAP_STATIC    = ",
  join(" \\\n\t", reverse sort keys %static), "
  
  MAP_PRELIBS   = $Config{perllibs} $Config{cryptlib}
  ";
  
      if (defined $libperl) {
  	($lperl = $libperl) =~ s/\$\(A\)/$self->{LIB_EXT}/;
      }
      unless ($libperl && -f $lperl) { # Ilya's code...
  	my $dir = $self->{PERL_SRC} || "$self->{PERL_ARCHLIB}/CORE";
  	$dir = "$self->{PERL_ARCHLIB}/.." if $self->{UNINSTALLED_PERL};
  	$libperl ||= "libperl$self->{LIB_EXT}";
  	$libperl   = "$dir/$libperl";
  	$lperl   ||= "libperl$self->{LIB_EXT}";
  	$lperl     = "$dir/$lperl";
  
          if (! -f $libperl and ! -f $lperl) {
            # We did not find a static libperl. Maybe there is a shared one?
            if ($Is{SunOS}) {
              $lperl  = $libperl = "$dir/$Config{libperl}";
              # SUNOS ld does not take the full path to a shared library
              $libperl = '' if $Is{SunOS4};
            }
          }
  
  	print "Warning: $libperl not found
      If you're going to build a static perl binary, make sure perl is installed
      otherwise ignore this warning\n"
  		unless (-f $lperl || defined($self->{PERL_SRC}));
      }
  
      # SUNOS ld does not take the full path to a shared library
      my $llibperl = $libperl ? '$(MAP_LIBPERL)' : '-lperl';
  
      push @m, "
  MAP_LIBPERL = $libperl
  LLIBPERL    = $llibperl
  ";
  
      push @m, '
  $(INST_ARCHAUTODIR)/extralibs.all : $(INST_ARCHAUTODIR)$(DFSEP).exists '.join(" \\\n\t", @$extra).'
  	$(NOECHO) $(RM_F)  $@
  	$(NOECHO) $(TOUCH) $@
  ';
  
      foreach my $catfile (@$extra){
  	push @m, "\tcat $catfile >> \$\@\n";
      }
  
  push @m, "
  \$(MAP_TARGET) :: $tmp/perlmain\$(OBJ_EXT) \$(MAP_LIBPERL) \$(MAP_STATIC) \$(INST_ARCHAUTODIR)/extralibs.all
  	\$(MAP_LINKCMD) -o \$\@ \$(OPTIMIZE) $tmp/perlmain\$(OBJ_EXT) \$(LDFROM) \$(MAP_STATIC) \$(LLIBPERL) `cat \$(INST_ARCHAUTODIR)/extralibs.all` \$(MAP_PRELIBS)
  	\$(NOECHO) \$(ECHO) 'To install the new \"\$(MAP_TARGET)\" binary, call'
  	\$(NOECHO) \$(ECHO) '    \$(MAKE) \$(USEMAKEFILE) $makefilename inst_perl MAP_TARGET=\$(MAP_TARGET)'
  	\$(NOECHO) \$(ECHO) 'To remove the intermediate files say'
  	\$(NOECHO) \$(ECHO) '    \$(MAKE) \$(USEMAKEFILE) $makefilename map_clean'
  
  $tmp/perlmain\$(OBJ_EXT): $tmp/perlmain.c
  ";
      push @m, "\t".$self->cd($tmp, qq[$cccmd "-I\$(PERL_INC)" perlmain.c])."\n";
  
      push @m, qq{
  $tmp/perlmain.c: $makefilename}, q{
  	$(NOECHO) $(ECHO) Writing $@
  	$(NOECHO) $(PERL) $(MAP_PERLINC) "-MExtUtils::Miniperl" \\
  		-e "writemain(grep s#.*/auto/##s, split(q| |, q|$(MAP_STATIC)|))" > $@t && $(MV) $@t $@
  
  };
      push @m, "\t", q{$(NOECHO) $(PERL) "$(INSTALLSCRIPT)/fixpmain"
  } if (defined (&Dos::UseLFN) && Dos::UseLFN()==0);
  
  
      push @m, q{
  doc_inst_perl :
  	$(NOECHO) $(ECHO) Appending installation info to "$(DESTINSTALLARCHLIB)/perllocal.pod"
  	-$(NOECHO) $(MKPATH) "$(DESTINSTALLARCHLIB)"
  	-$(NOECHO) $(DOC_INSTALL) \
  		"Perl binary" "$(MAP_TARGET)" \
  		MAP_STATIC "$(MAP_STATIC)" \
  		MAP_EXTRA "`cat $(INST_ARCHAUTODIR)/extralibs.all`" \
  		MAP_LIBPERL "$(MAP_LIBPERL)" \
  		>> "}.$self->catfile('$(DESTINSTALLARCHLIB)','perllocal.pod').q{"
  
  };
  
      push @m, q{
  inst_perl : pure_inst_perl doc_inst_perl
  
  pure_inst_perl : $(MAP_TARGET)
  	}.$self->{CP}.q{ $(MAP_TARGET) "}.$self->catfile('$(DESTINSTALLBIN)','$(MAP_TARGET)').q{"
  
  clean :: map_clean
  
  map_clean :
  	}.$self->{RM_F}.qq{ $tmp/perlmain\$(OBJ_EXT) $tmp/perlmain.c \$(MAP_TARGET) $makefilename \$(INST_ARCHAUTODIR)/extralibs.all
  };
  
      join '', @m;
  }
  
  =item makefile (o)
  
  Defines how to rewrite the Makefile.
  
  =cut
  
  sub makefile {
      my($self) = shift;
      my $m;
      # We do not know what target was originally specified so we
      # must force a manual rerun to be sure. But as it should only
      # happen very rarely it is not a significant problem.
      $m = '
  $(OBJECT) : $(FIRST_MAKEFILE)
  
  ' if $self->{OBJECT};
  
      my $newer_than_target = $Is{VMS} ? '$(MMS$SOURCE_LIST)' : '$?';
      my $mpl_args = join " ", map qq["$_"], @ARGV;
      my $cross = '';
      if (defined $::Cross::platform) {
          # Inherited from win32/buildext.pl
          $cross = "-MCross=$::Cross::platform ";
      }
      $m .= sprintf <<'MAKE_FRAG', $newer_than_target, $cross, $mpl_args;
  # We take a very conservative approach here, but it's worth it.
  # We move Makefile to Makefile.old here to avoid gnu make looping.
  $(FIRST_MAKEFILE) : Makefile.PL $(CONFIGDEP)
  	$(NOECHO) $(ECHO) "Makefile out-of-date with respect to %s"
  	$(NOECHO) $(ECHO) "Cleaning current config before rebuilding Makefile..."
  	-$(NOECHO) $(RM_F) $(MAKEFILE_OLD)
  	-$(NOECHO) $(MV)   $(FIRST_MAKEFILE) $(MAKEFILE_OLD)
  	- $(MAKE) $(USEMAKEFILE) $(MAKEFILE_OLD) clean $(DEV_NULL)
  	$(PERLRUN) %sMakefile.PL %s
  	$(NOECHO) $(ECHO) "==> Your Makefile has been rebuilt. <=="
  	$(NOECHO) $(ECHO) "==> Please rerun the $(MAKE) command.  <=="
  	$(FALSE)
  
  MAKE_FRAG
  
      return $m;
  }
  
  
  =item maybe_command
  
  Returns true, if the argument is likely to be a command.
  
  =cut
  
  sub maybe_command {
      my($self,$file) = @_;
      return $file if -x $file && ! -d $file;
      return;
  }
  
  
  =item needs_linking (o)
  
  Does this module need linking? Looks into subdirectory objects (see
  also has_link_code())
  
  =cut
  
  sub needs_linking {
      my($self) = shift;
  
      my $caller = (caller(0))[3];
      confess("needs_linking called too early") if
        $caller =~ /^ExtUtils::MakeMaker::/;
      return $self->{NEEDS_LINKING} if defined $self->{NEEDS_LINKING};
      if ($self->has_link_code or $self->{MAKEAPERL}){
  	$self->{NEEDS_LINKING} = 1;
  	return 1;
      }
      foreach my $child (keys %{$self->{CHILDREN}}) {
  	if ($self->{CHILDREN}->{$child}->needs_linking) {
  	    $self->{NEEDS_LINKING} = 1;
  	    return 1;
  	}
      }
      return $self->{NEEDS_LINKING} = 0;
  }
  
  
  =item parse_abstract
  
  parse a file and return what you think is the ABSTRACT
  
  =cut
  
  sub parse_abstract {
      my($self,$parsefile) = @_;
      my $result;
  
      local $/ = "\n";
      open(my $fh, '<', $parsefile) or die "Could not open '$parsefile': $!";
      my $inpod = 0;
      my $pod_encoding;
      my $package = $self->{DISTNAME};
      $package =~ s/-/::/g;
      while (<$fh>) {
          $inpod = /^=(?!cut)/ ? 1 : /^=cut/ ? 0 : $inpod;
          next if !$inpod;
          chop;
  
          if ( /^=encoding\s*(.*)$/i ) {
              $pod_encoding = $1;
          }
  
          if ( /^($package(?:\.pm)? \s+ -+ \s+)(.*)/x ) {
            $result = $2;
            next;
          }
          next unless $result;
  
          if ( $result && ( /^\s*$/ || /^\=/ ) ) {
            last;
          }
          $result = join ' ', $result, $_;
      }
      close $fh;
  
      if ( $pod_encoding and !( $] < 5.008 or !$Config{useperlio} ) ) {
          # Have to wrap in an eval{} for when running under PERL_CORE
          # Encode isn't available during build phase and parsing
          # ABSTRACT isn't important there
          eval {
            require Encode;
            $result = Encode::decode($pod_encoding, $result);
          }
      }
  
      return $result;
  }
  
  =item parse_version
  
      my $version = MM->parse_version($file);
  
  Parse a $file and return what $VERSION is set to by the first assignment.
  It will return the string "undef" if it can't figure out what $VERSION
  is. $VERSION should be for all to see, so C<our $VERSION> or plain $VERSION
  are okay, but C<my $VERSION> is not.
  
  C<<package Foo VERSION>> is also checked for.  The first version
  declaration found is used, but this may change as it differs from how
  Perl does it.
  
  parse_version() will try to C<use version> before checking for
  C<$VERSION> so the following will work.
  
      $VERSION = qv(1.2.3);
  
  =cut
  
  sub parse_version {
      my($self,$parsefile) = @_;
      my $result;
  
      local $/ = "\n";
      local $_;
      open(my $fh, '<', $parsefile) or die "Could not open '$parsefile': $!";
      my $inpod = 0;
      while (<$fh>) {
          $inpod = /^=(?!cut)/ ? 1 : /^=cut/ ? 0 : $inpod;
          next if $inpod || /^\s*#/;
          chop;
          next if /^\s*(if|unless|elsif)/;
          if ( m{^ \s* package \s+ \w[\w\:\']* \s+ (v?[0-9._]+) \s* ;  }x ) {
              local $^W = 0;
              $result = $1;
          }
          elsif ( m{(?<!\\) ([\$*]) (([\w\:\']*) \bVERSION)\b .* (?<![<>=!])\=[^=]}x ) {
  			$result = $self->get_version($parsefile, $1, $2);
          }
          else {
            next;
          }
          last if defined $result;
      }
      close $fh;
  
      if ( defined $result && $result !~ /^v?[\d_\.]+$/ ) {
        require version;
        my $normal = eval { version->new( $result ) };
        $result = $normal if defined $normal;
      }
      $result = "undef" unless defined $result;
      return $result;
  }
  
  sub get_version {
      my ($self, $parsefile, $sigil, $name) = @_;
      my $line = $_; # from the while() loop in parse_version
      {
          package ExtUtils::MakeMaker::_version;
          undef *version; # in case of unexpected version() sub
          eval {
              require version;
              version::->import;
          };
          no strict;
          local *{$name};
          local $^W = 0;
          $line = $1 if $line =~ m{^(.+)}s;
          eval($line); ## no critic
          return ${$name};
      }
  }
  
  =item pasthru (o)
  
  Defines the string that is passed to recursive make calls in
  subdirectories.
  
  =cut
  
  sub pasthru {
      my($self) = shift;
      my(@m);
  
      my(@pasthru);
      my($sep) = $Is{VMS} ? ',' : '';
      $sep .= "\\\n\t";
  
      foreach my $key (qw(LIB LIBPERL_A LINKTYPE OPTIMIZE
                       PREFIX INSTALL_BASE)
                   )
      {
          next unless defined $self->{$key};
  	push @pasthru, "$key=\"\$($key)\"";
      }
  
      foreach my $key (qw(DEFINE INC)) {
          next unless defined $self->{$key};
  	push @pasthru, "PASTHRU_$key=\"\$(PASTHRU_$key)\"";
      }
  
      push @m, "\nPASTHRU = ", join ($sep, @pasthru), "\n";
      join "", @m;
  }
  
  =item perl_script
  
  Takes one argument, a file name, and returns the file name, if the
  argument is likely to be a perl script. On MM_Unix this is true for
  any ordinary, readable file.
  
  =cut
  
  sub perl_script {
      my($self,$file) = @_;
      return $file if -r $file && -f _;
      return;
  }
  
  =item perldepend (o)
  
  Defines the dependency from all *.h files that come with the perl
  distribution.
  
  =cut
  
  sub perldepend {
      my($self) = shift;
      my(@m);
  
      my $make_config = $self->cd('$(PERL_SRC)', '$(MAKE) lib/Config.pm');
  
      push @m, sprintf <<'MAKE_FRAG', $make_config if $self->{PERL_SRC};
  # Check for unpropogated config.sh changes. Should never happen.
  # We do NOT just update config.h because that is not sufficient.
  # An out of date config.h is not fatal but complains loudly!
  $(PERL_INCDEP)/config.h: $(PERL_SRC)/config.sh
  	-$(NOECHO) $(ECHO) "Warning: $(PERL_INC)/config.h out of date with $(PERL_SRC)/config.sh"; $(FALSE)
  
  $(PERL_ARCHLIB)/Config.pm: $(PERL_SRC)/config.sh
  	$(NOECHO) $(ECHO) "Warning: $(PERL_ARCHLIB)/Config.pm may be out of date with $(PERL_SRC)/config.sh"
  	%s
  MAKE_FRAG
  
      return join "", @m unless $self->needs_linking;
  
      if ($self->{OBJECT}) {
          # Need to add an object file dependency on the perl headers.
          # this is very important for XS modules in perl.git development.
          push @m, $self->_perl_header_files_fragment("/"); # Directory separator between $(PERL_INC)/header.h
      }
  
      push @m, join(" ", sort values %{$self->{XS}})." : \$(XSUBPPDEPS)\n"  if %{$self->{XS}};
  
      return join "\n", @m;
  }
  
  
  =item pm_to_blib
  
  Defines target that copies all files in the hash PM to their
  destination and autosplits them. See L<ExtUtils::Install/DESCRIPTION>
  
  =cut
  
  sub pm_to_blib {
      my $self = shift;
      my($autodir) = $self->catdir('$(INST_LIB)','auto');
      my $r = q{
  pm_to_blib : $(FIRST_MAKEFILE) $(TO_INST_PM)
  };
  
      # VMS will swallow '' and PM_FILTER is often empty.  So use q[]
      my $pm_to_blib = $self->oneliner(<<CODE, ['-MExtUtils::Install']);
  pm_to_blib({\@ARGV}, '$autodir', q[\$(PM_FILTER)], '\$(PERM_DIR)')
  CODE
  
      my @cmds = $self->split_command($pm_to_blib,
                    map { ($_, $self->{PM}->{$_}) } sort keys %{$self->{PM}});
  
      $r .= join '', map { "\t\$(NOECHO) $_\n" } @cmds;
      $r .= qq{\t\$(NOECHO) \$(TOUCH) pm_to_blib\n};
  
      return $r;
  }
  
  =item post_constants (o)
  
  Returns an empty string per default. Dedicated to overrides from
  within Makefile.PL after all constants have been defined.
  
  =cut
  
  sub post_constants{
      "";
  }
  
  =item post_initialize (o)
  
  Returns an empty string per default. Used in Makefile.PLs to add some
  chunk of text to the Makefile after the object is initialized.
  
  =cut
  
  sub post_initialize {
      "";
  }
  
  =item postamble (o)
  
  Returns an empty string. Can be used in Makefile.PLs to write some
  text to the Makefile at the end.
  
  =cut
  
  sub postamble {
      "";
  }
  
  # transform dot-separated version string into comma-separated quadruple
  # examples:  '1.2.3.4.5' => '1,2,3,4'
  #            '1.2.3'     => '1,2,3,0'
  sub _ppd_version {
      my ($self, $string) = @_;
      return join ',', ((split /\./, $string), (0) x 4)[0..3];
  }
  
  =item ppd
  
  Defines target that creates a PPD (Perl Package Description) file
  for a binary distribution.
  
  =cut
  
  sub ppd {
      my($self) = @_;
  
      my $abstract = $self->{ABSTRACT} || '';
      $abstract =~ s/\n/\\n/sg;
      $abstract =~ s/</&lt;/g;
      $abstract =~ s/>/&gt;/g;
  
      my $author = join(', ',@{$self->{AUTHOR} || []});
      $author =~ s/</&lt;/g;
      $author =~ s/>/&gt;/g;
  
      my $ppd_file = '$(DISTNAME).ppd';
  
      my @ppd_cmds = $self->echo(<<'PPD_HTML', $ppd_file, { append => 0, allow_variables => 1 });
  <SOFTPKG NAME="$(DISTNAME)" VERSION="$(VERSION)">
  PPD_HTML
  
      my $ppd_xml = sprintf <<'PPD_HTML', $abstract, $author;
      <ABSTRACT>%s</ABSTRACT>
      <AUTHOR>%s</AUTHOR>
  PPD_HTML
  
      $ppd_xml .= "    <IMPLEMENTATION>\n";
      if ( $self->{MIN_PERL_VERSION} ) {
          my $min_perl_version = $self->_ppd_version($self->{MIN_PERL_VERSION});
          $ppd_xml .= sprintf <<'PPD_PERLVERS', $min_perl_version;
          <PERLCORE VERSION="%s" />
  PPD_PERLVERS
  
      }
  
      # Don't add "perl" to requires.  perl dependencies are
      # handles by ARCHITECTURE.
      my %prereqs = %{$self->{PREREQ_PM}};
      delete $prereqs{perl};
  
      # Build up REQUIRE
      foreach my $prereq (sort keys %prereqs) {
          my $name = $prereq;
          $name .= '::' unless $name =~ /::/;
          my $version = $prereqs{$prereq};
  
          my %attrs = ( NAME => $name );
          $attrs{VERSION} = $version if $version;
          my $attrs = join " ", map { qq[$_="$attrs{$_}"] } sort keys %attrs;
          $ppd_xml .= qq(        <REQUIRE $attrs />\n);
      }
  
      my $archname = $Config{archname};
      if ($] >= 5.008) {
          # archname did not change from 5.6 to 5.8, but those versions may
          # not be not binary compatible so now we append the part of the
          # version that changes when binary compatibility may change
          $archname .= "-$Config{PERL_REVISION}.$Config{PERL_VERSION}";
      }
      $ppd_xml .= sprintf <<'PPD_OUT', $archname;
          <ARCHITECTURE NAME="%s" />
  PPD_OUT
  
      if ($self->{PPM_INSTALL_SCRIPT}) {
          if ($self->{PPM_INSTALL_EXEC}) {
              $ppd_xml .= sprintf qq{        <INSTALL EXEC="%s">%s</INSTALL>\n},
                    $self->{PPM_INSTALL_EXEC}, $self->{PPM_INSTALL_SCRIPT};
          }
          else {
              $ppd_xml .= sprintf qq{        <INSTALL>%s</INSTALL>\n},
                    $self->{PPM_INSTALL_SCRIPT};
          }
      }
  
      if ($self->{PPM_UNINSTALL_SCRIPT}) {
          if ($self->{PPM_UNINSTALL_EXEC}) {
              $ppd_xml .= sprintf qq{        <UNINSTALL EXEC="%s">%s</UNINSTALL>\n},
                    $self->{PPM_UNINSTALL_EXEC}, $self->{PPM_UNINSTALL_SCRIPT};
          }
          else {
              $ppd_xml .= sprintf qq{        <UNINSTALL>%s</UNINSTALL>\n},
                    $self->{PPM_UNINSTALL_SCRIPT};
          }
      }
  
      my ($bin_location) = $self->{BINARY_LOCATION} || '';
      $bin_location =~ s/\\/\\\\/g;
  
      $ppd_xml .= sprintf <<'PPD_XML', $bin_location;
          <CODEBASE HREF="%s" />
      </IMPLEMENTATION>
  </SOFTPKG>
  PPD_XML
  
      push @ppd_cmds, $self->echo($ppd_xml, $ppd_file, { append => 1 });
  
      return sprintf <<'PPD_OUT', join "\n\t", @ppd_cmds;
  # Creates a PPD (Perl Package Description) for a binary distribution.
  ppd :
  	%s
  PPD_OUT
  
  }
  
  =item prefixify
  
    $MM->prefixify($var, $prefix, $new_prefix, $default);
  
  Using either $MM->{uc $var} || $Config{lc $var}, it will attempt to
  replace it's $prefix with a $new_prefix.
  
  Should the $prefix fail to match I<AND> a PREFIX was given as an
  argument to WriteMakefile() it will set it to the $new_prefix +
  $default.  This is for systems whose file layouts don't neatly fit into
  our ideas of prefixes.
  
  This is for heuristics which attempt to create directory structures
  that mirror those of the installed perl.
  
  For example:
  
      $MM->prefixify('installman1dir', '/usr', '/home/foo', 'man/man1');
  
  this will attempt to remove '/usr' from the front of the
  $MM->{INSTALLMAN1DIR} path (initializing it to $Config{installman1dir}
  if necessary) and replace it with '/home/foo'.  If this fails it will
  simply use '/home/foo/man/man1'.
  
  =cut
  
  sub prefixify {
      my($self,$var,$sprefix,$rprefix,$default) = @_;
  
      my $path = $self->{uc $var} ||
                 $Config_Override{lc $var} || $Config{lc $var} || '';
  
      $rprefix .= '/' if $sprefix =~ m|/$|;
  
      warn "  prefixify $var => $path\n" if $Verbose >= 2;
      warn "    from $sprefix to $rprefix\n" if $Verbose >= 2;
  
      if( $self->{ARGS}{PREFIX} &&
          $path !~ s{^\Q$sprefix\E\b}{$rprefix}s )
      {
  
          warn "    cannot prefix, using default.\n" if $Verbose >= 2;
          warn "    no default!\n" if !$default && $Verbose >= 2;
  
          $path = $self->catdir($rprefix, $default) if $default;
      }
  
      print "    now $path\n" if $Verbose >= 2;
      return $self->{uc $var} = $path;
  }
  
  
  =item processPL (o)
  
  Defines targets to run *.PL files.
  
  =cut
  
  sub processPL {
      my $self = shift;
      my $pl_files = $self->{PL_FILES};
  
      return "" unless $pl_files;
  
      my $m = '';
      foreach my $plfile (sort keys %$pl_files) {
          my $list = ref($pl_files->{$plfile})
                       ?  $pl_files->{$plfile}
  		     : [$pl_files->{$plfile}];
  
  	foreach my $target (@$list) {
              if( $Is{VMS} ) {
                  $plfile = vmsify($self->eliminate_macros($plfile));
                  $target = vmsify($self->eliminate_macros($target));
              }
  
  	    # Normally a .PL file runs AFTER pm_to_blib so it can have
  	    # blib in its @INC and load the just built modules.  BUT if
  	    # the generated module is something in $(TO_INST_PM) which
  	    # pm_to_blib depends on then it can't depend on pm_to_blib
  	    # else we have a dependency loop.
  	    my $pm_dep;
  	    my $perlrun;
  	    if( defined $self->{PM}{$target} ) {
  		$pm_dep  = '';
  		$perlrun = 'PERLRUN';
  	    }
  	    else {
  		$pm_dep  = 'pm_to_blib';
  		$perlrun = 'PERLRUNINST';
  	    }
  
              $m .= <<MAKE_FRAG;
  
  all :: $target
  	\$(NOECHO) \$(NOOP)
  
  $target :: $plfile $pm_dep
  	\$($perlrun) $plfile $target
  MAKE_FRAG
  
  	}
      }
  
      return $m;
  }
  
  =item quote_paren
  
  Backslashes parentheses C<()> in command line arguments.
  Doesn't handle recursive Makefile C<$(...)> constructs,
  but handles simple ones.
  
  =cut
  
  sub quote_paren {
      my $arg = shift;
      $arg =~ s{\$\((.+?)\)}{\$\\\\($1\\\\)}g;	# protect $(...)
      $arg =~ s{(?<!\\)([()])}{\\$1}g;		# quote unprotected
      $arg =~ s{\$\\\\\((.+?)\\\\\)}{\$($1)}g;	# unprotect $(...)
      return $arg;
  }
  
  =item replace_manpage_separator
  
    my $man_name = $MM->replace_manpage_separator($file_path);
  
  Takes the name of a package, which may be a nested package, in the
  form 'Foo/Bar.pm' and replaces the slash with C<::> or something else
  safe for a man page file name.  Returns the replacement.
  
  =cut
  
  sub replace_manpage_separator {
      my($self,$man) = @_;
  
      $man =~ s,/+,::,g;
      return $man;
  }
  
  
  =item cd
  
  =cut
  
  sub cd {
      my($self, $dir, @cmds) = @_;
  
      # No leading tab and no trailing newline makes for easier embedding
      my $make_frag = join "\n\t", map { "cd $dir && $_" } @cmds;
  
      return $make_frag;
  }
  
  =item oneliner
  
  =cut
  
  sub oneliner {
      my($self, $cmd, $switches) = @_;
      $switches = [] unless defined $switches;
  
      # Strip leading and trailing newlines
      $cmd =~ s{^\n+}{};
      $cmd =~ s{\n+$}{};
  
      my @cmds = split /\n/, $cmd;
      $cmd = join " \n\t  -e ", map $self->quote_literal($_), @cmds;
      $cmd = $self->escape_newlines($cmd);
  
      $switches = join ' ', @$switches;
  
      return qq{\$(ABSPERLRUN) $switches -e $cmd --};
  }
  
  
  =item quote_literal
  
  Quotes macro literal value suitable for being used on a command line so
  that when expanded by make, will be received by command as given to
  this method:
  
    my $quoted = $mm->quote_literal(q{it isn't});
    # returns:
    #   'it isn'\''t'
    print MAKEFILE "target:\n\techo $quoted\n";
    # when run "make target", will output:
    #   it isn't
  
  =cut
  
  sub quote_literal {
      my($self, $text, $opts) = @_;
      $opts->{allow_variables} = 1 unless defined $opts->{allow_variables};
  
      # Quote single quotes
      $text =~ s{'}{'\\''}g;
  
      $text = $opts->{allow_variables}
        ? $self->escape_dollarsigns($text) : $self->escape_all_dollarsigns($text);
  
      return "'$text'";
  }
  
  
  =item escape_newlines
  
  =cut
  
  sub escape_newlines {
      my($self, $text) = @_;
  
      $text =~ s{\n}{\\\n}g;
  
      return $text;
  }
  
  
  =item max_exec_len
  
  Using POSIX::ARG_MAX.  Otherwise falling back to 4096.
  
  =cut
  
  sub max_exec_len {
      my $self = shift;
  
      if (!defined $self->{_MAX_EXEC_LEN}) {
          if (my $arg_max = eval { require POSIX;  &POSIX::ARG_MAX }) {
              $self->{_MAX_EXEC_LEN} = $arg_max;
          }
          else {      # POSIX minimum exec size
              $self->{_MAX_EXEC_LEN} = 4096;
          }
      }
  
      return $self->{_MAX_EXEC_LEN};
  }
  
  
  =item static (o)
  
  Defines the static target.
  
  =cut
  
  sub static {
  # --- Static Loading Sections ---
  
      my($self) = shift;
      '
  ## $(INST_PM) has been moved to the all: target.
  ## It remains here for awhile to allow for old usage: "make static"
  static :: $(FIRST_MAKEFILE) $(INST_STATIC)
  	$(NOECHO) $(NOOP)
  ';
  }
  
  =item static_lib (o)
  
  Defines how to produce the *.a (or equivalent) files.
  
  =cut
  
  sub static_lib {
      my($self) = @_;
      return '' unless $self->has_link_code;
  
      my(@m);
      push(@m, <<'END');
  
  $(INST_STATIC) : $(OBJECT) $(MYEXTLIB) $(INST_ARCHAUTODIR)$(DFSEP).exists
  	$(RM_RF) $@
  END
  
      # If this extension has its own library (eg SDBM_File)
      # then copy that to $(INST_STATIC) and add $(OBJECT) into it.
      push(@m, <<'MAKE_FRAG') if $self->{MYEXTLIB};
  	$(CP) $(MYEXTLIB) "$@"
  MAKE_FRAG
  
      my $ar;
      if (exists $self->{FULL_AR} && -x $self->{FULL_AR}) {
          # Prefer the absolute pathed ar if available so that PATH
          # doesn't confuse us.  Perl itself is built with the full_ar.
          $ar = 'FULL_AR';
      } else {
          $ar = 'AR';
      }
      push @m, sprintf <<'MAKE_FRAG', $ar;
  	$(%s) $(AR_STATIC_ARGS) $@ $(OBJECT) && $(RANLIB) $@
  	$(CHMOD) $(PERM_RWX) $@
  	$(NOECHO) $(ECHO) "$(EXTRALIBS)" > "$(INST_ARCHAUTODIR)/extralibs.ld"
  MAKE_FRAG
  
      # Old mechanism - still available:
      push @m, <<'MAKE_FRAG' if $self->{PERL_SRC} && $self->{EXTRALIBS};
  	$(NOECHO) $(ECHO) "$(EXTRALIBS)" >> "$(PERL_SRC)/ext.libs"
  MAKE_FRAG
  
      join('', @m);
  }
  
  =item staticmake (o)
  
  Calls makeaperl.
  
  =cut
  
  sub staticmake {
      my($self, %attribs) = @_;
      my(@static);
  
      my(@searchdirs)=($self->{PERL_ARCHLIB}, $self->{SITEARCHEXP},  $self->{INST_ARCHLIB});
  
      # And as it's not yet built, we add the current extension
      # but only if it has some C code (or XS code, which implies C code)
      if (@{$self->{C}}) {
  	@static = $self->catfile($self->{INST_ARCHLIB},
  				 "auto",
  				 $self->{FULLEXT},
  				 "$self->{BASEEXT}$self->{LIB_EXT}"
  				);
      }
  
      # Either we determine now, which libraries we will produce in the
      # subdirectories or we do it at runtime of the make.
  
      # We could ask all subdir objects, but I cannot imagine, why it
      # would be necessary.
  
      # Instead we determine all libraries for the new perl at
      # runtime.
      my(@perlinc) = ($self->{INST_ARCHLIB}, $self->{INST_LIB}, $self->{PERL_ARCHLIB}, $self->{PERL_LIB});
  
      $self->makeaperl(MAKE	=> $self->{MAKEFILE},
  		     DIRS	=> \@searchdirs,
  		     STAT	=> \@static,
  		     INCL	=> \@perlinc,
  		     TARGET	=> $self->{MAP_TARGET},
  		     TMP	=> "",
  		     LIBPERL	=> $self->{LIBPERL_A}
  		    );
  }
  
  =item subdir_x (o)
  
  Helper subroutine for subdirs
  
  =cut
  
  sub subdir_x {
      my($self, $subdir) = @_;
  
      my $subdir_cmd = $self->cd($subdir,
        '$(MAKE) $(USEMAKEFILE) $(FIRST_MAKEFILE) all $(PASTHRU)'
      );
      return sprintf <<'EOT', $subdir_cmd;
  
  subdirs ::
  	$(NOECHO) %s
  EOT
  
  }
  
  =item subdirs (o)
  
  Defines targets to process subdirectories.
  
  =cut
  
  sub subdirs {
  # --- Sub-directory Sections ---
      my($self) = shift;
      my(@m);
      # This method provides a mechanism to automatically deal with
      # subdirectories containing further Makefile.PL scripts.
      # It calls the subdir_x() method for each subdirectory.
      foreach my $dir (@{$self->{DIR}}){
  	push(@m, $self->subdir_x($dir));
  ####	print "Including $dir subdirectory\n";
      }
      if (@m){
  	unshift(@m, "
  # The default clean, realclean and test targets in this Makefile
  # have automatically been given entries for each subdir.
  
  ");
      } else {
  	push(@m, "\n# none")
      }
      join('',@m);
  }
  
  =item test (o)
  
  Defines the test targets.
  
  =cut
  
  sub test {
  # --- Test and Installation Sections ---
  
      my($self, %attribs) = @_;
      my $tests = $attribs{TESTS} || '';
      if (!$tests && -d 't' && defined $attribs{RECURSIVE_TEST_FILES}) {
          $tests = $self->find_tests_recursive;
      }
      elsif (!$tests && -d 't') {
          $tests = $self->find_tests;
      }
      # have to do this because nmake is broken
      $tests =~ s!/!\\!g if $self->is_make_type('nmake');
      # note: 'test.pl' name is also hardcoded in init_dirscan()
      my(@m);
      push(@m,"
  TEST_VERBOSE=0
  TEST_TYPE=test_\$(LINKTYPE)
  TEST_FILE = test.pl
  TEST_FILES = $tests
  TESTDB_SW = -d
  
  testdb :: testdb_\$(LINKTYPE)
  
  test :: \$(TEST_TYPE) subdirs-test
  
  subdirs-test ::
  	\$(NOECHO) \$(NOOP)
  
  ");
  
      foreach my $dir (@{ $self->{DIR} }) {
          my $test = $self->cd($dir, '$(MAKE) test $(PASTHRU)');
  
          push @m, <<END
  subdirs-test ::
  	\$(NOECHO) $test
  
  END
      }
  
      push(@m, "\t\$(NOECHO) \$(ECHO) 'No tests defined for \$(NAME) extension.'\n")
  	unless $tests or -f "test.pl" or @{$self->{DIR}};
      push(@m, "\n");
  
      push(@m, "test_dynamic :: pure_all\n");
      push(@m, $self->test_via_harness('$(FULLPERLRUN)', '$(TEST_FILES)'))
        if $tests;
      push(@m, $self->test_via_script('$(FULLPERLRUN)', '$(TEST_FILE)'))
        if -f "test.pl";
      push(@m, "\n");
  
      push(@m, "testdb_dynamic :: pure_all\n");
      push(@m, $self->test_via_script('$(FULLPERLRUN) $(TESTDB_SW)',
                                      '$(TEST_FILE)'));
      push(@m, "\n");
  
      # Occasionally we may face this degenerate target:
      push @m, "test_ : test_dynamic\n\n";
  
      if ($self->needs_linking()) {
  	push(@m, "test_static :: pure_all \$(MAP_TARGET)\n");
  	push(@m, $self->test_via_harness('./$(MAP_TARGET)', '$(TEST_FILES)')) if $tests;
  	push(@m, $self->test_via_script('./$(MAP_TARGET)', '$(TEST_FILE)')) if -f "test.pl";
  	push(@m, "\n");
  	push(@m, "testdb_static :: pure_all \$(MAP_TARGET)\n");
  	push(@m, $self->test_via_script('./$(MAP_TARGET) $(TESTDB_SW)', '$(TEST_FILE)'));
  	push(@m, "\n");
      } else {
  	push @m, "test_static :: test_dynamic\n";
  	push @m, "testdb_static :: testdb_dynamic\n";
      }
      join("", @m);
  }
  
  =item test_via_harness (override)
  
  For some reason which I forget, Unix machines like to have
  PERL_DL_NONLAZY set for tests.
  
  =cut
  
  sub test_via_harness {
      my($self, $perl, $tests) = @_;
      return $self->SUPER::test_via_harness("PERL_DL_NONLAZY=1 $perl", $tests);
  }
  
  =item test_via_script (override)
  
  Again, the PERL_DL_NONLAZY thing.
  
  =cut
  
  sub test_via_script {
      my($self, $perl, $script) = @_;
      return $self->SUPER::test_via_script("PERL_DL_NONLAZY=1 $perl", $script);
  }
  
  
  =item tool_xsubpp (o)
  
  Determines typemaps, xsubpp version, prototype behaviour.
  
  =cut
  
  sub tool_xsubpp {
      my($self) = shift;
      return "" unless $self->needs_linking;
  
      my $xsdir;
      my @xsubpp_dirs = @INC;
  
      # Make sure we pick up the new xsubpp if we're building perl.
      unshift @xsubpp_dirs, $self->{PERL_LIB} if $self->{PERL_CORE};
  
      my $foundxsubpp = 0;
      foreach my $dir (@xsubpp_dirs) {
          $xsdir = $self->catdir($dir, 'ExtUtils');
          if( -r $self->catfile($xsdir, "xsubpp") ) {
              $foundxsubpp = 1;
              last;
          }
      }
      die "ExtUtils::MM_Unix::tool_xsubpp : Can't find xsubpp" if !$foundxsubpp;
  
      my $tmdir   = File::Spec->catdir($self->{PERL_LIB},"ExtUtils");
      my(@tmdeps) = $self->catfile($tmdir,'typemap');
      if( $self->{TYPEMAPS} ){
          foreach my $typemap (@{$self->{TYPEMAPS}}){
              if( ! -f  $typemap ) {
                  warn "Typemap $typemap not found.\n";
              }
              else {
                  push(@tmdeps,  $typemap);
              }
          }
      }
      push(@tmdeps, "typemap") if -f "typemap";
      my @tmargs = map(qq{-typemap "$_"}, @tmdeps);
      $_ = $self->quote_dep($_) for @tmdeps;
      if( exists $self->{XSOPT} ){
          unshift( @tmargs, $self->{XSOPT} );
      }
  
      if ($Is{VMS}                          &&
          $Config{'ldflags'}               &&
          $Config{'ldflags'} =~ m!/Debug!i &&
          (!exists($self->{XSOPT}) || $self->{XSOPT} !~ /linenumbers/)
         )
      {
          unshift(@tmargs,'-nolinenumbers');
      }
  
  
      $self->{XSPROTOARG} = "" unless defined $self->{XSPROTOARG};
      my $xsdirdep = $self->quote_dep($xsdir);
      # -dep for use when dependency not command
  
      return qq{
  XSUBPPDIR = $xsdir
  XSUBPP = "\$(XSUBPPDIR)\$(DFSEP)xsubpp"
  XSUBPPRUN = \$(PERLRUN) \$(XSUBPP)
  XSPROTOARG = $self->{XSPROTOARG}
  XSUBPPDEPS = @tmdeps $xsdirdep\$(DFSEP)xsubpp
  XSUBPPARGS = @tmargs
  XSUBPP_EXTRA_ARGS =
  };
  }
  
  
  =item all_target
  
  Build man pages, too
  
  =cut
  
  sub all_target {
      my $self = shift;
  
      return <<'MAKE_EXT';
  all :: pure_all manifypods
  	$(NOECHO) $(NOOP)
  MAKE_EXT
  }
  
  =item top_targets (o)
  
  Defines the targets all, subdirs, config, and O_FILES
  
  =cut
  
  sub top_targets {
  # --- Target Sections ---
  
      my($self) = shift;
      my(@m);
  
      push @m, $self->all_target, "\n" unless $self->{SKIPHASH}{'all'};
  
      push @m, '
  pure_all :: config pm_to_blib subdirs linkext
  	$(NOECHO) $(NOOP)
  
  subdirs :: $(MYEXTLIB)
  	$(NOECHO) $(NOOP)
  
  config :: $(FIRST_MAKEFILE) blibdirs
  	$(NOECHO) $(NOOP)
  ';
  
      push @m, '
  $(O_FILES): $(H_FILES)
  ' if @{$self->{O_FILES} || []} && @{$self->{H} || []};
  
      push @m, q{
  help :
  	perldoc ExtUtils::MakeMaker
  };
  
      join('',@m);
  }
  
  =item writedoc
  
  Obsolete, deprecated method. Not used since Version 5.21.
  
  =cut
  
  sub writedoc {
  # --- perllocal.pod section ---
      my($self,$what,$name,@attribs)=@_;
      my $time = localtime;
      print "=head2 $time: $what C<$name>\n\n=over 4\n\n=item *\n\n";
      print join "\n\n=item *\n\n", map("C<$_>",@attribs);
      print "\n\n=back\n\n";
  }
  
  =item xs_c (o)
  
  Defines the suffix rules to compile XS files to C.
  
  =cut
  
  sub xs_c {
      my($self) = shift;
      return '' unless $self->needs_linking();
      '
  .xs.c:
  	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $(XSUBPP_EXTRA_ARGS) $*.xs > $*.xsc && $(MV) $*.xsc $*.c
  ';
  }
  
  =item xs_cpp (o)
  
  Defines the suffix rules to compile XS files to C++.
  
  =cut
  
  sub xs_cpp {
      my($self) = shift;
      return '' unless $self->needs_linking();
      '
  .xs.cpp:
  	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.xsc && $(MV) $*.xsc $*.cpp
  ';
  }
  
  =item xs_o (o)
  
  Defines suffix rules to go from XS to object files directly. This is
  only intended for broken make implementations.
  
  =cut
  
  sub xs_o {	# many makes are too dumb to use xs_c then c_o
      my($self) = shift;
      return '' unless $self->needs_linking();
      '
  .xs$(OBJ_EXT):
  	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.xsc && $(MV) $*.xsc $*.c
  	$(CCCMD) $(CCCDLFLAGS) "-I$(PERL_INC)" $(PASTHRU_DEFINE) $(DEFINE) $*.c
  ';
  }
  
  
  1;
  
  =back
  
  =head1 SEE ALSO
  
  L<ExtUtils::MakeMaker>
  
  =cut
  
  __END__
PERL5_EXTUTILS_MM_UNIX

$fatpacked{"perl5/ExtUtils/MM_VMS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_EXTUTILS_MM_VMS';
  package ExtUtils::MM_VMS;
  
  use strict;
  
  use ExtUtils::MakeMaker::Config;
  require Exporter;
  
  BEGIN {
      # so we can compile the thing on non-VMS platforms.
      if( $^O eq 'VMS' ) {
          require VMS::Filespec;
          VMS::Filespec->import;
      }
  }
  
  use File::Basename;
  
  our $VERSION = '7.10';
  
  require ExtUtils::MM_Any;
  require ExtUtils::MM_Unix;
  our @ISA = qw( ExtUtils::MM_Any ExtUtils::MM_Unix );
  
  use ExtUtils::MakeMaker qw($Verbose neatvalue);
  our $Revision = $ExtUtils::MakeMaker::Revision;
  
  
  =head1 NAME
  
  ExtUtils::MM_VMS - methods to override UN*X behaviour in ExtUtils::MakeMaker
  
  =head1 SYNOPSIS
  
    Do not use this directly.
    Instead, use ExtUtils::MM and it will figure out which MM_*
    class to use for you.
  
  =head1 DESCRIPTION
  
  See ExtUtils::MM_Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  =head2 Methods always loaded
  
  =over 4
  
  =item wraplist
  
  Converts a list into a string wrapped at approximately 80 columns.
  
  =cut
  
  sub wraplist {
      my($self) = shift;
      my($line,$hlen) = ('',0);
  
      foreach my $word (@_) {
        # Perl bug -- seems to occasionally insert extra elements when
        # traversing array (scalar(@array) doesn't show them, but
        # foreach(@array) does) (5.00307)
        next unless $word =~ /\w/;
        $line .= ' ' if length($line);
        if ($hlen > 80) { $line .= "\\\n\t"; $hlen = 0; }
        $line .= $word;
        $hlen += length($word) + 2;
      }
      $line;
  }
  
  
  # This isn't really an override.  It's just here because ExtUtils::MM_VMS
  # appears in @MM::ISA before ExtUtils::Liblist::Kid, so if there isn't an ext()
  # in MM_VMS, then AUTOLOAD is called, and bad things happen.  So, we just
  # mimic inheritance here and hand off to ExtUtils::Liblist::Kid.
  # XXX This hackery will die soon. --Schwern
  sub ext {
      require ExtUtils::Liblist::Kid;
      goto &ExtUtils::Liblist::Kid::ext;
  }
  
  =back
  
  =head2 Methods
  
  Those methods which override default MM_Unix methods are marked
  "(override)", while methods unique to MM_VMS are marked "(specific)".
  For overridden methods, documentation is limited to an explanation
  of why this method overrides the MM_Unix method; see the ExtUtils::MM_Unix
  documentation for more details.
  
  =over 4
  
  =item guess_name (override)
  
  Try to determine name of extension being built.  We begin with the name
  of the current directory.  Since VMS filenames are case-insensitive,
  however, we look for a F<.pm> file whose name matches that of the current
  directory (presumably the 'main' F<.pm> file for this extension), and try
  to find a C<package> statement from which to obtain the Mixed::Case
  package name.
  
  =cut
  
  sub guess_name {
      my($self) = @_;
      my($defname,$defpm,@pm,%xs);
      local *PM;
  
      $defname = basename(fileify($ENV{'DEFAULT'}));
      $defname =~ s![\d\-_]*\.dir.*$!!;  # Clip off .dir;1 suffix, and package version
      $defpm = $defname;
      # Fallback in case for some reason a user has copied the files for an
      # extension into a working directory whose name doesn't reflect the
      # extension's name.  We'll use the name of a unique .pm file, or the
      # first .pm file with a matching .xs file.
      if (not -e "${defpm}.pm") {
        @pm = glob('*.pm');
        s/.pm$// for @pm;
        if (@pm == 1) { ($defpm = $pm[0]) =~ s/.pm$//; }
        elsif (@pm) {
          %xs = map { s/.xs$//; ($_,1) } glob('*.xs');  ## no critic
          if (keys %xs) {
              foreach my $pm (@pm) {
                  $defpm = $pm, last if exists $xs{$pm};
              }
          }
        }
      }
      if (open(my $pm, '<', "${defpm}.pm")){
          while (<$pm>) {
              if (/^\s*package\s+([^;]+)/i) {
                  $defname = $1;
                  last;
              }
          }
          print "Warning (non-fatal): Couldn't find package name in ${defpm}.pm;\n\t",
                       "defaulting package name to $defname\n"
              if eof($pm);
          close $pm;
      }
      else {
          print "Warning (non-fatal): Couldn't find ${defpm}.pm;\n\t",
                       "defaulting package name to $defname\n";
      }
      $defname =~ s#[\d.\-_]+$##;
      $defname;
  }
  
  =item find_perl (override)
  
  Use VMS file specification syntax and CLI commands to find and
  invoke Perl images.
  
  =cut
  
  sub find_perl {
      my($self, $ver, $names, $dirs, $trace) = @_;
      my($vmsfile,@sdirs,@snames,@cand);
      my($rslt);
      my($inabs) = 0;
      local *TCF;
  
      if( $self->{PERL_CORE} ) {
          # Check in relative directories first, so we pick up the current
          # version of Perl if we're running MakeMaker as part of the main build.
          @sdirs = sort { my($absa) = $self->file_name_is_absolute($a);
                          my($absb) = $self->file_name_is_absolute($b);
                          if ($absa && $absb) { return $a cmp $b }
                          else { return $absa ? 1 : ($absb ? -1 : ($a cmp $b)); }
                        } @$dirs;
          # Check miniperl before perl, and check names likely to contain
          # version numbers before "generic" names, so we pick up an
          # executable that's less likely to be from an old installation.
          @snames = sort { my($ba) = $a =~ m!([^:>\]/]+)$!;  # basename
                           my($bb) = $b =~ m!([^:>\]/]+)$!;
                           my($ahasdir) = (length($a) - length($ba) > 0);
                           my($bhasdir) = (length($b) - length($bb) > 0);
                           if    ($ahasdir and not $bhasdir) { return 1; }
                           elsif ($bhasdir and not $ahasdir) { return -1; }
                           else { $bb =~ /\d/ <=> $ba =~ /\d/
                                    or substr($ba,0,1) cmp substr($bb,0,1)
                                    or length($bb) <=> length($ba) } } @$names;
      }
      else {
          @sdirs  = @$dirs;
          @snames = @$names;
      }
  
      # Image names containing Perl version use '_' instead of '.' under VMS
      s/\.(\d+)$/_$1/ for @snames;
      if ($trace >= 2){
          print "Looking for perl $ver by these names:\n";
          print "\t@snames,\n";
          print "in these dirs:\n";
          print "\t@sdirs\n";
      }
      foreach my $dir (@sdirs){
          next unless defined $dir; # $self->{PERL_SRC} may be undefined
          $inabs++ if $self->file_name_is_absolute($dir);
          if ($inabs == 1) {
              # We've covered relative dirs; everything else is an absolute
              # dir (probably an installed location).  First, we'll try
              # potential command names, to see whether we can avoid a long
              # MCR expression.
              foreach my $name (@snames) {
                  push(@cand,$name) if $name =~ /^[\w\-\$]+$/;
              }
              $inabs++; # Should happen above in next $dir, but just in case...
          }
          foreach my $name (@snames){
              push @cand, ($name !~ m![/:>\]]!) ? $self->catfile($dir,$name)
                                                : $self->fixpath($name,0);
          }
      }
      foreach my $name (@cand) {
          print "Checking $name\n" if $trace >= 2;
          # If it looks like a potential command, try it without the MCR
          if ($name =~ /^[\w\-\$]+$/) {
              open(my $tcf, ">", "temp_mmvms.com")
                  or die('unable to open temp file');
              print $tcf "\$ set message/nofacil/nosever/noident/notext\n";
              print $tcf "\$ $name -e \"require $ver; print \"\"VER_OK\\n\"\"\"\n";
              close $tcf;
              $rslt = `\@temp_mmvms.com` ;
              unlink('temp_mmvms.com');
              if ($rslt =~ /VER_OK/) {
                  print "Using PERL=$name\n" if $trace;
                  return $name;
              }
          }
          next unless $vmsfile = $self->maybe_command($name);
          $vmsfile =~ s/;[\d\-]*$//;  # Clip off version number; we can use a newer version as well
          print "Executing $vmsfile\n" if ($trace >= 2);
          open(my $tcf, '>', "temp_mmvms.com")
                  or die('unable to open temp file');
          print $tcf "\$ set message/nofacil/nosever/noident/notext\n";
          print $tcf "\$ mcr $vmsfile -e \"require $ver; print \"\"VER_OK\\n\"\"\" \n";
          close $tcf;
          $rslt = `\@temp_mmvms.com`;
          unlink('temp_mmvms.com');
          if ($rslt =~ /VER_OK/) {
              print "Using PERL=MCR $vmsfile\n" if $trace;
              return "MCR $vmsfile";
          }
      }
      print "Unable to find a perl $ver (by these names: @$names, in these dirs: @$dirs)\n";
      0; # false and not empty
  }
  
  =item _fixin_replace_shebang (override)
  
  Helper routine for MM->fixin(), overridden because there's no such thing as an
  actual shebang line that will be interpreted by the shell, so we just prepend
  $Config{startperl} and preserve the shebang line argument for any switches it
  may contain.
  
  =cut
  
  sub _fixin_replace_shebang {
      my ( $self, $file, $line ) = @_;
  
      my ( undef, $arg ) = split ' ', $line, 2;
  
      return $Config{startperl} . "\n" . $Config{sharpbang} . "perl $arg\n";
  }
  
  =item maybe_command (override)
  
  Follows VMS naming conventions for executable files.
  If the name passed in doesn't exactly match an executable file,
  appends F<.Exe> (or equivalent) to check for executable image, and F<.Com>
  to check for DCL procedure.  If this fails, checks directories in DCL$PATH
  and finally F<Sys$System:> for an executable file having the name specified,
  with or without the F<.Exe>-equivalent suffix.
  
  =cut
  
  sub maybe_command {
      my($self,$file) = @_;
      return $file if -x $file && ! -d _;
      my(@dirs) = ('');
      my(@exts) = ('',$Config{'exe_ext'},'.exe','.com');
  
      if ($file !~ m![/:>\]]!) {
          for (my $i = 0; defined $ENV{"DCL\$PATH;$i"}; $i++) {
              my $dir = $ENV{"DCL\$PATH;$i"};
              $dir .= ':' unless $dir =~ m%[\]:]$%;
              push(@dirs,$dir);
          }
          push(@dirs,'Sys$System:');
          foreach my $dir (@dirs) {
              my $sysfile = "$dir$file";
              foreach my $ext (@exts) {
                  return $file if -x "$sysfile$ext" && ! -d _;
              }
          }
      }
      return 0;
  }
  
  
  =item pasthru (override)
  
  VMS has $(MMSQUALIFIERS) which is a listing of all the original command line
  options.  This is used in every invocation of make in the VMS Makefile so
  PASTHRU should not be necessary.  Using PASTHRU tends to blow commands past
  the 256 character limit.
  
  =cut
  
  sub pasthru {
      return "PASTHRU=\n";
  }
  
  
  =item pm_to_blib (override)
  
  VMS wants a dot in every file so we can't have one called 'pm_to_blib',
  it becomes 'pm_to_blib.' and MMS/K isn't smart enough to know that when
  you have a target called 'pm_to_blib' it should look for 'pm_to_blib.'.
  
  So in VMS its pm_to_blib.ts.
  
  =cut
  
  sub pm_to_blib {
      my $self = shift;
  
      my $make = $self->SUPER::pm_to_blib;
  
      $make =~ s{^pm_to_blib :}{pm_to_blib.ts :}m;
      $make =~ s{\$\(TOUCH\) pm_to_blib}{\$(TOUCH) pm_to_blib.ts};
  
      $make = <<'MAKE' . $make;
  # Dummy target to match Unix target name; we use pm_to_blib.ts as
  # timestamp file to avoid repeated invocations under VMS
  pm_to_blib : pm_to_blib.ts
  	$(NOECHO) $(NOOP)
  
  MAKE
  
      return $make;
  }
  
  
  =item perl_script (override)
  
  If name passed in doesn't specify a readable file, appends F<.com> or
  F<.pl> and tries again, since it's customary to have file types on all files
  under VMS.
  
  =cut
  
  sub perl_script {
      my($self,$file) = @_;
      return $file if -r $file && ! -d _;
      return "$file.com" if -r "$file.com";
      return "$file.pl" if -r "$file.pl";
      return '';
  }
  
  
  =item replace_manpage_separator
  
  Use as separator a character which is legal in a VMS-syntax file name.
  
  =cut
  
  sub replace_manpage_separator {
      my($self,$man) = @_;
      $man = unixify($man);
      $man =~ s#/+#__#g;
      $man;
  }
  
  =item init_DEST
  
  (override) Because of the difficulty concatenating VMS filepaths we
  must pre-expand the DEST* variables.
  
  =cut
  
  sub init_DEST {
      my $self = shift;
  
      $self->SUPER::init_DEST;
  
      # Expand DEST variables.
      foreach my $var ($self->installvars) {
          my $destvar = 'DESTINSTALL'.$var;
          $self->{$destvar} = $self->eliminate_macros($self->{$destvar});
      }
  }
  
  
  =item init_DIRFILESEP
  
  No separator between a directory path and a filename on VMS.
  
  =cut
  
  sub init_DIRFILESEP {
      my($self) = shift;
  
      $self->{DIRFILESEP} = '';
      return 1;
  }
  
  
  =item init_main (override)
  
  
  =cut
  
  sub init_main {
      my($self) = shift;
  
      $self->SUPER::init_main;
  
      $self->{DEFINE} ||= '';
      if ($self->{DEFINE} ne '') {
          my(@terms) = split(/\s+/,$self->{DEFINE});
          my(@defs,@udefs);
          foreach my $def (@terms) {
              next unless $def;
              my $targ = \@defs;
              if ($def =~ s/^-([DU])//) {    # If it was a Unix-style definition
                  $targ = \@udefs if $1 eq 'U';
                  $def =~ s/='(.*)'$/=$1/;  # then remove shell-protection ''
                  $def =~ s/^'(.*)'$/$1/;   # from entire term or argument
              }
              if ($def =~ /=/) {
                  $def =~ s/"/""/g;  # Protect existing " from DCL
                  $def = qq["$def"]; # and quote to prevent parsing of =
              }
              push @$targ, $def;
          }
  
          $self->{DEFINE} = '';
          if (@defs)  {
              $self->{DEFINE}  = '/Define=(' . join(',',@defs)  . ')';
          }
          if (@udefs) {
              $self->{DEFINE} .= '/Undef=('  . join(',',@udefs) . ')';
          }
      }
  }
  
  =item init_tools (override)
  
  Provide VMS-specific forms of various utility commands.
  
  Sets DEV_NULL to nothing because I don't know how to do it on VMS.
  
  Changes EQUALIZE_TIMESTAMP to set revision date of target file to
  one second later than source file, since MMK interprets precisely
  equal revision dates for a source and target file as a sign that the
  target needs to be updated.
  
  =cut
  
  sub init_tools {
      my($self) = @_;
  
      $self->{NOOP}               = 'Continue';
      $self->{NOECHO}             ||= '@ ';
  
      $self->{MAKEFILE}           ||= $self->{FIRST_MAKEFILE} || 'Descrip.MMS';
      $self->{FIRST_MAKEFILE}     ||= $self->{MAKEFILE};
      $self->{MAKE_APERL_FILE}    ||= 'Makeaperl.MMS';
      $self->{MAKEFILE_OLD}       ||= $self->eliminate_macros('$(FIRST_MAKEFILE)_old');
  #
  #   If an extension is not specified, then MMS/MMK assumes an
  #   an extension of .MMS.  If there really is no extension,
  #   then a trailing "." needs to be appended to specify a
  #   a null extension.
  #
      $self->{MAKEFILE} .= '.' unless $self->{MAKEFILE} =~ m/\./;
      $self->{FIRST_MAKEFILE} .= '.' unless $self->{FIRST_MAKEFILE} =~ m/\./;
      $self->{MAKE_APERL_FILE} .= '.' unless $self->{MAKE_APERL_FILE} =~ m/\./;
      $self->{MAKEFILE_OLD} .= '.' unless $self->{MAKEFILE_OLD} =~ m/\./;
  
      $self->{MACROSTART}         ||= '/Macro=(';
      $self->{MACROEND}           ||= ')';
      $self->{USEMAKEFILE}        ||= '/Descrip=';
  
      $self->{EQUALIZE_TIMESTAMP} ||= '$(ABSPERLRUN) -we "open F,qq{>>$ARGV[1]};close F;utime(0,(stat($ARGV[0]))[9]+1,$ARGV[1])"';
  
      $self->{MOD_INSTALL} ||=
        $self->oneliner(<<'CODE', ['-MExtUtils::Install']);
  install([ from_to => {split('\|', <STDIN>)}, verbose => '$(VERBINST)', uninstall_shadows => '$(UNINST)', dir_mode => '$(PERM_DIR)' ]);
  CODE
  
      $self->{UMASK_NULL} = '! ';
  
      $self->SUPER::init_tools;
  
      # Use the default shell
      $self->{SHELL}    ||= 'Posix';
  
      # Redirection on VMS goes before the command, not after as on Unix.
      # $(DEV_NULL) is used once and its not worth going nuts over making
      # it work.  However, Unix's DEV_NULL is quite wrong for VMS.
      $self->{DEV_NULL}   = '';
  
      return;
  }
  
  =item init_platform (override)
  
  Add PERL_VMS, MM_VMS_REVISION and MM_VMS_VERSION.
  
  MM_VMS_REVISION is for backwards compatibility before MM_VMS had a
  $VERSION.
  
  =cut
  
  sub init_platform {
      my($self) = shift;
  
      $self->{MM_VMS_REVISION} = $Revision;
      $self->{MM_VMS_VERSION}  = $VERSION;
      $self->{PERL_VMS} = $self->catdir($self->{PERL_SRC}, 'VMS')
        if $self->{PERL_SRC};
  }
  
  
  =item platform_constants
  
  =cut
  
  sub platform_constants {
      my($self) = shift;
      my $make_frag = '';
  
      foreach my $macro (qw(PERL_VMS MM_VMS_REVISION MM_VMS_VERSION))
      {
          next unless defined $self->{$macro};
          $make_frag .= "$macro = $self->{$macro}\n";
      }
  
      return $make_frag;
  }
  
  
  =item init_VERSION (override)
  
  Override the *DEFINE_VERSION macros with VMS semantics.  Translate the
  MAKEMAKER filepath to VMS style.
  
  =cut
  
  sub init_VERSION {
      my $self = shift;
  
      $self->SUPER::init_VERSION;
  
      $self->{DEFINE_VERSION}    = '"$(VERSION_MACRO)=""$(VERSION)"""';
      $self->{XS_DEFINE_VERSION} = '"$(XS_VERSION_MACRO)=""$(XS_VERSION)"""';
      $self->{MAKEMAKER} = vmsify($INC{'ExtUtils/MakeMaker.pm'});
  }
  
  
  =item constants (override)
  
  Fixes up numerous file and directory macros to insure VMS syntax
  regardless of input syntax.  Also makes lists of files
  comma-separated.
  
  =cut
  
  sub constants {
      my($self) = @_;
  
      # Be kind about case for pollution
      for (@ARGV) { $_ = uc($_) if /POLLUTE/i; }
  
      # Cleanup paths for directories in MMS macros.
      foreach my $macro ( qw [
              INST_BIN INST_SCRIPT INST_LIB INST_ARCHLIB
              PERL_LIB PERL_ARCHLIB
              PERL_INC PERL_SRC ],
                          (map { 'INSTALL'.$_ } $self->installvars)
                        )
      {
          next unless defined $self->{$macro};
          next if $macro =~ /MAN/ && $self->{$macro} eq 'none';
          $self->{$macro} = $self->fixpath($self->{$macro},1);
      }
  
      # Cleanup paths for files in MMS macros.
      foreach my $macro ( qw[LIBPERL_A FIRST_MAKEFILE MAKEFILE_OLD
                             MAKE_APERL_FILE MYEXTLIB] )
      {
          next unless defined $self->{$macro};
          $self->{$macro} = $self->fixpath($self->{$macro},0);
      }
  
      # Fixup files for MMS macros
      # XXX is this list complete?
      for my $macro (qw/
                     FULLEXT VERSION_FROM
  	      /	) {
          next unless defined $self->{$macro};
          $self->{$macro} = $self->fixpath($self->{$macro},0);
      }
  
  
      for my $macro (qw/
                     OBJECT LDFROM
  	      /	) {
          next unless defined $self->{$macro};
  
          # Must expand macros before splitting on unescaped whitespace.
          $self->{$macro} = $self->eliminate_macros($self->{$macro});
          if ($self->{$macro} =~ /(?<!\^)\s/) {
              $self->{$macro} =~ s/(\\)?\n+\s+/ /g;
              $self->{$macro} = $self->wraplist(
                  map $self->fixpath($_,0), split /,?(?<!\^)\s+/, $self->{$macro}
              );
          }
          else {
              $self->{$macro} = $self->fixpath($self->{$macro},0);
          }
      }
  
      for my $macro (qw/ XS MAN1PODS MAN3PODS PM /) {
          # Where is the space coming from? --jhi
          next unless $self ne " " && defined $self->{$macro};
          my %tmp = ();
          for my $key (keys %{$self->{$macro}}) {
              $tmp{$self->fixpath($key,0)} =
                                       $self->fixpath($self->{$macro}{$key},0);
          }
          $self->{$macro} = \%tmp;
      }
  
      for my $macro (qw/ C O_FILES H /) {
          next unless defined $self->{$macro};
          my @tmp = ();
          for my $val (@{$self->{$macro}}) {
              push(@tmp,$self->fixpath($val,0));
          }
          $self->{$macro} = \@tmp;
      }
  
      # mms/k does not define a $(MAKE) macro.
      $self->{MAKE} = '$(MMS)$(MMSQUALIFIERS)';
  
      return $self->SUPER::constants;
  }
  
  
  =item special_targets
  
  Clear the default .SUFFIXES and put in our own list.
  
  =cut
  
  sub special_targets {
      my $self = shift;
  
      my $make_frag .= <<'MAKE_FRAG';
  .SUFFIXES :
  .SUFFIXES : $(OBJ_EXT) .c .cpp .cxx .xs
  
  MAKE_FRAG
  
      return $make_frag;
  }
  
  =item cflags (override)
  
  Bypass shell script and produce qualifiers for CC directly (but warn
  user if a shell script for this extension exists).  Fold multiple
  /Defines into one, since some C compilers pay attention to only one
  instance of this qualifier on the command line.
  
  =cut
  
  sub cflags {
      my($self,$libperl) = @_;
      my($quals) = $self->{CCFLAGS} || $Config{'ccflags'};
      my($definestr,$undefstr,$flagoptstr) = ('','','');
      my($incstr) = '/Include=($(PERL_INC)';
      my($name,$sys,@m);
  
      ( $name = $self->{NAME} . "_cflags" ) =~ s/:/_/g ;
      print "Unix shell script ".$Config{"$self->{'BASEEXT'}_cflags"}.
           " required to modify CC command for $self->{'BASEEXT'}\n"
      if ($Config{$name});
  
      if ($quals =~ / -[DIUOg]/) {
  	while ($quals =~ / -([Og])(\d*)\b/) {
  	    my($type,$lvl) = ($1,$2);
  	    $quals =~ s/ -$type$lvl\b\s*//;
  	    if ($type eq 'g') { $flagoptstr = '/NoOptimize'; }
  	    else { $flagoptstr = '/Optimize' . (defined($lvl) ? "=$lvl" : ''); }
  	}
  	while ($quals =~ / -([DIU])(\S+)/) {
  	    my($type,$def) = ($1,$2);
  	    $quals =~ s/ -$type$def\s*//;
  	    $def =~ s/"/""/g;
  	    if    ($type eq 'D') { $definestr .= qq["$def",]; }
  	    elsif ($type eq 'I') { $incstr .= ',' . $self->fixpath($def,1); }
  	    else                 { $undefstr  .= qq["$def",]; }
  	}
      }
      if (length $quals and $quals !~ m!/!) {
  	warn "MM_VMS: Ignoring unrecognized CCFLAGS elements \"$quals\"\n";
  	$quals = '';
      }
      $definestr .= q["PERL_POLLUTE",] if $self->{POLLUTE};
      if (length $definestr) { chop($definestr); $quals .= "/Define=($definestr)"; }
      if (length $undefstr)  { chop($undefstr);  $quals .= "/Undef=($undefstr)";   }
      # Deal with $self->{DEFINE} here since some C compilers pay attention
      # to only one /Define clause on command line, so we have to
      # conflate the ones from $Config{'ccflags'} and $self->{DEFINE}
      # ($self->{DEFINE} has already been VMSified in constants() above)
      if ($self->{DEFINE}) { $quals .= $self->{DEFINE}; }
      for my $type (qw(Def Undef)) {
  	my(@terms);
  	while ($quals =~ m:/${type}i?n?e?=([^/]+):ig) {
  		my $term = $1;
  		$term =~ s:^\((.+)\)$:$1:;
  		push @terms, $term;
  	    }
  	if ($type eq 'Def') {
  	    push @terms, qw[ $(DEFINE_VERSION) $(XS_DEFINE_VERSION) ];
  	}
  	if (@terms) {
  	    $quals =~ s:/${type}i?n?e?=[^/]+::ig;
  	    $quals .= "/${type}ine=(" . join(',',@terms) . ')';
  	}
      }
  
      $libperl or $libperl = $self->{LIBPERL_A} || "libperl.olb";
  
      # Likewise with $self->{INC} and /Include
      if ($self->{'INC'}) {
  	my(@includes) = split(/\s+/,$self->{INC});
  	foreach (@includes) {
  	    s/^-I//;
  	    $incstr .= ','.$self->fixpath($_,1);
  	}
      }
      $quals .= "$incstr)";
  #    $quals =~ s/,,/,/g; $quals =~ s/\(,/(/g;
      $self->{CCFLAGS} = $quals;
  
      $self->{PERLTYPE} ||= '';
  
      $self->{OPTIMIZE} ||= $flagoptstr || $Config{'optimize'};
      if ($self->{OPTIMIZE} !~ m!/!) {
  	if    ($self->{OPTIMIZE} =~ m!-g!) { $self->{OPTIMIZE} = '/Debug/NoOptimize' }
  	elsif ($self->{OPTIMIZE} =~ /-O(\d*)/) {
  	    $self->{OPTIMIZE} = '/Optimize' . (defined($1) ? "=$1" : '');
  	}
  	else {
  	    warn "MM_VMS: Can't parse OPTIMIZE \"$self->{OPTIMIZE}\"; using default\n" if length $self->{OPTIMIZE};
  	    $self->{OPTIMIZE} = '/Optimize';
  	}
      }
  
      return $self->{CFLAGS} = qq{
  CCFLAGS = $self->{CCFLAGS}
  OPTIMIZE = $self->{OPTIMIZE}
  PERLTYPE = $self->{PERLTYPE}
  };
  }
  
  =item const_cccmd (override)
  
  Adds directives to point C preprocessor to the right place when
  handling #include E<lt>sys/foo.hE<gt> directives.  Also constructs CC
  command line a bit differently than MM_Unix method.
  
  =cut
  
  sub const_cccmd {
      my($self,$libperl) = @_;
      my(@m);
  
      return $self->{CONST_CCCMD} if $self->{CONST_CCCMD};
      return '' unless $self->needs_linking();
      if ($Config{'vms_cc_type'} eq 'gcc') {
          push @m,'
  .FIRST
  	',$self->{NOECHO},'If F$TrnLnm("Sys").eqs."" Then Define/NoLog SYS GNU_CC_Include:[VMS]';
      }
      elsif ($Config{'vms_cc_type'} eq 'vaxc') {
          push @m,'
  .FIRST
  	',$self->{NOECHO},'If F$TrnLnm("Sys").eqs."" .and. F$TrnLnm("VAXC$Include").eqs."" Then Define/NoLog SYS Sys$Library
  	',$self->{NOECHO},'If F$TrnLnm("Sys").eqs."" .and. F$TrnLnm("VAXC$Include").nes."" Then Define/NoLog SYS VAXC$Include';
      }
      else {
          push @m,'
  .FIRST
  	',$self->{NOECHO},'If F$TrnLnm("Sys").eqs."" .and. F$TrnLnm("DECC$System_Include").eqs."" Then Define/NoLog SYS ',
  		($Config{'archname'} eq 'VMS_AXP' ? 'Sys$Library' : 'DECC$Library_Include'),'
  	',$self->{NOECHO},'If F$TrnLnm("Sys").eqs."" .and. F$TrnLnm("DECC$System_Include").nes."" Then Define/NoLog SYS DECC$System_Include';
      }
  
      push(@m, "\n\nCCCMD = $Config{'cc'} \$(CCFLAGS)\$(OPTIMIZE)\n");
  
      $self->{CONST_CCCMD} = join('',@m);
  }
  
  
  =item tools_other (override)
  
  Throw in some dubious extra macros for Makefile args.
  
  Also keep around the old $(SAY) macro in case somebody's using it.
  
  =cut
  
  sub tools_other {
      my($self) = @_;
  
      # XXX Are these necessary?  Does anyone override them?  They're longer
      # than just typing the literal string.
      my $extra_tools = <<'EXTRA_TOOLS';
  
  # Just in case anyone is using the old macro.
  USEMACROS = $(MACROSTART)
  SAY = $(ECHO)
  
  EXTRA_TOOLS
  
      return $self->SUPER::tools_other . $extra_tools;
  }
  
  =item init_dist (override)
  
  VMSish defaults for some values.
  
    macro         description                     default
  
    ZIPFLAGS      flags to pass to ZIP            -Vu
  
    COMPRESS      compression command to          gzip
                  use for tarfiles
    SUFFIX        suffix to put on                -gz
                  compressed files
  
    SHAR          shar command to use             vms_share
  
    DIST_DEFAULT  default target to use to        tardist
                  create a distribution
  
    DISTVNAME     Use VERSION_SYM instead of      $(DISTNAME)-$(VERSION_SYM)
                  VERSION for the name
  
  =cut
  
  sub init_dist {
      my($self) = @_;
      $self->{ZIPFLAGS}     ||= '-Vu';
      $self->{COMPRESS}     ||= 'gzip';
      $self->{SUFFIX}       ||= '-gz';
      $self->{SHAR}         ||= 'vms_share';
      $self->{DIST_DEFAULT} ||= 'zipdist';
  
      $self->SUPER::init_dist;
  
      $self->{DISTVNAME} = "$self->{DISTNAME}-$self->{VERSION_SYM}"
        unless $self->{ARGS}{DISTVNAME};
  
      return;
  }
  
  =item c_o (override)
  
  Use VMS syntax on command line.  In particular, $(DEFINE) and
  $(PERL_INC) have been pulled into $(CCCMD).  Also use MM[SK] macros.
  
  =cut
  
  sub c_o {
      my($self) = @_;
      return '' unless $self->needs_linking();
      '
  .c$(OBJ_EXT) :
  	$(CCCMD) $(CCCDLFLAGS) $(MMS$TARGET_NAME).c
  
  .cpp$(OBJ_EXT) :
  	$(CCCMD) $(CCCDLFLAGS) $(MMS$TARGET_NAME).cpp
  
  .cxx$(OBJ_EXT) :
  	$(CCCMD) $(CCCDLFLAGS) $(MMS$TARGET_NAME).cxx
  
  ';
  }
  
  =item xs_c (override)
  
  Use MM[SK] macros.
  
  =cut
  
  sub xs_c {
      my($self) = @_;
      return '' unless $self->needs_linking();
      '
  .xs.c :
  	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $(MMS$TARGET_NAME).xs >$(MMS$TARGET)
  ';
  }
  
  =item xs_o (override)
  
  Use MM[SK] macros, and VMS command line for C compiler.
  
  =cut
  
  sub xs_o {	# many makes are too dumb to use xs_c then c_o
      my($self) = @_;
      return '' unless $self->needs_linking();
      '
  .xs$(OBJ_EXT) :
  	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $(MMS$TARGET_NAME).xs >$(MMS$TARGET_NAME).c
  	$(CCCMD) $(CCCDLFLAGS) $(MMS$TARGET_NAME).c
  ';
  }
  
  
  =item dlsyms (override)
  
  Create VMS linker options files specifying universal symbols for this
  extension's shareable image, and listing other shareable images or
  libraries to which it should be linked.
  
  =cut
  
  sub dlsyms {
      my($self,%attribs) = @_;
  
      return '' unless $self->needs_linking();
  
      my($funcs) = $attribs{DL_FUNCS} || $self->{DL_FUNCS} || {};
      my($vars)  = $attribs{DL_VARS}  || $self->{DL_VARS}  || [];
      my($funclist)  = $attribs{FUNCLIST}  || $self->{FUNCLIST}  || [];
      my(@m);
  
      unless ($self->{SKIPHASH}{'dynamic'}) {
  	push(@m,'
  dynamic :: $(INST_ARCHAUTODIR)$(BASEEXT).opt
  	$(NOECHO) $(NOOP)
  ');
      }
  
      push(@m,'
  static :: $(INST_ARCHAUTODIR)$(BASEEXT).opt
  	$(NOECHO) $(NOOP)
  ') unless $self->{SKIPHASH}{'static'};
  
      push @m,'
  $(INST_ARCHAUTODIR)$(BASEEXT).opt : $(BASEEXT).opt
  	$(CP) $(MMS$SOURCE) $(MMS$TARGET)
  
  $(BASEEXT).opt : Makefile.PL
  	$(PERLRUN) -e "use ExtUtils::Mksymlists;" -
  	',qq[-e "Mksymlists('NAME' => '$self->{NAME}', 'DL_FUNCS' => ],
  	neatvalue($funcs),q[, 'DL_VARS' => ],neatvalue($vars),
  	q[, 'FUNCLIST' => ],neatvalue($funclist),qq[)"\n];
  
      push @m, '	$(PERL) -e "print ""$(INST_STATIC)/Include=';
      if ($self->{OBJECT} =~ /\bBASEEXT\b/ or
          $self->{OBJECT} =~ /\b$self->{BASEEXT}\b/i) {
          push @m, ($Config{d_vms_case_sensitive_symbols}
  	           ? uc($self->{BASEEXT}) :'$(BASEEXT)');
      }
      else {  # We don't have a "main" object file, so pull 'em all in
          # Upcase module names if linker is being case-sensitive
          my($upcase) = $Config{d_vms_case_sensitive_symbols};
          my(@omods) = split ' ', $self->eliminate_macros($self->{OBJECT});
          for (@omods) {
              s/\.[^.]*$//;         # Trim off file type
              s[\$\(\w+_EXT\)][];   # even as a macro
              s/.*[:>\/\]]//;       # Trim off dir spec
              $_ = uc if $upcase;
          };
  
          my(@lines);
          my $tmp = shift @omods;
          foreach my $elt (@omods) {
              $tmp .= ",$elt";
              if (length($tmp) > 80) { push @lines, $tmp;  $tmp = ''; }
          }
          push @lines, $tmp;
          push @m, '(', join( qq[, -\\n\\t"";" >>\$(MMS\$TARGET)\n\t\$(PERL) -e "print ""], @lines),')';
      }
      push @m, '\n$(INST_STATIC)/Library\n"";" >>$(MMS$TARGET)',"\n";
  
      if (length $self->{LDLOADLIBS}) {
          my($line) = '';
          foreach my $lib (split ' ', $self->{LDLOADLIBS}) {
              $lib =~ s%\$%\\\$%g;  # Escape '$' in VMS filespecs
              if (length($line) + length($lib) > 160) {
                  push @m, "\t\$(PERL) -e \"print qq{$line}\" >>\$(MMS\$TARGET)\n";
                  $line = $lib . '\n';
              }
              else { $line .= $lib . '\n'; }
          }
          push @m, "\t\$(PERL) -e \"print qq{$line}\" >>\$(MMS\$TARGET)\n" if $line;
      }
  
      join('',@m);
  
  }
  
  =item dynamic_lib (override)
  
  Use VMS Link command.
  
  =cut
  
  sub dynamic_lib {
      my($self, %attribs) = @_;
      return '' unless $self->needs_linking(); #might be because of a subdir
  
      return '' unless $self->has_link_code();
  
      my($otherldflags) = $attribs{OTHERLDFLAGS} || "";
      my($inst_dynamic_dep) = $attribs{INST_DYNAMIC_DEP} || "";
      my $shr = $Config{'dbgprefix'} . 'PerlShr';
      my(@m);
      push @m,"
  
  OTHERLDFLAGS = $otherldflags
  INST_DYNAMIC_DEP = $inst_dynamic_dep
  
  ";
      push @m, '
  $(INST_DYNAMIC) : $(INST_STATIC) $(PERL_INC)perlshr_attr.opt $(INST_ARCHAUTODIR)$(DFSEP).exists $(EXPORT_LIST) $(PERL_ARCHIVE) $(INST_DYNAMIC_DEP)
  	If F$TrnLNm("',$shr,'").eqs."" Then Define/NoLog/User ',"$shr Sys\$Share:$shr.$Config{'dlext'}",'
  	Link $(LDFLAGS) /Shareable=$(MMS$TARGET)$(OTHERLDFLAGS) $(BASEEXT).opt/Option,$(PERL_INC)perlshr_attr.opt/Option
  ';
  
      join('',@m);
  }
  
  
  =item static_lib (override)
  
  Use VMS commands to manipulate object library.
  
  =cut
  
  sub static_lib {
      my($self) = @_;
      return '' unless $self->needs_linking();
  
      return '
  $(INST_STATIC) :
  	$(NOECHO) $(NOOP)
  ' unless ($self->{OBJECT} or @{$self->{C} || []} or $self->{MYEXTLIB});
  
      my(@m);
      push @m,'
  # Rely on suffix rule for update action
  $(OBJECT) : $(INST_ARCHAUTODIR)$(DFSEP).exists
  
  $(INST_STATIC) : $(OBJECT) $(MYEXTLIB)
  ';
      # If this extension has its own library (eg SDBM_File)
      # then copy that to $(INST_STATIC) and add $(OBJECT) into it.
      push(@m, "\t",'$(CP) $(MYEXTLIB) $(MMS$TARGET)',"\n") if $self->{MYEXTLIB};
  
      push(@m,"\t",'If F$Search("$(MMS$TARGET)").eqs."" Then Library/Object/Create $(MMS$TARGET)',"\n");
  
      # if there was a library to copy, then we can't use MMS$SOURCE_LIST,
      # 'cause it's a library and you can't stick them in other libraries.
      # In that case, we use $OBJECT instead and hope for the best
      if ($self->{MYEXTLIB}) {
        push(@m,"\t",'Library/Object/Replace $(MMS$TARGET) $(OBJECT)',"\n");
      } else {
        push(@m,"\t",'Library/Object/Replace $(MMS$TARGET) $(MMS$SOURCE_LIST)',"\n");
      }
  
      push @m, "\t\$(NOECHO) \$(PERL) -e 1 >\$(INST_ARCHAUTODIR)extralibs.ld\n";
      foreach my $lib (split ' ', $self->{EXTRALIBS}) {
        push(@m,"\t",'$(NOECHO) $(PERL) -e "print qq{',$lib,'\n}" >>$(INST_ARCHAUTODIR)extralibs.ld',"\n");
      }
      join('',@m);
  }
  
  
  =item extra_clean_files
  
  Clean up some OS specific files.  Plus the temp file used to shorten
  a lot of commands.  And the name mangler database.
  
  =cut
  
  sub extra_clean_files {
      return qw(
                *.Map *.Dmp *.Lis *.cpp *.$(DLEXT) *.Opt $(BASEEXT).bso
                .MM_Tmp cxx_repository
               );
  }
  
  
  =item zipfile_target
  
  =item tarfile_target
  
  =item shdist_target
  
  Syntax for invoking shar, tar and zip differs from that for Unix.
  
  =cut
  
  sub zipfile_target {
      my($self) = shift;
  
      return <<'MAKE_FRAG';
  $(DISTVNAME).zip : distdir
  	$(PREOP)
  	$(ZIP) "$(ZIPFLAGS)" $(MMS$TARGET) [.$(DISTVNAME)...]*.*;
  	$(RM_RF) $(DISTVNAME)
  	$(POSTOP)
  MAKE_FRAG
  }
  
  sub tarfile_target {
      my($self) = shift;
  
      return <<'MAKE_FRAG';
  $(DISTVNAME).tar$(SUFFIX) : distdir
  	$(PREOP)
  	$(TO_UNIX)
          $(TAR) "$(TARFLAGS)" $(DISTVNAME).tar [.$(DISTVNAME)...]
  	$(RM_RF) $(DISTVNAME)
  	$(COMPRESS) $(DISTVNAME).tar
  	$(POSTOP)
  MAKE_FRAG
  }
  
  sub shdist_target {
      my($self) = shift;
  
      return <<'MAKE_FRAG';
  shdist : distdir
  	$(PREOP)
  	$(SHAR) [.$(DISTVNAME)...]*.*; $(DISTVNAME).share
  	$(RM_RF) $(DISTVNAME)
  	$(POSTOP)
  MAKE_FRAG
  }
  
  
  # --- Test and Installation Sections ---
  
  =item install (override)
  
  Work around DCL's 255 character limit several times,and use
  VMS-style command line quoting in a few cases.
  
  =cut
  
  sub install {
      my($self, %attribs) = @_;
      my(@m);
  
      push @m, q[
  install :: all pure_install doc_install
  	$(NOECHO) $(NOOP)
  
  install_perl :: all pure_perl_install doc_perl_install
  	$(NOECHO) $(NOOP)
  
  install_site :: all pure_site_install doc_site_install
  	$(NOECHO) $(NOOP)
  
  install_vendor :: all pure_vendor_install doc_vendor_install
  	$(NOECHO) $(NOOP)
  
  pure_install :: pure_$(INSTALLDIRS)_install
  	$(NOECHO) $(NOOP)
  
  doc_install :: doc_$(INSTALLDIRS)_install
          $(NOECHO) $(NOOP)
  
  pure__install : pure_site_install
  	$(NOECHO) $(ECHO) "INSTALLDIRS not defined, defaulting to INSTALLDIRS=site"
  
  doc__install : doc_site_install
  	$(NOECHO) $(ECHO) "INSTALLDIRS not defined, defaulting to INSTALLDIRS=site"
  
  # This hack brought to you by DCL's 255-character command line limit
  pure_perl_install ::
  ];
      push @m,
  q[	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'read|'.File::Spec->catfile('$(PERL_ARCHLIB)','auto','$(FULLEXT)','.packlist').'|'" >.MM_tmp
  	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'write|'.File::Spec->catfile('$(DESTINSTALLARCHLIB)','auto','$(FULLEXT)','.packlist').'|'" >>.MM_tmp
  ] unless $self->{NO_PACKLIST};
  
      push @m,
  q[	$(NOECHO) $(ECHO_N) "$(INST_LIB)|$(DESTINSTALLPRIVLIB)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_ARCHLIB)|$(DESTINSTALLARCHLIB)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_BIN)|$(DESTINSTALLBIN)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_SCRIPT)|$(DESTINSTALLSCRIPT)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_MAN1DIR) $(DESTINSTALLMAN1DIR) " >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_MAN3DIR)|$(DESTINSTALLMAN3DIR)" >>.MM_tmp
  	$(NOECHO) $(MOD_INSTALL) <.MM_tmp
  	$(NOECHO) $(RM_F) .MM_tmp
  	$(NOECHO) $(WARN_IF_OLD_PACKLIST) "].$self->catfile($self->{SITEARCHEXP},'auto',$self->{FULLEXT},'.packlist').q["
  
  # Likewise
  pure_site_install ::
  ];
      push @m,
  q[	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'read|'.File::Spec->catfile('$(SITEARCHEXP)','auto','$(FULLEXT)','.packlist').'|'" >.MM_tmp
  	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'write|'.File::Spec->catfile('$(DESTINSTALLSITEARCH)','auto','$(FULLEXT)','.packlist').'|'" >>.MM_tmp
  ] unless $self->{NO_PACKLIST};
  
      push @m,
  q[	$(NOECHO) $(ECHO_N) "$(INST_LIB)|$(DESTINSTALLSITELIB)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_ARCHLIB)|$(DESTINSTALLSITEARCH)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_BIN)|$(DESTINSTALLSITEBIN)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_SCRIPT)|$(DESTINSTALLSCRIPT)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_MAN1DIR)|$(DESTINSTALLSITEMAN1DIR)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_MAN3DIR)|$(DESTINSTALLSITEMAN3DIR)" >>.MM_tmp
  	$(NOECHO) $(MOD_INSTALL) <.MM_tmp
  	$(NOECHO) $(RM_F) .MM_tmp
  	$(NOECHO) $(WARN_IF_OLD_PACKLIST) "].$self->catfile($self->{PERL_ARCHLIB},'auto',$self->{FULLEXT},'.packlist').q["
  
  pure_vendor_install ::
  ];
      push @m,
  q[	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'read|'.File::Spec->catfile('$(VENDORARCHEXP)','auto','$(FULLEXT)','.packlist').'|'" >.MM_tmp
  	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'write|'.File::Spec->catfile('$(DESTINSTALLVENDORARCH)','auto','$(FULLEXT)','.packlist').'|'" >>.MM_tmp
  ] unless $self->{NO_PACKLIST};
  
      push @m,
  q[	$(NOECHO) $(ECHO_N) "$(INST_LIB)|$(DESTINSTALLVENDORLIB)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_ARCHLIB)|$(DESTINSTALLVENDORARCH)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_BIN)|$(DESTINSTALLVENDORBIN)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_SCRIPT)|$(DESTINSTALLSCRIPT)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_MAN1DIR)|$(DESTINSTALLVENDORMAN1DIR)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_MAN3DIR)|$(DESTINSTALLVENDORMAN3DIR)" >>.MM_tmp
  	$(NOECHO) $(MOD_INSTALL) <.MM_tmp
  	$(NOECHO) $(RM_F) .MM_tmp
  
  ];
  
      push @m, q[
  # Ditto
  doc_perl_install ::
  	$(NOECHO) $(NOOP)
  
  # And again
  doc_site_install ::
  	$(NOECHO) $(NOOP)
  
  doc_vendor_install ::
  	$(NOECHO) $(NOOP)
  
  ] if $self->{NO_PERLLOCAL};
  
      push @m, q[
  # Ditto
  doc_perl_install ::
  	$(NOECHO) $(ECHO) "Appending installation info to ].$self->catfile($self->{DESTINSTALLARCHLIB}, 'perllocal.pod').q["
  	$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
  	$(NOECHO) $(ECHO_N) "installed into|$(INSTALLPRIVLIB)|" >.MM_tmp
  	$(NOECHO) $(ECHO_N) "LINKTYPE|$(LINKTYPE)|VERSION|$(VERSION)|EXE_FILES|$(EXE_FILES) " >>.MM_tmp
  	$(NOECHO) $(DOC_INSTALL) "Module" "$(NAME)" <.MM_tmp >>].$self->catfile($self->{DESTINSTALLARCHLIB},'perllocal.pod').q[
  	$(NOECHO) $(RM_F) .MM_tmp
  
  # And again
  doc_site_install ::
  	$(NOECHO) $(ECHO) "Appending installation info to ].$self->catfile($self->{DESTINSTALLARCHLIB}, 'perllocal.pod').q["
  	$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
  	$(NOECHO) $(ECHO_N) "installed into|$(INSTALLSITELIB)|" >.MM_tmp
  	$(NOECHO) $(ECHO_N) "LINKTYPE|$(LINKTYPE)|VERSION|$(VERSION)|EXE_FILES|$(EXE_FILES) " >>.MM_tmp
  	$(NOECHO) $(DOC_INSTALL) "Module" "$(NAME)" <.MM_tmp >>].$self->catfile($self->{DESTINSTALLARCHLIB},'perllocal.pod').q[
  	$(NOECHO) $(RM_F) .MM_tmp
  
  doc_vendor_install ::
  	$(NOECHO) $(ECHO) "Appending installation info to ].$self->catfile($self->{DESTINSTALLARCHLIB}, 'perllocal.pod').q["
  	$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
  	$(NOECHO) $(ECHO_N) "installed into|$(INSTALLVENDORLIB)|" >.MM_tmp
  	$(NOECHO) $(ECHO_N) "LINKTYPE|$(LINKTYPE)|VERSION|$(VERSION)|EXE_FILES|$(EXE_FILES) " >>.MM_tmp
  	$(NOECHO) $(DOC_INSTALL) "Module" "$(NAME)" <.MM_tmp >>].$self->catfile($self->{DESTINSTALLARCHLIB},'perllocal.pod').q[
  	$(NOECHO) $(RM_F) .MM_tmp
  
  ] unless $self->{NO_PERLLOCAL};
  
      push @m, q[
  uninstall :: uninstall_from_$(INSTALLDIRS)dirs
  	$(NOECHO) $(NOOP)
  
  uninstall_from_perldirs ::
  	$(NOECHO) $(UNINSTALL) ].$self->catfile($self->{PERL_ARCHLIB},'auto',$self->{FULLEXT},'.packlist').q[
  
  uninstall_from_sitedirs ::
  	$(NOECHO) $(UNINSTALL) ].$self->catfile($self->{SITEARCHEXP},'auto',$self->{FULLEXT},'.packlist').q[
  
  uninstall_from_vendordirs ::
  	$(NOECHO) $(UNINSTALL) ].$self->catfile($self->{VENDORARCHEXP},'auto',$self->{FULLEXT},'.packlist').q[
  ];
  
      join('',@m);
  }
  
  =item perldepend (override)
  
  Use VMS-style syntax for files; it's cheaper to just do it directly here
  than to have the MM_Unix method call C<catfile> repeatedly.  Also, if
  we have to rebuild Config.pm, use MM[SK] to do it.
  
  =cut
  
  sub perldepend {
      my($self) = @_;
      my(@m);
  
      if ($self->{OBJECT}) {
          # Need to add an object file dependency on the perl headers.
          # this is very important for XS modules in perl.git development.
  
          push @m, $self->_perl_header_files_fragment(""); # empty separator on VMS as its in the $(PERL_INC)
      }
  
      if ($self->{PERL_SRC}) {
  	my(@macros);
  	my($mmsquals) = '$(USEMAKEFILE)[.vms]$(FIRST_MAKEFILE)';
  	push(@macros,'__AXP__=1') if $Config{'archname'} eq 'VMS_AXP';
  	push(@macros,'DECC=1')    if $Config{'vms_cc_type'} eq 'decc';
  	push(@macros,'GNUC=1')    if $Config{'vms_cc_type'} eq 'gcc';
  	push(@macros,'SOCKET=1')  if $Config{'d_has_sockets'};
  	push(@macros,qq["CC=$Config{'cc'}"])  if $Config{'cc'} =~ m!/!;
  	$mmsquals .= '$(USEMACROS)' . join(',',@macros) . '$(MACROEND)' if @macros;
  	push(@m,q[
  # Check for unpropagated config.sh changes. Should never happen.
  # We do NOT just update config.h because that is not sufficient.
  # An out of date config.h is not fatal but complains loudly!
  $(PERL_INC)config.h : $(PERL_SRC)config.sh
  	$(NOOP)
  
  $(PERL_ARCHLIB)Config.pm : $(PERL_SRC)config.sh
  	$(NOECHO) Write Sys$Error "$(PERL_ARCHLIB)Config.pm may be out of date with config.h or genconfig.pl"
  	olddef = F$Environment("Default")
  	Set Default $(PERL_SRC)
  	$(MMS)],$mmsquals,);
  	if ($self->{PERL_ARCHLIB} =~ m|\[-| && $self->{PERL_SRC} =~ m|(\[-+)|) {
  	    my($prefix,$target) = ($1,$self->fixpath('$(PERL_ARCHLIB)Config.pm',0));
  	    $target =~ s/\Q$prefix/[/;
  	    push(@m," $target");
  	}
  	else { push(@m,' $(MMS$TARGET)'); }
  	push(@m,q[
  	Set Default 'olddef'
  ]);
      }
  
      push(@m, join(" ", map($self->fixpath($_,0),values %{$self->{XS}}))." : \$(XSUBPPDEPS)\n")
        if %{$self->{XS}};
  
      join('',@m);
  }
  
  
  =item makeaperl (override)
  
  Undertake to build a new set of Perl images using VMS commands.  Since
  VMS does dynamic loading, it's not necessary to statically link each
  extension into the Perl image, so this isn't the normal build path.
  Consequently, it hasn't really been tested, and may well be incomplete.
  
  =cut
  
  our %olbs;  # needs to be localized
  
  sub makeaperl {
      my($self, %attribs) = @_;
      my($makefilename, $searchdirs, $static, $extra, $perlinc, $target, $tmpdir, $libperl) =
        @attribs{qw(MAKE DIRS STAT EXTRA INCL TARGET TMP LIBPERL)};
      my(@m);
      push @m, "
  # --- MakeMaker makeaperl section ---
  MAP_TARGET    = $target
  ";
      return join '', @m if $self->{PARENT};
  
      my($dir) = join ":", @{$self->{DIR}};
  
      unless ($self->{MAKEAPERL}) {
  	push @m, q{
  $(MAKE_APERL_FILE) : $(FIRST_MAKEFILE)
  	$(NOECHO) $(ECHO) "Writing ""$(MMS$TARGET)"" for this $(MAP_TARGET)"
  	$(NOECHO) $(PERLRUNINST) \
  		Makefile.PL DIR=}, $dir, q{ \
  		FIRST_MAKEFILE=$(MAKE_APERL_FILE) LINKTYPE=static \
  		MAKEAPERL=1 NORECURS=1 };
  
  	push @m, map(q[ \\\n\t\t"$_"], @ARGV),q{
  
  $(MAP_TARGET) :: $(MAKE_APERL_FILE)
  	$(MAKE)$(USEMAKEFILE)$(MAKE_APERL_FILE) static $(MMS$TARGET)
  };
  	push @m, "\n";
  
  	return join '', @m;
      }
  
  
      my($linkcmd,@optlibs,@staticpkgs,$extralist,$targdir,$libperldir,%libseen);
      local($_);
  
      # The front matter of the linkcommand...
      $linkcmd = join ' ', $Config{'ld'},
  	    grep($_, @Config{qw(large split ldflags ccdlflags)});
      $linkcmd =~ s/\s+/ /g;
  
      # Which *.olb files could we make use of...
      local(%olbs);       # XXX can this be lexical?
      $olbs{$self->{INST_ARCHAUTODIR}} = "$self->{BASEEXT}\$(LIB_EXT)";
      require File::Find;
      File::Find::find(sub {
  	return unless m/\Q$self->{LIB_EXT}\E$/;
  	return if m/^libperl/;
  
  	if( exists $self->{INCLUDE_EXT} ){
  		my $found = 0;
  
  		(my $xx = $File::Find::name) =~ s,.*?/auto/,,;
  		$xx =~ s,/?$_,,;
  		$xx =~ s,/,::,g;
  
  		# Throw away anything not explicitly marked for inclusion.
  		# DynaLoader is implied.
  		foreach my $incl ((@{$self->{INCLUDE_EXT}},'DynaLoader')){
  			if( $xx eq $incl ){
  				$found++;
  				last;
  			}
  		}
  		return unless $found;
  	}
  	elsif( exists $self->{EXCLUDE_EXT} ){
  		(my $xx = $File::Find::name) =~ s,.*?/auto/,,;
  		$xx =~ s,/?$_,,;
  		$xx =~ s,/,::,g;
  
  		# Throw away anything explicitly marked for exclusion
  		foreach my $excl (@{$self->{EXCLUDE_EXT}}){
  			return if( $xx eq $excl );
  		}
  	}
  
  	$olbs{$ENV{DEFAULT}} = $_;
      }, grep( -d $_, @{$searchdirs || []}));
  
      # We trust that what has been handed in as argument will be buildable
      $static = [] unless $static;
      @olbs{@{$static}} = (1) x @{$static};
  
      $extra = [] unless $extra && ref $extra eq 'ARRAY';
      # Sort the object libraries in inverse order of
      # filespec length to try to insure that dependent extensions
      # will appear before their parents, so the linker will
      # search the parent library to resolve references.
      # (e.g. Intuit::DWIM will precede Intuit, so unresolved
      # references from [.intuit.dwim]dwim.obj can be found
      # in [.intuit]intuit.olb).
      for (sort { length($a) <=> length($b) } keys %olbs) {
  	next unless $olbs{$_} =~ /\Q$self->{LIB_EXT}\E$/;
  	my($dir) = $self->fixpath($_,1);
  	my($extralibs) = $dir . "extralibs.ld";
  	my($extopt) = $dir . $olbs{$_};
  	$extopt =~ s/$self->{LIB_EXT}$/.opt/;
  	push @optlibs, "$dir$olbs{$_}";
  	# Get external libraries this extension will need
  	if (-f $extralibs ) {
  	    my %seenthis;
  	    open my $list, "<", $extralibs or warn $!,next;
  	    while (<$list>) {
  		chomp;
  		# Include a library in the link only once, unless it's mentioned
  		# multiple times within a single extension's options file, in which
  		# case we assume the builder needed to search it again later in the
  		# link.
  		my $skip = exists($libseen{$_}) && !exists($seenthis{$_});
  		$libseen{$_}++;  $seenthis{$_}++;
  		next if $skip;
  		push @$extra,$_;
  	    }
  	}
  	# Get full name of extension for ExtUtils::Miniperl
  	if (-f $extopt) {
  	    open my $opt, '<', $extopt or die $!;
  	    while (<$opt>) {
  		next unless /(?:UNIVERSAL|VECTOR)=boot_([\w_]+)/;
  		my $pkg = $1;
  		$pkg =~ s#__*#::#g;
  		push @staticpkgs,$pkg;
  	    }
  	}
      }
      # Place all of the external libraries after all of the Perl extension
      # libraries in the final link, in order to maximize the opportunity
      # for XS code from multiple extensions to resolve symbols against the
      # same external library while only including that library once.
      push @optlibs, @$extra;
  
      $target = "Perl$Config{'exe_ext'}" unless $target;
      my $shrtarget;
      ($shrtarget,$targdir) = fileparse($target);
      $shrtarget =~ s/^([^.]*)/$1Shr/;
      $shrtarget = $targdir . $shrtarget;
      $target = "Perlshr.$Config{'dlext'}" unless $target;
      $tmpdir = "[]" unless $tmpdir;
      $tmpdir = $self->fixpath($tmpdir,1);
      if (@optlibs) { $extralist = join(' ',@optlibs); }
      else          { $extralist = ''; }
      # Let ExtUtils::Liblist find the necessary libs for us (but skip PerlShr)
      # that's what we're building here).
      push @optlibs, grep { !/PerlShr/i } split ' ', +($self->ext())[2];
      if ($libperl) {
  	unless (-f $libperl || -f ($libperl = $self->catfile($Config{'installarchlib'},'CORE',$libperl))) {
  	    print "Warning: $libperl not found\n";
  	    undef $libperl;
  	}
      }
      unless ($libperl) {
  	if (defined $self->{PERL_SRC}) {
  	    $libperl = $self->catfile($self->{PERL_SRC},"libperl$self->{LIB_EXT}");
  	} elsif (-f ($libperl = $self->catfile($Config{'installarchlib'},'CORE',"libperl$self->{LIB_EXT}")) ) {
  	} else {
  	    print "Warning: $libperl not found
      If you're going to build a static perl binary, make sure perl is installed
      otherwise ignore this warning\n";
  	}
      }
      $libperldir = $self->fixpath((fileparse($libperl))[1],1);
  
      push @m, '
  # Fill in the target you want to produce if it\'s not perl
  MAP_TARGET    = ',$self->fixpath($target,0),'
  MAP_SHRTARGET = ',$self->fixpath($shrtarget,0),"
  MAP_LINKCMD   = $linkcmd
  MAP_PERLINC   = ", $perlinc ? map('"$_" ',@{$perlinc}) : '',"
  MAP_EXTRA     = $extralist
  MAP_LIBPERL = ",$self->fixpath($libperl,0),'
  ';
  
  
      push @m,"\n${tmpdir}Makeaperl.Opt : \$(MAP_EXTRA)\n";
      foreach (@optlibs) {
  	push @m,'	$(NOECHO) $(PERL) -e "print q{',$_,'}" >>$(MMS$TARGET)',"\n";
      }
      push @m,"\n${tmpdir}PerlShr.Opt :\n\t";
      push @m,'$(NOECHO) $(PERL) -e "print q{$(MAP_SHRTARGET)}" >$(MMS$TARGET)',"\n";
  
      push @m,'
  $(MAP_SHRTARGET) : $(MAP_LIBPERL) Makeaperl.Opt ',"${libperldir}Perlshr_Attr.Opt",'
  	$(MAP_LINKCMD)/Shareable=$(MMS$TARGET) $(MAP_LIBPERL), Makeaperl.Opt/Option ',"${libperldir}Perlshr_Attr.Opt/Option",'
  $(MAP_TARGET) : $(MAP_SHRTARGET) ',"${tmpdir}perlmain\$(OBJ_EXT) ${tmpdir}PerlShr.Opt",'
  	$(MAP_LINKCMD) ',"${tmpdir}perlmain\$(OBJ_EXT)",', PerlShr.Opt/Option
  	$(NOECHO) $(ECHO) "To install the new ""$(MAP_TARGET)"" binary, say"
  	$(NOECHO) $(ECHO) "    $(MAKE)$(USEMAKEFILE)$(FIRST_MAKEFILE) inst_perl $(USEMACROS)MAP_TARGET=$(MAP_TARGET)$(ENDMACRO)"
  	$(NOECHO) $(ECHO) "To remove the intermediate files, say
  	$(NOECHO) $(ECHO) "    $(MAKE)$(USEMAKEFILE)$(FIRST_MAKEFILE) map_clean"
  ';
      push @m,"\n${tmpdir}perlmain.c : \$(FIRST_MAKEFILE)\n\t\$(NOECHO) \$(PERL) -e 1 >${tmpdir}Writemain.tmp\n";
      push @m, "# More from the 255-char line length limit\n";
      foreach (@staticpkgs) {
  	push @m,'	$(NOECHO) $(PERL) -e "print q{',$_,qq[}" >>${tmpdir}Writemain.tmp\n];
      }
  
      push @m, sprintf <<'MAKE_FRAG', $tmpdir, $tmpdir;
  	$(NOECHO) $(PERL) $(MAP_PERLINC) -ane "use ExtUtils::Miniperl; writemain(@F)" %sWritemain.tmp >$(MMS$TARGET)
  	$(NOECHO) $(RM_F) %sWritemain.tmp
  MAKE_FRAG
  
      push @m, q[
  # Still more from the 255-char line length limit
  doc_inst_perl :
  	$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
  	$(NOECHO) $(ECHO) "Perl binary $(MAP_TARGET)|" >.MM_tmp
  	$(NOECHO) $(ECHO) "MAP_STATIC|$(MAP_STATIC)|" >>.MM_tmp
  	$(NOECHO) $(PERL) -pl040 -e " " ].$self->catfile('$(INST_ARCHAUTODIR)','extralibs.all'),q[ >>.MM_tmp
  	$(NOECHO) $(ECHO) -e "MAP_LIBPERL|$(MAP_LIBPERL)|" >>.MM_tmp
  	$(NOECHO) $(DOC_INSTALL) <.MM_tmp >>].$self->catfile('$(DESTINSTALLARCHLIB)','perllocal.pod').q[
  	$(NOECHO) $(RM_F) .MM_tmp
  ];
  
      push @m, "
  inst_perl : pure_inst_perl doc_inst_perl
  	\$(NOECHO) \$(NOOP)
  
  pure_inst_perl : \$(MAP_TARGET)
  	$self->{CP} \$(MAP_SHRTARGET) ",$self->fixpath($Config{'installbin'},1),"
  	$self->{CP} \$(MAP_TARGET) ",$self->fixpath($Config{'installbin'},1),"
  
  clean :: map_clean
  	\$(NOECHO) \$(NOOP)
  
  map_clean :
  	\$(RM_F) ${tmpdir}perlmain\$(OBJ_EXT) ${tmpdir}perlmain.c \$(FIRST_MAKEFILE)
  	\$(RM_F) ${tmpdir}Makeaperl.Opt ${tmpdir}PerlShr.Opt \$(MAP_TARGET)
  ";
  
      join '', @m;
  }
  
  
  # --- Output postprocessing section ---
  
  =item maketext_filter (override)
  
  Insure that colons marking targets are preceded by space, in order
  to distinguish the target delimiter from a colon appearing as
  part of a filespec.
  
  =cut
  
  sub maketext_filter {
      my($self, $text) = @_;
  
      $text =~ s/^([^\s:=]+)(:+\s)/$1 $2/mg;
      return $text;
  }
  
  =item prefixify (override)
  
  prefixifying on VMS is simple.  Each should simply be:
  
      perl_root:[some.dir]
  
  which can just be converted to:
  
      volume:[your.prefix.some.dir]
  
  otherwise you get the default layout.
  
  In effect, your search prefix is ignored and $Config{vms_prefix} is
  used instead.
  
  =cut
  
  sub prefixify {
      my($self, $var, $sprefix, $rprefix, $default) = @_;
  
      # Translate $(PERLPREFIX) to a real path.
      $rprefix = $self->eliminate_macros($rprefix);
      $rprefix = vmspath($rprefix) if $rprefix;
      $sprefix = vmspath($sprefix) if $sprefix;
  
      $default = vmsify($default)
        unless $default =~ /\[.*\]/;
  
      (my $var_no_install = $var) =~ s/^install//;
      my $path = $self->{uc $var} ||
                 $ExtUtils::MM_Unix::Config_Override{lc $var} ||
                 $Config{lc $var} || $Config{lc $var_no_install};
  
      if( !$path ) {
          warn "  no Config found for $var.\n" if $Verbose >= 2;
          $path = $self->_prefixify_default($rprefix, $default);
      }
      elsif( !$self->{ARGS}{PREFIX} || !$self->file_name_is_absolute($path) ) {
          # do nothing if there's no prefix or if its relative
      }
      elsif( $sprefix eq $rprefix ) {
          warn "  no new prefix.\n" if $Verbose >= 2;
      }
      else {
  
          warn "  prefixify $var => $path\n"     if $Verbose >= 2;
          warn "    from $sprefix to $rprefix\n" if $Verbose >= 2;
  
          my($path_vol, $path_dirs) = $self->splitpath( $path );
          if( $path_vol eq $Config{vms_prefix}.':' ) {
              warn "  $Config{vms_prefix}: seen\n" if $Verbose >= 2;
  
              $path_dirs =~ s{^\[}{\[.} unless $path_dirs =~ m{^\[\.};
              $path = $self->_catprefix($rprefix, $path_dirs);
          }
          else {
              $path = $self->_prefixify_default($rprefix, $default);
          }
      }
  
      print "    now $path\n" if $Verbose >= 2;
      return $self->{uc $var} = $path;
  }
  
  
  sub _prefixify_default {
      my($self, $rprefix, $default) = @_;
  
      warn "  cannot prefix, using default.\n" if $Verbose >= 2;
  
      if( !$default ) {
          warn "No default!\n" if $Verbose >= 1;
          return;
      }
      if( !$rprefix ) {
          warn "No replacement prefix!\n" if $Verbose >= 1;
          return '';
      }
  
      return $self->_catprefix($rprefix, $default);
  }
  
  sub _catprefix {
      my($self, $rprefix, $default) = @_;
  
      my($rvol, $rdirs) = $self->splitpath($rprefix);
      if( $rvol ) {
          return $self->catpath($rvol,
                                     $self->catdir($rdirs, $default),
                                     ''
                                    )
      }
      else {
          return $self->catdir($rdirs, $default);
      }
  }
  
  
  =item cd
  
  =cut
  
  sub cd {
      my($self, $dir, @cmds) = @_;
  
      $dir = vmspath($dir);
  
      my $cmd = join "\n\t", map "$_", @cmds;
  
      # No leading tab makes it look right when embedded
      my $make_frag = sprintf <<'MAKE_FRAG', $dir, $cmd;
  startdir = F$Environment("Default")
  	Set Default %s
  	%s
  	Set Default 'startdir'
  MAKE_FRAG
  
      # No trailing newline makes this easier to embed
      chomp $make_frag;
  
      return $make_frag;
  }
  
  
  =item oneliner
  
  =cut
  
  sub oneliner {
      my($self, $cmd, $switches) = @_;
      $switches = [] unless defined $switches;
  
      # Strip leading and trailing newlines
      $cmd =~ s{^\n+}{};
      $cmd =~ s{\n+$}{};
  
      $cmd = $self->quote_literal($cmd);
      $cmd = $self->escape_newlines($cmd);
  
      # Switches must be quoted else they will be lowercased.
      $switches = join ' ', map { qq{"$_"} } @$switches;
  
      return qq{\$(ABSPERLRUN) $switches -e $cmd "--"};
  }
  
  
  =item B<echo>
  
  perl trips up on "<foo>" thinking it's an input redirect.  So we use the
  native Write command instead.  Besides, its faster.
  
  =cut
  
  sub echo {
      my($self, $text, $file, $opts) = @_;
  
      # Compatibility with old options
      if( !ref $opts ) {
          my $append = $opts;
          $opts = { append => $append || 0 };
      }
      my $opencmd = $opts->{append} ? 'Open/Append' : 'Open/Write';
  
      $opts->{allow_variables} = 0 unless defined $opts->{allow_variables};
  
      my $ql_opts = { allow_variables => $opts->{allow_variables} };
  
      my @cmds = ("\$(NOECHO) $opencmd MMECHOFILE $file ");
      push @cmds, map { '$(NOECHO) Write MMECHOFILE '.$self->quote_literal($_, $ql_opts) }
                  split /\n/, $text;
      push @cmds, '$(NOECHO) Close MMECHOFILE';
      return @cmds;
  }
  
  
  =item quote_literal
  
  =cut
  
  sub quote_literal {
      my($self, $text, $opts) = @_;
      $opts->{allow_variables} = 1 unless defined $opts->{allow_variables};
  
      # I believe this is all we should need.
      $text =~ s{"}{""}g;
  
      $text = $opts->{allow_variables}
        ? $self->escape_dollarsigns($text) : $self->escape_all_dollarsigns($text);
  
      return qq{"$text"};
  }
  
  =item escape_dollarsigns
  
  Quote, don't escape.
  
  =cut
  
  sub escape_dollarsigns {
      my($self, $text) = @_;
  
      # Quote dollar signs which are not starting a variable
      $text =~ s{\$ (?!\() }{"\$"}gx;
  
      return $text;
  }
  
  
  =item escape_all_dollarsigns
  
  Quote, don't escape.
  
  =cut
  
  sub escape_all_dollarsigns {
      my($self, $text) = @_;
  
      # Quote dollar signs
      $text =~ s{\$}{"\$\"}gx;
  
      return $text;
  }
  
  =item escape_newlines
  
  =cut
  
  sub escape_newlines {
      my($self, $text) = @_;
  
      $text =~ s{\n}{-\n}g;
  
      return $text;
  }
  
  =item max_exec_len
  
  256 characters.
  
  =cut
  
  sub max_exec_len {
      my $self = shift;
  
      return $self->{_MAX_EXEC_LEN} ||= 256;
  }
  
  =item init_linker
  
  =cut
  
  sub init_linker {
      my $self = shift;
      $self->{EXPORT_LIST} ||= '$(BASEEXT).opt';
  
      my $shr = $Config{dbgprefix} . 'PERLSHR';
      if ($self->{PERL_SRC}) {
          $self->{PERL_ARCHIVE} ||=
            $self->catfile($self->{PERL_SRC}, "$shr.$Config{'dlext'}");
      }
      else {
          $self->{PERL_ARCHIVE} ||=
            $ENV{$shr} ? $ENV{$shr} : "Sys\$Share:$shr.$Config{'dlext'}";
      }
  
      $self->{PERL_ARCHIVEDEP} ||= '';
      $self->{PERL_ARCHIVE_AFTER} ||= '';
  }
  
  
  =item catdir (override)
  
  =item catfile (override)
  
  Eliminate the macros in the output to the MMS/MMK file.
  
  (File::Spec::VMS used to do this for us, but it's being removed)
  
  =cut
  
  sub catdir {
      my $self = shift;
  
      # Process the macros on VMS MMS/MMK
      my @args = map { m{\$\(} ? $self->eliminate_macros($_) : $_  } @_;
  
      my $dir = $self->SUPER::catdir(@args);
  
      # Fix up the directory and force it to VMS format.
      $dir = $self->fixpath($dir, 1);
  
      return $dir;
  }
  
  sub catfile {
      my $self = shift;
  
      # Process the macros on VMS MMS/MMK
      my @args = map { m{\$\(} ? $self->eliminate_macros($_) : $_  } @_;
  
      my $file = $self->SUPER::catfile(@args);
  
      $file = vmsify($file);
  
      return $file
  }
  
  
  =item eliminate_macros
  
  Expands MM[KS]/Make macros in a text string, using the contents of
  identically named elements of C<%$self>, and returns the result
  as a file specification in Unix syntax.
  
  NOTE:  This is the canonical version of the method.  The version in
  File::Spec::VMS is deprecated.
  
  =cut
  
  sub eliminate_macros {
      my($self,$path) = @_;
      return '' unless $path;
      $self = {} unless ref $self;
  
      my($npath) = unixify($path);
      # sometimes unixify will return a string with an off-by-one trailing null
      $npath =~ s{\0$}{};
  
      my($complex) = 0;
      my($head,$macro,$tail);
  
      # perform m##g in scalar context so it acts as an iterator
      while ($npath =~ m#(.*?)\$\((\S+?)\)(.*)#gs) {
          if (defined $self->{$2}) {
              ($head,$macro,$tail) = ($1,$2,$3);
              if (ref $self->{$macro}) {
                  if (ref $self->{$macro} eq 'ARRAY') {
                      $macro = join ' ', @{$self->{$macro}};
                  }
                  else {
                      print "Note: can't expand macro \$($macro) containing ",ref($self->{$macro}),
                            "\n\t(using MMK-specific deferred substitutuon; MMS will break)\n";
                      $macro = "\cB$macro\cB";
                      $complex = 1;
                  }
              }
              else { ($macro = unixify($self->{$macro})) =~ s#/\Z(?!\n)##; }
              $npath = "$head$macro$tail";
          }
      }
      if ($complex) { $npath =~ s#\cB(.*?)\cB#\${$1}#gs; }
      $npath;
  }
  
  =item fixpath
  
     my $path = $mm->fixpath($path);
     my $path = $mm->fixpath($path, $is_dir);
  
  Catchall routine to clean up problem MM[SK]/Make macros.  Expands macros
  in any directory specification, in order to avoid juxtaposing two
  VMS-syntax directories when MM[SK] is run.  Also expands expressions which
  are all macro, so that we can tell how long the expansion is, and avoid
  overrunning DCL's command buffer when MM[KS] is running.
  
  fixpath() checks to see whether the result matches the name of a
  directory in the current default directory and returns a directory or
  file specification accordingly.  C<$is_dir> can be set to true to
  force fixpath() to consider the path to be a directory or false to force
  it to be a file.
  
  NOTE:  This is the canonical version of the method.  The version in
  File::Spec::VMS is deprecated.
  
  =cut
  
  sub fixpath {
      my($self,$path,$force_path) = @_;
      return '' unless $path;
      $self = bless {}, $self unless ref $self;
      my($fixedpath,$prefix,$name);
  
      if ($path =~ m#^\$\([^\)]+\)\Z(?!\n)#s || $path =~ m#[/:>\]]#) {
          if ($force_path or $path =~ /(?:DIR\)|\])\Z(?!\n)/) {
              $fixedpath = vmspath($self->eliminate_macros($path));
          }
          else {
              $fixedpath = vmsify($self->eliminate_macros($path));
          }
      }
      elsif ((($prefix,$name) = ($path =~ m#^\$\(([^\)]+)\)(.+)#s)) && $self->{$prefix}) {
          my($vmspre) = $self->eliminate_macros("\$($prefix)");
          # is it a dir or just a name?
          $vmspre = ($vmspre =~ m|/| or $prefix =~ /DIR\Z(?!\n)/) ? vmspath($vmspre) : '';
          $fixedpath = ($vmspre ? $vmspre : $self->{$prefix}) . $name;
          $fixedpath = vmspath($fixedpath) if $force_path;
      }
      else {
          $fixedpath = $path;
          $fixedpath = vmspath($fixedpath) if $force_path;
      }
      # No hints, so we try to guess
      if (!defined($force_path) and $fixedpath !~ /[:>(.\]]/) {
          $fixedpath = vmspath($fixedpath) if -d $fixedpath;
      }
  
      # Trim off root dirname if it's had other dirs inserted in front of it.
      $fixedpath =~ s/\.000000([\]>])/$1/;
      # Special case for VMS absolute directory specs: these will have had device
      # prepended during trip through Unix syntax in eliminate_macros(), since
      # Unix syntax has no way to express "absolute from the top of this device's
      # directory tree".
      if ($path =~ /^[\[>][^.\-]/) { $fixedpath =~ s/^[^\[<]+//; }
  
      return $fixedpath;
  }
  
  
  =item os_flavor
  
  VMS is VMS.
  
  =cut
  
  sub os_flavor {
      return('VMS');
  }
  
  
  =item is_make_type (override)
  
  None of the make types being checked for is viable on VMS,
  plus our $self->{MAKE} is an unexpanded (and unexpandable)
  macro whose value is known only to the make utility itself.
  
  =cut
  
  sub is_make_type {
      my($self, $type) = @_;
      return 0;
  }
  
  
  =back
  
  
  =head1 AUTHOR
  
  Original author Charles Bailey F<bailey@newman.upenn.edu>
  
  Maintained by Michael G Schwern F<schwern@pobox.com>
  
  See L<ExtUtils::MakeMaker> for patching and contact information.
  
  
  =cut
  
  1;
  
PERL5_EXTUTILS_MM_VMS

$fatpacked{"perl5/ExtUtils/MM_VOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_EXTUTILS_MM_VOS';
  package ExtUtils::MM_VOS;
  
  use strict;
  our $VERSION = '7.10';
  
  require ExtUtils::MM_Unix;
  our @ISA = qw(ExtUtils::MM_Unix);
  
  
  =head1 NAME
  
  ExtUtils::MM_VOS - VOS specific subclass of ExtUtils::MM_Unix
  
  =head1 SYNOPSIS
  
    Don't use this module directly.
    Use ExtUtils::MM and let it choose.
  
  =head1 DESCRIPTION
  
  This is a subclass of ExtUtils::MM_Unix which contains functionality for
  VOS.
  
  Unless otherwise stated it works just like ExtUtils::MM_Unix
  
  =head2 Overridden methods
  
  =head3 extra_clean_files
  
  Cleanup VOS core files
  
  =cut
  
  sub extra_clean_files {
      return qw(*.kp);
  }
  
  
  =head1 AUTHOR
  
  Michael G Schwern <schwern@pobox.com> with code from ExtUtils::MM_Unix
  
  =head1 SEE ALSO
  
  L<ExtUtils::MakeMaker>
  
  =cut
  
  
  1;
PERL5_EXTUTILS_MM_VOS

$fatpacked{"perl5/ExtUtils/MM_Win32.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_EXTUTILS_MM_WIN32';
  package ExtUtils::MM_Win32;
  
  use strict;
  
  
  =head1 NAME
  
  ExtUtils::MM_Win32 - methods to override UN*X behaviour in ExtUtils::MakeMaker
  
  =head1 SYNOPSIS
  
   use ExtUtils::MM_Win32; # Done internally by ExtUtils::MakeMaker if needed
  
  =head1 DESCRIPTION
  
  See ExtUtils::MM_Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  =cut
  
  use ExtUtils::MakeMaker::Config;
  use File::Basename;
  use File::Spec;
  use ExtUtils::MakeMaker qw( neatvalue );
  
  require ExtUtils::MM_Any;
  require ExtUtils::MM_Unix;
  our @ISA = qw( ExtUtils::MM_Any ExtUtils::MM_Unix );
  our $VERSION = '7.10';
  
  $ENV{EMXSHELL} = 'sh'; # to run `commands`
  
  my ( $BORLAND, $GCC, $DLLTOOL ) = _identify_compiler_environment( \%Config );
  
  sub _identify_compiler_environment {
  	my ( $config ) = @_;
  
  	my $BORLAND = $config->{cc} =~ /^bcc/i ? 1 : 0;
  	my $GCC     = $config->{cc} =~ /\bgcc\b/i ? 1 : 0;
  	my $DLLTOOL = $config->{dlltool} || 'dlltool';
  
  	return ( $BORLAND, $GCC, $DLLTOOL );
  }
  
  
  =head2 Overridden methods
  
  =over 4
  
  =item B<dlsyms>
  
  =cut
  
  sub dlsyms {
      my($self,%attribs) = @_;
  
      my($funcs) = $attribs{DL_FUNCS} || $self->{DL_FUNCS} || {};
      my($vars)  = $attribs{DL_VARS} || $self->{DL_VARS} || [];
      my($funclist) = $attribs{FUNCLIST} || $self->{FUNCLIST} || [];
      my($imports)  = $attribs{IMPORTS} || $self->{IMPORTS} || {};
      my(@m);
  
      if (not $self->{SKIPHASH}{'dynamic'}) {
  	push(@m,"
  $self->{BASEEXT}.def: Makefile.PL
  ",
       q!	$(PERLRUN) -MExtUtils::Mksymlists \\
       -e "Mksymlists('NAME'=>\"!, $self->{NAME},
       q!\", 'DLBASE' => '!,$self->{DLBASE},
       # The above two lines quoted differently to work around
       # a bug in the 4DOS/4NT command line interpreter.  The visible
       # result of the bug was files named q('extension_name',) *with the
       # single quotes and the comma* in the extension build directories.
       q!', 'DL_FUNCS' => !,neatvalue($funcs),
       q!, 'FUNCLIST' => !,neatvalue($funclist),
       q!, 'IMPORTS' => !,neatvalue($imports),
       q!, 'DL_VARS' => !, neatvalue($vars), q!);"
  !);
      }
      join('',@m);
  }
  
  =item replace_manpage_separator
  
  Changes the path separator with .
  
  =cut
  
  sub replace_manpage_separator {
      my($self,$man) = @_;
      $man =~ s,/+,.,g;
      $man;
  }
  
  
  =item B<maybe_command>
  
  Since Windows has nothing as simple as an executable bit, we check the
  file extension.
  
  The PATHEXT env variable will be used to get a list of extensions that
  might indicate a command, otherwise .com, .exe, .bat and .cmd will be
  used by default.
  
  =cut
  
  sub maybe_command {
      my($self,$file) = @_;
      my @e = exists($ENV{'PATHEXT'})
            ? split(/;/, $ENV{PATHEXT})
  	  : qw(.com .exe .bat .cmd);
      my $e = '';
      for (@e) { $e .= "\Q$_\E|" }
      chop $e;
      # see if file ends in one of the known extensions
      if ($file =~ /($e)$/i) {
  	return $file if -e $file;
      }
      else {
  	for (@e) {
  	    return "$file$_" if -e "$file$_";
  	}
      }
      return;
  }
  
  
  =item B<init_DIRFILESEP>
  
  Using \ for Windows, except for "gmake" where it is /.
  
  =cut
  
  sub init_DIRFILESEP {
      my($self) = shift;
  
      # The ^ makes sure its not interpreted as an escape in nmake
      $self->{DIRFILESEP} = $self->is_make_type('nmake') ? '^\\' :
                            $self->is_make_type('dmake') ? '\\\\' :
                            $self->is_make_type('gmake') ? '/'
                                                         : '\\';
  }
  
  =item init_tools
  
  Override some of the slower, portable commands with Windows specific ones.
  
  =cut
  
  sub init_tools {
      my ($self) = @_;
  
      $self->{NOOP}     ||= 'rem';
      $self->{DEV_NULL} ||= '> NUL';
  
      $self->{FIXIN}    ||= $self->{PERL_CORE} ?
        "\$(PERLRUN) $self->{PERL_SRC}\\win32\\bin\\pl2bat.pl" :
        'pl2bat.bat';
  
      $self->SUPER::init_tools;
  
      # Setting SHELL from $Config{sh} can break dmake.  Its ok without it.
      delete $self->{SHELL};
  
      return;
  }
  
  
  =item init_others
  
  Override the default link and compile tools.
  
  LDLOADLIBS's default is changed to $Config{libs}.
  
  Adjustments are made for Borland's quirks needing -L to come first.
  
  =cut
  
  sub init_others {
      my $self = shift;
  
      $self->{LD}     ||= 'link';
      $self->{AR}     ||= 'lib';
  
      $self->SUPER::init_others;
  
      $self->{LDLOADLIBS} ||= $Config{libs};
      # -Lfoo must come first for Borland, so we put it in LDDLFLAGS
      if ($BORLAND) {
          my $libs = $self->{LDLOADLIBS};
          my $libpath = '';
          while ($libs =~ s/(?:^|\s)(("?)-L.+?\2)(?:\s|$)/ /) {
              $libpath .= ' ' if length $libpath;
              $libpath .= $1;
          }
          $self->{LDLOADLIBS} = $libs;
          $self->{LDDLFLAGS} ||= $Config{lddlflags};
          $self->{LDDLFLAGS} .= " $libpath";
      }
  
      return;
  }
  
  
  =item init_platform
  
  Add MM_Win32_VERSION.
  
  =item platform_constants
  
  =cut
  
  sub init_platform {
      my($self) = shift;
  
      $self->{MM_Win32_VERSION} = $VERSION;
  
      return;
  }
  
  sub platform_constants {
      my($self) = shift;
      my $make_frag = '';
  
      foreach my $macro (qw(MM_Win32_VERSION))
      {
          next unless defined $self->{$macro};
          $make_frag .= "$macro = $self->{$macro}\n";
      }
  
      return $make_frag;
  }
  
  
  =item constants
  
  Add MAXLINELENGTH for dmake before all the constants are output.
  
  =cut
  
  sub constants {
      my $self = shift;
  
      my $make_text = $self->SUPER::constants;
      return $make_text unless $self->is_make_type('dmake');
  
      # dmake won't read any single "line" (even those with escaped newlines)
      # larger than a certain size which can be as small as 8k.  PM_TO_BLIB
      # on large modules like DateTime::TimeZone can create lines over 32k.
      # So we'll crank it up to a <ironic>WHOPPING</ironic> 64k.
      #
      # This has to come here before all the constants and not in
      # platform_constants which is after constants.
      my $size = $self->{MAXLINELENGTH} || 800000;
      my $prefix = qq{
  # Get dmake to read long commands like PM_TO_BLIB
  MAXLINELENGTH = $size
  
  };
  
      return $prefix . $make_text;
  }
  
  
  =item special_targets
  
  Add .USESHELL target for dmake.
  
  =cut
  
  sub special_targets {
      my($self) = @_;
  
      my $make_frag = $self->SUPER::special_targets;
  
      $make_frag .= <<'MAKE_FRAG' if $self->is_make_type('dmake');
  .USESHELL :
  MAKE_FRAG
  
      return $make_frag;
  }
  
  
  =item static_lib
  
  Changes how to run the linker.
  
  The rest is duplicate code from MM_Unix.  Should move the linker code
  to its own method.
  
  =cut
  
  sub static_lib {
      my($self) = @_;
      return '' unless $self->has_link_code;
  
      my(@m);
      push(@m, <<'END');
  $(INST_STATIC): $(OBJECT) $(MYEXTLIB) $(INST_ARCHAUTODIR)$(DFSEP).exists
  	$(RM_RF) $@
  END
  
      # If this extension has its own library (eg SDBM_File)
      # then copy that to $(INST_STATIC) and add $(OBJECT) into it.
      push @m, <<'MAKE_FRAG' if $self->{MYEXTLIB};
  	$(CP) $(MYEXTLIB) $@
  MAKE_FRAG
  
      push @m,
  q{	$(AR) }.($BORLAND ? '$@ $(OBJECT:^"+")'
  			  : ($GCC ? '-ru $@ $(OBJECT)'
  			          : '-out:$@ $(OBJECT)')).q{
  	$(CHMOD) $(PERM_RWX) $@
  	$(NOECHO) $(ECHO) "$(EXTRALIBS)" > $(INST_ARCHAUTODIR)\extralibs.ld
  };
  
      # Old mechanism - still available:
      push @m, <<'MAKE_FRAG' if $self->{PERL_SRC} && $self->{EXTRALIBS};
  	$(NOECHO) $(ECHO) "$(EXTRALIBS)" >> $(PERL_SRC)\ext.libs
  MAKE_FRAG
  
      join('', @m);
  }
  
  
  =item dynamic_lib
  
  Complicated stuff for Win32 that I don't understand. :(
  
  =cut
  
  sub dynamic_lib {
      my($self, %attribs) = @_;
      return '' unless $self->needs_linking(); #might be because of a subdir
  
      return '' unless $self->has_link_code;
  
      my($otherldflags) = $attribs{OTHERLDFLAGS} || ($BORLAND ? 'c0d32.obj': '');
      my($inst_dynamic_dep) = $attribs{INST_DYNAMIC_DEP} || "";
      my($ldfrom) = '$(LDFROM)';
      my(@m);
  
      push(@m,'
  # This section creates the dynamically loadable $(INST_DYNAMIC)
  # from $(OBJECT) and possibly $(MYEXTLIB).
  OTHERLDFLAGS = '.$otherldflags.'
  INST_DYNAMIC_DEP = '.$inst_dynamic_dep.'
  
  $(INST_DYNAMIC): $(OBJECT) $(MYEXTLIB) $(BOOTSTRAP) $(INST_ARCHAUTODIR)$(DFSEP).exists $(EXPORT_LIST) $(PERL_ARCHIVEDEP) $(INST_DYNAMIC_DEP)
  ');
      if ($GCC) {
        push(@m,
         q{	}.$DLLTOOL.q{ --def $(EXPORT_LIST) --output-exp dll.exp
  	$(LD) -o $@ -Wl,--base-file -Wl,dll.base $(LDDLFLAGS) }.$ldfrom.q{ $(OTHERLDFLAGS) $(MYEXTLIB) "$(PERL_ARCHIVE)" $(LDLOADLIBS) dll.exp
  	}.$DLLTOOL.q{ --def $(EXPORT_LIST) --base-file dll.base --output-exp dll.exp
  	$(LD) -o $@ $(LDDLFLAGS) }.$ldfrom.q{ $(OTHERLDFLAGS) $(MYEXTLIB) "$(PERL_ARCHIVE)" $(LDLOADLIBS) dll.exp });
      } elsif ($BORLAND) {
        push(@m,
         q{	$(LD) $(LDDLFLAGS) $(OTHERLDFLAGS) }.$ldfrom.q{,$@,,}
         .($self->is_make_type('dmake')
                  ? q{"$(PERL_ARCHIVE:s,/,\,)" $(LDLOADLIBS:s,/,\,) }
  		 .q{$(MYEXTLIB:s,/,\,),$(EXPORT_LIST:s,/,\,)}
  		: q{"$(subst /,\,$(PERL_ARCHIVE))" $(subst /,\,$(LDLOADLIBS)) }
  		 .q{$(subst /,\,$(MYEXTLIB)),$(subst /,\,$(EXPORT_LIST))})
         .q{,$(RESFILES)});
      } else {	# VC
        push(@m,
         q{	$(LD) -out:$@ $(LDDLFLAGS) }.$ldfrom.q{ $(OTHERLDFLAGS) }
        .q{$(MYEXTLIB) "$(PERL_ARCHIVE)" $(LDLOADLIBS) -def:$(EXPORT_LIST)});
  
        # Embed the manifest file if it exists
        push(@m, q{
  	if exist $@.manifest mt -nologo -manifest $@.manifest -outputresource:$@;2
  	if exist $@.manifest del $@.manifest});
      }
      push @m, '
  	$(CHMOD) $(PERM_RWX) $@
  ';
  
      join('',@m);
  }
  
  =item extra_clean_files
  
  Clean out some extra dll.{base,exp} files which might be generated by
  gcc.  Otherwise, take out all *.pdb files.
  
  =cut
  
  sub extra_clean_files {
      my $self = shift;
  
      return $GCC ? (qw(dll.base dll.exp)) : ('*.pdb');
  }
  
  =item init_linker
  
  =cut
  
  sub init_linker {
      my $self = shift;
  
      $self->{PERL_ARCHIVE}       = "\$(PERL_INC)\\$Config{libperl}";
      $self->{PERL_ARCHIVEDEP}    = "\$(PERL_INCDEP)\\$Config{libperl}";
      $self->{PERL_ARCHIVE_AFTER} = '';
      $self->{EXPORT_LIST}        = '$(BASEEXT).def';
  }
  
  
  =item perl_script
  
  Checks for the perl program under several common perl extensions.
  
  =cut
  
  sub perl_script {
      my($self,$file) = @_;
      return $file if -r $file && -f _;
      return "$file.pl"  if -r "$file.pl" && -f _;
      return "$file.plx" if -r "$file.plx" && -f _;
      return "$file.bat" if -r "$file.bat" && -f _;
      return;
  }
  
  sub can_dep_space {
      my $self = shift;
      1; # with Win32::GetShortPathName
  }
  
  =item quote_dep
  
  =cut
  
  sub quote_dep {
      my ($self, $arg) = @_;
      if ($arg =~ / / and not $self->is_make_type('gmake')) {
          require Win32;
          $arg = Win32::GetShortPathName($arg);
          die <<EOF if not defined $arg or $arg =~ / /;
  Tried to use make dependency with space for non-GNU make:
    '$arg'
  Fallback to short pathname failed.
  EOF
          return $arg;
      }
      return $self->SUPER::quote_dep($arg);
  }
  
  =item xs_o
  
  This target is stubbed out.  Not sure why.
  
  =cut
  
  sub xs_o {
      return ''
  }
  
  
  =item pasthru
  
  All we send is -nologo to nmake to prevent it from printing its damned
  banner.
  
  =cut
  
  sub pasthru {
      my($self) = shift;
      return "PASTHRU = " . ($self->is_make_type('nmake') ? "-nologo" : "");
  }
  
  
  =item arch_check (override)
  
  Normalize all arguments for consistency of comparison.
  
  =cut
  
  sub arch_check {
      my $self = shift;
  
      # Win32 is an XS module, minperl won't have it.
      # arch_check() is not critical, so just fake it.
      return 1 unless $self->can_load_xs;
      return $self->SUPER::arch_check( map { $self->_normalize_path_name($_) } @_);
  }
  
  sub _normalize_path_name {
      my $self = shift;
      my $file = shift;
  
      require Win32;
      my $short = Win32::GetShortPathName($file);
      return defined $short ? lc $short : lc $file;
  }
  
  
  =item oneliner
  
  These are based on what command.com does on Win98.  They may be wrong
  for other Windows shells, I don't know.
  
  =cut
  
  sub oneliner {
      my($self, $cmd, $switches) = @_;
      $switches = [] unless defined $switches;
  
      # Strip leading and trailing newlines
      $cmd =~ s{^\n+}{};
      $cmd =~ s{\n+$}{};
  
      $cmd = $self->quote_literal($cmd);
      $cmd = $self->escape_newlines($cmd);
  
      $switches = join ' ', @$switches;
  
      return qq{\$(ABSPERLRUN) $switches -e $cmd --};
  }
  
  
  sub quote_literal {
      my($self, $text, $opts) = @_;
      $opts->{allow_variables} = 1 unless defined $opts->{allow_variables};
  
      # See: http://www.autohotkey.net/~deleyd/parameters/parameters.htm#CPP
  
      # Apply the Microsoft C/C++ parsing rules
      $text =~ s{\\\\"}{\\\\\\\\\\"}g;  # \\" -> \\\\\"
      $text =~ s{(?<!\\)\\"}{\\\\\\"}g; # \"  -> \\\"
      $text =~ s{(?<!\\)"}{\\"}g;       # "   -> \"
      $text = qq{"$text"} if $text =~ /[ \t]/;
  
      # Apply the Command Prompt parsing rules (cmd.exe)
      my @text = split /("[^"]*")/, $text;
      # We should also escape parentheses, but it breaks one-liners containing
      # $(MACRO)s in makefiles.
      s{([<>|&^@!])}{^$1}g foreach grep { !/^"[^"]*"$/ } @text;
      $text = join('', @text);
  
      # dmake expands {{ to { and }} to }.
      if( $self->is_make_type('dmake') ) {
          $text =~ s/{/{{/g;
          $text =~ s/}/}}/g;
      }
  
      $text = $opts->{allow_variables}
        ? $self->escape_dollarsigns($text) : $self->escape_all_dollarsigns($text);
  
      return $text;
  }
  
  
  sub escape_newlines {
      my($self, $text) = @_;
  
      # Escape newlines
      $text =~ s{\n}{\\\n}g;
  
      return $text;
  }
  
  
  =item cd
  
  dmake can handle Unix style cd'ing but nmake (at least 1.5) cannot.  It
  wants:
  
      cd dir1\dir2
      command
      another_command
      cd ..\..
  
  =cut
  
  sub cd {
      my($self, $dir, @cmds) = @_;
  
      return $self->SUPER::cd($dir, @cmds) unless $self->is_make_type('nmake');
  
      my $cmd = join "\n\t", map "$_", @cmds;
  
      my $updirs = $self->catdir(map { $self->updir } $self->splitdir($dir));
  
      # No leading tab and no trailing newline makes for easier embedding.
      my $make_frag = sprintf <<'MAKE_FRAG', $dir, $cmd, $updirs;
  cd %s
  	%s
  	cd %s
  MAKE_FRAG
  
      chomp $make_frag;
  
      return $make_frag;
  }
  
  
  =item max_exec_len
  
  nmake 1.50 limits command length to 2048 characters.
  
  =cut
  
  sub max_exec_len {
      my $self = shift;
  
      return $self->{_MAX_EXEC_LEN} ||= 2 * 1024;
  }
  
  
  =item os_flavor
  
  Windows is Win32.
  
  =cut
  
  sub os_flavor {
      return('Win32');
  }
  
  
  =item cflags
  
  Defines the PERLDLL symbol if we are configured for static building since all
  code destined for the perl5xx.dll must be compiled with the PERLDLL symbol
  defined.
  
  =cut
  
  sub cflags {
      my($self,$libperl)=@_;
      return $self->{CFLAGS} if $self->{CFLAGS};
      return '' unless $self->needs_linking();
  
      my $base = $self->SUPER::cflags($libperl);
      foreach (split /\n/, $base) {
          /^(\S*)\s*=\s*(\S*)$/ and $self->{$1} = $2;
      };
      $self->{CCFLAGS} .= " -DPERLDLL" if ($self->{LINKTYPE} eq 'static');
  
      return $self->{CFLAGS} = qq{
  CCFLAGS = $self->{CCFLAGS}
  OPTIMIZE = $self->{OPTIMIZE}
  PERLTYPE = $self->{PERLTYPE}
  };
  
  }
  
  1;
  __END__
  
  =back
PERL5_EXTUTILS_MM_WIN32

$fatpacked{"perl5/ExtUtils/MM_Win95.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_EXTUTILS_MM_WIN95';
  package ExtUtils::MM_Win95;
  
  use strict;
  
  our $VERSION = '7.10';
  
  require ExtUtils::MM_Win32;
  our @ISA = qw(ExtUtils::MM_Win32);
  
  use ExtUtils::MakeMaker::Config;
  
  
  =head1 NAME
  
  ExtUtils::MM_Win95 - method to customize MakeMaker for Win9X
  
  =head1 SYNOPSIS
  
    You should not be using this module directly.
  
  =head1 DESCRIPTION
  
  This is a subclass of ExtUtils::MM_Win32 containing changes necessary
  to get MakeMaker playing nice with command.com and other Win9Xisms.
  
  =head2 Overridden methods
  
  Most of these make up for limitations in the Win9x/nmake command shell.
  Mostly its lack of &&.
  
  =over 4
  
  
  =item xs_c
  
  The && problem.
  
  =cut
  
  sub xs_c {
      my($self) = shift;
      return '' unless $self->needs_linking();
      '
  .xs.c:
  	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.c
  	'
  }
  
  
  =item xs_cpp
  
  The && problem
  
  =cut
  
  sub xs_cpp {
      my($self) = shift;
      return '' unless $self->needs_linking();
      '
  .xs.cpp:
  	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.cpp
  	';
  }
  
  =item xs_o
  
  The && problem.
  
  =cut
  
  sub xs_o {
      my($self) = shift;
      return '' unless $self->needs_linking();
      '
  .xs$(OBJ_EXT):
  	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.c
  	$(CCCMD) $(CCCDLFLAGS) -I$(PERL_INC) $(DEFINE) $*.c
  	';
  }
  
  
  =item max_exec_len
  
  Win98 chokes on things like Encode if we set the max length to nmake's max
  of 2K.  So we go for a more conservative value of 1K.
  
  =cut
  
  sub max_exec_len {
      my $self = shift;
  
      return $self->{_MAX_EXEC_LEN} ||= 1024;
  }
  
  
  =item os_flavor
  
  Win95 and Win98 and WinME are collectively Win9x and Win32
  
  =cut
  
  sub os_flavor {
      my $self = shift;
      return ($self->SUPER::os_flavor, 'Win9x');
  }
  
  
  =back
  
  
  =head1 AUTHOR
  
  Code originally inside MM_Win32.  Original author unknown.
  
  Currently maintained by Michael G Schwern C<schwern@pobox.com>.
  
  Send patches and ideas to C<makemaker@perl.org>.
  
  See https://metacpan.org/release/ExtUtils-MakeMaker.
  
  =cut
  
  
  1;
PERL5_EXTUTILS_MM_WIN95

$fatpacked{"perl5/ExtUtils/MY.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_EXTUTILS_MY';
  package ExtUtils::MY;
  
  use strict;
  require ExtUtils::MM;
  
  our $VERSION = '7.10';
  our @ISA = qw(ExtUtils::MM);
  
  {
      package MY;
      our @ISA = qw(ExtUtils::MY);
  }
  
  sub DESTROY {}
  
  
  =head1 NAME
  
  ExtUtils::MY - ExtUtils::MakeMaker subclass for customization
  
  =head1 SYNOPSIS
  
    # in your Makefile.PL
    sub MY::whatever {
        ...
    }
  
  =head1 DESCRIPTION
  
  B<FOR INTERNAL USE ONLY>
  
  ExtUtils::MY is a subclass of ExtUtils::MM.  Its provided in your
  Makefile.PL for you to add and override MakeMaker functionality.
  
  It also provides a convenient alias via the MY class.
  
  ExtUtils::MY might turn out to be a temporary solution, but MY won't
  go away.
  
  =cut
PERL5_EXTUTILS_MY

$fatpacked{"perl5/ExtUtils/MakeMaker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_EXTUTILS_MAKEMAKER';
  # $Id$
  package ExtUtils::MakeMaker;
  
  use strict;
  
  BEGIN {require 5.006;}
  
  require Exporter;
  use ExtUtils::MakeMaker::Config;
  use ExtUtils::MakeMaker::version; # ensure we always have our fake version.pm
  use Carp;
  use File::Path;
  my $CAN_DECODE = eval { require ExtUtils::MakeMaker::Locale; }; # 2 birds, 1 stone
  eval { ExtUtils::MakeMaker::Locale::reinit('UTF-8') }
    if $CAN_DECODE and $ExtUtils::MakeMaker::Locale::ENCODING_LOCALE eq 'US-ASCII';
  
  our $Verbose = 0;       # exported
  our @Parent;            # needs to be localized
  our @Get_from_Config;   # referenced by MM_Unix
  our @MM_Sections;
  our @Overridable;
  my @Prepend_parent;
  my %Recognized_Att_Keys;
  our %macro_fsentity; # whether a macro is a filesystem name
  our %macro_dep; # whether a macro is a dependency
  
  our $VERSION = '7.10';
  $VERSION = eval $VERSION;  ## no critic [BuiltinFunctions::ProhibitStringyEval]
  
  # Emulate something resembling CVS $Revision$
  (our $Revision = $VERSION) =~ s{_}{};
  $Revision = int $Revision * 10000;
  
  our $Filename = __FILE__;   # referenced outside MakeMaker
  
  our @ISA = qw(Exporter);
  our @EXPORT    = qw(&WriteMakefile $Verbose &prompt);
  our @EXPORT_OK = qw($VERSION &neatvalue &mkbootstrap &mksymlists
                      &WriteEmptyMakefile);
  
  # These will go away once the last of the Win32 & VMS specific code is
  # purged.
  my $Is_VMS     = $^O eq 'VMS';
  my $Is_Win32   = $^O eq 'MSWin32';
  my $UNDER_CORE = $ENV{PERL_CORE};
  
  full_setup();
  
  require ExtUtils::MM;  # Things like CPAN assume loading ExtUtils::MakeMaker
                         # will give them MM.
  
  require ExtUtils::MY;  # XXX pre-5.8 versions of ExtUtils::Embed expect
                         # loading ExtUtils::MakeMaker will give them MY.
                         # This will go when Embed is its own CPAN module.
  
  
  sub WriteMakefile {
      croak "WriteMakefile: Need even number of args" if @_ % 2;
  
      require ExtUtils::MY;
      my %att = @_;
  
      _convert_compat_attrs(\%att);
  
      _verify_att(\%att);
  
      my $mm = MM->new(\%att);
      $mm->flush;
  
      return $mm;
  }
  
  
  # Basic signatures of the attributes WriteMakefile takes.  Each is the
  # reference type.  Empty value indicate it takes a non-reference
  # scalar.
  my %Att_Sigs;
  my %Special_Sigs = (
   AUTHOR             => 'ARRAY',
   C                  => 'ARRAY',
   CONFIG             => 'ARRAY',
   CONFIGURE          => 'CODE',
   DIR                => 'ARRAY',
   DL_FUNCS           => 'HASH',
   DL_VARS            => 'ARRAY',
   EXCLUDE_EXT        => 'ARRAY',
   EXE_FILES          => 'ARRAY',
   FUNCLIST           => 'ARRAY',
   H                  => 'ARRAY',
   IMPORTS            => 'HASH',
   INCLUDE_EXT        => 'ARRAY',
   LIBS               => ['ARRAY',''],
   MAN1PODS           => 'HASH',
   MAN3PODS           => 'HASH',
   META_ADD           => 'HASH',
   META_MERGE         => 'HASH',
   OBJECT             => ['ARRAY', ''],
   PL_FILES           => 'HASH',
   PM                 => 'HASH',
   PMLIBDIRS          => 'ARRAY',
   PMLIBPARENTDIRS    => 'ARRAY',
   PREREQ_PM          => 'HASH',
   BUILD_REQUIRES     => 'HASH',
   CONFIGURE_REQUIRES => 'HASH',
   TEST_REQUIRES      => 'HASH',
   SKIP               => 'ARRAY',
   TYPEMAPS           => 'ARRAY',
   XS                 => 'HASH',
   VERSION            => ['version',''],
   _KEEP_AFTER_FLUSH  => '',
  
   clean      => 'HASH',
   depend     => 'HASH',
   dist       => 'HASH',
   dynamic_lib=> 'HASH',
   linkext    => 'HASH',
   macro      => 'HASH',
   postamble  => 'HASH',
   realclean  => 'HASH',
   test       => 'HASH',
   tool_autosplit => 'HASH',
  );
  
  @Att_Sigs{keys %Recognized_Att_Keys} = ('') x keys %Recognized_Att_Keys;
  @Att_Sigs{keys %Special_Sigs} = values %Special_Sigs;
  
  sub _convert_compat_attrs { #result of running several times should be same
      my($att) = @_;
      if (exists $att->{AUTHOR}) {
          if ($att->{AUTHOR}) {
              if (!ref($att->{AUTHOR})) {
                  my $t = $att->{AUTHOR};
                  $att->{AUTHOR} = [$t];
              }
          } else {
                  $att->{AUTHOR} = [];
          }
      }
  }
  
  sub _verify_att {
      my($att) = @_;
  
      while( my($key, $val) = each %$att ) {
          my $sig = $Att_Sigs{$key};
          unless( defined $sig ) {
              warn "WARNING: $key is not a known parameter.\n";
              next;
          }
  
          my @sigs   = ref $sig ? @$sig : $sig;
          my $given  = ref $val;
          unless( grep { _is_of_type($val, $_) } @sigs ) {
              my $takes = join " or ", map { _format_att($_) } @sigs;
  
              my $has = _format_att($given);
              warn "WARNING: $key takes a $takes not a $has.\n".
                   "         Please inform the author.\n";
          }
      }
  }
  
  
  # Check if a given thing is a reference or instance of $type
  sub _is_of_type {
      my($thing, $type) = @_;
  
      return 1 if ref $thing eq $type;
  
      local $SIG{__DIE__};
      return 1 if eval{ $thing->isa($type) };
  
      return 0;
  }
  
  
  sub _format_att {
      my $given = shift;
  
      return $given eq ''        ? "string/number"
           : uc $given eq $given ? "$given reference"
           :                       "$given object"
           ;
  }
  
  
  sub prompt ($;$) {  ## no critic
      my($mess, $def) = @_;
      confess("prompt function called without an argument")
          unless defined $mess;
  
      my $isa_tty = -t STDIN && (-t STDOUT || !(-f STDOUT || -c STDOUT)) ;
  
      my $dispdef = defined $def ? "[$def] " : " ";
      $def = defined $def ? $def : "";
  
      local $|=1;
      local $\;
      print "$mess $dispdef";
  
      my $ans;
      if ($ENV{PERL_MM_USE_DEFAULT} || (!$isa_tty && eof STDIN)) {
          print "$def\n";
      }
      else {
          $ans = <STDIN>;
          if( defined $ans ) {
              $ans =~ s{\015?\012$}{};
          }
          else { # user hit ctrl-D
              print "\n";
          }
      }
  
      return (!defined $ans || $ans eq '') ? $def : $ans;
  }
  
  sub eval_in_subdirs {
      my($self) = @_;
      use Cwd qw(cwd abs_path);
      my $pwd = cwd() || die "Can't figure out your cwd!";
  
      local @INC = map eval {abs_path($_) if -e} || $_, @INC;
      push @INC, '.';     # '.' has to always be at the end of @INC
  
      foreach my $dir (@{$self->{DIR}}){
          my($abs) = $self->catdir($pwd,$dir);
          eval { $self->eval_in_x($abs); };
          last if $@;
      }
      chdir $pwd;
      die $@ if $@;
  }
  
  sub eval_in_x {
      my($self,$dir) = @_;
      chdir $dir or carp("Couldn't change to directory $dir: $!");
  
      {
          package main;
          do './Makefile.PL';
      };
      if ($@) {
  #         if ($@ =~ /prerequisites/) {
  #             die "MakeMaker WARNING: $@";
  #         } else {
  #             warn "WARNING from evaluation of $dir/Makefile.PL: $@";
  #         }
          die "ERROR from evaluation of $dir/Makefile.PL: $@";
      }
  }
  
  
  # package name for the classes into which the first object will be blessed
  my $PACKNAME = 'PACK000';
  
  sub full_setup {
      $Verbose ||= 0;
  
      my @dep_macros = qw/
      PERL_INCDEP        PERL_ARCHLIBDEP     PERL_ARCHIVEDEP
      /;
  
      my @fs_macros = qw/
      FULLPERL XSUBPPDIR
  
      INST_ARCHLIB INST_SCRIPT INST_BIN INST_LIB INST_MAN1DIR INST_MAN3DIR
      INSTALLDIRS
      DESTDIR PREFIX INSTALL_BASE
      PERLPREFIX      SITEPREFIX      VENDORPREFIX
      INSTALLPRIVLIB  INSTALLSITELIB  INSTALLVENDORLIB
      INSTALLARCHLIB  INSTALLSITEARCH INSTALLVENDORARCH
      INSTALLBIN      INSTALLSITEBIN  INSTALLVENDORBIN
      INSTALLMAN1DIR          INSTALLMAN3DIR
      INSTALLSITEMAN1DIR      INSTALLSITEMAN3DIR
      INSTALLVENDORMAN1DIR    INSTALLVENDORMAN3DIR
      INSTALLSCRIPT   INSTALLSITESCRIPT  INSTALLVENDORSCRIPT
      PERL_LIB        PERL_ARCHLIB
      SITELIBEXP      SITEARCHEXP
  
      MAKE LIBPERL_A LIB PERL_SRC PERL_INC
      PPM_INSTALL_EXEC PPM_UNINSTALL_EXEC
      PPM_INSTALL_SCRIPT PPM_UNINSTALL_SCRIPT
      /;
  
      my @attrib_help = qw/
  
      AUTHOR ABSTRACT ABSTRACT_FROM BINARY_LOCATION
      C CAPI CCFLAGS CONFIG CONFIGURE DEFINE DIR DISTNAME DISTVNAME
      DL_FUNCS DL_VARS
      EXCLUDE_EXT EXE_FILES FIRST_MAKEFILE
      FULLPERLRUN FULLPERLRUNINST
      FUNCLIST H IMPORTS
  
      INC INCLUDE_EXT LDFROM LIBS LICENSE
      LINKTYPE MAKEAPERL MAKEFILE MAKEFILE_OLD MAN1PODS MAN3PODS MAP_TARGET
      META_ADD META_MERGE MIN_PERL_VERSION BUILD_REQUIRES CONFIGURE_REQUIRES
      MYEXTLIB NAME NEEDS_LINKING NOECHO NO_META NO_MYMETA NO_PACKLIST NO_PERLLOCAL
      NORECURS NO_VC OBJECT OPTIMIZE PERL_MALLOC_OK PERL PERLMAINCC PERLRUN
      PERLRUNINST PERL_CORE
      PERM_DIR PERM_RW PERM_RWX MAGICXS
      PL_FILES PM PM_FILTER PMLIBDIRS PMLIBPARENTDIRS POLLUTE
      PREREQ_FATAL PREREQ_PM PREREQ_PRINT PRINT_PREREQ
      SIGN SKIP TEST_REQUIRES TYPEMAPS UNINST VERSION VERSION_FROM XS XSOPT XSPROTOARG
      XS_VERSION clean depend dist dynamic_lib linkext macro realclean
      tool_autosplit
  
      MAN1EXT MAN3EXT
  
      MACPERL_SRC MACPERL_LIB MACLIBS_68K MACLIBS_PPC MACLIBS_SC MACLIBS_MRC
      MACLIBS_ALL_68K MACLIBS_ALL_PPC MACLIBS_SHARED
          /;
      push @attrib_help, @fs_macros;
      @macro_fsentity{@fs_macros, @dep_macros} = (1) x (@fs_macros+@dep_macros);
      @macro_dep{@dep_macros} = (1) x @dep_macros;
  
      # IMPORTS is used under OS/2 and Win32
  
      # @Overridable is close to @MM_Sections but not identical.  The
      # order is important. Many subroutines declare macros. These
      # depend on each other. Let's try to collect the macros up front,
      # then pasthru, then the rules.
  
      # MM_Sections are the sections we have to call explicitly
      # in Overridable we have subroutines that are used indirectly
  
  
      @MM_Sections =
          qw(
  
   post_initialize const_config constants platform_constants
   tool_autosplit tool_xsubpp tools_other
  
   makemakerdflt
  
   dist macro depend cflags const_loadlibs const_cccmd
   post_constants
  
   pasthru
  
   special_targets
   c_o xs_c xs_o
   top_targets blibdirs linkext dlsyms dynamic_bs dynamic
   dynamic_lib static static_lib manifypods processPL
   installbin subdirs
   clean_subdirs clean realclean_subdirs realclean
   metafile signature
   dist_basics dist_core distdir dist_test dist_ci distmeta distsignature
   install force perldepend makefile staticmake test ppd
  
            ); # loses section ordering
  
      @Overridable = @MM_Sections;
      push @Overridable, qw[
  
   libscan makeaperl needs_linking
   subdir_x test_via_harness test_via_script
  
   init_VERSION init_dist init_INST init_INSTALL init_DEST init_dirscan
   init_PM init_MANPODS init_xs init_PERL init_DIRFILESEP init_linker
                           ];
  
      push @MM_Sections, qw[
  
   pm_to_blib selfdocument
  
                           ];
  
      # Postamble needs to be the last that was always the case
      push @MM_Sections, "postamble";
      push @Overridable, "postamble";
  
      # All sections are valid keys.
      @Recognized_Att_Keys{@MM_Sections} = (1) x @MM_Sections;
  
      # we will use all these variables in the Makefile
      @Get_from_Config =
          qw(
             ar cc cccdlflags ccdlflags dlext dlsrc exe_ext full_ar ld
             lddlflags ldflags libc lib_ext obj_ext osname osvers ranlib
             sitelibexp sitearchexp so
            );
  
      # 5.5.3 doesn't have any concept of vendor libs
      push @Get_from_Config, qw( vendorarchexp vendorlibexp ) if $] >= 5.006;
  
      foreach my $item (@attrib_help){
          $Recognized_Att_Keys{$item} = 1;
      }
      foreach my $item (@Get_from_Config) {
          $Recognized_Att_Keys{uc $item} = $Config{$item};
          print "Attribute '\U$item\E' => '$Config{$item}'\n"
              if ($Verbose >= 2);
      }
  
      #
      # When we eval a Makefile.PL in a subdirectory, that one will ask
      # us (the parent) for the values and will prepend "..", so that
      # all files to be installed end up below OUR ./blib
      #
      @Prepend_parent = qw(
             INST_BIN INST_LIB INST_ARCHLIB INST_SCRIPT
             MAP_TARGET INST_MAN1DIR INST_MAN3DIR PERL_SRC
             PERL FULLPERL
      );
  }
  
  sub new {
      my($class,$self) = @_;
      my($key);
  
      _convert_compat_attrs($self) if defined $self && $self;
  
      # Store the original args passed to WriteMakefile()
      foreach my $k (keys %$self) {
          $self->{ARGS}{$k} = $self->{$k};
      }
  
      $self = {} unless defined $self;
  
      # Temporarily bless it into MM so it can be used as an
      # object.  It will be blessed into a temp package later.
      bless $self, "MM";
  
      # Cleanup all the module requirement bits
      for my $key (qw(PREREQ_PM BUILD_REQUIRES CONFIGURE_REQUIRES TEST_REQUIRES)) {
          $self->{$key}      ||= {};
          $self->clean_versions( $key );
      }
  
  
      if ("@ARGV" =~ /\bPREREQ_PRINT\b/) {
          $self->_PREREQ_PRINT;
      }
  
      # PRINT_PREREQ is RedHatism.
      if ("@ARGV" =~ /\bPRINT_PREREQ\b/) {
          $self->_PRINT_PREREQ;
     }
  
      print "MakeMaker (v$VERSION)\n" if $Verbose;
      if (-f "MANIFEST" && ! -f "Makefile" && ! $UNDER_CORE){
          check_manifest();
      }
  
      check_hints($self);
  
      if ( defined $self->{MIN_PERL_VERSION}
            && $self->{MIN_PERL_VERSION} !~ /^v?[\d_\.]+$/ ) {
        require version;
        my $normal = eval {
          local $SIG{__WARN__} = sub {
              # simulate "use warnings FATAL => 'all'" for vintage perls
              die @_;
          };
          version->new( $self->{MIN_PERL_VERSION} )
        };
        $self->{MIN_PERL_VERSION} = $normal if defined $normal && !$@;
      }
  
      # Translate X.Y.Z to X.00Y00Z
      if( defined $self->{MIN_PERL_VERSION} ) {
          $self->{MIN_PERL_VERSION} =~ s{ ^v? (\d+) \. (\d+) \. (\d+) $ }
                                        {sprintf "%d.%03d%03d", $1, $2, $3}ex;
      }
  
      my $perl_version_ok = eval {
          local $SIG{__WARN__} = sub {
              # simulate "use warnings FATAL => 'all'" for vintage perls
              die @_;
          };
          !$self->{MIN_PERL_VERSION} or $self->{MIN_PERL_VERSION} <= $]
      };
      if (!$perl_version_ok) {
          if (!defined $perl_version_ok) {
              die <<'END';
  Warning: MIN_PERL_VERSION is not in a recognized format.
  Recommended is a quoted numerical value like '5.005' or '5.008001'.
  END
          }
          elsif ($self->{PREREQ_FATAL}) {
              die sprintf <<"END", $self->{MIN_PERL_VERSION}, $];
  MakeMaker FATAL: perl version too low for this distribution.
  Required is %s. We run %s.
  END
          }
          else {
              warn sprintf
                  "Warning: Perl version %s or higher required. We run %s.\n",
                  $self->{MIN_PERL_VERSION}, $];
          }
      }
  
      my %configure_att;         # record &{$self->{CONFIGURE}} attributes
      my(%initial_att) = %$self; # record initial attributes
  
      my(%unsatisfied) = ();
      my $prereqs = $self->_all_prereqs;
      foreach my $prereq (sort keys %$prereqs) {
          my $required_version = $prereqs->{$prereq};
  
          my $pr_version = 0;
          my $installed_file;
  
          if ( $prereq eq 'perl' ) {
            if ( defined $required_version && $required_version =~ /^v?[\d_\.]+$/
                 || $required_version !~ /^v?[\d_\.]+$/ ) {
              require version;
              my $normal = eval { version->new( $required_version ) };
              $required_version = $normal if defined $normal;
            }
            $installed_file = $prereq;
            $pr_version = $];
          }
          else {
            $installed_file = MM->_installed_file_for_module($prereq);
            $pr_version = MM->parse_version($installed_file) if $installed_file;
            $pr_version = 0 if $pr_version eq 'undef';
          }
  
          # convert X.Y_Z alpha version #s to X.YZ for easier comparisons
          $pr_version =~ s/(\d+)\.(\d+)_(\d+)/$1.$2$3/;
  
          if (!$installed_file) {
              warn sprintf "Warning: prerequisite %s %s not found.\n",
                $prereq, $required_version
                     unless $self->{PREREQ_FATAL}
                         or $UNDER_CORE;
  
              $unsatisfied{$prereq} = 'not installed';
          }
          elsif ($pr_version < $required_version ){
              warn sprintf "Warning: prerequisite %s %s not found. We have %s.\n",
                $prereq, $required_version, ($pr_version || 'unknown version')
                    unless $self->{PREREQ_FATAL}
                         or $UNDER_CORE;
  
              $unsatisfied{$prereq} = $required_version ? $required_version : 'unknown version' ;
          }
      }
  
      if (%unsatisfied && $self->{PREREQ_FATAL}){
          my $failedprereqs = join "\n", map {"    $_ $unsatisfied{$_}"}
                              sort { $a cmp $b } keys %unsatisfied;
          die <<"END";
  MakeMaker FATAL: prerequisites not found.
  $failedprereqs
  
  Please install these modules first and rerun 'perl Makefile.PL'.
  END
      }
  
      if (defined $self->{CONFIGURE}) {
          if (ref $self->{CONFIGURE} eq 'CODE') {
              %configure_att = %{&{$self->{CONFIGURE}}};
              _convert_compat_attrs(\%configure_att);
              $self = { %$self, %configure_att };
          } else {
              croak "Attribute 'CONFIGURE' to WriteMakefile() not a code reference\n";
          }
      }
  
      # This is for old Makefiles written pre 5.00, will go away
      if ( Carp::longmess("") =~ /runsubdirpl/s ){
          carp("WARNING: Please rerun 'perl Makefile.PL' to regenerate your Makefiles\n");
      }
  
      my $newclass = ++$PACKNAME;
      local @Parent = @Parent;    # Protect against non-local exits
      {
          print "Blessing Object into class [$newclass]\n" if $Verbose>=2;
          mv_all_methods("MY",$newclass);
          bless $self, $newclass;
          push @Parent, $self;
          require ExtUtils::MY;
  
          no strict 'refs';   ## no critic;
          @{"$newclass\:\:ISA"} = 'MM';
      }
  
      if (defined $Parent[-2]){
          $self->{PARENT} = $Parent[-2];
          for my $key (@Prepend_parent) {
              next unless defined $self->{PARENT}{$key};
  
              # Don't stomp on WriteMakefile() args.
              next if defined $self->{ARGS}{$key} and
                      $self->{ARGS}{$key} eq $self->{$key};
  
              $self->{$key} = $self->{PARENT}{$key};
  
              if ($Is_VMS && $key =~ /PERL$/) {
                  # PERL or FULLPERL will be a command verb or even a
                  # command with an argument instead of a full file
                  # specification under VMS.  So, don't turn the command
                  # into a filespec, but do add a level to the path of
                  # the argument if not already absolute.
                  my @cmd = split /\s+/, $self->{$key};
                  $cmd[1] = $self->catfile('[-]',$cmd[1])
                    unless (@cmd < 2) || $self->file_name_is_absolute($cmd[1]);
                  $self->{$key} = join(' ', @cmd);
              } else {
                  my $value = $self->{$key};
                  # not going to test in FS so only stripping start
                  $value =~ s/^"// if $key =~ /PERL$/;
                  $value = $self->catdir("..", $value)
                    unless $self->file_name_is_absolute($value);
                  $value = qq{"$value} if $key =~ /PERL$/;
                  $self->{$key} = $value;
              }
          }
          if ($self->{PARENT}) {
              $self->{PARENT}->{CHILDREN}->{$newclass} = $self;
              foreach my $opt (qw(POLLUTE PERL_CORE LINKTYPE LD OPTIMIZE)) {
                  if (exists $self->{PARENT}->{$opt}
                      and not exists $self->{$opt})
                      {
                          # inherit, but only if already unspecified
                          $self->{$opt} = $self->{PARENT}->{$opt};
                      }
              }
          }
          my @fm = grep /^FIRST_MAKEFILE=/, @ARGV;
          parse_args($self,@fm) if @fm;
      }
      else {
          parse_args($self, _shellwords($ENV{PERL_MM_OPT} || ''),@ARGV);
      }
  
      # RT#91540 PREREQ_FATAL not recognized on command line
      if (%unsatisfied && $self->{PREREQ_FATAL}){
          my $failedprereqs = join "\n", map {"    $_ $unsatisfied{$_}"}
                              sort { $a cmp $b } keys %unsatisfied;
          die <<"END";
  MakeMaker FATAL: prerequisites not found.
  $failedprereqs
  
  Please install these modules first and rerun 'perl Makefile.PL'.
  END
      }
  
      $self->{NAME} ||= $self->guess_name;
  
      warn "Warning: NAME must be a package name\n"
        unless $self->{NAME} =~ m!^[A-Z_a-z][0-9A-Z_a-z]*(?:::[0-9A-Z_a-z]+)*$!;
  
      ($self->{NAME_SYM} = $self->{NAME}) =~ s/\W+/_/g;
  
      $self->init_MAKE;
      $self->init_main;
      $self->init_VERSION;
      $self->init_dist;
      $self->init_INST;
      $self->init_INSTALL;
      $self->init_DEST;
      $self->init_dirscan;
      $self->init_PM;
      $self->init_MANPODS;
      $self->init_xs;
      $self->init_PERL;
      $self->init_DIRFILESEP;
      $self->init_linker;
      $self->init_ABSTRACT;
  
      $self->arch_check(
          $INC{'Config.pm'},
          $self->catfile($Config{'archlibexp'}, "Config.pm")
      );
  
      $self->init_tools();
      $self->init_others();
      $self->init_platform();
      $self->init_PERM();
      my($argv) = neatvalue(\@ARGV);
      $argv =~ s/^\[/(/;
      $argv =~ s/\]$/)/;
  
      push @{$self->{RESULT}}, <<END;
  # This Makefile is for the $self->{NAME} extension to perl.
  #
  # It was generated automatically by MakeMaker version
  # $VERSION (Revision: $Revision) from the contents of
  # Makefile.PL. Don't edit this file, edit Makefile.PL instead.
  #
  #       ANY CHANGES MADE HERE WILL BE LOST!
  #
  #   MakeMaker ARGV: $argv
  #
  END
  
      push @{$self->{RESULT}}, $self->_MakeMaker_Parameters_section(\%initial_att);
  
      if (defined $self->{CONFIGURE}) {
         push @{$self->{RESULT}}, <<END;
  
  #   MakeMaker 'CONFIGURE' Parameters:
  END
          if (scalar(keys %configure_att) > 0) {
              foreach my $key (sort keys %configure_att){
                 next if $key eq 'ARGS';
                 my($v) = neatvalue($configure_att{$key});
                 $v =~ s/(CODE|HASH|ARRAY|SCALAR)\([\dxa-f]+\)/$1\(...\)/;
                 $v =~ tr/\n/ /s;
                 push @{$self->{RESULT}}, "#     $key => $v";
              }
          }
          else
          {
             push @{$self->{RESULT}}, "# no values returned";
          }
          undef %configure_att;  # free memory
      }
  
      # turn the SKIP array into a SKIPHASH hash
      for my $skip (@{$self->{SKIP} || []}) {
          $self->{SKIPHASH}{$skip} = 1;
      }
      delete $self->{SKIP}; # free memory
  
      if ($self->{PARENT}) {
          for (qw/install dist dist_basics dist_core distdir dist_test dist_ci/) {
              $self->{SKIPHASH}{$_} = 1;
          }
      }
  
      # We run all the subdirectories now. They don't have much to query
      # from the parent, but the parent has to query them: if they need linking!
      unless ($self->{NORECURS}) {
          $self->eval_in_subdirs if @{$self->{DIR}};
      }
  
      foreach my $section ( @MM_Sections ){
          # Support for new foo_target() methods.
          my $method = $section;
          $method .= '_target' unless $self->can($method);
  
          print "Processing Makefile '$section' section\n" if ($Verbose >= 2);
          my($skipit) = $self->skipcheck($section);
          if ($skipit){
              push @{$self->{RESULT}}, "\n# --- MakeMaker $section section $skipit.";
          } else {
              my(%a) = %{$self->{$section} || {}};
              push @{$self->{RESULT}}, "\n# --- MakeMaker $section section:";
              push @{$self->{RESULT}}, "# " . join ", ", %a if $Verbose && %a;
              push @{$self->{RESULT}}, $self->maketext_filter(
                  $self->$method( %a )
              );
          }
      }
  
      push @{$self->{RESULT}}, "\n# End.";
  
      $self;
  }
  
  sub WriteEmptyMakefile {
      croak "WriteEmptyMakefile: Need an even number of args" if @_ % 2;
  
      my %att = @_;
      my $self = MM->new(\%att);
  
      my $new = $self->{MAKEFILE};
      my $old = $self->{MAKEFILE_OLD};
      if (-f $old) {
          _unlink($old) or warn "unlink $old: $!";
      }
      if ( -f $new ) {
          _rename($new, $old) or warn "rename $new => $old: $!"
      }
      open my $mfh, '>', $new or die "open $new for write: $!";
      print $mfh <<'EOP';
  all :
  
  clean :
  
  install :
  
  makemakerdflt :
  
  test :
  
  EOP
      close $mfh or die "close $new for write: $!";
  }
  
  
  =begin private
  
  =head3 _installed_file_for_module
  
    my $file = MM->_installed_file_for_module($module);
  
  Return the first installed .pm $file associated with the $module.  The
  one which will show up when you C<use $module>.
  
  $module is something like "strict" or "Test::More".
  
  =end private
  
  =cut
  
  sub _installed_file_for_module {
      my $class  = shift;
      my $prereq = shift;
  
      my $file = "$prereq.pm";
      $file =~ s{::}{/}g;
  
      my $path;
      for my $dir (@INC) {
          my $tmp = File::Spec->catfile($dir, $file);
          if ( -r $tmp ) {
              $path = $tmp;
              last;
          }
      }
  
      return $path;
  }
  
  
  # Extracted from MakeMaker->new so we can test it
  sub _MakeMaker_Parameters_section {
      my $self = shift;
      my $att  = shift;
  
      my @result = <<'END';
  #   MakeMaker Parameters:
  END
  
      foreach my $key (sort keys %$att){
          next if $key eq 'ARGS';
          my $v;
          if ($key eq 'PREREQ_PM') {
              # CPAN.pm takes prereqs from this field in 'Makefile'
              # and does not know about BUILD_REQUIRES
              $v = neatvalue({
                  %{ $att->{PREREQ_PM} || {} },
                  %{ $att->{BUILD_REQUIRES} || {} },
                  %{ $att->{TEST_REQUIRES} || {} },
              });
          } else {
              $v = neatvalue($att->{$key});
          }
  
          $v =~ s/(CODE|HASH|ARRAY|SCALAR)\([\dxa-f]+\)/$1\(...\)/;
          $v =~ tr/\n/ /s;
          push @result, "#     $key => $v";
      }
  
      return @result;
  }
  
  # _shellwords and _parseline borrowed from Text::ParseWords
  sub _shellwords {
      my (@lines) = @_;
      my @allwords;
  
      foreach my $line (@lines) {
        $line =~ s/^\s+//;
        my @words = _parse_line('\s+', 0, $line);
        pop @words if (@words and !defined $words[-1]);
        return() unless (@words || !length($line));
        push(@allwords, @words);
      }
      return(@allwords);
  }
  
  sub _parse_line {
      my($delimiter, $keep, $line) = @_;
      my($word, @pieces);
  
      no warnings 'uninitialized';  # we will be testing undef strings
  
      while (length($line)) {
          # This pattern is optimised to be stack conservative on older perls.
          # Do not refactor without being careful and testing it on very long strings.
          # See Perl bug #42980 for an example of a stack busting input.
          $line =~ s/^
                      (?:
                          # double quoted string
                          (")                             # $quote
                          ((?>[^\\"]*(?:\\.[^\\"]*)*))"   # $quoted
          | # --OR--
                          # singe quoted string
                          (')                             # $quote
                          ((?>[^\\']*(?:\\.[^\\']*)*))'   # $quoted
                      |   # --OR--
                          # unquoted string
              (                               # $unquoted
                              (?:\\.|[^\\"'])*?
                          )
                          # followed by
              (                               # $delim
                              \Z(?!\n)                    # EOL
                          |   # --OR--
                              (?-x:$delimiter)            # delimiter
                          |   # --OR--
                              (?!^)(?=["'])               # a quote
                          )
          )//xs or return;    # extended layout
          my ($quote, $quoted, $unquoted, $delim) = (($1 ? ($1,$2) : ($3,$4)), $5, $6);
  
  
    return() unless( defined($quote) || length($unquoted) || length($delim));
  
          if ($keep) {
        $quoted = "$quote$quoted$quote";
    }
          else {
        $unquoted =~ s/\\(.)/$1/sg;
        if (defined $quote) {
      $quoted =~ s/\\(.)/$1/sg if ($quote eq '"');
      #$quoted =~ s/\\([\\'])/$1/g if ( $PERL_SINGLE_QUOTE && $quote eq "'");
              }
    }
          $word .= substr($line, 0, 0); # leave results tainted
          $word .= defined $quote ? $quoted : $unquoted;
  
          if (length($delim)) {
              push(@pieces, $word);
              push(@pieces, $delim) if ($keep eq 'delimiters');
              undef $word;
          }
          if (!length($line)) {
              push(@pieces, $word);
    }
      }
      return(@pieces);
  }
  
  sub check_manifest {
      print "Checking if your kit is complete...\n";
      require ExtUtils::Manifest;
      # avoid warning
      $ExtUtils::Manifest::Quiet = $ExtUtils::Manifest::Quiet = 1;
      my(@missed) = ExtUtils::Manifest::manicheck();
      if (@missed) {
          print "Warning: the following files are missing in your kit:\n";
          print "\t", join "\n\t", @missed;
          print "\n";
          print "Please inform the author.\n";
      } else {
          print "Looks good\n";
      }
  }
  
  sub parse_args{
      my($self, @args) = @_;
      @args = map { Encode::decode(locale => $_) } @args if $CAN_DECODE;
      foreach (@args) {
          unless (m/(.*?)=(.*)/) {
              ++$Verbose if m/^verb/;
              next;
          }
          my($name, $value) = ($1, $2);
          if ($value =~ m/^~(\w+)?/) { # tilde with optional username
              $value =~ s [^~(\w*)]
                  [$1 ?
                   ((getpwnam($1))[7] || "~$1") :
                   (getpwuid($>))[7]
                   ]ex;
          }
  
          # Remember the original args passed it.  It will be useful later.
          $self->{ARGS}{uc $name} = $self->{uc $name} = $value;
      }
  
      # catch old-style 'potential_libs' and inform user how to 'upgrade'
      if (defined $self->{potential_libs}){
          my($msg)="'potential_libs' => '$self->{potential_libs}' should be";
          if ($self->{potential_libs}){
              print "$msg changed to:\n\t'LIBS' => ['$self->{potential_libs}']\n";
          } else {
              print "$msg deleted.\n";
          }
          $self->{LIBS} = [$self->{potential_libs}];
          delete $self->{potential_libs};
      }
      # catch old-style 'ARMAYBE' and inform user how to 'upgrade'
      if (defined $self->{ARMAYBE}){
          my($armaybe) = $self->{ARMAYBE};
          print "ARMAYBE => '$armaybe' should be changed to:\n",
                          "\t'dynamic_lib' => {ARMAYBE => '$armaybe'}\n";
          my(%dl) = %{$self->{dynamic_lib} || {}};
          $self->{dynamic_lib} = { %dl, ARMAYBE => $armaybe};
          delete $self->{ARMAYBE};
      }
      if (defined $self->{LDTARGET}){
          print "LDTARGET should be changed to LDFROM\n";
          $self->{LDFROM} = $self->{LDTARGET};
          delete $self->{LDTARGET};
      }
      # Turn a DIR argument on the command line into an array
      if (defined $self->{DIR} && ref \$self->{DIR} eq 'SCALAR') {
          # So they can choose from the command line, which extensions they want
          # the grep enables them to have some colons too much in case they
          # have to build a list with the shell
          $self->{DIR} = [grep $_, split ":", $self->{DIR}];
      }
      # Turn a INCLUDE_EXT argument on the command line into an array
      if (defined $self->{INCLUDE_EXT} && ref \$self->{INCLUDE_EXT} eq 'SCALAR') {
          $self->{INCLUDE_EXT} = [grep $_, split '\s+', $self->{INCLUDE_EXT}];
      }
      # Turn a EXCLUDE_EXT argument on the command line into an array
      if (defined $self->{EXCLUDE_EXT} && ref \$self->{EXCLUDE_EXT} eq 'SCALAR') {
          $self->{EXCLUDE_EXT} = [grep $_, split '\s+', $self->{EXCLUDE_EXT}];
      }
  
      foreach my $mmkey (sort keys %$self){
          next if $mmkey eq 'ARGS';
          print "  $mmkey => ", neatvalue($self->{$mmkey}), "\n" if $Verbose;
          print "'$mmkey' is not a known MakeMaker parameter name.\n"
              unless exists $Recognized_Att_Keys{$mmkey};
      }
      $| = 1 if $Verbose;
  }
  
  sub check_hints {
      my($self) = @_;
      # We allow extension-specific hints files.
  
      require File::Spec;
      my $curdir = File::Spec->curdir;
  
      my $hint_dir = File::Spec->catdir($curdir, "hints");
      return unless -d $hint_dir;
  
      # First we look for the best hintsfile we have
      my($hint)="${^O}_$Config{osvers}";
      $hint =~ s/\./_/g;
      $hint =~ s/_$//;
      return unless $hint;
  
      # Also try without trailing minor version numbers.
      while (1) {
          last if -f File::Spec->catfile($hint_dir, "$hint.pl");  # found
      } continue {
          last unless $hint =~ s/_[^_]*$//; # nothing to cut off
      }
      my $hint_file = File::Spec->catfile($hint_dir, "$hint.pl");
  
      return unless -f $hint_file;    # really there
  
      _run_hintfile($self, $hint_file);
  }
  
  sub _run_hintfile {
      our $self;
      local($self) = shift;       # make $self available to the hint file.
      my($hint_file) = shift;
  
      local($@, $!);
      warn "Processing hints file $hint_file\n";
  
      # Just in case the ./ isn't on the hint file, which File::Spec can
      # often strip off, we bung the curdir into @INC
      local @INC = (File::Spec->curdir, @INC);
      my $ret = do $hint_file;
      if( !defined $ret ) {
          my $error = $@ || $!;
          warn $error;
      }
  }
  
  sub mv_all_methods {
      my($from,$to) = @_;
  
      # Here you see the *current* list of methods that are overridable
      # from Makefile.PL via MY:: subroutines. As of VERSION 5.07 I'm
      # still trying to reduce the list to some reasonable minimum --
      # because I want to make it easier for the user. A.K.
  
      local $SIG{__WARN__} = sub {
          # can't use 'no warnings redefined', 5.6 only
          warn @_ unless $_[0] =~ /^Subroutine .* redefined/
      };
      foreach my $method (@Overridable) {
  
          # We cannot say "next" here. Nick might call MY->makeaperl
          # which isn't defined right now
  
          # Above statement was written at 4.23 time when Tk-b8 was
          # around. As Tk-b9 only builds with 5.002something and MM 5 is
          # standard, we try to enable the next line again. It was
          # commented out until MM 5.23
  
          next unless defined &{"${from}::$method"};
  
          {
              no strict 'refs';   ## no critic
              *{"${to}::$method"} = \&{"${from}::$method"};
  
              # If we delete a method, then it will be undefined and cannot
              # be called.  But as long as we have Makefile.PLs that rely on
              # %MY:: being intact, we have to fill the hole with an
              # inheriting method:
  
              {
                  package MY;
                  my $super = "SUPER::".$method;
                  *{$method} = sub {
                      shift->$super(@_);
                  };
              }
          }
      }
  
      # We have to clean out %INC also, because the current directory is
      # changed frequently and Graham Barr prefers to get his version
      # out of a History.pl file which is "required" so wouldn't get
      # loaded again in another extension requiring a History.pl
  
      # With perl5.002_01 the deletion of entries in %INC caused Tk-b11
      # to core dump in the middle of a require statement. The required
      # file was Tk/MMutil.pm.  The consequence is, we have to be
      # extremely careful when we try to give perl a reason to reload a
      # library with same name.  The workaround prefers to drop nothing
      # from %INC and teach the writers not to use such libraries.
  
  #    my $inc;
  #    foreach $inc (keys %INC) {
  #       #warn "***$inc*** deleted";
  #       delete $INC{$inc};
  #    }
  }
  
  sub skipcheck {
      my($self) = shift;
      my($section) = @_;
      if ($section eq 'dynamic') {
          print "Warning (non-fatal): Target 'dynamic' depends on targets ",
          "in skipped section 'dynamic_bs'\n"
              if $self->{SKIPHASH}{dynamic_bs} && $Verbose;
          print "Warning (non-fatal): Target 'dynamic' depends on targets ",
          "in skipped section 'dynamic_lib'\n"
              if $self->{SKIPHASH}{dynamic_lib} && $Verbose;
      }
      if ($section eq 'dynamic_lib') {
          print "Warning (non-fatal): Target '\$(INST_DYNAMIC)' depends on ",
          "targets in skipped section 'dynamic_bs'\n"
              if $self->{SKIPHASH}{dynamic_bs} && $Verbose;
      }
      if ($section eq 'static') {
          print "Warning (non-fatal): Target 'static' depends on targets ",
          "in skipped section 'static_lib'\n"
              if $self->{SKIPHASH}{static_lib} && $Verbose;
      }
      return 'skipped' if $self->{SKIPHASH}{$section};
      return '';
  }
  
  sub flush {
      my $self = shift;
  
      # This needs a bit more work for more wacky OSen
      my $type = 'Unix-style';
      if ( $self->os_flavor_is('Win32') ) {
        my $make = $self->make;
        $make = +( File::Spec->splitpath( $make ) )[-1];
        $make =~ s!\.exe$!!i;
        $type = $make . '-style';
      }
      elsif ( $Is_VMS ) {
          $type = $Config{make} . '-style';
      }
  
      my $finalname = $self->{MAKEFILE};
      print "Generating a $type $finalname\n";
      print "Writing $finalname for $self->{NAME}\n";
  
      unlink($finalname, "MakeMaker.tmp", $Is_VMS ? 'Descrip.MMS' : ());
      open(my $fh,">", "MakeMaker.tmp")
          or die "Unable to open MakeMaker.tmp: $!";
      binmode $fh, ':encoding(locale)' if $CAN_DECODE;
  
      for my $chunk (@{$self->{RESULT}}) {
          my $to_write = $chunk;
          utf8::encode $to_write if !$CAN_DECODE && $] > 5.008;
          print $fh "$to_write\n" or die "Can't write to MakeMaker.tmp: $!";
      }
  
      close $fh
          or die "Can't write to MakeMaker.tmp: $!";
      _rename("MakeMaker.tmp", $finalname) or
        warn "rename MakeMaker.tmp => $finalname: $!";
      chmod 0644, $finalname unless $Is_VMS;
  
      unless ($self->{NO_MYMETA}) {
          # Write MYMETA.yml to communicate metadata up to the CPAN clients
          if ( $self->write_mymeta( $self->mymeta ) ) {
              print "Writing MYMETA.yml and MYMETA.json\n";
          }
  
      }
      my %keep = map { ($_ => 1) } qw(NEEDS_LINKING HAS_LINK_CODE);
      if ($self->{PARENT} && !$self->{_KEEP_AFTER_FLUSH}) {
          foreach (keys %$self) { # safe memory
              delete $self->{$_} unless $keep{$_};
          }
      }
  
      system("$Config::Config{eunicefix} $finalname") unless $Config::Config{eunicefix} eq ":";
  }
  
  # This is a rename for OS's where the target must be unlinked first.
  sub _rename {
      my($src, $dest) = @_;
      chmod 0666, $dest;
      unlink $dest;
      return rename $src, $dest;
  }
  
  # This is an unlink for OS's where the target must be writable first.
  sub _unlink {
      my @files = @_;
      chmod 0666, @files;
      return unlink @files;
  }
  
  
  # The following mkbootstrap() is only for installations that are calling
  # the pre-4.1 mkbootstrap() from their old Makefiles. This MakeMaker
  # writes Makefiles, that use ExtUtils::Mkbootstrap directly.
  sub mkbootstrap {
      die <<END;
  !!! Your Makefile has been built such a long time ago, !!!
  !!! that is unlikely to work with current MakeMaker.   !!!
  !!! Please rebuild your Makefile                       !!!
  END
  }
  
  # Ditto for mksymlists() as of MakeMaker 5.17
  sub mksymlists {
      die <<END;
  !!! Your Makefile has been built such a long time ago, !!!
  !!! that is unlikely to work with current MakeMaker.   !!!
  !!! Please rebuild your Makefile                       !!!
  END
  }
  
  sub neatvalue {
      my($v) = @_;
      return "undef" unless defined $v;
      my($t) = ref $v;
      return "q[$v]" unless $t;
      if ($t eq 'ARRAY') {
          my(@m, @neat);
          push @m, "[";
          foreach my $elem (@$v) {
              push @neat, "q[$elem]";
          }
          push @m, join ", ", @neat;
          push @m, "]";
          return join "", @m;
      }
      return $v unless $t eq 'HASH';
      my(@m, $key, $val);
      for my $key (sort keys %$v) {
          last unless defined $key; # cautious programming in case (undef,undef) is true
          push @m,"$key=>".neatvalue($v->{$key});
      }
      return "{ ".join(', ',@m)." }";
  }
  
  sub _find_magic_vstring {
      my $value = shift;
      return $value if $UNDER_CORE;
      my $tvalue = '';
      require B;
      my $sv = B::svref_2object(\$value);
      my $magic = ref($sv) eq 'B::PVMG' ? $sv->MAGIC : undef;
      while ( $magic ) {
          if ( $magic->TYPE eq 'V' ) {
              $tvalue = $magic->PTR;
              $tvalue =~ s/^v?(.+)$/v$1/;
              last;
          }
          else {
              $magic = $magic->MOREMAGIC;
          }
      }
      return $tvalue;
  }
  
  
  # Look for weird version numbers, warn about them and set them to 0
  # before CPAN::Meta chokes.
  sub clean_versions {
      my($self, $key) = @_;
      my $reqs = $self->{$key};
      for my $module (keys %$reqs) {
          my $v = $reqs->{$module};
          my $printable = _find_magic_vstring($v);
          $v = $printable if length $printable;
          my $version = eval {
              local $SIG{__WARN__} = sub {
                # simulate "use warnings FATAL => 'all'" for vintage perls
                die @_;
              };
              version->new($v)->stringify;
          };
          if( $@ || $reqs->{$module} eq '' ) {
              if ( $] < 5.008 && $v !~ /^v?[\d_\.]+$/ ) {
                 $v = sprintf "v%vd", $v unless $v eq '';
              }
              carp "Unparsable version '$v' for prerequisite $module";
              $reqs->{$module} = 0;
          }
          else {
              $reqs->{$module} = $version;
          }
      }
  }
  
  sub selfdocument {
      my($self) = @_;
      my(@m);
      if ($Verbose){
          push @m, "\n# Full list of MakeMaker attribute values:";
          foreach my $key (sort keys %$self){
              next if $key eq 'RESULT' || $key =~ /^[A-Z][a-z]/;
              my($v) = neatvalue($self->{$key});
              $v =~ s/(CODE|HASH|ARRAY|SCALAR)\([\dxa-f]+\)/$1\(...\)/;
              $v =~ tr/\n/ /s;
              push @m, "# $key => $v";
          }
      }
      join "\n", @m;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  ExtUtils::MakeMaker - Create a module Makefile
  
  =head1 SYNOPSIS
  
    use ExtUtils::MakeMaker;
  
    WriteMakefile(
        NAME              => "Foo::Bar",
        VERSION_FROM      => "lib/Foo/Bar.pm",
    );
  
  =head1 DESCRIPTION
  
  This utility is designed to write a Makefile for an extension module
  from a Makefile.PL. It is based on the Makefile.SH model provided by
  Andy Dougherty and the perl5-porters.
  
  It splits the task of generating the Makefile into several subroutines
  that can be individually overridden.  Each subroutine returns the text
  it wishes to have written to the Makefile.
  
  As there are various Make programs with incompatible syntax, which
  use operating system shells, again with incompatible syntax, it is
  important for users of this module to know which flavour of Make
  a Makefile has been written for so they'll use the correct one and
  won't have to face the possibly bewildering errors resulting from
  using the wrong one.
  
  On POSIX systems, that program will likely be GNU Make; on Microsoft
  Windows, it will be either Microsoft NMake, DMake or GNU Make.
  See the section on the L</"MAKE"> parameter for details.
  
  ExtUtils::MakeMaker (EUMM) is object oriented. Each directory below the current
  directory that contains a Makefile.PL is treated as a separate
  object. This makes it possible to write an unlimited number of
  Makefiles with a single invocation of WriteMakefile().
  
  All inputs to WriteMakefile are Unicode characters, not just octets. EUMM
  seeks to handle all of these correctly. It is currently still not possible
  to portably use Unicode characters in module names, because this requires
  Perl to handle Unicode filenames, which is not yet the case on Windows.
  
  =head2 How To Write A Makefile.PL
  
  See L<ExtUtils::MakeMaker::Tutorial>.
  
  The long answer is the rest of the manpage :-)
  
  =head2 Default Makefile Behaviour
  
  The generated Makefile enables the user of the extension to invoke
  
    perl Makefile.PL # optionally "perl Makefile.PL verbose"
    make
    make test        # optionally set TEST_VERBOSE=1
    make install     # See below
  
  The Makefile to be produced may be altered by adding arguments of the
  form C<KEY=VALUE>. E.g.
  
    perl Makefile.PL INSTALL_BASE=~
  
  Other interesting targets in the generated Makefile are
  
    make config     # to check if the Makefile is up-to-date
    make clean      # delete local temp files (Makefile gets renamed)
    make realclean  # delete derived files (including ./blib)
    make ci         # check in all the files in the MANIFEST file
    make dist       # see below the Distribution Support section
  
  =head2 make test
  
  MakeMaker checks for the existence of a file named F<test.pl> in the
  current directory, and if it exists it executes the script with the
  proper set of perl C<-I> options.
  
  MakeMaker also checks for any files matching glob("t/*.t"). It will
  execute all matching files in alphabetical order via the
  L<Test::Harness> module with the C<-I> switches set correctly.
  
  If you'd like to see the raw output of your tests, set the
  C<TEST_VERBOSE> variable to true.
  
    make test TEST_VERBOSE=1
  
  If you want to run particular test files, set the C<TEST_FILES> variable.
  It is possible to use globbing with this mechanism.
  
    make test TEST_FILES='t/foobar.t t/dagobah*.t'
  
  Windows users who are using C<nmake> should note that due to a bug in C<nmake>,
  when specifying C<TEST_FILES> you must use back-slashes instead of forward-slashes.
  
    nmake test TEST_FILES='t\foobar.t t\dagobah*.t'
  
  =head2 make testdb
  
  A useful variation of the above is the target C<testdb>. It runs the
  test under the Perl debugger (see L<perldebug>). If the file
  F<test.pl> exists in the current directory, it is used for the test.
  
  If you want to debug some other testfile, set the C<TEST_FILE> variable
  thusly:
  
    make testdb TEST_FILE=t/mytest.t
  
  By default the debugger is called using C<-d> option to perl. If you
  want to specify some other option, set the C<TESTDB_SW> variable:
  
    make testdb TESTDB_SW=-Dx
  
  =head2 make install
  
  make alone puts all relevant files into directories that are named by
  the macros INST_LIB, INST_ARCHLIB, INST_SCRIPT, INST_MAN1DIR and
  INST_MAN3DIR.  All these default to something below ./blib if you are
  I<not> building below the perl source directory. If you I<are>
  building below the perl source, INST_LIB and INST_ARCHLIB default to
  ../../lib, and INST_SCRIPT is not defined.
  
  The I<install> target of the generated Makefile copies the files found
  below each of the INST_* directories to their INSTALL*
  counterparts. Which counterparts are chosen depends on the setting of
  INSTALLDIRS according to the following table:
  
                                   INSTALLDIRS set to
                             perl        site          vendor
  
                   PERLPREFIX      SITEPREFIX          VENDORPREFIX
    INST_ARCHLIB   INSTALLARCHLIB  INSTALLSITEARCH     INSTALLVENDORARCH
    INST_LIB       INSTALLPRIVLIB  INSTALLSITELIB      INSTALLVENDORLIB
    INST_BIN       INSTALLBIN      INSTALLSITEBIN      INSTALLVENDORBIN
    INST_SCRIPT    INSTALLSCRIPT   INSTALLSITESCRIPT   INSTALLVENDORSCRIPT
    INST_MAN1DIR   INSTALLMAN1DIR  INSTALLSITEMAN1DIR  INSTALLVENDORMAN1DIR
    INST_MAN3DIR   INSTALLMAN3DIR  INSTALLSITEMAN3DIR  INSTALLVENDORMAN3DIR
  
  The INSTALL... macros in turn default to their %Config
  ($Config{installprivlib}, $Config{installarchlib}, etc.) counterparts.
  
  You can check the values of these variables on your system with
  
      perl '-V:install.*'
  
  And to check the sequence in which the library directories are
  searched by perl, run
  
      perl -le 'print join $/, @INC'
  
  Sometimes older versions of the module you're installing live in other
  directories in @INC.  Because Perl loads the first version of a module it
  finds, not the newest, you might accidentally get one of these older
  versions even after installing a brand new version.  To delete I<all other
  versions of the module you're installing> (not simply older ones) set the
  C<UNINST> variable.
  
      make install UNINST=1
  
  
  =head2 INSTALL_BASE
  
  INSTALL_BASE can be passed into Makefile.PL to change where your
  module will be installed.  INSTALL_BASE is more like what everyone
  else calls "prefix" than PREFIX is.
  
  To have everything installed in your home directory, do the following.
  
      # Unix users, INSTALL_BASE=~ works fine
      perl Makefile.PL INSTALL_BASE=/path/to/your/home/dir
  
  Like PREFIX, it sets several INSTALL* attributes at once.  Unlike
  PREFIX it is easy to predict where the module will end up.  The
  installation pattern looks like this:
  
      INSTALLARCHLIB     INSTALL_BASE/lib/perl5/$Config{archname}
      INSTALLPRIVLIB     INSTALL_BASE/lib/perl5
      INSTALLBIN         INSTALL_BASE/bin
      INSTALLSCRIPT      INSTALL_BASE/bin
      INSTALLMAN1DIR     INSTALL_BASE/man/man1
      INSTALLMAN3DIR     INSTALL_BASE/man/man3
  
  INSTALL_BASE in MakeMaker and C<--install_base> in Module::Build (as
  of 0.28) install to the same location.  If you want MakeMaker and
  Module::Build to install to the same location simply set INSTALL_BASE
  and C<--install_base> to the same location.
  
  INSTALL_BASE was added in 6.31.
  
  
  =head2 PREFIX and LIB attribute
  
  PREFIX and LIB can be used to set several INSTALL* attributes in one
  go.  Here's an example for installing into your home directory.
  
      # Unix users, PREFIX=~ works fine
      perl Makefile.PL PREFIX=/path/to/your/home/dir
  
  This will install all files in the module under your home directory,
  with man pages and libraries going into an appropriate place (usually
  ~/man and ~/lib).  How the exact location is determined is complicated
  and depends on how your Perl was configured.  INSTALL_BASE works more
  like what other build systems call "prefix" than PREFIX and we
  recommend you use that instead.
  
  Another way to specify many INSTALL directories with a single
  parameter is LIB.
  
      perl Makefile.PL LIB=~/lib
  
  This will install the module's architecture-independent files into
  ~/lib, the architecture-dependent files into ~/lib/$archname.
  
  Note, that in both cases the tilde expansion is done by MakeMaker, not
  by perl by default, nor by make.
  
  Conflicts between parameters LIB, PREFIX and the various INSTALL*
  arguments are resolved so that:
  
  =over 4
  
  =item *
  
  setting LIB overrides any setting of INSTALLPRIVLIB, INSTALLARCHLIB,
  INSTALLSITELIB, INSTALLSITEARCH (and they are not affected by PREFIX);
  
  =item *
  
  without LIB, setting PREFIX replaces the initial C<$Config{prefix}>
  part of those INSTALL* arguments, even if the latter are explicitly
  set (but are set to still start with C<$Config{prefix}>).
  
  =back
  
  If the user has superuser privileges, and is not working on AFS or
  relatives, then the defaults for INSTALLPRIVLIB, INSTALLARCHLIB,
  INSTALLSCRIPT, etc. will be appropriate, and this incantation will be
  the best:
  
      perl Makefile.PL;
      make;
      make test
      make install
  
  make install by default writes some documentation of what has been
  done into the file C<$(INSTALLARCHLIB)/perllocal.pod>. This feature
  can be bypassed by calling make pure_install.
  
  =head2 AFS users
  
  will have to specify the installation directories as these most
  probably have changed since perl itself has been installed. They will
  have to do this by calling
  
      perl Makefile.PL INSTALLSITELIB=/afs/here/today \
          INSTALLSCRIPT=/afs/there/now INSTALLMAN3DIR=/afs/for/manpages
      make
  
  Be careful to repeat this procedure every time you recompile an
  extension, unless you are sure the AFS installation directories are
  still valid.
  
  =head2 Static Linking of a new Perl Binary
  
  An extension that is built with the above steps is ready to use on
  systems supporting dynamic loading. On systems that do not support
  dynamic loading, any newly created extension has to be linked together
  with the available resources. MakeMaker supports the linking process
  by creating appropriate targets in the Makefile whenever an extension
  is built. You can invoke the corresponding section of the makefile with
  
      make perl
  
  That produces a new perl binary in the current directory with all
  extensions linked in that can be found in INST_ARCHLIB, SITELIBEXP,
  and PERL_ARCHLIB. To do that, MakeMaker writes a new Makefile, on
  UNIX, this is called F<Makefile.aperl> (may be system dependent). If you
  want to force the creation of a new perl, it is recommended that you
  delete this F<Makefile.aperl>, so the directories are searched through
  for linkable libraries again.
  
  The binary can be installed into the directory where perl normally
  resides on your machine with
  
      make inst_perl
  
  To produce a perl binary with a different name than C<perl>, either say
  
      perl Makefile.PL MAP_TARGET=myperl
      make myperl
      make inst_perl
  
  or say
  
      perl Makefile.PL
      make myperl MAP_TARGET=myperl
      make inst_perl MAP_TARGET=myperl
  
  In any case you will be prompted with the correct invocation of the
  C<inst_perl> target that installs the new binary into INSTALLBIN.
  
  make inst_perl by default writes some documentation of what has been
  done into the file C<$(INSTALLARCHLIB)/perllocal.pod>. This
  can be bypassed by calling make pure_inst_perl.
  
  Warning: the inst_perl: target will most probably overwrite your
  existing perl binary. Use with care!
  
  Sometimes you might want to build a statically linked perl although
  your system supports dynamic loading. In this case you may explicitly
  set the linktype with the invocation of the Makefile.PL or make:
  
      perl Makefile.PL LINKTYPE=static    # recommended
  
  or
  
      make LINKTYPE=static                # works on most systems
  
  =head2 Determination of Perl Library and Installation Locations
  
  MakeMaker needs to know, or to guess, where certain things are
  located.  Especially INST_LIB and INST_ARCHLIB (where to put the files
  during the make(1) run), PERL_LIB and PERL_ARCHLIB (where to read
  existing modules from), and PERL_INC (header files and C<libperl*.*>).
  
  Extensions may be built either using the contents of the perl source
  directory tree or from the installed perl library. The recommended way
  is to build extensions after you have run 'make install' on perl
  itself. You can do that in any directory on your hard disk that is not
  below the perl source tree. The support for extensions below the ext
  directory of the perl distribution is only good for the standard
  extensions that come with perl.
  
  If an extension is being built below the C<ext/> directory of the perl
  source then MakeMaker will set PERL_SRC automatically (e.g.,
  C<../..>).  If PERL_SRC is defined and the extension is recognized as
  a standard extension, then other variables default to the following:
  
    PERL_INC     = PERL_SRC
    PERL_LIB     = PERL_SRC/lib
    PERL_ARCHLIB = PERL_SRC/lib
    INST_LIB     = PERL_LIB
    INST_ARCHLIB = PERL_ARCHLIB
  
  If an extension is being built away from the perl source then MakeMaker
  will leave PERL_SRC undefined and default to using the installed copy
  of the perl library. The other variables default to the following:
  
    PERL_INC     = $archlibexp/CORE
    PERL_LIB     = $privlibexp
    PERL_ARCHLIB = $archlibexp
    INST_LIB     = ./blib/lib
    INST_ARCHLIB = ./blib/arch
  
  If perl has not yet been installed then PERL_SRC can be defined on the
  command line as shown in the previous section.
  
  
  =head2 Which architecture dependent directory?
  
  If you don't want to keep the defaults for the INSTALL* macros,
  MakeMaker helps you to minimize the typing needed: the usual
  relationship between INSTALLPRIVLIB and INSTALLARCHLIB is determined
  by Configure at perl compilation time. MakeMaker supports the user who
  sets INSTALLPRIVLIB. If INSTALLPRIVLIB is set, but INSTALLARCHLIB not,
  then MakeMaker defaults the latter to be the same subdirectory of
  INSTALLPRIVLIB as Configure decided for the counterparts in %Config,
  otherwise it defaults to INSTALLPRIVLIB. The same relationship holds
  for INSTALLSITELIB and INSTALLSITEARCH.
  
  MakeMaker gives you much more freedom than needed to configure
  internal variables and get different results. It is worth mentioning
  that make(1) also lets you configure most of the variables that are
  used in the Makefile. But in the majority of situations this will not
  be necessary, and should only be done if the author of a package
  recommends it (or you know what you're doing).
  
  =head2 Using Attributes and Parameters
  
  The following attributes may be specified as arguments to WriteMakefile()
  or as NAME=VALUE pairs on the command line. Attributes that became
  available with later versions of MakeMaker are indicated.
  
  In order to maintain portability of attributes with older versions of
  MakeMaker you may want to use L<App::EUMM::Upgrade> with your C<Makefile.PL>.
  
  =over 2
  
  =item ABSTRACT
  
  One line description of the module. Will be included in PPD file.
  
  =item ABSTRACT_FROM
  
  Name of the file that contains the package description. MakeMaker looks
  for a line in the POD matching /^($package\s-\s)(.*)/. This is typically
  the first line in the "=head1 NAME" section. $2 becomes the abstract.
  
  =item AUTHOR
  
  Array of strings containing name (and email address) of package author(s).
  Is used in CPAN Meta files (META.yml or META.json) and PPD
  (Perl Package Description) files for PPM (Perl Package Manager).
  
  =item BINARY_LOCATION
  
  Used when creating PPD files for binary packages.  It can be set to a
  full or relative path or URL to the binary archive for a particular
  architecture.  For example:
  
          perl Makefile.PL BINARY_LOCATION=x86/Agent.tar.gz
  
  builds a PPD package that references a binary of the C<Agent> package,
  located in the C<x86> directory relative to the PPD itself.
  
  =item BUILD_REQUIRES
  
  Available in version 6.5503 and above.
  
  A hash of modules that are needed to build your module but not run it.
  
  This will go into the C<build_requires> field of your F<META.yml> and the C<build> of the C<prereqs> field of your F<META.json>.
  
  Defaults to C<<< { "ExtUtils::MakeMaker" => 0 } >>> if this attribute is not specified.
  
  The format is the same as PREREQ_PM.
  
  =item C
  
  Ref to array of *.c file names. Initialised from a directory scan
  and the values portion of the XS attribute hash. This is not
  currently used by MakeMaker but may be handy in Makefile.PLs.
  
  =item CCFLAGS
  
  String that will be included in the compiler call command line between
  the arguments INC and OPTIMIZE.
  
  =item CONFIG
  
  Arrayref. E.g. [qw(archname manext)] defines ARCHNAME & MANEXT from
  config.sh. MakeMaker will add to CONFIG the following values anyway:
  ar
  cc
  cccdlflags
  ccdlflags
  dlext
  dlsrc
  ld
  lddlflags
  ldflags
  libc
  lib_ext
  obj_ext
  ranlib
  sitelibexp
  sitearchexp
  so
  
  =item CONFIGURE
  
  CODE reference. The subroutine should return a hash reference. The
  hash may contain further attributes, e.g. {LIBS =E<gt> ...}, that have to
  be determined by some evaluation method.
  
  =item CONFIGURE_REQUIRES
  
  Available in version 6.52 and above.
  
  A hash of modules that are required to run Makefile.PL itself, but not
  to run your distribution.
  
  This will go into the C<configure_requires> field of your F<META.yml> and the C<configure> of the C<prereqs> field of your F<META.json>.
  
  Defaults to C<<< { "ExtUtils::MakeMaker" => 0 } >>> if this attribute is not specified.
  
  The format is the same as PREREQ_PM.
  
  =item DEFINE
  
  Something like C<"-DHAVE_UNISTD_H">
  
  =item DESTDIR
  
  This is the root directory into which the code will be installed.  It
  I<prepends itself to the normal prefix>.  For example, if your code
  would normally go into F</usr/local/lib/perl> you could set DESTDIR=~/tmp/
  and installation would go into F<~/tmp/usr/local/lib/perl>.
  
  This is primarily of use for people who repackage Perl modules.
  
  NOTE: Due to the nature of make, it is important that you put the trailing
  slash on your DESTDIR.  F<~/tmp/> not F<~/tmp>.
  
  =item DIR
  
  Ref to array of subdirectories containing Makefile.PLs e.g. ['sdbm']
  in ext/SDBM_File
  
  =item DISTNAME
  
  A safe filename for the package.
  
  Defaults to NAME below but with :: replaced with -.
  
  For example, Foo::Bar becomes Foo-Bar.
  
  =item DISTVNAME
  
  Your name for distributing the package with the version number
  included.  This is used by 'make dist' to name the resulting archive
  file.
  
  Defaults to DISTNAME-VERSION.
  
  For example, version 1.04 of Foo::Bar becomes Foo-Bar-1.04.
  
  On some OS's where . has special meaning VERSION_SYM may be used in
  place of VERSION.
  
  =item DLEXT
  
  Specifies the extension of the module's loadable object. For example:
  
    DLEXT => 'unusual_ext', # Default value is $Config{so}
  
  NOTE: When using this option to alter the extension of a module's
  loadable object, it is also necessary that the module's pm file
  specifies the same change:
  
    local $DynaLoader::dl_dlext = 'unusual_ext';
  
  =item DL_FUNCS
  
  Hashref of symbol names for routines to be made available as universal
  symbols.  Each key/value pair consists of the package name and an
  array of routine names in that package.  Used only under AIX, OS/2,
  VMS and Win32 at present.  The routine names supplied will be expanded
  in the same way as XSUB names are expanded by the XS() macro.
  Defaults to
  
    {"$(NAME)" => ["boot_$(NAME)" ] }
  
  e.g.
  
    {"RPC" => [qw( boot_rpcb rpcb_gettime getnetconfigent )],
     "NetconfigPtr" => [ 'DESTROY'] }
  
  Please see the L<ExtUtils::Mksymlists> documentation for more information
  about the DL_FUNCS, DL_VARS and FUNCLIST attributes.
  
  =item DL_VARS
  
  Array of symbol names for variables to be made available as universal symbols.
  Used only under AIX, OS/2, VMS and Win32 at present.  Defaults to [].
  (e.g. [ qw(Foo_version Foo_numstreams Foo_tree ) ])
  
  =item EXCLUDE_EXT
  
  Array of extension names to exclude when doing a static build.  This
  is ignored if INCLUDE_EXT is present.  Consult INCLUDE_EXT for more
  details.  (e.g.  [ qw( Socket POSIX ) ] )
  
  This attribute may be most useful when specified as a string on the
  command line:  perl Makefile.PL EXCLUDE_EXT='Socket Safe'
  
  =item EXE_FILES
  
  Ref to array of executable files. The files will be copied to the
  INST_SCRIPT directory. Make realclean will delete them from there
  again.
  
  If your executables start with something like #!perl or
  #!/usr/bin/perl MakeMaker will change this to the path of the perl
  'Makefile.PL' was invoked with so the programs will be sure to run
  properly even if perl is not in /usr/bin/perl.
  
  =item FIRST_MAKEFILE
  
  The name of the Makefile to be produced.  This is used for the second
  Makefile that will be produced for the MAP_TARGET.
  
  Defaults to 'Makefile' or 'Descrip.MMS' on VMS.
  
  (Note: we couldn't use MAKEFILE because dmake uses this for something
  else).
  
  =item FULLPERL
  
  Perl binary able to run this extension, load XS modules, etc...
  
  =item FULLPERLRUN
  
  Like PERLRUN, except it uses FULLPERL.
  
  =item FULLPERLRUNINST
  
  Like PERLRUNINST, except it uses FULLPERL.
  
  =item FUNCLIST
  
  This provides an alternate means to specify function names to be
  exported from the extension.  Its value is a reference to an
  array of function names to be exported by the extension.  These
  names are passed through unaltered to the linker options file.
  
  =item H
  
  Ref to array of *.h file names. Similar to C.
  
  =item IMPORTS
  
  This attribute is used to specify names to be imported into the
  extension. Takes a hash ref.
  
  It is only used on OS/2 and Win32.
  
  =item INC
  
  Include file dirs eg: C<"-I/usr/5include -I/path/to/inc">
  
  =item INCLUDE_EXT
  
  Array of extension names to be included when doing a static build.
  MakeMaker will normally build with all of the installed extensions when
  doing a static build, and that is usually the desired behavior.  If
  INCLUDE_EXT is present then MakeMaker will build only with those extensions
  which are explicitly mentioned. (e.g.  [ qw( Socket POSIX ) ])
  
  It is not necessary to mention DynaLoader or the current extension when
  filling in INCLUDE_EXT.  If the INCLUDE_EXT is mentioned but is empty then
  only DynaLoader and the current extension will be included in the build.
  
  This attribute may be most useful when specified as a string on the
  command line:  perl Makefile.PL INCLUDE_EXT='POSIX Socket Devel::Peek'
  
  =item INSTALLARCHLIB
  
  Used by 'make install', which copies files from INST_ARCHLIB to this
  directory if INSTALLDIRS is set to perl.
  
  =item INSTALLBIN
  
  Directory to install binary files (e.g. tkperl) into if
  INSTALLDIRS=perl.
  
  =item INSTALLDIRS
  
  Determines which of the sets of installation directories to choose:
  perl, site or vendor.  Defaults to site.
  
  =item INSTALLMAN1DIR
  
  =item INSTALLMAN3DIR
  
  These directories get the man pages at 'make install' time if
  INSTALLDIRS=perl.  Defaults to $Config{installman*dir}.
  
  If set to 'none', no man pages will be installed.
  
  =item INSTALLPRIVLIB
  
  Used by 'make install', which copies files from INST_LIB to this
  directory if INSTALLDIRS is set to perl.
  
  Defaults to $Config{installprivlib}.
  
  =item INSTALLSCRIPT
  
  Used by 'make install' which copies files from INST_SCRIPT to this
  directory if INSTALLDIRS=perl.
  
  =item INSTALLSITEARCH
  
  Used by 'make install', which copies files from INST_ARCHLIB to this
  directory if INSTALLDIRS is set to site (default).
  
  =item INSTALLSITEBIN
  
  Used by 'make install', which copies files from INST_BIN to this
  directory if INSTALLDIRS is set to site (default).
  
  =item INSTALLSITELIB
  
  Used by 'make install', which copies files from INST_LIB to this
  directory if INSTALLDIRS is set to site (default).
  
  =item INSTALLSITEMAN1DIR
  
  =item INSTALLSITEMAN3DIR
  
  These directories get the man pages at 'make install' time if
  INSTALLDIRS=site (default).  Defaults to
  $(SITEPREFIX)/man/man$(MAN*EXT).
  
  If set to 'none', no man pages will be installed.
  
  =item INSTALLSITESCRIPT
  
  Used by 'make install' which copies files from INST_SCRIPT to this
  directory if INSTALLDIRS is set to site (default).
  
  =item INSTALLVENDORARCH
  
  Used by 'make install', which copies files from INST_ARCHLIB to this
  directory if INSTALLDIRS is set to vendor.
  
  =item INSTALLVENDORBIN
  
  Used by 'make install', which copies files from INST_BIN to this
  directory if INSTALLDIRS is set to vendor.
  
  =item INSTALLVENDORLIB
  
  Used by 'make install', which copies files from INST_LIB to this
  directory if INSTALLDIRS is set to vendor.
  
  =item INSTALLVENDORMAN1DIR
  
  =item INSTALLVENDORMAN3DIR
  
  These directories get the man pages at 'make install' time if
  INSTALLDIRS=vendor.  Defaults to $(VENDORPREFIX)/man/man$(MAN*EXT).
  
  If set to 'none', no man pages will be installed.
  
  =item INSTALLVENDORSCRIPT
  
  Used by 'make install' which copies files from INST_SCRIPT to this
  directory if INSTALLDIRS is set to vendor.
  
  =item INST_ARCHLIB
  
  Same as INST_LIB for architecture dependent files.
  
  =item INST_BIN
  
  Directory to put real binary files during 'make'. These will be copied
  to INSTALLBIN during 'make install'
  
  =item INST_LIB
  
  Directory where we put library files of this extension while building
  it.
  
  =item INST_MAN1DIR
  
  Directory to hold the man pages at 'make' time
  
  =item INST_MAN3DIR
  
  Directory to hold the man pages at 'make' time
  
  =item INST_SCRIPT
  
  Directory where executable files should be installed during
  'make'. Defaults to "./blib/script", just to have a dummy location during
  testing. make install will copy the files in INST_SCRIPT to
  INSTALLSCRIPT.
  
  =item LD
  
  Program to be used to link libraries for dynamic loading.
  
  Defaults to $Config{ld}.
  
  =item LDDLFLAGS
  
  Any special flags that might need to be passed to ld to create a
  shared library suitable for dynamic loading.  It is up to the makefile
  to use it.  (See L<Config/lddlflags>)
  
  Defaults to $Config{lddlflags}.
  
  =item LDFROM
  
  Defaults to "$(OBJECT)" and is used in the ld command to specify
  what files to link/load from (also see dynamic_lib below for how to
  specify ld flags)
  
  =item LIB
  
  LIB should only be set at C<perl Makefile.PL> time but is allowed as a
  MakeMaker argument. It has the effect of setting both INSTALLPRIVLIB
  and INSTALLSITELIB to that value regardless any explicit setting of
  those arguments (or of PREFIX).  INSTALLARCHLIB and INSTALLSITEARCH
  are set to the corresponding architecture subdirectory.
  
  =item LIBPERL_A
  
  The filename of the perllibrary that will be used together with this
  extension. Defaults to libperl.a.
  
  =item LIBS
  
  An anonymous array of alternative library
  specifications to be searched for (in order) until
  at least one library is found. E.g.
  
    'LIBS' => ["-lgdbm", "-ldbm -lfoo", "-L/path -ldbm.nfs"]
  
  Mind, that any element of the array
  contains a complete set of arguments for the ld
  command. So do not specify
  
    'LIBS' => ["-ltcl", "-ltk", "-lX11"]
  
  See ODBM_File/Makefile.PL for an example, where an array is needed. If
  you specify a scalar as in
  
    'LIBS' => "-ltcl -ltk -lX11"
  
  MakeMaker will turn it into an array with one element.
  
  =item LICENSE
  
  Available in version 6.31 and above.
  
  The licensing terms of your distribution.  Generally it's "perl_5" for the
  same license as Perl itself.
  
  See L<CPAN::Meta::Spec> for the list of options.
  
  Defaults to "unknown".
  
  =item LINKTYPE
  
  'static' or 'dynamic' (default unless usedl=undef in
  config.sh). Should only be used to force static linking (also see
  linkext below).
  
  =item MAGICXS
  
  When this is set to C<1>, C<OBJECT> will be automagically derived from
  C<O_FILES>.
  
  =item MAKE
  
  Variant of make you intend to run the generated Makefile with.  This
  parameter lets Makefile.PL know what make quirks to account for when
  generating the Makefile.
  
  MakeMaker also honors the MAKE environment variable.  This parameter
  takes precedence.
  
  Currently the only significant values are 'dmake' and 'nmake' for Windows
  users, instructing MakeMaker to generate a Makefile in the flavour of
  DMake ("Dennis Vadura's Make") or Microsoft NMake respectively.
  
  Defaults to $Config{make}, which may go looking for a Make program
  in your environment.
  
  How are you supposed to know what flavour of Make a Makefile has
  been generated for if you didn't specify a value explicitly? Search
  the generated Makefile for the definition of the MAKE variable,
  which is used to recursively invoke the Make utility. That will tell
  you what Make you're supposed to invoke the Makefile with.
  
  =item MAKEAPERL
  
  Boolean which tells MakeMaker that it should include the rules to
  make a perl. This is handled automatically as a switch by
  MakeMaker. The user normally does not need it.
  
  =item MAKEFILE_OLD
  
  When 'make clean' or similar is run, the $(FIRST_MAKEFILE) will be
  backed up at this location.
  
  Defaults to $(FIRST_MAKEFILE).old or $(FIRST_MAKEFILE)_old on VMS.
  
  =item MAN1PODS
  
  Hashref of pod-containing files. MakeMaker will default this to all
  EXE_FILES files that include POD directives. The files listed
  here will be converted to man pages and installed as was requested
  at Configure time.
  
  This hash should map POD files (or scripts containing POD) to the
  man file names under the C<blib/man1/> directory, as in the following
  example:
  
    MAN1PODS            => {
      'doc/command.pod'    => 'blib/man1/command.1',
      'scripts/script.pl'  => 'blib/man1/script.1',
    }
  
  =item MAN3PODS
  
  Hashref that assigns to *.pm and *.pod files the files into which the
  manpages are to be written. MakeMaker parses all *.pod and *.pm files
  for POD directives. Files that contain POD will be the default keys of
  the MAN3PODS hashref. These will then be converted to man pages during
  C<make> and will be installed during C<make install>.
  
  Example similar to MAN1PODS.
  
  =item MAP_TARGET
  
  If it is intended that a new perl binary be produced, this variable
  may hold a name for that binary. Defaults to perl
  
  =item META_ADD
  
  =item META_MERGE
  
  Available in version 6.46 and above.
  
  A hashref of items to add to the CPAN Meta file (F<META.yml> or
  F<META.json>).
  
  They differ in how they behave if they have the same key as the
  default metadata.  META_ADD will override the default value with its
  own.  META_MERGE will merge its value with the default.
  
  Unless you want to override the defaults, prefer META_MERGE so as to
  get the advantage of any future defaults.
  
  Where prereqs are concerned, if META_MERGE is used, prerequisites are merged
  with their counterpart C<WriteMakefile()> argument
  (PREREQ_PM is merged into {prereqs}{runtime}{requires},
  BUILD_REQUIRES into C<{prereqs}{build}{requires}>,
  CONFIGURE_REQUIRES into C<{prereqs}{configure}{requires}>,
  and TEST_REQUIRES into C<{prereqs}{test}{requires})>.
  When prereqs are specified with META_ADD, the only prerequisites added to the
  file come from the metadata, not C<WriteMakefile()> arguments.
  
  Note that these configuration options are only used for generating F<META.yml>
  and F<META.json> -- they are NOT used for F<MYMETA.yml> and F<MYMETA.json>.
  Therefore data in these fields should NOT be used for dynamic (user-side)
  configuration.
  
  By default CPAN Meta specification C<1.4> is used. In order to use
  CPAN Meta specification C<2.0>, indicate with C<meta-spec> the version
  you want to use.
  
    META_MERGE        => {
  
      "meta-spec" => { version => 2 },
  
      resources => {
  
        repository => {
            type => 'git',
            url => 'git://github.com/Perl-Toolchain-Gang/ExtUtils-MakeMaker.git',
            web => 'https://github.com/Perl-Toolchain-Gang/ExtUtils-MakeMaker',
        },
  
      },
  
    },
  
  =item MIN_PERL_VERSION
  
  Available in version 6.48 and above.
  
  The minimum required version of Perl for this distribution.
  
  Either the 5.006001 or the 5.6.1 format is acceptable.
  
  =item MYEXTLIB
  
  If the extension links to a library that it builds, set this to the
  name of the library (see SDBM_File)
  
  =item NAME
  
  The package representing the distribution. For example, C<Test::More>
  or C<ExtUtils::MakeMaker>. It will be used to derive information about
  the distribution such as the L</DISTNAME>, installation locations
  within the Perl library and where XS files will be looked for by
  default (see L</XS>).
  
  C<NAME> I<must> be a valid Perl package name and it I<must> have an
  associated C<.pm> file. For example, C<Foo::Bar> is a valid C<NAME>
  and there must exist F<Foo/Bar.pm>.  Any XS code should be in
  F<Bar.xs> unless stated otherwise.
  
  Your distribution B<must> have a C<NAME>.
  
  =item NEEDS_LINKING
  
  MakeMaker will figure out if an extension contains linkable code
  anywhere down the directory tree, and will set this variable
  accordingly, but you can speed it up a very little bit if you define
  this boolean variable yourself.
  
  =item NOECHO
  
  Command so make does not print the literal commands it's running.
  
  By setting it to an empty string you can generate a Makefile that
  prints all commands. Mainly used in debugging MakeMaker itself.
  
  Defaults to C<@>.
  
  =item NORECURS
  
  Boolean.  Attribute to inhibit descending into subdirectories.
  
  =item NO_META
  
  When true, suppresses the generation and addition to the MANIFEST of
  the META.yml and META.json module meta-data files during 'make distdir'.
  
  Defaults to false.
  
  =item NO_MYMETA
  
  When true, suppresses the generation of MYMETA.yml and MYMETA.json module
  meta-data files during 'perl Makefile.PL'.
  
  Defaults to false.
  
  =item NO_PACKLIST
  
  When true, suppresses the writing of C<packlist> files for installs.
  
  Defaults to false.
  
  =item NO_PERLLOCAL
  
  When true, suppresses the appending of installations to C<perllocal>.
  
  Defaults to false.
  
  =item NO_VC
  
  In general, any generated Makefile checks for the current version of
  MakeMaker and the version the Makefile was built under. If NO_VC is
  set, the version check is neglected. Do not write this into your
  Makefile.PL, use it interactively instead.
  
  =item OBJECT
  
  List of object files, defaults to '$(BASEEXT)$(OBJ_EXT)', but can be a long
  string or an array containing all object files, e.g. "tkpBind.o
  tkpButton.o tkpCanvas.o" or ["tkpBind.o", "tkpButton.o", "tkpCanvas.o"]
  
  (Where BASEEXT is the last component of NAME, and OBJ_EXT is $Config{obj_ext}.)
  
  =item OPTIMIZE
  
  Defaults to C<-O>. Set it to C<-g> to turn debugging on. The flag is
  passed to subdirectory makes.
  
  =item PERL
  
  Perl binary for tasks that can be done by miniperl.
  
  =item PERL_CORE
  
  Set only when MakeMaker is building the extensions of the Perl core
  distribution.
  
  =item PERLMAINCC
  
  The call to the program that is able to compile perlmain.c. Defaults
  to $(CC).
  
  =item PERL_ARCHLIB
  
  Same as for PERL_LIB, but for architecture dependent files.
  
  Used only when MakeMaker is building the extensions of the Perl core
  distribution (because normally $(PERL_ARCHLIB) is automatically in @INC,
  and adding it would get in the way of PERL5LIB).
  
  =item PERL_LIB
  
  Directory containing the Perl library to use.
  
  Used only when MakeMaker is building the extensions of the Perl core
  distribution (because normally $(PERL_LIB) is automatically in @INC,
  and adding it would get in the way of PERL5LIB).
  
  =item PERL_MALLOC_OK
  
  defaults to 0.  Should be set to TRUE if the extension can work with
  the memory allocation routines substituted by the Perl malloc() subsystem.
  This should be applicable to most extensions with exceptions of those
  
  =over 4
  
  =item *
  
  with bugs in memory allocations which are caught by Perl's malloc();
  
  =item *
  
  which interact with the memory allocator in other ways than via
  malloc(), realloc(), free(), calloc(), sbrk() and brk();
  
  =item *
  
  which rely on special alignment which is not provided by Perl's malloc().
  
  =back
  
  B<NOTE.>  Neglecting to set this flag in I<any one> of the loaded extension
  nullifies many advantages of Perl's malloc(), such as better usage of
  system resources, error detection, memory usage reporting, catchable failure
  of memory allocations, etc.
  
  =item PERLPREFIX
  
  Directory under which core modules are to be installed.
  
  Defaults to $Config{installprefixexp}, falling back to
  $Config{installprefix}, $Config{prefixexp} or $Config{prefix} should
  $Config{installprefixexp} not exist.
  
  Overridden by PREFIX.
  
  =item PERLRUN
  
  Use this instead of $(PERL) when you wish to run perl.  It will set up
  extra necessary flags for you.
  
  =item PERLRUNINST
  
  Use this instead of $(PERL) when you wish to run perl to work with
  modules.  It will add things like -I$(INST_ARCH) and other necessary
  flags so perl can see the modules you're about to install.
  
  =item PERL_SRC
  
  Directory containing the Perl source code (use of this should be
  avoided, it may be undefined)
  
  =item PERM_DIR
  
  Desired permission for directories. Defaults to C<755>.
  
  =item PERM_RW
  
  Desired permission for read/writable files. Defaults to C<644>.
  
  =item PERM_RWX
  
  Desired permission for executable files. Defaults to C<755>.
  
  =item PL_FILES
  
  MakeMaker can run programs to generate files for you at build time.
  By default any file named *.PL (except Makefile.PL and Build.PL) in
  the top level directory will be assumed to be a Perl program and run
  passing its own basename in as an argument.  For example...
  
      perl foo.PL foo
  
  This behavior can be overridden by supplying your own set of files to
  search.  PL_FILES accepts a hash ref, the key being the file to run
  and the value is passed in as the first argument when the PL file is run.
  
      PL_FILES => {'bin/foobar.PL' => 'bin/foobar'}
  
  Would run bin/foobar.PL like this:
  
      perl bin/foobar.PL bin/foobar
  
  If multiple files from one program are desired an array ref can be used.
  
      PL_FILES => {'bin/foobar.PL' => [qw(bin/foobar1 bin/foobar2)]}
  
  In this case the program will be run multiple times using each target file.
  
      perl bin/foobar.PL bin/foobar1
      perl bin/foobar.PL bin/foobar2
  
  PL files are normally run B<after> pm_to_blib and include INST_LIB and
  INST_ARCH in their C<@INC>, so the just built modules can be
  accessed... unless the PL file is making a module (or anything else in
  PM) in which case it is run B<before> pm_to_blib and does not include
  INST_LIB and INST_ARCH in its C<@INC>.  This apparently odd behavior
  is there for backwards compatibility (and it's somewhat DWIM).
  
  
  =item PM
  
  Hashref of .pm files and *.pl files to be installed.  e.g.
  
    {'name_of_file.pm' => '$(INST_LIB)/install_as.pm'}
  
  By default this will include *.pm and *.pl and the files found in
  the PMLIBDIRS directories.  Defining PM in the
  Makefile.PL will override PMLIBDIRS.
  
  =item PMLIBDIRS
  
  Ref to array of subdirectories containing library files.  Defaults to
  [ 'lib', $(BASEEXT) ]. The directories will be scanned and I<any> files
  they contain will be installed in the corresponding location in the
  library.  A libscan() method can be used to alter the behaviour.
  Defining PM in the Makefile.PL will override PMLIBDIRS.
  
  (Where BASEEXT is the last component of NAME.)
  
  =item PM_FILTER
  
  A filter program, in the traditional Unix sense (input from stdin, output
  to stdout) that is passed on each .pm file during the build (in the
  pm_to_blib() phase).  It is empty by default, meaning no filtering is done.
  
  Great care is necessary when defining the command if quoting needs to be
  done.  For instance, you would need to say:
  
    {'PM_FILTER' => 'grep -v \\"^\\#\\"'}
  
  to remove all the leading comments on the fly during the build.  The
  extra \\ are necessary, unfortunately, because this variable is interpolated
  within the context of a Perl program built on the command line, and double
  quotes are what is used with the -e switch to build that command line.  The
  # is escaped for the Makefile, since what is going to be generated will then
  be:
  
    PM_FILTER = grep -v \"^\#\"
  
  Without the \\ before the #, we'd have the start of a Makefile comment,
  and the macro would be incorrectly defined.
  
  =item POLLUTE
  
  Release 5.005 grandfathered old global symbol names by providing preprocessor
  macros for extension source compatibility.  As of release 5.6, these
  preprocessor definitions are not available by default.  The POLLUTE flag
  specifies that the old names should still be defined:
  
    perl Makefile.PL POLLUTE=1
  
  Please inform the module author if this is necessary to successfully install
  a module under 5.6 or later.
  
  =item PPM_INSTALL_EXEC
  
  Name of the executable used to run C<PPM_INSTALL_SCRIPT> below. (e.g. perl)
  
  =item PPM_INSTALL_SCRIPT
  
  Name of the script that gets executed by the Perl Package Manager after
  the installation of a package.
  
  =item PPM_UNINSTALL_EXEC
  
  Name of the executable used to run C<PPM_UNINSTALL_SCRIPT> below. (e.g. perl)
  
  =item PPM_UNINSTALL_SCRIPT
  
  Name of the script that gets executed by the Perl Package Manager before
  the removal of a package.
  
  =item PREFIX
  
  This overrides all the default install locations.  Man pages,
  libraries, scripts, etc...  MakeMaker will try to make an educated
  guess about where to place things under the new PREFIX based on your
  Config defaults.  Failing that, it will fall back to a structure
  which should be sensible for your platform.
  
  If you specify LIB or any INSTALL* variables they will not be affected
  by the PREFIX.
  
  =item PREREQ_FATAL
  
  Bool. If this parameter is true, failing to have the required modules
  (or the right versions thereof) will be fatal. C<perl Makefile.PL>
  will C<die> instead of simply informing the user of the missing dependencies.
  
  It is I<extremely> rare to have to use C<PREREQ_FATAL>. Its use by module
  authors is I<strongly discouraged> and should never be used lightly.
  
  For dependencies that are required in order to run C<Makefile.PL>,
  see C<CONFIGURE_REQUIRES>.
  
  Module installation tools have ways of resolving unmet dependencies but
  to do that they need a F<Makefile>.  Using C<PREREQ_FATAL> breaks this.
  That's bad.
  
  Assuming you have good test coverage, your tests should fail with
  missing dependencies informing the user more strongly that something
  is wrong.  You can write a F<t/00compile.t> test which will simply
  check that your code compiles and stop "make test" prematurely if it
  doesn't.  See L<Test::More/BAIL_OUT> for more details.
  
  
  =item PREREQ_PM
  
  A hash of modules that are needed to run your module.  The keys are
  the module names ie. Test::More, and the minimum version is the
  value. If the required version number is 0 any version will do.
  
  This will go into the C<requires> field of your F<META.yml> and the C<runtime> of the C<prereqs> field of your F<META.json>.
  
      PREREQ_PM => {
          # Require Test::More at least 0.47
          "Test::More" => "0.47",
  
          # Require any version of Acme::Buffy
          "Acme::Buffy" => 0,
      }
  
  =item PREREQ_PRINT
  
  Bool.  If this parameter is true, the prerequisites will be printed to
  stdout and MakeMaker will exit.  The output format is an evalable hash
  ref.
  
    $PREREQ_PM = {
                   'A::B' => Vers1,
                   'C::D' => Vers2,
                   ...
                 };
  
  If a distribution defines a minimal required perl version, this is
  added to the output as an additional line of the form:
  
    $MIN_PERL_VERSION = '5.008001';
  
  If BUILD_REQUIRES is not empty, it will be dumped as $BUILD_REQUIRES hashref.
  
  =item PRINT_PREREQ
  
  RedHatism for C<PREREQ_PRINT>.  The output format is different, though:
  
      perl(A::B)>=Vers1 perl(C::D)>=Vers2 ...
  
  A minimal required perl version, if present, will look like this:
  
      perl(perl)>=5.008001
  
  =item SITEPREFIX
  
  Like PERLPREFIX, but only for the site install locations.
  
  Defaults to $Config{siteprefixexp}.  Perls prior to 5.6.0 didn't have
  an explicit siteprefix in the Config.  In those cases
  $Config{installprefix} will be used.
  
  Overridable by PREFIX
  
  =item SIGN
  
  When true, perform the generation and addition to the MANIFEST of the
  SIGNATURE file in the distdir during 'make distdir', via 'cpansign
  -s'.
  
  Note that you need to install the Module::Signature module to
  perform this operation.
  
  Defaults to false.
  
  =item SKIP
  
  Arrayref. E.g. [qw(name1 name2)] skip (do not write) sections of the
  Makefile. Caution! Do not use the SKIP attribute for the negligible
  speedup. It may seriously damage the resulting Makefile. Only use it
  if you really need it.
  
  =item TEST_REQUIRES
  
  Available in version 6.64 and above.
  
  A hash of modules that are needed to test your module but not run or
  build it.
  
  This will go into the C<build_requires> field of your F<META.yml> and the C<test> of the C<prereqs> field of your F<META.json>.
  
  The format is the same as PREREQ_PM.
  
  =item TYPEMAPS
  
  Ref to array of typemap file names.  Use this when the typemaps are
  in some directory other than the current directory or when they are
  not named B<typemap>.  The last typemap in the list takes
  precedence.  A typemap in the current directory has highest
  precedence, even if it isn't listed in TYPEMAPS.  The default system
  typemap has lowest precedence.
  
  =item VENDORPREFIX
  
  Like PERLPREFIX, but only for the vendor install locations.
  
  Defaults to $Config{vendorprefixexp}.
  
  Overridable by PREFIX
  
  =item VERBINST
  
  If true, make install will be verbose
  
  =item VERSION
  
  Your version number for distributing the package.  This defaults to
  0.1.
  
  =item VERSION_FROM
  
  Instead of specifying the VERSION in the Makefile.PL you can let
  MakeMaker parse a file to determine the version number. The parsing
  routine requires that the file named by VERSION_FROM contains one
  single line to compute the version number. The first line in the file
  that contains something like a $VERSION assignment or C<package Name
  VERSION> will be used. The following lines will be parsed o.k.:
  
      # Good
      package Foo::Bar 1.23;                      # 1.23
      $VERSION   = '1.00';                        # 1.00
      *VERSION   = \'1.01';                       # 1.01
      ($VERSION) = q$Revision$ =~ /(\d+)/g;       # The digits in $Revision$
      $FOO::VERSION = '1.10';                     # 1.10
      *FOO::VERSION = \'1.11';                    # 1.11
  
  but these will fail:
  
      # Bad
      my $VERSION         = '1.01';
      local $VERSION      = '1.02';
      local $FOO::VERSION = '1.30';
  
  (Putting C<my> or C<local> on the preceding line will work o.k.)
  
  "Version strings" are incompatible and should not be used.
  
      # Bad
      $VERSION = 1.2.3;
      $VERSION = v1.2.3;
  
  L<version> objects are fine.  As of MakeMaker 6.35 version.pm will be
  automatically loaded, but you must declare the dependency on version.pm.
  For compatibility with older MakeMaker you should load on the same line
  as $VERSION is declared.
  
      # All on one line
      use version; our $VERSION = qv(1.2.3);
  
  The file named in VERSION_FROM is not added as a dependency to
  Makefile. This is not really correct, but it would be a major pain
  during development to have to rewrite the Makefile for any smallish
  change in that file. If you want to make sure that the Makefile
  contains the correct VERSION macro after any change of the file, you
  would have to do something like
  
      depend => { Makefile => '$(VERSION_FROM)' }
  
  See attribute C<depend> below.
  
  =item VERSION_SYM
  
  A sanitized VERSION with . replaced by _.  For places where . has
  special meaning (some filesystems, RCS labels, etc...)
  
  =item XS
  
  Hashref of .xs files. MakeMaker will default this.  e.g.
  
    {'name_of_file.xs' => 'name_of_file.c'}
  
  The .c files will automatically be included in the list of files
  deleted by a make clean.
  
  =item XSOPT
  
  String of options to pass to xsubpp.  This might include C<-C++> or
  C<-extern>.  Do not include typemaps here; the TYPEMAP parameter exists for
  that purpose.
  
  =item XSPROTOARG
  
  May be set to C<-protoypes>, C<-noprototypes> or the empty string.  The
  empty string is equivalent to the xsubpp default, or C<-noprototypes>.
  See the xsubpp documentation for details.  MakeMaker
  defaults to the empty string.
  
  =item XS_VERSION
  
  Your version number for the .xs file of this package.  This defaults
  to the value of the VERSION attribute.
  
  =back
  
  =head2 Additional lowercase attributes
  
  can be used to pass parameters to the methods which implement that
  part of the Makefile.  Parameters are specified as a hash ref but are
  passed to the method as a hash.
  
  =over 2
  
  =item clean
  
    {FILES => "*.xyz foo"}
  
  =item depend
  
    {ANY_TARGET => ANY_DEPENDENCY, ...}
  
  (ANY_TARGET must not be given a double-colon rule by MakeMaker.)
  
  =item dist
  
    {TARFLAGS => 'cvfF', COMPRESS => 'gzip', SUFFIX => '.gz',
    SHAR => 'shar -m', DIST_CP => 'ln', ZIP => '/bin/zip',
    ZIPFLAGS => '-rl', DIST_DEFAULT => 'private tardist' }
  
  If you specify COMPRESS, then SUFFIX should also be altered, as it is
  needed to tell make the target file of the compression. Setting
  DIST_CP to ln can be useful, if you need to preserve the timestamps on
  your files. DIST_CP can take the values 'cp', which copies the file,
  'ln', which links the file, and 'best' which copies symbolic links and
  links the rest. Default is 'best'.
  
  =item dynamic_lib
  
    {ARMAYBE => 'ar', OTHERLDFLAGS => '...', INST_DYNAMIC_DEP => '...'}
  
  =item linkext
  
    {LINKTYPE => 'static', 'dynamic' or ''}
  
  NB: Extensions that have nothing but *.pm files had to say
  
    {LINKTYPE => ''}
  
  with Pre-5.0 MakeMakers. Since version 5.00 of MakeMaker such a line
  can be deleted safely. MakeMaker recognizes when there's nothing to
  be linked.
  
  =item macro
  
    {ANY_MACRO => ANY_VALUE, ...}
  
  =item postamble
  
  Anything put here will be passed to MY::postamble() if you have one.
  
  =item realclean
  
    {FILES => '$(INST_ARCHAUTODIR)/*.xyz'}
  
  =item test
  
  Specify the targets for testing.
  
    {TESTS => 't/*.t'}
  
  C<RECURSIVE_TEST_FILES> can be used to include all directories
  recursively under C<t> that contain C<.t> files. It will be ignored if
  you provide your own C<TESTS> attribute, defaults to false.
  
    {RECURSIVE_TEST_FILES=>1}
  
  =item tool_autosplit
  
    {MAXLEN => 8}
  
  =back
  
  =head2 Overriding MakeMaker Methods
  
  If you cannot achieve the desired Makefile behaviour by specifying
  attributes you may define private subroutines in the Makefile.PL.
  Each subroutine returns the text it wishes to have written to
  the Makefile. To override a section of the Makefile you can
  either say:
  
          sub MY::c_o { "new literal text" }
  
  or you can edit the default by saying something like:
  
          package MY; # so that "SUPER" works right
          sub c_o {
              my $inherited = shift->SUPER::c_o(@_);
              $inherited =~ s/old text/new text/;
              $inherited;
          }
  
  If you are running experiments with embedding perl as a library into
  other applications, you might find MakeMaker is not sufficient. You'd
  better have a look at ExtUtils::Embed which is a collection of utilities
  for embedding.
  
  If you still need a different solution, try to develop another
  subroutine that fits your needs and submit the diffs to
  C<makemaker@perl.org>
  
  For a complete description of all MakeMaker methods see
  L<ExtUtils::MM_Unix>.
  
  Here is a simple example of how to add a new target to the generated
  Makefile:
  
      sub MY::postamble {
          return <<'MAKE_FRAG';
      $(MYEXTLIB): sdbm/Makefile
              cd sdbm && $(MAKE) all
  
      MAKE_FRAG
      }
  
  =head2 The End Of Cargo Cult Programming
  
  WriteMakefile() now does some basic sanity checks on its parameters to
  protect against typos and malformatted values.  This means some things
  which happened to work in the past will now throw warnings and
  possibly produce internal errors.
  
  Some of the most common mistakes:
  
  =over 2
  
  =item C<< MAN3PODS => ' ' >>
  
  This is commonly used to suppress the creation of man pages.  MAN3PODS
  takes a hash ref not a string, but the above worked by accident in old
  versions of MakeMaker.
  
  The correct code is C<< MAN3PODS => { } >>.
  
  =back
  
  
  =head2 Hintsfile support
  
  MakeMaker.pm uses the architecture-specific information from
  Config.pm. In addition it evaluates architecture specific hints files
  in a C<hints/> directory. The hints files are expected to be named
  like their counterparts in C<PERL_SRC/hints>, but with an C<.pl> file
  name extension (eg. C<next_3_2.pl>). They are simply C<eval>ed by
  MakeMaker within the WriteMakefile() subroutine, and can be used to
  execute commands as well as to include special variables. The rules
  which hintsfile is chosen are the same as in Configure.
  
  The hintsfile is eval()ed immediately after the arguments given to
  WriteMakefile are stuffed into a hash reference $self but before this
  reference becomes blessed. So if you want to do the equivalent to
  override or create an attribute you would say something like
  
      $self->{LIBS} = ['-ldbm -lucb -lc'];
  
  =head2 Distribution Support
  
  For authors of extensions MakeMaker provides several Makefile
  targets. Most of the support comes from the ExtUtils::Manifest module,
  where additional documentation can be found.
  
  =over 4
  
  =item    make distcheck
  
  reports which files are below the build directory but not in the
  MANIFEST file and vice versa. (See ExtUtils::Manifest::fullcheck() for
  details)
  
  =item    make skipcheck
  
  reports which files are skipped due to the entries in the
  C<MANIFEST.SKIP> file (See ExtUtils::Manifest::skipcheck() for
  details)
  
  =item    make distclean
  
  does a realclean first and then the distcheck. Note that this is not
  needed to build a new distribution as long as you are sure that the
  MANIFEST file is ok.
  
  =item    make veryclean
  
  does a realclean first and then removes backup files such as C<*~>,
  C<*.bak>, C<*.old> and C<*.orig>
  
  =item    make manifest
  
  rewrites the MANIFEST file, adding all remaining files found (See
  ExtUtils::Manifest::mkmanifest() for details)
  
  =item    make distdir
  
  Copies all the files that are in the MANIFEST file to a newly created
  directory with the name C<$(DISTNAME)-$(VERSION)>. If that directory
  exists, it will be removed first.
  
  Additionally, it will create META.yml and META.json module meta-data file
  in the distdir and add this to the distdir's MANIFEST.  You can shut this
  behavior off with the NO_META flag.
  
  =item   make disttest
  
  Makes a distdir first, and runs a C<perl Makefile.PL>, a make, and
  a make test in that directory.
  
  =item    make tardist
  
  First does a distdir. Then a command $(PREOP) which defaults to a null
  command, followed by $(TO_UNIX), which defaults to a null command under
  UNIX, and will convert files in distribution directory to UNIX format
  otherwise. Next it runs C<tar> on that directory into a tarfile and
  deletes the directory. Finishes with a command $(POSTOP) which
  defaults to a null command.
  
  =item    make dist
  
  Defaults to $(DIST_DEFAULT) which in turn defaults to tardist.
  
  =item    make uutardist
  
  Runs a tardist first and uuencodes the tarfile.
  
  =item    make shdist
  
  First does a distdir. Then a command $(PREOP) which defaults to a null
  command. Next it runs C<shar> on that directory into a sharfile and
  deletes the intermediate directory again. Finishes with a command
  $(POSTOP) which defaults to a null command.  Note: For shdist to work
  properly a C<shar> program that can handle directories is mandatory.
  
  =item    make zipdist
  
  First does a distdir. Then a command $(PREOP) which defaults to a null
  command. Runs C<$(ZIP) $(ZIPFLAGS)> on that directory into a
  zipfile. Then deletes that directory. Finishes with a command
  $(POSTOP) which defaults to a null command.
  
  =item    make ci
  
  Does a $(CI) and a $(RCS_LABEL) on all files in the MANIFEST file.
  
  =back
  
  Customization of the dist targets can be done by specifying a hash
  reference to the dist attribute of the WriteMakefile call. The
  following parameters are recognized:
  
      CI           ('ci -u')
      COMPRESS     ('gzip --best')
      POSTOP       ('@ :')
      PREOP        ('@ :')
      TO_UNIX      (depends on the system)
      RCS_LABEL    ('rcs -q -Nv$(VERSION_SYM):')
      SHAR         ('shar')
      SUFFIX       ('.gz')
      TAR          ('tar')
      TARFLAGS     ('cvf')
      ZIP          ('zip')
      ZIPFLAGS     ('-r')
  
  An example:
  
      WriteMakefile(
          ...other options...
          dist => {
              COMPRESS => "bzip2",
              SUFFIX   => ".bz2"
          }
      );
  
  
  =head2 Module Meta-Data (META and MYMETA)
  
  Long plaguing users of MakeMaker based modules has been the problem of
  getting basic information about the module out of the sources
  I<without> running the F<Makefile.PL> and doing a bunch of messy
  heuristics on the resulting F<Makefile>.  Over the years, it has become
  standard to keep this information in one or more CPAN Meta files
  distributed with each distribution.
  
  The original format of CPAN Meta files was L<YAML> and the corresponding
  file was called F<META.yml>.  In 2010, version 2 of the L<CPAN::Meta::Spec>
  was released, which mandates JSON format for the metadata in order to
  overcome certain compatibility issues between YAML serializers and to
  avoid breaking older clients unable to handle a new version of the spec.
  The L<CPAN::Meta> library is now standard for accessing old and new-style
  Meta files.
  
  If L<CPAN::Meta> is installed, MakeMaker will automatically generate
  F<META.json> and F<META.yml> files for you and add them to your F<MANIFEST> as
  part of the 'distdir' target (and thus the 'dist' target).  This is intended to
  seamlessly and rapidly populate CPAN with module meta-data.  If you wish to
  shut this feature off, set the C<NO_META> C<WriteMakefile()> flag to true.
  
  At the 2008 QA Hackathon in Oslo, Perl module toolchain maintainers agrees
  to use the CPAN Meta format to communicate post-configuration requirements
  between toolchain components.  These files, F<MYMETA.json> and F<MYMETA.yml>,
  are generated when F<Makefile.PL> generates a F<Makefile> (if L<CPAN::Meta>
  is installed).  Clients like L<CPAN> or L<CPANPLUS> will read this
  files to see what prerequisites must be fulfilled before building or testing
  the distribution.  If you with to shut this feature off, set the C<NO_MYMETA>
  C<WriteMakeFile()> flag to true.
  
  =head2 Disabling an extension
  
  If some events detected in F<Makefile.PL> imply that there is no way
  to create the Module, but this is a normal state of things, then you
  can create a F<Makefile> which does nothing, but succeeds on all the
  "usual" build targets.  To do so, use
  
      use ExtUtils::MakeMaker qw(WriteEmptyMakefile);
      WriteEmptyMakefile();
  
  instead of WriteMakefile().
  
  This may be useful if other modules expect this module to be I<built>
  OK, as opposed to I<work> OK (say, this system-dependent module builds
  in a subdirectory of some other distribution, or is listed as a
  dependency in a CPAN::Bundle, but the functionality is supported by
  different means on the current architecture).
  
  =head2 Other Handy Functions
  
  =over 4
  
  =item prompt
  
      my $value = prompt($message);
      my $value = prompt($message, $default);
  
  The C<prompt()> function provides an easy way to request user input
  used to write a makefile.  It displays the $message as a prompt for
  input.  If a $default is provided it will be used as a default.  The
  function returns the $value selected by the user.
  
  If C<prompt()> detects that it is not running interactively and there
  is nothing on STDIN or if the PERL_MM_USE_DEFAULT environment variable
  is set to true, the $default will be used without prompting.  This
  prevents automated processes from blocking on user input.
  
  If no $default is provided an empty string will be used instead.
  
  =back
  
  =head2 Supported versions of Perl
  
  Please note that while this module works on Perl 5.6, it is no longer
  being routinely tested on 5.6 - the earliest Perl version being routinely
  tested, and expressly supported, is 5.8.1. However, patches to repair
  any breakage on 5.6 are still being accepted.
  
  =head1 ENVIRONMENT
  
  =over 4
  
  =item PERL_MM_OPT
  
  Command line options used by C<MakeMaker-E<gt>new()>, and thus by
  C<WriteMakefile()>.  The string is split as the shell would, and the result
  is processed before any actual command line arguments are processed.
  
    PERL_MM_OPT='CCFLAGS="-Wl,-rpath -Wl,/foo/bar/lib" LIBS="-lwibble -lwobble"'
  
  =item PERL_MM_USE_DEFAULT
  
  If set to a true value then MakeMaker's prompt function will
  always return the default without waiting for user input.
  
  =item PERL_CORE
  
  Same as the PERL_CORE parameter.  The parameter overrides this.
  
  =back
  
  =head1 SEE ALSO
  
  L<Module::Build> is a pure-Perl alternative to MakeMaker which does
  not rely on make or any other external utility.  It is easier to
  extend to suit your needs.
  
  L<Module::Install> is a wrapper around MakeMaker which adds features
  not normally available.
  
  L<ExtUtils::ModuleMaker> and L<Module::Starter> are both modules to
  help you setup your distribution.
  
  L<CPAN::Meta> and L<CPAN::Meta::Spec> explain CPAN Meta files in detail.
  
  L<File::ShareDir::Install> makes it easy to install static, sometimes
  also referred to as 'shared' files. L<File::ShareDir> helps accessing
  the shared files after installation.
  
  L<Dist::Zilla> makes it easy for the module author to create MakeMaker-based
  distributions with lots of bells and whistles.
  
  =head1 AUTHORS
  
  Andy Dougherty C<doughera@lafayette.edu>, Andreas KE<ouml>nig
  C<andreas.koenig@mind.de>, Tim Bunce C<timb@cpan.org>.  VMS
  support by Charles Bailey C<bailey@newman.upenn.edu>.  OS/2 support
  by Ilya Zakharevich C<ilya@math.ohio-state.edu>.
  
  Currently maintained by Michael G Schwern C<schwern@pobox.com>
  
  Send patches and ideas to C<makemaker@perl.org>.
  
  Send bug reports via http://rt.cpan.org/.  Please send your
  generated Makefile along with your report.
  
  For more up-to-date information, see L<https://metacpan.org/release/ExtUtils-MakeMaker>.
  
  Repository available at L<https://github.com/Perl-Toolchain-Gang/ExtUtils-MakeMaker>.
  
  =head1 LICENSE
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  
  =cut
PERL5_EXTUTILS_MAKEMAKER

$fatpacked{"perl5/ExtUtils/MakeMaker/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_EXTUTILS_MAKEMAKER_CONFIG';
  package ExtUtils::MakeMaker::Config;
  
  use strict;
  
  our $VERSION = '7.10';
  
  use Config ();
  
  # Give us an overridable config.
  our %Config = %Config::Config;
  
  sub import {
      my $caller = caller;
  
      no strict 'refs';   ## no critic
      *{$caller.'::Config'} = \%Config;
  }
  
  1;
  
  
  =head1 NAME
  
  ExtUtils::MakeMaker::Config - Wrapper around Config.pm
  
  
  =head1 SYNOPSIS
  
    use ExtUtils::MakeMaker::Config;
    print $Config{installbin};  # or whatever
  
  
  =head1 DESCRIPTION
  
  B<FOR INTERNAL USE ONLY>
  
  A very thin wrapper around Config.pm so MakeMaker is easier to test.
  
  =cut
PERL5_EXTUTILS_MAKEMAKER_CONFIG

$fatpacked{"perl5/ExtUtils/MakeMaker/Locale.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_EXTUTILS_MAKEMAKER_LOCALE';
  package ExtUtils::MakeMaker::Locale;
  
  use strict;
  our $VERSION = "7.10";
  
  use base 'Exporter';
  our @EXPORT_OK = qw(
      decode_argv env
      $ENCODING_LOCALE $ENCODING_LOCALE_FS
      $ENCODING_CONSOLE_IN $ENCODING_CONSOLE_OUT
  );
  
  use Encode ();
  use Encode::Alias ();
  
  our $ENCODING_LOCALE;
  our $ENCODING_LOCALE_FS;
  our $ENCODING_CONSOLE_IN;
  our $ENCODING_CONSOLE_OUT;
  
  sub DEBUG () { 0 }
  
  sub _init {
      if ($^O eq "MSWin32") {
  	unless ($ENCODING_LOCALE) {
  	    # Try to obtain what the Windows ANSI code page is
  	    eval {
  		unless (defined &GetConsoleCP) {
  		    require Win32;
                      # no point falling back to Win32::GetConsoleCP from this
                      # as added same time, 0.45
                      eval { Win32::GetConsoleCP() };
                      # manually "import" it since Win32->import refuses
  		    *GetConsoleCP = sub { &Win32::GetConsoleCP } unless $@;
  		}
  		unless (defined &GetConsoleCP) {
  		    require Win32::API;
  		    Win32::API->Import('kernel32', 'int GetConsoleCP()');
  		}
  		if (defined &GetConsoleCP) {
  		    my $cp = GetConsoleCP();
  		    $ENCODING_LOCALE = "cp$cp" if $cp;
  		}
  	    };
  	}
  
  	unless ($ENCODING_CONSOLE_IN) {
              # only test one since set together
              unless (defined &GetInputCP) {
                  eval {
                      require Win32;
                      eval { Win32::GetConsoleCP() };
                      # manually "import" it since Win32->import refuses
                      *GetInputCP = sub { &Win32::GetConsoleCP } unless $@;
                      *GetOutputCP = sub { &Win32::GetConsoleOutputCP } unless $@;
                  };
                  unless (defined &GetInputCP) {
                      eval {
                          # try Win32::Console module for codepage to use
                          require Win32::Console;
                          eval { Win32::Console::InputCP() };
                          *GetInputCP = sub { &Win32::Console::InputCP }
                              unless $@;
                          *GetOutputCP = sub { &Win32::Console::OutputCP }
                              unless $@;
                      };
                  }
                  unless (defined &GetInputCP) {
                      # final fallback
                      *GetInputCP = *GetOutputCP = sub {
                          # another fallback that could work is:
                          # reg query HKLM\System\CurrentControlSet\Control\Nls\CodePage /v ACP
                          ((qx(chcp) || '') =~ /^Active code page: (\d+)/)
                              ? $1 : ();
                      };
                  }
  	    }
              my $cp = GetInputCP();
              $ENCODING_CONSOLE_IN = "cp$cp" if $cp;
              $cp = GetOutputCP();
              $ENCODING_CONSOLE_OUT = "cp$cp" if $cp;
  	}
      }
  
      unless ($ENCODING_LOCALE) {
  	eval {
  	    require I18N::Langinfo;
  	    $ENCODING_LOCALE = I18N::Langinfo::langinfo(I18N::Langinfo::CODESET());
  
  	    # Workaround of Encode < v2.25.  The "646" encoding  alias was
  	    # introduced in Encode-2.25, but we don't want to require that version
  	    # quite yet.  Should avoid the CPAN testers failure reported from
  	    # openbsd-4.7/perl-5.10.0 combo.
  	    $ENCODING_LOCALE = "ascii" if $ENCODING_LOCALE eq "646";
  
  	    # https://rt.cpan.org/Ticket/Display.html?id=66373
  	    $ENCODING_LOCALE = "hp-roman8" if $^O eq "hpux" && $ENCODING_LOCALE eq "roman8";
  	};
  	$ENCODING_LOCALE ||= $ENCODING_CONSOLE_IN;
      }
  
      if ($^O eq "darwin") {
  	$ENCODING_LOCALE_FS ||= "UTF-8";
      }
  
      # final fallback
      $ENCODING_LOCALE ||= $^O eq "MSWin32" ? "cp1252" : "UTF-8";
      $ENCODING_LOCALE_FS ||= $ENCODING_LOCALE;
      $ENCODING_CONSOLE_IN ||= $ENCODING_LOCALE;
      $ENCODING_CONSOLE_OUT ||= $ENCODING_CONSOLE_IN;
  
      unless (Encode::find_encoding($ENCODING_LOCALE)) {
  	my $foundit;
  	if (lc($ENCODING_LOCALE) eq "gb18030") {
  	    eval {
  		require Encode::HanExtra;
  	    };
  	    if ($@) {
  		die "Need Encode::HanExtra to be installed to support locale codeset ($ENCODING_LOCALE), stopped";
  	    }
  	    $foundit++ if Encode::find_encoding($ENCODING_LOCALE);
  	}
  	die "The locale codeset ($ENCODING_LOCALE) isn't one that perl can decode, stopped"
  	    unless $foundit;
  
      }
  
      # use Data::Dump; ddx $ENCODING_LOCALE, $ENCODING_LOCALE_FS, $ENCODING_CONSOLE_IN, $ENCODING_CONSOLE_OUT;
  }
  
  _init();
  Encode::Alias::define_alias(sub {
      no strict 'refs';
      no warnings 'once';
      return ${"ENCODING_" . uc(shift)};
  }, "locale");
  
  sub _flush_aliases {
      no strict 'refs';
      for my $a (keys %Encode::Alias::Alias) {
  	if (defined ${"ENCODING_" . uc($a)}) {
  	    delete $Encode::Alias::Alias{$a};
  	    warn "Flushed alias cache for $a" if DEBUG;
  	}
      }
  }
  
  sub reinit {
      $ENCODING_LOCALE = shift;
      $ENCODING_LOCALE_FS = shift;
      $ENCODING_CONSOLE_IN = $ENCODING_LOCALE;
      $ENCODING_CONSOLE_OUT = $ENCODING_LOCALE;
      _init();
      _flush_aliases();
  }
  
  sub decode_argv {
      die if defined wantarray;
      for (@ARGV) {
  	$_ = Encode::decode(locale => $_, @_);
      }
  }
  
  sub env {
      my $k = Encode::encode(locale => shift);
      my $old = $ENV{$k};
      if (@_) {
  	my $v = shift;
  	if (defined $v) {
  	    $ENV{$k} = Encode::encode(locale => $v);
  	}
  	else {
  	    delete $ENV{$k};
  	}
      }
      return Encode::decode(locale => $old) if defined wantarray;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  ExtUtils::MakeMaker::Locale - bundled Encode::Locale
  
  =head1 SYNOPSIS
  
    use Encode::Locale;
    use Encode;
  
    $string = decode(locale => $bytes);
    $bytes = encode(locale => $string);
  
    if (-t) {
        binmode(STDIN, ":encoding(console_in)");
        binmode(STDOUT, ":encoding(console_out)");
        binmode(STDERR, ":encoding(console_out)");
    }
  
    # Processing file names passed in as arguments
    my $uni_filename = decode(locale => $ARGV[0]);
    open(my $fh, "<", encode(locale_fs => $uni_filename))
       || die "Can't open '$uni_filename': $!";
    binmode($fh, ":encoding(locale)");
    ...
  
  =head1 DESCRIPTION
  
  In many applications it's wise to let Perl use Unicode for the strings it
  processes.  Most of the interfaces Perl has to the outside world are still byte
  based.  Programs therefore need to decode byte strings that enter the program
  from the outside and encode them again on the way out.
  
  The POSIX locale system is used to specify both the language conventions
  requested by the user and the preferred character set to consume and
  output.  The C<Encode::Locale> module looks up the charset and encoding (called
  a CODESET in the locale jargon) and arranges for the L<Encode> module to know
  this encoding under the name "locale".  It means bytes obtained from the
  environment can be converted to Unicode strings by calling C<<
  Encode::encode(locale => $bytes) >> and converted back again with C<<
  Encode::decode(locale => $string) >>.
  
  Where file systems interfaces pass file names in and out of the program we also
  need care.  The trend is for operating systems to use a fixed file encoding
  that don't actually depend on the locale; and this module determines the most
  appropriate encoding for file names. The L<Encode> module will know this
  encoding under the name "locale_fs".  For traditional Unix systems this will
  be an alias to the same encoding as "locale".
  
  For programs running in a terminal window (called a "Console" on some systems)
  the "locale" encoding is usually a good choice for what to expect as input and
  output.  Some systems allows us to query the encoding set for the terminal and
  C<Encode::Locale> will do that if available and make these encodings known
  under the C<Encode> aliases "console_in" and "console_out".  For systems where
  we can't determine the terminal encoding these will be aliased as the same
  encoding as "locale".  The advice is to use "console_in" for input known to
  come from the terminal and "console_out" for output to the terminal.
  
  In addition to arranging for various Encode aliases the following functions and
  variables are provided:
  
  =over
  
  =item decode_argv( )
  
  =item decode_argv( Encode::FB_CROAK )
  
  This will decode the command line arguments to perl (the C<@ARGV> array) in-place.
  
  The function will by default replace characters that can't be decoded by
  "\x{FFFD}", the Unicode replacement character.
  
  Any argument provided is passed as CHECK to underlying Encode::decode() call.
  Pass the value C<Encode::FB_CROAK> to have the decoding croak if not all the
  command line arguments can be decoded.  See L<Encode/"Handling Malformed Data">
  for details on other options for CHECK.
  
  =item env( $uni_key )
  
  =item env( $uni_key => $uni_value )
  
  Interface to get/set environment variables.  Returns the current value as a
  Unicode string. The $uni_key and $uni_value arguments are expected to be
  Unicode strings as well.  Passing C<undef> as $uni_value deletes the
  environment variable named $uni_key.
  
  The returned value will have the characters that can't be decoded replaced by
  "\x{FFFD}", the Unicode replacement character.
  
  There is no interface to request alternative CHECK behavior as for
  decode_argv().  If you need that you need to call encode/decode yourself.
  For example:
  
      my $key = Encode::encode(locale => $uni_key, Encode::FB_CROAK);
      my $uni_value = Encode::decode(locale => $ENV{$key}, Encode::FB_CROAK);
  
  =item reinit( )
  
  =item reinit( $encoding )
  
  Reinitialize the encodings from the locale.  You want to call this function if
  you changed anything in the environment that might influence the locale.
  
  This function will croak if the determined encoding isn't recognized by
  the Encode module.
  
  With argument force $ENCODING_... variables to set to the given value.
  
  =item $ENCODING_LOCALE
  
  The encoding name determined to be suitable for the current locale.
  L<Encode> know this encoding as "locale".
  
  =item $ENCODING_LOCALE_FS
  
  The encoding name determined to be suitable for file system interfaces
  involving file names.
  L<Encode> know this encoding as "locale_fs".
  
  =item $ENCODING_CONSOLE_IN
  
  =item $ENCODING_CONSOLE_OUT
  
  The encodings to be used for reading and writing output to the a console.
  L<Encode> know these encodings as "console_in" and "console_out".
  
  =back
  
  =head1 NOTES
  
  This table summarizes the mapping of the encodings set up
  by the C<Encode::Locale> module:
  
    Encode      |         |              |
    Alias       | Windows | Mac OS X     | POSIX
    ------------+---------+--------------+------------
    locale      | ANSI    | nl_langinfo  | nl_langinfo
    locale_fs   | ANSI    | UTF-8        | nl_langinfo
    console_in  | OEM     | nl_langinfo  | nl_langinfo
    console_out | OEM     | nl_langinfo  | nl_langinfo
  
  =head2 Windows
  
  Windows has basically 2 sets of APIs.  A wide API (based on passing UTF-16
  strings) and a byte based API based a character set called ANSI.  The
  regular Perl interfaces to the OS currently only uses the ANSI APIs.
  Unfortunately ANSI is not a single character set.
  
  The encoding that corresponds to ANSI varies between different editions of
  Windows.  For many western editions of Windows ANSI corresponds to CP-1252
  which is a character set similar to ISO-8859-1.  Conceptually the ANSI
  character set is a similar concept to the POSIX locale CODESET so this module
  figures out what the ANSI code page is and make this available as
  $ENCODING_LOCALE and the "locale" Encoding alias.
  
  Windows systems also operate with another byte based character set.
  It's called the OEM code page.  This is the encoding that the Console
  takes as input and output.  It's common for the OEM code page to
  differ from the ANSI code page.
  
  =head2 Mac OS X
  
  On Mac OS X the file system encoding is always UTF-8 while the locale
  can otherwise be set up as normal for POSIX systems.
  
  File names on Mac OS X will at the OS-level be converted to
  NFD-form.  A file created by passing a NFC-filename will come
  in NFD-form from readdir().  See L<Unicode::Normalize> for details
  of NFD/NFC.
  
  Actually, Apple does not follow the Unicode NFD standard since not all
  character ranges are decomposed.  The claim is that this avoids problems with
  round trip conversions from old Mac text encodings.  See L<Encode::UTF8Mac> for
  details.
  
  =head2 POSIX (Linux and other Unixes)
  
  File systems might vary in what encoding is to be used for
  filenames.  Since this module has no way to actually figure out
  what the is correct it goes with the best guess which is to
  assume filenames are encoding according to the current locale.
  Users are advised to always specify UTF-8 as the locale charset.
  
  =head1 SEE ALSO
  
  L<I18N::Langinfo>, L<Encode>, L<Term::Encoding>
  
  =head1 AUTHOR
  
  Copyright 2010 Gisle Aas <gisle@aas.no>.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
PERL5_EXTUTILS_MAKEMAKER_LOCALE

$fatpacked{"perl5/ExtUtils/MakeMaker/version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_EXTUTILS_MAKEMAKER_VERSION';
  #--------------------------------------------------------------------------#
  # This is a modified copy of version.pm 0.9909, bundled exclusively for
  # use by ExtUtils::Makemaker and its dependencies to bootstrap when
  # version.pm is not available.  It should not be used by ordinary modules.
  #
  # When loaded, it will try to load version.pm.  If that fails, it will load
  # ExtUtils::MakeMaker::version::vpp and alias various *version functions
  # to functions in that module.  It will also override UNIVERSAL::VERSION.
  #--------------------------------------------------------------------------#
  
  package ExtUtils::MakeMaker::version;
  
  use 5.006002;
  use strict;
  
  use vars qw(@ISA $VERSION $CLASS $STRICT $LAX *declare *qv);
  
  $VERSION = '7.10';
  $CLASS = 'version';
  
  {
      local $SIG{'__DIE__'};
      eval "use version";
      if ( $@ ) { # don't have any version.pm installed
          eval "use ExtUtils::MakeMaker::version::vpp";
          die "$@" if ( $@ );
          local $^W;
          delete $INC{'version.pm'};
          $INC{'version.pm'} = $INC{'ExtUtils/MakeMaker/version.pm'};
          push @version::ISA, "ExtUtils::MakeMaker::version::vpp";
          $version::VERSION = $VERSION;
          *version::qv = \&ExtUtils::MakeMaker::version::vpp::qv;
          *version::declare = \&ExtUtils::MakeMaker::version::vpp::declare;
          *version::_VERSION = \&ExtUtils::MakeMaker::version::vpp::_VERSION;
          *version::vcmp = \&ExtUtils::MakeMaker::version::vpp::vcmp;
          *version::new = \&ExtUtils::MakeMaker::version::vpp::new;
          if ($] >= 5.009000) {
              no strict 'refs';
              *version::stringify = \&ExtUtils::MakeMaker::version::vpp::stringify;
              *{'version::(""'} = \&ExtUtils::MakeMaker::version::vpp::stringify;
              *{'version::(<=>'} = \&ExtUtils::MakeMaker::version::vpp::vcmp;
              *version::parse = \&ExtUtils::MakeMaker::version::vpp::parse;
          }
          require ExtUtils::MakeMaker::version::regex;
          *version::is_lax = \&ExtUtils::MakeMaker::version::regex::is_lax;
          *version::is_strict = \&ExtUtils::MakeMaker::version::regex::is_strict;
          *LAX = \$ExtUtils::MakeMaker::version::regex::LAX;
          *STRICT = \$ExtUtils::MakeMaker::version::regex::STRICT;
      }
      elsif ( ! version->can('is_qv') ) {
          *version::is_qv = sub { exists $_[0]->{qv} };
      }
  }
  
  1;
PERL5_EXTUTILS_MAKEMAKER_VERSION

$fatpacked{"perl5/ExtUtils/MakeMaker/version/regex.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_EXTUTILS_MAKEMAKER_VERSION_REGEX';
  #--------------------------------------------------------------------------#
  # This is a modified copy of version.pm 0.9909, bundled exclusively for
  # use by ExtUtils::Makemaker and its dependencies to bootstrap when
  # version.pm is not available.  It should not be used by ordinary modules.
  #--------------------------------------------------------------------------#
  
  package ExtUtils::MakeMaker::version::regex;
  
  use strict;
  
  use vars qw($VERSION $CLASS $STRICT $LAX);
  
  $VERSION = '7.10';
  
  #--------------------------------------------------------------------------#
  # Version regexp components
  #--------------------------------------------------------------------------#
  
  # Fraction part of a decimal version number.  This is a common part of
  # both strict and lax decimal versions
  
  my $FRACTION_PART = qr/\.[0-9]+/;
  
  # First part of either decimal or dotted-decimal strict version number.
  # Unsigned integer with no leading zeroes (except for zero itself) to
  # avoid confusion with octal.
  
  my $STRICT_INTEGER_PART = qr/0|[1-9][0-9]*/;
  
  # First part of either decimal or dotted-decimal lax version number.
  # Unsigned integer, but allowing leading zeros.  Always interpreted
  # as decimal.  However, some forms of the resulting syntax give odd
  # results if used as ordinary Perl expressions, due to how perl treats
  # octals.  E.g.
  #   version->new("010" ) == 10
  #   version->new( 010  ) == 8
  #   version->new( 010.2) == 82  # "8" . "2"
  
  my $LAX_INTEGER_PART = qr/[0-9]+/;
  
  # Second and subsequent part of a strict dotted-decimal version number.
  # Leading zeroes are permitted, and the number is always decimal.
  # Limited to three digits to avoid overflow when converting to decimal
  # form and also avoid problematic style with excessive leading zeroes.
  
  my $STRICT_DOTTED_DECIMAL_PART = qr/\.[0-9]{1,3}/;
  
  # Second and subsequent part of a lax dotted-decimal version number.
  # Leading zeroes are permitted, and the number is always decimal.  No
  # limit on the numerical value or number of digits, so there is the
  # possibility of overflow when converting to decimal form.
  
  my $LAX_DOTTED_DECIMAL_PART = qr/\.[0-9]+/;
  
  # Alpha suffix part of lax version number syntax.  Acts like a
  # dotted-decimal part.
  
  my $LAX_ALPHA_PART = qr/_[0-9]+/;
  
  #--------------------------------------------------------------------------#
  # Strict version regexp definitions
  #--------------------------------------------------------------------------#
  
  # Strict decimal version number.
  
  my $STRICT_DECIMAL_VERSION =
      qr/ $STRICT_INTEGER_PART $FRACTION_PART? /x;
  
  # Strict dotted-decimal version number.  Must have both leading "v" and
  # at least three parts, to avoid confusion with decimal syntax.
  
  my $STRICT_DOTTED_DECIMAL_VERSION =
      qr/ v $STRICT_INTEGER_PART $STRICT_DOTTED_DECIMAL_PART{2,} /x;
  
  # Complete strict version number syntax -- should generally be used
  # anchored: qr/ \A $STRICT \z /x
  
  $STRICT =
      qr/ $STRICT_DECIMAL_VERSION | $STRICT_DOTTED_DECIMAL_VERSION /x;
  
  #--------------------------------------------------------------------------#
  # Lax version regexp definitions
  #--------------------------------------------------------------------------#
  
  # Lax decimal version number.  Just like the strict one except for
  # allowing an alpha suffix or allowing a leading or trailing
  # decimal-point
  
  my $LAX_DECIMAL_VERSION =
      qr/ $LAX_INTEGER_PART (?: \. | $FRACTION_PART $LAX_ALPHA_PART? )?
  	|
  	$FRACTION_PART $LAX_ALPHA_PART?
      /x;
  
  # Lax dotted-decimal version number.  Distinguished by having either
  # leading "v" or at least three non-alpha parts.  Alpha part is only
  # permitted if there are at least two non-alpha parts. Strangely
  # enough, without the leading "v", Perl takes .1.2 to mean v0.1.2,
  # so when there is no "v", the leading part is optional
  
  my $LAX_DOTTED_DECIMAL_VERSION =
      qr/
  	v $LAX_INTEGER_PART (?: $LAX_DOTTED_DECIMAL_PART+ $LAX_ALPHA_PART? )?
  	|
  	$LAX_INTEGER_PART? $LAX_DOTTED_DECIMAL_PART{2,} $LAX_ALPHA_PART?
      /x;
  
  # Complete lax version number syntax -- should generally be used
  # anchored: qr/ \A $LAX \z /x
  #
  # The string 'undef' is a special case to make for easier handling
  # of return values from ExtUtils::MM->parse_version
  
  $LAX =
      qr/ undef | $LAX_DECIMAL_VERSION | $LAX_DOTTED_DECIMAL_VERSION /x;
  
  #--------------------------------------------------------------------------#
  
  # Preloaded methods go here.
  sub is_strict	{ defined $_[0] && $_[0] =~ qr/ \A $STRICT \z /x }
  sub is_lax	{ defined $_[0] && $_[0] =~ qr/ \A $LAX \z /x }
  
  1;
PERL5_EXTUTILS_MAKEMAKER_VERSION_REGEX

$fatpacked{"perl5/ExtUtils/MakeMaker/version/vpp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_EXTUTILS_MAKEMAKER_VERSION_VPP';
  #--------------------------------------------------------------------------#
  # This is a modified copy of version.pm 0.9909, bundled exclusively for
  # use by ExtUtils::Makemaker and its dependencies to bootstrap when
  # version.pm is not available.  It should not be used by ordinary modules.
  #--------------------------------------------------------------------------#
  
  package ExtUtils::MakeMaker::charstar;
  # a little helper class to emulate C char* semantics in Perl
  # so that prescan_version can use the same code as in C
  
  use overload (
      '""'	=> \&thischar,
      '0+'	=> \&thischar,
      '++'	=> \&increment,
      '--'	=> \&decrement,
      '+'		=> \&plus,
      '-'		=> \&minus,
      '*'		=> \&multiply,
      'cmp'	=> \&cmp,
      '<=>'	=> \&spaceship,
      'bool'	=> \&thischar,
      '='		=> \&clone,
  );
  
  sub new {
      my ($self, $string) = @_;
      my $class = ref($self) || $self;
  
      my $obj = {
  	string  => [split(//,$string)],
  	current => 0,
      };
      return bless $obj, $class;
  }
  
  sub thischar {
      my ($self) = @_;
      my $last = $#{$self->{string}};
      my $curr = $self->{current};
      if ($curr >= 0 && $curr <= $last) {
  	return $self->{string}->[$curr];
      }
      else {
  	return '';
      }
  }
  
  sub increment {
      my ($self) = @_;
      $self->{current}++;
  }
  
  sub decrement {
      my ($self) = @_;
      $self->{current}--;
  }
  
  sub plus {
      my ($self, $offset) = @_;
      my $rself = $self->clone;
      $rself->{current} += $offset;
      return $rself;
  }
  
  sub minus {
      my ($self, $offset) = @_;
      my $rself = $self->clone;
      $rself->{current} -= $offset;
      return $rself;
  }
  
  sub multiply {
      my ($left, $right, $swapped) = @_;
      my $char = $left->thischar();
      return $char * $right;
  }
  
  sub spaceship {
      my ($left, $right, $swapped) = @_;
      unless (ref($right)) { # not an object already
  	$right = $left->new($right);
      }
      return $left->{current} <=> $right->{current};
  }
  
  sub cmp {
      my ($left, $right, $swapped) = @_;
      unless (ref($right)) { # not an object already
  	if (length($right) == 1) { # comparing single character only
  	    return $left->thischar cmp $right;
  	}
  	$right = $left->new($right);
      }
      return $left->currstr cmp $right->currstr;
  }
  
  sub bool {
      my ($self) = @_;
      my $char = $self->thischar;
      return ($char ne '');
  }
  
  sub clone {
      my ($left, $right, $swapped) = @_;
      $right = {
  	string  => [@{$left->{string}}],
  	current => $left->{current},
      };
      return bless $right, ref($left);
  }
  
  sub currstr {
      my ($self, $s) = @_;
      my $curr = $self->{current};
      my $last = $#{$self->{string}};
      if (defined($s) && $s->{current} < $last) {
  	$last = $s->{current};
      }
  
      my $string = join('', @{$self->{string}}[$curr..$last]);
      return $string;
  }
  
  package ExtUtils::MakeMaker::version::vpp;
  
  use 5.006002;
  use strict;
  
  use Config;
  use vars qw($VERSION $CLASS @ISA $LAX $STRICT);
  $VERSION = '7.10';
  $CLASS = 'ExtUtils::MakeMaker::version::vpp';
  
  require ExtUtils::MakeMaker::version::regex;
  *ExtUtils::MakeMaker::version::vpp::is_strict = \&ExtUtils::MakeMaker::version::regex::is_strict;
  *ExtUtils::MakeMaker::version::vpp::is_lax = \&ExtUtils::MakeMaker::version::regex::is_lax;
  *LAX = \$ExtUtils::MakeMaker::version::regex::LAX;
  *STRICT = \$ExtUtils::MakeMaker::version::regex::STRICT;
  
  use overload (
      '""'       => \&stringify,
      '0+'       => \&numify,
      'cmp'      => \&vcmp,
      '<=>'      => \&vcmp,
      'bool'     => \&vbool,
      '+'        => \&vnoop,
      '-'        => \&vnoop,
      '*'        => \&vnoop,
      '/'        => \&vnoop,
      '+='        => \&vnoop,
      '-='        => \&vnoop,
      '*='        => \&vnoop,
      '/='        => \&vnoop,
      'abs'      => \&vnoop,
  );
  
  eval "use warnings";
  if ($@) {
      eval '
  	package
  	warnings;
  	sub enabled {return $^W;}
  	1;
      ';
  }
  
  sub import {
      no strict 'refs';
      my ($class) = shift;
  
      # Set up any derived class
      unless ($class eq $CLASS) {
  	local $^W;
  	*{$class.'::declare'} =  \&{$CLASS.'::declare'};
  	*{$class.'::qv'} = \&{$CLASS.'::qv'};
      }
  
      my %args;
      if (@_) { # any remaining terms are arguments
  	map { $args{$_} = 1 } @_
      }
      else { # no parameters at all on use line
  	%args =
  	(
  	    qv => 1,
  	    'UNIVERSAL::VERSION' => 1,
  	);
      }
  
      my $callpkg = caller();
  
      if (exists($args{declare})) {
  	*{$callpkg.'::declare'} =
  	    sub {return $class->declare(shift) }
  	  unless defined(&{$callpkg.'::declare'});
      }
  
      if (exists($args{qv})) {
  	*{$callpkg.'::qv'} =
  	    sub {return $class->qv(shift) }
  	  unless defined(&{$callpkg.'::qv'});
      }
  
      if (exists($args{'UNIVERSAL::VERSION'})) {
  	local $^W;
  	*UNIVERSAL::VERSION
  		= \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'VERSION'})) {
  	*{$callpkg.'::VERSION'} = \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'is_strict'})) {
  	*{$callpkg.'::is_strict'} = \&{$CLASS.'::is_strict'}
  	  unless defined(&{$callpkg.'::is_strict'});
      }
  
      if (exists($args{'is_lax'})) {
  	*{$callpkg.'::is_lax'} = \&{$CLASS.'::is_lax'}
  	  unless defined(&{$callpkg.'::is_lax'});
      }
  }
  
  my $VERSION_MAX = 0x7FFFFFFF;
  
  # implement prescan_version as closely to the C version as possible
  use constant TRUE  => 1;
  use constant FALSE => 0;
  
  sub isDIGIT {
      my ($char) = shift->thischar();
      return ($char =~ /\d/);
  }
  
  sub isALPHA {
      my ($char) = shift->thischar();
      return ($char =~ /[a-zA-Z]/);
  }
  
  sub isSPACE {
      my ($char) = shift->thischar();
      return ($char =~ /\s/);
  }
  
  sub BADVERSION {
      my ($s, $errstr, $error) = @_;
      if ($errstr) {
  	$$errstr = $error;
      }
      return $s;
  }
  
  sub prescan_version {
      my ($s, $strict, $errstr, $sqv, $ssaw_decimal, $swidth, $salpha) = @_;
      my $qv          = defined $sqv          ? $$sqv          : FALSE;
      my $saw_decimal = defined $ssaw_decimal ? $$ssaw_decimal : 0;
      my $width       = defined $swidth       ? $$swidth       : 3;
      my $alpha       = defined $salpha       ? $$salpha       : FALSE;
  
      my $d = $s;
  
      if ($qv && isDIGIT($d)) {
  	goto dotted_decimal_version;
      }
  
      if ($d eq 'v') { # explicit v-string
  	$d++;
  	if (isDIGIT($d)) {
  	    $qv = TRUE;
  	}
  	else { # degenerate v-string
  	    # requires v1.2.3
  	    return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	}
  
  dotted_decimal_version:
  	if ($strict && $d eq '0' && isDIGIT($d+1)) {
  	    # no leading zeros allowed
  	    return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)");
  	}
  
  	while (isDIGIT($d)) { 	# integer part
  	    $d++;
  	}
  
  	if ($d eq '.')
  	{
  	    $saw_decimal++;
  	    $d++; 		# decimal point
  	}
  	else
  	{
  	    if ($strict) {
  		# require v1.2.3
  		return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	    }
  	    else {
  		goto version_prescan_finish;
  	    }
  	}
  
  	{
  	    my $i = 0;
  	    my $j = 0;
  	    while (isDIGIT($d)) {	# just keep reading
  		$i++;
  		while (isDIGIT($d)) {
  		    $d++; $j++;
  		    # maximum 3 digits between decimal
  		    if ($strict && $j > 3) {
  			return BADVERSION($s,$errstr,"Invalid version format (maximum 3 digits between decimals)");
  		    }
  		}
  		if ($d eq '_') {
  		    if ($strict) {
  			return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  		    }
  		    if ( $alpha ) {
  			return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)");
  		    }
  		    $d++;
  		    $alpha = TRUE;
  		}
  		elsif ($d eq '.') {
  		    if ($alpha) {
  			return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)");
  		    }
  		    $saw_decimal++;
  		    $d++;
  		}
  		elsif (!isDIGIT($d)) {
  		    last;
  		}
  		$j = 0;
  	    }
  
  	    if ($strict && $i < 2) {
  		# requires v1.2.3
  		return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	    }
  	}
      } 					# end if dotted-decimal
      else
      {					# decimal versions
  	my $j = 0;
  	# special $strict case for leading '.' or '0'
  	if ($strict) {
  	    if ($d eq '.') {
  		return BADVERSION($s,$errstr,"Invalid version format (0 before decimal required)");
  	    }
  	    if ($d eq '0' && isDIGIT($d+1)) {
  		return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)");
  	    }
  	}
  
  	# and we never support negative version numbers
  	if ($d eq '-') {
  	    return BADVERSION($s,$errstr,"Invalid version format (negative version number)");
  	}
  
  	# consume all of the integer part
  	while (isDIGIT($d)) {
  	    $d++;
  	}
  
  	# look for a fractional part
  	if ($d eq '.') {
  	    # we found it, so consume it
  	    $saw_decimal++;
  	    $d++;
  	}
  	elsif (!$d || $d eq ';' || isSPACE($d) || $d eq '}') {
  	    if ( $d == $s ) {
  		# found nothing
  		return BADVERSION($s,$errstr,"Invalid version format (version required)");
  	    }
  	    # found just an integer
  	    goto version_prescan_finish;
  	}
  	elsif ( $d == $s ) {
  	    # didn't find either integer or period
  	    return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
  	}
  	elsif ($d eq '_') {
  	    # underscore can't come after integer part
  	    if ($strict) {
  		return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  	    }
  	    elsif (isDIGIT($d+1)) {
  		return BADVERSION($s,$errstr,"Invalid version format (alpha without decimal)");
  	    }
  	    else {
  		return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)");
  	    }
  	}
  	elsif ($d) {
  	    # anything else after integer part is just invalid data
  	    return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
  	}
  
  	# scan the fractional part after the decimal point
  	if ($d && !isDIGIT($d) && ($strict || ! ($d eq ';' || isSPACE($d) || $d eq '}') )) {
  		# $strict or lax-but-not-the-end
  		return BADVERSION($s,$errstr,"Invalid version format (fractional part required)");
  	}
  
  	while (isDIGIT($d)) {
  	    $d++; $j++;
  	    if ($d eq '.' && isDIGIT($d-1)) {
  		if ($alpha) {
  		    return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)");
  		}
  		if ($strict) {
  		    return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions must begin with 'v')");
  		}
  		$d = $s; # start all over again
  		$qv = TRUE;
  		goto dotted_decimal_version;
  	    }
  	    if ($d eq '_') {
  		if ($strict) {
  		    return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  		}
  		if ( $alpha ) {
  		    return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)");
  		}
  		if ( ! isDIGIT($d+1) ) {
  		    return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)");
  		}
  		$width = $j;
  		$d++;
  		$alpha = TRUE;
  	    }
  	}
      }
  
  version_prescan_finish:
      while (isSPACE($d)) {
  	$d++;
      }
  
      if ($d && !isDIGIT($d) && (! ($d eq ';' || $d eq '}') )) {
  	# trailing non-numeric data
  	return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
      }
  
      if (defined $sqv) {
  	$$sqv = $qv;
      }
      if (defined $swidth) {
  	$$swidth = $width;
      }
      if (defined $ssaw_decimal) {
  	$$ssaw_decimal = $saw_decimal;
      }
      if (defined $salpha) {
  	$$salpha = $alpha;
      }
      return $d;
  }
  
  sub scan_version {
      my ($s, $rv, $qv) = @_;
      my $start;
      my $pos;
      my $last;
      my $errstr;
      my $saw_decimal = 0;
      my $width = 3;
      my $alpha = FALSE;
      my $vinf = FALSE;
      my @av;
  
      $s = new ExtUtils::MakeMaker::charstar $s;
  
      while (isSPACE($s)) { # leading whitespace is OK
  	$s++;
      }
  
      $last = prescan_version($s, FALSE, \$errstr, \$qv, \$saw_decimal,
  	\$width, \$alpha);
  
      if ($errstr) {
  	# 'undef' is a special case and not an error
  	if ( $s ne 'undef') {
  	    require Carp;
  	    Carp::croak($errstr);
  	}
      }
  
      $start = $s;
      if ($s eq 'v') {
  	$s++;
      }
      $pos = $s;
  
      if ( $qv ) {
  	$$rv->{qv} = $qv;
      }
      if ( $alpha ) {
  	$$rv->{alpha} = $alpha;
      }
      if ( !$qv && $width < 3 ) {
  	$$rv->{width} = $width;
      }
  
      while (isDIGIT($pos)) {
  	$pos++;
      }
      if (!isALPHA($pos)) {
  	my $rev;
  
  	for (;;) {
  	    $rev = 0;
  	    {
    		# this is atoi() that delimits on underscores
    		my $end = $pos;
    		my $mult = 1;
  		my $orev;
  
  		#  the following if() will only be true after the decimal
  		#  point of a version originally created with a bare
  		#  floating point number, i.e. not quoted in any way
  		#
   		if ( !$qv && $s > $start && $saw_decimal == 1 ) {
  		    $mult *= 100;
   		    while ( $s < $end ) {
  			$orev = $rev;
   			$rev += $s * $mult;
   			$mult /= 10;
  			if (   (abs($orev) > abs($rev))
  			    || (abs($rev) > $VERSION_MAX )) {
  			    warn("Integer overflow in version %d",
  					   $VERSION_MAX);
  			    $s = $end - 1;
  			    $rev = $VERSION_MAX;
  			    $vinf = 1;
  			}
   			$s++;
  			if ( $s eq '_' ) {
  			    $s++;
  			}
   		    }
    		}
   		else {
   		    while (--$end >= $s) {
  			$orev = $rev;
   			$rev += $end * $mult;
   			$mult *= 10;
  			if (   (abs($orev) > abs($rev))
  			    || (abs($rev) > $VERSION_MAX )) {
  			    warn("Integer overflow in version");
  			    $end = $s - 1;
  			    $rev = $VERSION_MAX;
  			    $vinf = 1;
  			}
   		    }
   		}
    	    }
  
    	    # Append revision
  	    push @av, $rev;
  	    if ( $vinf ) {
  		$s = $last;
  		last;
  	    }
  	    elsif ( $pos eq '.' ) {
  		$s = ++$pos;
  	    }
  	    elsif ( $pos eq '_' && isDIGIT($pos+1) ) {
  		$s = ++$pos;
  	    }
  	    elsif ( $pos eq ',' && isDIGIT($pos+1) ) {
  		$s = ++$pos;
  	    }
  	    elsif ( isDIGIT($pos) ) {
  		$s = $pos;
  	    }
  	    else {
  		$s = $pos;
  		last;
  	    }
  	    if ( $qv ) {
  		while ( isDIGIT($pos) ) {
  		    $pos++;
  		}
  	    }
  	    else {
  		my $digits = 0;
  		while ( ( isDIGIT($pos) || $pos eq '_' ) && $digits < 3 ) {
  		    if ( $pos ne '_' ) {
  			$digits++;
  		    }
  		    $pos++;
  		}
  	    }
  	}
      }
      if ( $qv ) { # quoted versions always get at least three terms
  	my $len = $#av;
  	#  This for loop appears to trigger a compiler bug on OS X, as it
  	#  loops infinitely. Yes, len is negative. No, it makes no sense.
  	#  Compiler in question is:
  	#  gcc version 3.3 20030304 (Apple Computer, Inc. build 1640)
  	#  for ( len = 2 - len; len > 0; len-- )
  	#  av_push(MUTABLE_AV(sv), newSViv(0));
  	#
  	$len = 2 - $len;
  	while ($len-- > 0) {
  	    push @av, 0;
  	}
      }
  
      # need to save off the current version string for later
      if ( $vinf ) {
  	$$rv->{original} = "v.Inf";
  	$$rv->{vinf} = 1;
      }
      elsif ( $s > $start ) {
  	$$rv->{original} = $start->currstr($s);
  	if ( $qv && $saw_decimal == 1 && $start ne 'v' ) {
  	    # need to insert a v to be consistent
  	    $$rv->{original} = 'v' . $$rv->{original};
  	}
      }
      else {
  	$$rv->{original} = '0';
  	push(@av, 0);
      }
  
      # And finally, store the AV in the hash
      $$rv->{version} = \@av;
  
      # fix RT#19517 - special case 'undef' as string
      if ($s eq 'undef') {
  	$s += 5;
      }
  
      return $s;
  }
  
  sub new {
      my $class = shift;
      unless (defined $class or $#_ > 1) {
  	require Carp;
  	Carp::croak('Usage: version::new(class, version)');
      }
  
      my $self = bless ({}, ref ($class) || $class);
      my $qv = FALSE;
  
      if ( $#_ == 1 ) { # must be CVS-style
  	$qv = TRUE;
      }
      my $value = pop; # always going to be the last element
  
      if ( ref($value) && eval('$value->isa("version")') ) {
  	# Can copy the elements directly
  	$self->{version} = [ @{$value->{version} } ];
  	$self->{qv} = 1 if $value->{qv};
  	$self->{alpha} = 1 if $value->{alpha};
  	$self->{original} = ''.$value->{original};
  	return $self;
      }
  
      if ( not defined $value or $value =~ /^undef$/ ) {
  	# RT #19517 - special case for undef comparison
  	# or someone forgot to pass a value
  	push @{$self->{version}}, 0;
  	$self->{original} = "0";
  	return ($self);
      }
  
  
      if (ref($value) =~ m/ARRAY|HASH/) {
  	require Carp;
  	Carp::croak("Invalid version format (non-numeric data)");
      }
  
      $value = _un_vstring($value);
  
      if ($Config{d_setlocale} && eval { require POSIX } ) {
        require locale;
  	my $currlocale = POSIX::setlocale(&POSIX::LC_ALL);
  
  	# if the current locale uses commas for decimal points, we
  	# just replace commas with decimal places, rather than changing
  	# locales
  	if ( POSIX::localeconv()->{decimal_point} eq ',' ) {
  	    $value =~ tr/,/./;
  	}
      }
  
      # exponential notation
      if ( $value =~ /\d+.?\d*e[-+]?\d+/ ) {
  	$value = sprintf("%.9f",$value);
  	$value =~ s/(0+)$//; # trim trailing zeros
      }
  
      my $s = scan_version($value, \$self, $qv);
  
      if ($s) { # must be something left over
  	warn("Version string '%s' contains invalid data; "
  		   ."ignoring: '%s'", $value, $s);
      }
  
      return ($self);
  }
  
  *parse = \&new;
  
  sub numify {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      my $width = $self->{width} || 3;
      my $alpha = $self->{alpha} || "";
      my $len = $#{$self->{version}};
      my $digit = $self->{version}[0];
      my $string = sprintf("%d.", $digit );
  
      for ( my $i = 1 ; $i < $len ; $i++ ) {
  	$digit = $self->{version}[$i];
  	if ( $width < 3 ) {
  	    my $denom = 10**(3-$width);
  	    my $quot = int($digit/$denom);
  	    my $rem = $digit - ($quot * $denom);
  	    $string .= sprintf("%0".$width."d_%d", $quot, $rem);
  	}
  	else {
  	    $string .= sprintf("%03d", $digit);
  	}
      }
  
      if ( $len > 0 ) {
  	$digit = $self->{version}[$len];
  	if ( $alpha && $width == 3 ) {
  	    $string .= "_";
  	}
  	$string .= sprintf("%0".$width."d", $digit);
      }
      else # $len = 0
      {
  	$string .= sprintf("000");
      }
  
      return $string;
  }
  
  sub normal {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      my $alpha = $self->{alpha} || "";
      my $len = $#{$self->{version}};
      my $digit = $self->{version}[0];
      my $string = sprintf("v%d", $digit );
  
      for ( my $i = 1 ; $i < $len ; $i++ ) {
  	$digit = $self->{version}[$i];
  	$string .= sprintf(".%d", $digit);
      }
  
      if ( $len > 0 ) {
  	$digit = $self->{version}[$len];
  	if ( $alpha ) {
  	    $string .= sprintf("_%0d", $digit);
  	}
  	else {
  	    $string .= sprintf(".%0d", $digit);
  	}
      }
  
      if ( $len <= 2 ) {
  	for ( $len = 2 - $len; $len != 0; $len-- ) {
  	    $string .= sprintf(".%0d", 0);
  	}
      }
  
      return $string;
  }
  
  sub stringify {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      return exists $self->{original}
      	? $self->{original}
  	: exists $self->{qv}
  	    ? $self->normal
  	    : $self->numify;
  }
  
  sub vcmp {
      require UNIVERSAL;
      my ($left,$right,$swap) = @_;
      my $class = ref($left);
      unless ( UNIVERSAL::isa($right, $class) ) {
  	$right = $class->new($right);
      }
  
      if ( $swap ) {
  	($left, $right) = ($right, $left);
      }
      unless (_verify($left)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      unless (_verify($right)) {
  	require Carp;
  	Carp::croak("Invalid version format");
      }
      my $l = $#{$left->{version}};
      my $r = $#{$right->{version}};
      my $m = $l < $r ? $l : $r;
      my $lalpha = $left->is_alpha;
      my $ralpha = $right->is_alpha;
      my $retval = 0;
      my $i = 0;
      while ( $i <= $m && $retval == 0 ) {
  	$retval = $left->{version}[$i] <=> $right->{version}[$i];
  	$i++;
      }
  
      # tiebreaker for alpha with identical terms
      if ( $retval == 0
  	&& $l == $r
  	&& $left->{version}[$m] == $right->{version}[$m]
  	&& ( $lalpha || $ralpha ) ) {
  
  	if ( $lalpha && !$ralpha ) {
  	    $retval = -1;
  	}
  	elsif ( $ralpha && !$lalpha) {
  	    $retval = +1;
  	}
      }
  
      # possible match except for trailing 0's
      if ( $retval == 0 && $l != $r ) {
  	if ( $l < $r ) {
  	    while ( $i <= $r && $retval == 0 ) {
  		if ( $right->{version}[$i] != 0 ) {
  		    $retval = -1; # not a match after all
  		}
  		$i++;
  	    }
  	}
  	else {
  	    while ( $i <= $l && $retval == 0 ) {
  		if ( $left->{version}[$i] != 0 ) {
  		    $retval = +1; # not a match after all
  		}
  		$i++;
  	    }
  	}
      }
  
      return $retval;
  }
  
  sub vbool {
      my ($self) = @_;
      return vcmp($self,$self->new("0"),1);
  }
  
  sub vnoop {
      require Carp;
      Carp::croak("operation not supported with version object");
  }
  
  sub is_alpha {
      my ($self) = @_;
      return (exists $self->{alpha});
  }
  
  sub qv {
      my $value = shift;
      my $class = $CLASS;
      if (@_) {
  	$class = ref($value) || $value;
  	$value = shift;
      }
  
      $value = _un_vstring($value);
      $value = 'v'.$value unless $value =~ /(^v|\d+\.\d+\.\d)/;
      my $obj = $CLASS->new($value);
      return bless $obj, $class;
  }
  
  *declare = \&qv;
  
  sub is_qv {
      my ($self) = @_;
      return (exists $self->{qv});
  }
  
  
  sub _verify {
      my ($self) = @_;
      if ( ref($self)
  	&& eval { exists $self->{version} }
  	&& ref($self->{version}) eq 'ARRAY'
  	) {
  	return 1;
      }
      else {
  	return 0;
      }
  }
  
  sub _is_non_alphanumeric {
      my $s = shift;
      $s = new ExtUtils::MakeMaker::charstar $s;
      while ($s) {
  	return 0 if isSPACE($s); # early out
  	return 1 unless (isALPHA($s) || isDIGIT($s) || $s =~ /[.-]/);
  	$s++;
      }
      return 0;
  }
  
  sub _un_vstring {
      my $value = shift;
      # may be a v-string
      if ( length($value) >= 3 && $value !~ /[._]/
  	&& _is_non_alphanumeric($value)) {
  	my $tvalue;
  	if ( $] ge 5.008_001 ) {
  	    $tvalue = _find_magic_vstring($value);
  	    $value = $tvalue if length $tvalue;
  	}
  	elsif ( $] ge 5.006_000 ) {
  	    $tvalue = sprintf("v%vd",$value);
  	    if ( $tvalue =~ /^v\d+(\.\d+){2,}$/ ) {
  		# must be a v-string
  		$value = $tvalue;
  	    }
  	}
      }
      return $value;
  }
  
  sub _find_magic_vstring {
      my $value = shift;
      my $tvalue = '';
      require B;
      my $sv = B::svref_2object(\$value);
      my $magic = ref($sv) eq 'B::PVMG' ? $sv->MAGIC : undef;
      while ( $magic ) {
  	if ( $magic->TYPE eq 'V' ) {
  	    $tvalue = $magic->PTR;
  	    $tvalue =~ s/^v?(.+)$/v$1/;
  	    last;
  	}
  	else {
  	    $magic = $magic->MOREMAGIC;
  	}
      }
      return $tvalue;
  }
  
  sub _VERSION {
      my ($obj, $req) = @_;
      my $class = ref($obj) || $obj;
  
      no strict 'refs';
      if ( exists $INC{"$class.pm"} and not %{"$class\::"} and $] >= 5.008) {
  	 # file but no package
  	require Carp;
  	Carp::croak( "$class defines neither package nor VERSION"
  	    ."--version check failed");
      }
  
      my $version = eval "\$$class\::VERSION";
      if ( defined $version ) {
  	local $^W if $] <= 5.008;
  	$version = ExtUtils::MakeMaker::version::vpp->new($version);
      }
  
      if ( defined $req ) {
  	unless ( defined $version ) {
  	    require Carp;
  	    my $msg =  $] < 5.006
  	    ? "$class version $req required--this is only version "
  	    : "$class does not define \$$class\::VERSION"
  	      ."--version check failed";
  
  	    if ( $ENV{VERSION_DEBUG} ) {
  		Carp::confess($msg);
  	    }
  	    else {
  		Carp::croak($msg);
  	    }
  	}
  
  	$req = ExtUtils::MakeMaker::version::vpp->new($req);
  
  	if ( $req > $version ) {
  	    require Carp;
  	    if ( $req->is_qv ) {
  		Carp::croak(
  		    sprintf ("%s version %s required--".
  			"this is only version %s", $class,
  			$req->normal, $version->normal)
  		);
  	    }
  	    else {
  		Carp::croak(
  		    sprintf ("%s version %s required--".
  			"this is only version %s", $class,
  			$req->stringify, $version->stringify)
  		);
  	    }
  	}
      }
  
      return defined $version ? $version->stringify : undef;
  }
  
  1; #this line is important and will help the module return a true value
PERL5_EXTUTILS_MAKEMAKER_VERSION_VPP

$fatpacked{"perl5/ExtUtils/Mkbootstrap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_EXTUTILS_MKBOOTSTRAP';
  package ExtUtils::Mkbootstrap;
  
  # There's just too much Dynaloader incest here to turn on strict vars.
  use strict 'refs';
  
  our $VERSION = '7.10';
  
  require Exporter;
  our @ISA = ('Exporter');
  our @EXPORT = ('&Mkbootstrap');
  
  use Config;
  
  our $Verbose = 0;
  
  
  sub Mkbootstrap {
      my($baseext, @bsloadlibs)=@_;
      @bsloadlibs = grep($_, @bsloadlibs); # strip empty libs
  
      print "	bsloadlibs=@bsloadlibs\n" if $Verbose;
  
      # We need DynaLoader here because we and/or the *_BS file may
      # call dl_findfile(). We don't say `use' here because when
      # first building perl extensions the DynaLoader will not have
      # been built when MakeMaker gets first used.
      require DynaLoader;
  
      rename "$baseext.bs", "$baseext.bso"
        if -s "$baseext.bs";
  
      if (-f "${baseext}_BS"){
  	$_ = "${baseext}_BS";
  	package DynaLoader; # execute code as if in DynaLoader
  	local($osname, $dlsrc) = (); # avoid warnings
  	($osname, $dlsrc) = @Config::Config{qw(osname dlsrc)};
  	$bscode = "";
  	unshift @INC, ".";
  	require $_;
  	shift @INC;
      }
  
      if ($Config{'dlsrc'} =~ /^dl_dld/){
  	package DynaLoader;
  	push(@dl_resolve_using, dl_findfile('-lc'));
      }
  
      my(@all) = (@bsloadlibs, @DynaLoader::dl_resolve_using);
      my($method) = '';
      if (@all){
  	open my $bs, ">", "$baseext.bs"
  		or die "Unable to open $baseext.bs: $!";
  	print "Writing $baseext.bs\n";
  	print "	containing: @all" if $Verbose;
  	print $bs "# $baseext DynaLoader bootstrap file for $^O architecture.\n";
  	print $bs "# Do not edit this file, changes will be lost.\n";
  	print $bs "# This file was automatically generated by the\n";
  	print $bs "# Mkbootstrap routine in ExtUtils::Mkbootstrap (v$VERSION).\n";
  	print $bs "\@DynaLoader::dl_resolve_using = ";
  	# If @all contains names in the form -lxxx or -Lxxx then it's asking for
  	# runtime library location so we automatically add a call to dl_findfile()
  	if (" @all" =~ m/ -[lLR]/){
  	    print $bs "  dl_findfile(qw(\n  @all\n  ));\n";
  	}else{
  	    print $bs "  qw(@all);\n";
  	}
  	# write extra code if *_BS says so
  	print $bs $DynaLoader::bscode if $DynaLoader::bscode;
  	print $bs "\n1;\n";
  	close $bs;
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  ExtUtils::Mkbootstrap - make a bootstrap file for use by DynaLoader
  
  =head1 SYNOPSIS
  
  C<Mkbootstrap>
  
  =head1 DESCRIPTION
  
  Mkbootstrap typically gets called from an extension Makefile.
  
  There is no C<*.bs> file supplied with the extension. Instead, there may
  be a C<*_BS> file which has code for the special cases, like posix for
  berkeley db on the NeXT.
  
  This file will get parsed, and produce a maybe empty
  C<@DynaLoader::dl_resolve_using> array for the current architecture.
  That will be extended by $BSLOADLIBS, which was computed by
  ExtUtils::Liblist::ext(). If this array still is empty, we do nothing,
  else we write a .bs file with an C<@DynaLoader::dl_resolve_using>
  array.
  
  The C<*_BS> file can put some code into the generated C<*.bs> file by
  placing it in C<$bscode>. This is a handy 'escape' mechanism that may
  prove useful in complex situations.
  
  If @DynaLoader::dl_resolve_using contains C<-L*> or C<-l*> entries then
  Mkbootstrap will automatically add a dl_findfile() call to the
  generated C<*.bs> file.
  
  =cut
PERL5_EXTUTILS_MKBOOTSTRAP

$fatpacked{"perl5/ExtUtils/Mksymlists.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_EXTUTILS_MKSYMLISTS';
  package ExtUtils::Mksymlists;
  
  use 5.006;
  use strict qw[ subs refs ];
  # no strict 'vars';  # until filehandles are exempted
  
  use Carp;
  use Exporter;
  use Config;
  
  our @ISA = qw(Exporter);
  our @EXPORT = qw(&Mksymlists);
  our $VERSION = '7.10';
  
  sub Mksymlists {
      my(%spec) = @_;
      my($osname) = $^O;
  
      croak("Insufficient information specified to Mksymlists")
          unless ( $spec{NAME} or
                   ($spec{FILE} and ($spec{DL_FUNCS} or $spec{FUNCLIST})) );
  
      $spec{DL_VARS} = [] unless $spec{DL_VARS};
      ($spec{FILE} = $spec{NAME}) =~ s/.*::// unless $spec{FILE};
      $spec{FUNCLIST} = [] unless $spec{FUNCLIST};
      $spec{DL_FUNCS} = { $spec{NAME} => [] }
          unless ( ($spec{DL_FUNCS} and keys %{$spec{DL_FUNCS}}) or
                   @{$spec{FUNCLIST}});
      if (defined $spec{DL_FUNCS}) {
          foreach my $package (sort keys %{$spec{DL_FUNCS}}) {
              my($packprefix,$bootseen);
              ($packprefix = $package) =~ s/\W/_/g;
              foreach my $sym (@{$spec{DL_FUNCS}->{$package}}) {
                  if ($sym =~ /^boot_/) {
                      push(@{$spec{FUNCLIST}},$sym);
                      $bootseen++;
                  }
                  else {
                      push(@{$spec{FUNCLIST}},"XS_${packprefix}_$sym");
                  }
              }
              push(@{$spec{FUNCLIST}},"boot_$packprefix") unless $bootseen;
          }
      }
  
  #    We'll need this if we ever add any OS which uses mod2fname
  #    not as pseudo-builtin.
  #    require DynaLoader;
      if (defined &DynaLoader::mod2fname and not $spec{DLBASE}) {
          $spec{DLBASE} = DynaLoader::mod2fname([ split(/::/,$spec{NAME}) ]);
      }
  
      if    ($osname eq 'aix') { _write_aix(\%spec); }
      elsif ($osname eq 'MacOS'){ _write_aix(\%spec) }
      elsif ($osname eq 'VMS') { _write_vms(\%spec) }
      elsif ($osname eq 'os2') { _write_os2(\%spec) }
      elsif ($osname eq 'MSWin32') { _write_win32(\%spec) }
      else {
          croak("Don't know how to create linker option file for $osname\n");
      }
  }
  
  
  sub _write_aix {
      my($data) = @_;
  
      rename "$data->{FILE}.exp", "$data->{FILE}.exp_old";
  
      open( my $exp, ">", "$data->{FILE}.exp")
          or croak("Can't create $data->{FILE}.exp: $!\n");
      print $exp join("\n",@{$data->{DL_VARS}}, "\n") if @{$data->{DL_VARS}};
      print $exp join("\n",@{$data->{FUNCLIST}}, "\n") if @{$data->{FUNCLIST}};
      close $exp;
  }
  
  
  sub _write_os2 {
      my($data) = @_;
      require Config;
      my $threaded = ($Config::Config{archname} =~ /-thread/ ? " threaded" : "");
  
      if (not $data->{DLBASE}) {
          ($data->{DLBASE} = $data->{NAME}) =~ s/.*:://;
          $data->{DLBASE} = substr($data->{DLBASE},0,7) . '_';
      }
      my $distname = $data->{DISTNAME} || $data->{NAME};
      $distname = "Distribution $distname";
      my $patchlevel = " pl$Config{perl_patchlevel}" || '';
      my $comment = sprintf "Perl (v%s%s%s) module %s",
        $Config::Config{version}, $threaded, $patchlevel, $data->{NAME};
      chomp $comment;
      if ($data->{INSTALLDIRS} and $data->{INSTALLDIRS} eq 'perl') {
          $distname = 'perl5-porters@perl.org';
          $comment = "Core $comment";
      }
      $comment = "$comment (Perl-config: $Config{config_args})";
      $comment = substr($comment, 0, 200) . "...)" if length $comment > 203;
      rename "$data->{FILE}.def", "$data->{FILE}_def.old";
  
      open(my $def, ">", "$data->{FILE}.def")
          or croak("Can't create $data->{FILE}.def: $!\n");
      print $def "LIBRARY '$data->{DLBASE}' INITINSTANCE TERMINSTANCE\n";
      print $def "DESCRIPTION '\@#$distname:$data->{VERSION}#\@ $comment'\n";
      print $def "CODE LOADONCALL\n";
      print $def "DATA LOADONCALL NONSHARED MULTIPLE\n";
      print $def "EXPORTS\n  ";
      print $def join("\n  ",@{$data->{DL_VARS}}, "\n") if @{$data->{DL_VARS}};
      print $def join("\n  ",@{$data->{FUNCLIST}}, "\n") if @{$data->{FUNCLIST}};
      _print_imports($def, $data);
      close $def;
  }
  
  sub _print_imports {
      my ($def, $data)= @_;
      my $imports= $data->{IMPORTS}
          or return;
      if ( keys %$imports ) {
          print $def "IMPORTS\n";
          foreach my $name (sort keys %$imports) {
              print $def "  $name=$imports->{$name}\n";
          }
      }
  }
  
  sub _write_win32 {
      my($data) = @_;
  
      require Config;
      if (not $data->{DLBASE}) {
          ($data->{DLBASE} = $data->{NAME}) =~ s/.*:://;
          $data->{DLBASE} = substr($data->{DLBASE},0,7) . '_';
      }
      rename "$data->{FILE}.def", "$data->{FILE}_def.old";
  
      open( my $def, ">", "$data->{FILE}.def" )
          or croak("Can't create $data->{FILE}.def: $!\n");
      # put library name in quotes (it could be a keyword, like 'Alias')
      if ($Config::Config{'cc'} !~ /^gcc/i) {
          print $def "LIBRARY \"$data->{DLBASE}\"\n";
      }
      print $def "EXPORTS\n  ";
      my @syms;
      # Export public symbols both with and without underscores to
      # ensure compatibility between DLLs from Borland C and Visual C
      # NOTE: DynaLoader itself only uses the names without underscores,
      # so this is only to cover the case when the extension DLL may be
      # linked to directly from C. GSAR 97-07-10
  
      #bcc dropped in 5.16, so dont create useless extra symbols for export table
      unless($] >= 5.016) {
          if ($Config::Config{'cc'} =~ /^bcc/i) {
              push @syms, "_$_", "$_ = _$_"
                  for (@{$data->{DL_VARS}}, @{$data->{FUNCLIST}});
          }
          else {
              push @syms, "$_", "_$_ = $_"
                  for (@{$data->{DL_VARS}}, @{$data->{FUNCLIST}});
          }
      } else {
          push @syms, "$_"
              for (@{$data->{DL_VARS}}, @{$data->{FUNCLIST}});
      }
      print $def join("\n  ",@syms, "\n") if @syms;
      _print_imports($def, $data);
      close $def;
  }
  
  
  sub _write_vms {
      my($data) = @_;
  
      require Config; # a reminder for once we do $^O
      require ExtUtils::XSSymSet;
  
      my($isvax) = $Config::Config{'archname'} =~ /VAX/i;
      my($set) = new ExtUtils::XSSymSet;
  
      rename "$data->{FILE}.opt", "$data->{FILE}.opt_old";
  
      open(my $opt,">", "$data->{FILE}.opt")
          or croak("Can't create $data->{FILE}.opt: $!\n");
  
      # Options file declaring universal symbols
      # Used when linking shareable image for dynamic extension,
      # or when linking PerlShr into which we've added this package
      # as a static extension
      # We don't do anything to preserve order, so we won't relax
      # the GSMATCH criteria for a dynamic extension
  
      print $opt "case_sensitive=yes\n"
          if $Config::Config{d_vms_case_sensitive_symbols};
  
      foreach my $sym (@{$data->{FUNCLIST}}) {
          my $safe = $set->addsym($sym);
          if ($isvax) { print $opt "UNIVERSAL=$safe\n" }
          else        { print $opt "SYMBOL_VECTOR=($safe=PROCEDURE)\n"; }
      }
  
      foreach my $sym (@{$data->{DL_VARS}}) {
          my $safe = $set->addsym($sym);
          print $opt "PSECT_ATTR=${sym},PIC,OVR,RD,NOEXE,WRT,NOSHR\n";
          if ($isvax) { print $opt "UNIVERSAL=$safe\n" }
          else        { print $opt "SYMBOL_VECTOR=($safe=DATA)\n"; }
      }
  
      close $opt;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  ExtUtils::Mksymlists - write linker options files for dynamic extension
  
  =head1 SYNOPSIS
  
      use ExtUtils::Mksymlists;
      Mksymlists(  NAME     => $name ,
                   DL_VARS  => [ $var1, $var2, $var3 ],
                   DL_FUNCS => { $pkg1 => [ $func1, $func2 ],
                                 $pkg2 => [ $func3 ] );
  
  =head1 DESCRIPTION
  
  C<ExtUtils::Mksymlists> produces files used by the linker under some OSs
  during the creation of shared libraries for dynamic extensions.  It is
  normally called from a MakeMaker-generated Makefile when the extension
  is built.  The linker option file is generated by calling the function
  C<Mksymlists>, which is exported by default from C<ExtUtils::Mksymlists>.
  It takes one argument, a list of key-value pairs, in which the following
  keys are recognized:
  
  =over 4
  
  =item DLBASE
  
  This item specifies the name by which the linker knows the
  extension, which may be different from the name of the
  extension itself (for instance, some linkers add an '_' to the
  name of the extension).  If it is not specified, it is derived
  from the NAME attribute.  It is presently used only by OS2 and Win32.
  
  =item DL_FUNCS
  
  This is identical to the DL_FUNCS attribute available via MakeMaker,
  from which it is usually taken.  Its value is a reference to an
  associative array, in which each key is the name of a package, and
  each value is an a reference to an array of function names which
  should be exported by the extension.  For instance, one might say
  C<DL_FUNCS =E<gt> { Homer::Iliad =E<gt> [ qw(trojans greeks) ],
  Homer::Odyssey =E<gt> [ qw(travellers family suitors) ] }>.  The
  function names should be identical to those in the XSUB code;
  C<Mksymlists> will alter the names written to the linker option
  file to match the changes made by F<xsubpp>.  In addition, if
  none of the functions in a list begin with the string B<boot_>,
  C<Mksymlists> will add a bootstrap function for that package,
  just as xsubpp does.  (If a B<boot_E<lt>pkgE<gt>> function is
  present in the list, it is passed through unchanged.)  If
  DL_FUNCS is not specified, it defaults to the bootstrap
  function for the extension specified in NAME.
  
  =item DL_VARS
  
  This is identical to the DL_VARS attribute available via MakeMaker,
  and, like DL_FUNCS, it is usually specified via MakeMaker.  Its
  value is a reference to an array of variable names which should
  be exported by the extension.
  
  =item FILE
  
  This key can be used to specify the name of the linker option file
  (minus the OS-specific extension), if for some reason you do not
  want to use the default value, which is the last word of the NAME
  attribute (I<e.g.> for C<Tk::Canvas>, FILE defaults to C<Canvas>).
  
  =item FUNCLIST
  
  This provides an alternate means to specify function names to be
  exported from the extension.  Its value is a reference to an
  array of function names to be exported by the extension.  These
  names are passed through unaltered to the linker options file.
  Specifying a value for the FUNCLIST attribute suppresses automatic
  generation of the bootstrap function for the package. To still create
  the bootstrap name you have to specify the package name in the
  DL_FUNCS hash:
  
      Mksymlists(  NAME     => $name ,
  		 FUNCLIST => [ $func1, $func2 ],
                   DL_FUNCS => { $pkg => [] } );
  
  
  =item IMPORTS
  
  This attribute is used to specify names to be imported into the
  extension. It is currently only used by OS/2 and Win32.
  
  =item NAME
  
  This gives the name of the extension (I<e.g.> C<Tk::Canvas>) for which
  the linker option file will be produced.
  
  =back
  
  When calling C<Mksymlists>, one should always specify the NAME
  attribute.  In most cases, this is all that's necessary.  In
  the case of unusual extensions, however, the other attributes
  can be used to provide additional information to the linker.
  
  =head1 AUTHOR
  
  Charles Bailey I<E<lt>bailey@newman.upenn.eduE<gt>>
  
  =head1 REVISION
  
  Last revised 14-Feb-1996, for Perl 5.002.
PERL5_EXTUTILS_MKSYMLISTS

$fatpacked{"perl5/ExtUtils/testlib.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_EXTUTILS_TESTLIB';
  package ExtUtils::testlib;
  
  use strict;
  use warnings;
  
  our $VERSION = '7.10';
  
  use Cwd;
  use File::Spec;
  
  # So the tests can chdir around and not break @INC.
  # We use getcwd() because otherwise rel2abs will blow up under taint
  # mode pre-5.8.  We detaint is so @INC won't be tainted.  This is
  # no worse, and probably better, than just shoving an untainted,
  # relative "blib/lib" onto @INC.
  my $cwd;
  BEGIN {
      ($cwd) = getcwd() =~ /(.*)/;
  }
  use lib map { File::Spec->rel2abs($_, $cwd) } qw(blib/arch blib/lib);
  1;
  __END__
  
  =head1 NAME
  
  ExtUtils::testlib - add blib/* directories to @INC
  
  =head1 SYNOPSIS
  
    use ExtUtils::testlib;
  
  =head1 DESCRIPTION
  
  After an extension has been built and before it is installed it may be
  desirable to test it bypassing C<make test>. By adding
  
      use ExtUtils::testlib;
  
  to a test program the intermediate directories used by C<make> are
  added to @INC.
  
PERL5_EXTUTILS_TESTLIB

$fatpacked{"perl5/File/Nonblock.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_FILE_NONBLOCK';
  package File::Nonblock;
  
  use strict;
  use warnings;
  
  use vars qw/$VERSION/;
  $VERSION = '2016021901';
  
  use English qw( -no_match_vars );
  use Scalar::Util qw(openhandle);
  use IPC::Open2 qw( open2 );
  use IO::Select qw();
  use Symbol qw(gensym);
  use File::Which qw ( which );
  
  my $lines_per_read = 100;
  my $read_timeout = 0;
  my $read_buffer_size = 8*1024;
  my $MIN_COMPRESS_RATIO = 0.94;
  my $gzip = which('gzip');
  my $buffer = {};
  my $open_files = {};
  my $open_handles = {};
  my $last_incomplete_line = {};
  my $complete_lines = {};
  
  sub update_map {
      my @descriptors = qw(
          pid eof size real_size progress_frac
          prev_progress progress progress_state
          ratio selector read_buffer_size
          bytes_read );
      undef $open_handles;
  
      for my $file_name ( keys %{ $open_files } ) {
          my $handle = $open_files->{$file_name}{'handle'};
          $open_handles->{$handle}{'name'} = $file_name;
  
          for my $descriptor (@descriptors) {
              $open_handles->{$handle}{$descriptor} = \$open_files->{$file_name}{$descriptor};
          }
      }
  
      return 1;
  }
  
  sub name {
      my ($file) = @_;
      return $file if ( not ref $file );
      return undef if not ( ref $file eq 'GLOB' );
      return $open_handles->{$file}{'name'} if exists $open_handles->{$file}{'name'};
      return readlink "/proc/$$/fd/" . fileno($file) if openhandle($file);
      return undef;
  }
  
  sub open {
      my ($file, $buf_sz) = @_;
      $buf_sz ||= $read_buffer_size;
      die "No file specified" if not $file;
  
      my $handle = gensym;
      my $file_name = '';
  
      if ( not ref $file ) {
  
          return undef if exists $open_files->{$file};
          die "File $file does not exist" if (! -f $file);
  
          $file_name = $file;
  
          if ( $file =~ m/\.(gz)$/ ) {
  
              my ($u_size, $c_size, $ratio) = (0, 0);
  
              my $child_pid = open my $child, '-|';
              defined $child_pid or die "Can't fork: $!";
  
              if ( $child_pid ) {
                  ($c_size, $u_size, $ratio) = ( split " ", (<$child>)[1] )[0..2];
                  $ratio = ($ratio =~ s/%$//) / 100;
                  close $child;
              }
              else {
                  ($EUID, $EGID) = ($UID, $GID);
                  exec $gzip, '--list', $file or die "Could not exec $gzip: $!";
              }
  
              while ( $ratio < $MIN_COMPRESS_RATIO ) {
                  $u_size *= 2;
                  $ratio = 1 - ( $c_size / $u_size );
              }
  
  
              $open_files->{$file_name}{'real_size'} = $u_size;
              $open_files->{$file_name}{'size'} = $c_size;
              $open_files->{$file_name}{'ratio'} = $ratio;
  
              $open_files->{$file_name}{'pid'} = open2($handle, undef, $gzip, '-dc', $file)
                  or die "Could not fork $gzip: $!";
          }
          else {
              open $handle, '<', $file_name;
              $open_files->{$file_name}{'pid'} = 0;
              $open_files->{$file_name}{'real_size'} = (stat($file))[7];
              $open_files->{$file_name}{'size'} = $open_files->{$file_name}{'real_size'};
              $open_files->{$file_name}{'ratio'} = 0;
          }
      }
      elsif ( ref $file eq 'GLOB' ) {
  
          die "Passed a closed file handle" if ( !openhandle($file) );
  
          $file_name = name($file);
          $handle = $file;
          $open_files->{$file_name}{'pid'} = 0;
          $open_files->{$file_name}{'real_size'} = (stat($file))[7];
          $open_files->{$file_name}{'size'} = $open_files->{$file_name}{'real_size'};
          $open_files->{$file_name}{'ratio'} = 0;
  
          return undef if exists $open_files->{$file_name};
      }
      else {
          die "Unknown argument";
      }
  
      $open_files->{$file_name}{'selector'} = IO::Select->new();
      $open_files->{$file_name}{'selector'}->add($handle);
  
      $open_files->{$file_name}{'handle'} = $handle;
      $open_files->{$file_name}{'bytes_read'} = 0;
      $open_files->{$file_name}{'progress'} = 0;
      $open_files->{$file_name}{'prev_progress'} = 0;
      $open_files->{$file_name}{'progress_frac'} = 0;
      $open_files->{$file_name}{'progress_state'} = 'Reading';
      $open_files->{$file_name}{'eof'} = 0;
  
      @{ $open_files->{$file_name}{'stat'} } = stat($handle);
  
      $open_files->{$file_name}{'read_buffer_size'} = $buf_sz;
      $buffer->{$file_name} = '';
      vec($buffer->{$file_name}, $buf_sz, 8) = 0;
      $buffer->{$file_name} = '';
  
      update_map();
  
      return $read_timeout > 0 ? ( $open_files->{$file_name}{'selector'}->can_read($read_timeout) )[0]
                               : ( $open_files->{$file_name}{'selector'}->can_read )[0];
  }
  
  sub stat {
      my ($file) = @_;
      return undef if not $file;
  
      my $file_name;
  
      if ( not ref $file ) {
          return undef unless exists $open_files->{$file};
          return stat($file) if ( -r $file );
      }
      elsif ( ref $file eq 'GLOB' ) {
          return undef unless exists $open_handles->{$file};
  
          $file_name = name($file);
          return undef if not $file_name;
  
          if ( $open_files->{$file_name}{'pid'} != 0 ) {
              return @{ $open_files->{$file_name}{'stat'} };
          }
  
          return (stat($file_name))[7] if ( -r $file_name );
      }
      else {
          die "Unknown argument";
      }
  
      return undef;
  }
  
  sub update_size {
      my ($file) = @_;
      return undef if not $file;
  
      my $file_name = '';
  
      if ( not ref $file ) {
          return undef if not exists $open_files->{$file};
          return undef if not openhandle($open_files->{$file}{'handle'});
          $file_name = $file;
   
      }
      elsif ( ref $file eq 'GLOB' ) {
          return undef if not exists $open_handles->{$file};
          return undef if not openhandle($file);
          $file_name = name($file);
      }
      else {
          die "Unknown argument";
      }
  
      my $ref = $open_files->{$file_name};
  
      $ref->{'real_size'} = $ref->{'bytes_read'} if ( $ref->{'eof'} );
      $ref->{'real_size'} *= 2 if ( $ref->{'bytes_read'} > $ref->{'real_size'} );
  
      $ref->{'ratio'} = 1 - ( $ref->{'real_size'} / $ref->{'size'} );
  
      1;
  }
  
  sub tell {
      my ($file) = @_;
      return undef if not $file;
  
      my $file_name;
  
      if ( not ref $file ) {
          return undef if not exists $open_files->{$file};
          return undef if not openhandle($open_files->{$file}{'handle'});
          $file_name = $file;
      }
      elsif ( ref $file eq 'GLOB' ) {
          return undef if not exists $open_handles->{$file};
          return undef if not openhandle($file);
          $file_name = name($file);
      }
      else {
          die "Unknown argument";
      }
  
      my $ref = $open_files->{$file_name};
      my $bytes_read = $ref->{'pid'} == 0 ? tell($ref->{'handle'})
                                          : $ref->{'bytes_read'};
  
      update_size($file) if ( $ref->{'pid'} != 0 );
  
      return $bytes_read;
  }
  
  sub eof {
      my ($file) = @_;
      return undef if not $file;
  
      my $file_name;
  
      if ( not ref $file ) {
          $file_name = $file if exists $open_files->{$file};
          return undef if not openhandle($open_files->{$file}{'handle'});
      }
      elsif ( ref $file eq 'GLOB' ) {
          $file_name = name($file);
          return undef if not $file_name;
          return undef if not openhandle($file);
      }
      else {
          die "Unknown argument";
      }
  
      return $open_files->{$file_name}{'eof'};
  }
  
  sub size {
      my ($file) = @_;
      return undef if not $file;
  
      my $file_name;
  
      if ( not ref $file ) {
          return undef unless exists $open_files->{$file};
          return (CORE::stat($file))[7] if ( -r $file );
      }
      elsif ( ref $file eq 'GLOB' ) {
          return undef unless exists $open_handles->{$file};
  
          $file_name = name($file);
          return undef if not $file_name;
  
          if ( $open_files->{$file_name}{'pid'} != 0 ) {
              update_size($file);
              return $open_files->{$file_name}{'real_size'};
          }
  
          return (CORE::stat($file_name))[7] if ( -r $file_name );
      }
      else {
          die "Unknown argument";
      }
  
      return undef;
  }
  
  sub progress {
      my ($file) = @_;
      return undef if not $file;
  
      my $file_name;
  
      if ( not ref $file ) {
          return undef unless exists $open_files->{$file};
          $file_name = $file;
      }
      elsif ( ref $file eq 'GLOB' ) {
          return undef unless exists $open_handles->{$file};
  
          $file_name = name($file);
          return undef if not $file_name;
      }
      else {
          die "Unknown argument";
      }
  
      my $ref = $open_files->{$file_name};
  
      update_size($file) if ( $ref->{'pid'} != 0 );
  
      my $progress = $ref->{'eof'} ? 1
                                   : $ref->{'bytes_read'} / $ref->{'real_size'};
  
      $open_files->{$file_name}{'progress'} = $progress if ( $progress > $ref->{'progress'} );
  
      return $ref->{'progress'};
  }
  
  sub new_progress {
      my ($file, $threshold) = @_;
      return undef if not $file;
  
      $threshold ||= 1;
  
      my $file_name;
  
      if ( not ref $file ) {
          return undef unless exists $open_files->{$file};
          $file_name = $file;
      }
      elsif ( ref $file eq 'GLOB' ) {
          return undef unless exists $open_handles->{$file};
  
          $file_name = name($file);
          return undef if not $file_name;
      }
      else {
          die "Unknown argument";
      }
  
      my $ref = $open_files->{$file_name};
      my $change = (progress($file) - $open_files->{$file_name}{'prev_progress'}) * 100;
      my $new_change = 0;
  
      if ( $change > $threshold ) {
  
          $open_files->{$file_name}{'prev_progress'} = progress($file);
  
          my ( $frac, $whole ) = POSIX::modf($change);
          $open_files->{$file_name}{'progress_frac'} += $frac;
          $new_change = $whole;
          ( $frac, $whole ) = POSIX::modf($open_files->{$file_name}{'progress_frac'});
          $open_files->{$file_name}{'progress_frac'} = $frac;
          $new_change += $whole;
      }
  
      return $new_change;
  }
  
  sub set_progress_state {
      my ($file, $text) = @_;
      return undef if ( not $file or not defined $text );
  
      my $file_name;
  
      if ( not ref $file ) {
          return undef unless exists $open_files->{$file};
          $file_name = $file;
      }
      elsif ( ref $file eq 'GLOB' ) {
          return undef unless exists $open_handles->{$file};
  
          $file_name = name($file);
          return undef if not $file_name;
      }
      else {
          die "Unknown argument";
      }
  
      $open_files->{$file_name}{'progress_state'} = $text;
  
      return $text;
  }
  
  sub progress_state {
      my ($file) = @_;
      return undef if not $file;
  
      my $file_name;
  
      if ( not ref $file ) {
          return undef unless exists $open_files->{$file};
          $file_name = $file;
      }
      elsif ( ref $file eq 'GLOB' ) {
          return undef unless exists $open_handles->{$file};
  
          $file_name = name($file);
          return undef if not $file_name;
      }
      else {
          die "Unknown argument";
      }
  
      return $open_files->{$file_name}{'progress_state'};
  
  }
  
  sub read_buffer {
      my ($file, $timeout) = @_;
      return undef if not $file;
  
      my $file_name = '';
      my $read_fd_map = '';
      my $bytes_read = 0;
  
      $timeout ||= $read_timeout;
  
      if ( not ref $file ) {
          return undef if not exists $open_files->{$file};
          $file_name = $file;
          $file = $open_files->{$file}{'handle'};
      }
      elsif ( ref $file eq 'GLOB' ) {
          return undef if not openhandle($file);
          $file_name = name($file);
      }
      else {
          die "Unknown argument"
      }
  
      $last_incomplete_line->{$file_name} ||= '';
      vec($read_fd_map, fileno($file), 1) = 1;
  
      return undef unless select($read_fd_map, undef, undef, $timeout) >= 0;
      return undef unless vec($read_fd_map, fileno($file), 1);
  
      $open_files->{$file_name}{'bytes_read'}
          += $bytes_read
           = sysread($file, $buffer->{$file_name}, $open_files->{$file_name}{'read_buffer_size'});
  
      if (not $bytes_read) {
          $open_files->{$file_name}{'eof'} = 1;
          return $last_incomplete_line->{$file_name};
      }
  
      $open_files->{$file_name}{'bytes_read'} += $bytes_read;
  
      $buffer->{$file_name} = $last_incomplete_line->{$file_name} . $buffer->{$file_name};
      $last_incomplete_line->{$file_name} =
          (substr($buffer->{$file_name}, -1) !~ /[\r\n]/ && $buffer->{$file_name} =~ s|([^$/]*)$||) ? $1 : '';
  
      return $buffer->{$file_name} ? split(m|$/|, $buffer->{$file_name})
                                   : undef;
  
      #return (splice @{ $complete_lines->{$file_name} }, 0, 1)[0] if (defined wantarray and not wantarray);
  
      #return ( $lines_in_buffer <= $num_lines ) ? (splice @{ $complete_lines->{$file_name} }, 0, $lines_in_buffer)
      #                                          : (splice @{ $complete_lines->{$file_name} }, 0, $num_lines)
  }
  
  sub read_lines {
      my ($file, $num_lines) = @_;
      $num_lines ||= $lines_per_read;
  
      my $file_name = '';
      my $bytes_read = 0;
      my @lines;
  
      require bytes;
  
      if ( not ref $file ) {
          return undef if not exists $open_files->{$file};
          $file_name = $file;
          $file = $open_files->{$file}{'handle'};
      }
      elsif ( ref $file eq 'GLOB' ) {
          return undef if not openhandle($file);
          $file_name = name($file);
      }
      else {
          die "Unknown argument";
      }
  
      return 0 if $open_files->{$file_name}{'eof'};
  
      if ( $open_files->{$file_name}{'selector'}->can_read ) {
  
          for (1 .. $num_lines) {
              $_ = <$file>;
              last unless defined $_;
              $bytes_read += bytes::length($_);
              chomp;
              push @lines, $_
          }
      }
  
      $open_files->{$file_name}{'bytes_read'} += $bytes_read;
  
      $open_files->{$file_name}{'eof'} = 1
          if (scalar @lines < $num_lines);
  
      return \@lines;
  }
  
  sub read_line {
      my ($file) = @_;
  
      return @{read_lines($file, 1)}[0];
  }
  
  sub close {
      my ($file) = @_;
      return undef if not $file;
  
      if ( not ref $file ) {
          return undef if not exists $open_files->{$file};
          close $open_files->{$file}{'handle'} if ( openhandle($open_files->{$file}{'handle'}) );
          waitpid $open_files->{$file}{'pid'}, 0 if ( $open_files->{$file}{'pid'} > 0 );
          delete $open_files->{$file};
      }
      elsif ( ref $file eq 'GLOB' ) {
          my $file_name = name($file);
          return undef if not $file_name;
          close $file if openhandle($file);
          waitpid $open_files->{$file_name}{'pid'}, 0 if ( $open_files->{$file_name}{'pid'} > 0 );
          delete $open_files->{$file_name};
      }
      else {
          die "Unknown argument";
      }
  
      update_map();
      return 1;
  }
  
  1;
PERL5_FILE_NONBLOCK

$fatpacked{"perl5/Geo/IPfree.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_GEO_IPFREE';
  package Geo::IPfree;
  use 5.006;
  use strict;
  use warnings;
  
  use Memoize;
  use Carp qw();
  
  require Exporter;
  our @ISA = qw(Exporter);
  
  our $VERSION = '1.151940';
  
  our @EXPORT    = qw(LookUp LoadDB);
  our @EXPORT_OK = @EXPORT;
  
  my $DEFAULT_DB   = 'ipscountry.dat';
  my $cache_expire = 5000;
  my @baseX        = (
      0 .. 9,
      'A' .. 'Z',
      'a' .. 'z',
      split( m{}, q(.,;'"`<>{}[]=+-~*@#%$&!?) )
  );
  
  my ( %baseX, $base, $THIS, %countrys );
  
  {
      my $c = 0;
      %baseX = map { $_ => ( $c++ ) } @baseX;
      $base = @baseX;
  
      my @data;
      while ( <DATA> ) {
          last if m{^__END__};
          chomp;
          push @data, split m{ }, $_, 2;
      }
      %countrys = @data;
  }
  
  sub new {
      my ( $class, $db_file ) = @_;
  
      if ( !defined $_[ 0 ] || $_[ 0 ] !~ /^[\w:]+$/ ) {
          $class   = 'Geo::IPfree';
          $db_file = $_[ 0 ];
      }
  
      my $this = bless( {}, $class );
  
      if ( !defined $db_file ) { $db_file = _find_db_file(); }
  
      $this->LoadDB( $db_file );
  
      $this->Clean_Cache();
      $this->{ cache } = 1;
  
      return $this;
  }
  
  sub _find_db_file {
      my @locations = (
          qw(/usr/local/share /usr/local/share/GeoIPfree),
          map { $_, "$_/Geo" } @INC
      );
  
      # lastly, find where this module was loaded, and try that dir
      my ( $lib ) = ( $INC{ 'Geo/IPfree.pm' } =~ /^(.*?)[\\\/]+[^\\\/]+$/gs );
      push @locations, $lib;
  
      for my $file ( map { "$_/$DEFAULT_DB" } @locations ) {
          return $file if -e $file;
      }
  }
  
  sub LoadDB {
      my $this = shift;
      my ( $db_file ) = @_;
  
      if ( -d $db_file ) { $db_file .= "/$DEFAULT_DB"; }
  
      if ( !-s $db_file ) {
          Carp::croak( "Can't load database, blank or not there: $db_file" );
      }
  
      my $buffer = '';
      open( my $handler, '<', $db_file )
          || Carp::croak( "Failed to open database file $db_file for read!" );
      binmode( $handler );
      $this->{ dbfile } = $db_file;
  
      delete $this->{ pos } if $this->{ pos };
  
      while ( read( $handler, $buffer, 1, length( $buffer ) ) ) {
          if ( $buffer =~ /##headers##(\d+)##$/s ) {
              my $headers;
              read( $handler, $headers, $1 );
              my ( %head ) = ( $headers =~ /(\d+)=(\d+)/gs );
              $this->{ pos }{ $_ } = $head{ $_ } for keys %head;
              $buffer = '';
          }
          elsif ( $buffer =~ /##start##$/s ) {
              $this->{ start } = tell( $handler );
              last;
          }
      }
  
      $this->{ searchorder } = [ sort { $a <=> $b } keys %{ $this->{ pos } } ];
      $this->{ handler } = $handler;
  }
  
  sub LookUp {
      my $this;
  
      if ( $#_ == 0 ) {
          if ( !$THIS ) { $THIS = Geo::IPfree->new(); }
          $this = $THIS;
      }
      else { $this = shift; }
  
      my ( $ip ) = @_;
  
      $ip =~ s/\.+/\./gs;
      $ip =~ s/^\.//;
      $ip =~ s/\.$//;
  
      if ( $ip !~ /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/ ) {
          $ip = nslookup( $ip );
      }
  
      return unless length $ip;
  
      ## Since the last class is always from the same country, will try 0 and cache 0:
      my $ip_class = $ip;
      $ip_class =~ s/\.\d+$/\.0/;
  
      if ( $this->{ cache } && $this->{ CACHE }{ $ip_class } ) {
          return ( @{ $this->{ CACHE }{ $ip_class } }, $ip_class );
      }
  
      my $ipnb = ip2nb( $ip_class );
  
      my $buf_pos = 0;
  
      foreach my $Key ( @{ $this->{ searchorder } } ) {
          if ( $ipnb <= $Key ) { $buf_pos = $this->{ pos }{ $Key }; last; }
      }
  
      my ( $buffer, $country, $iprange );
  
      ## Will use the DB in the memory:
      if ( $this->{ FASTER } ) {
          while ( $buf_pos < $this->{ DB_SIZE } ) {
              $buffer  = substr( $this->{ DB }, $buf_pos, 7 );
              $country = substr( $buffer,       0,        2 );
              $iprange = baseX2dec( substr( $buffer, 2, 5 ) );
              $buf_pos += 7;
              last if $ipnb >= $iprange;
          }
      }
      ## Will read the DB in the disk:
      else {
          seek( $this->{ handler }, 0, 0 )
              if $] < 5.006001;    ## Fix bug on Perl 5.6.0
          seek( $this->{ handler }, $buf_pos + $this->{ start }, 0 );
          while ( read( $this->{ handler }, $buffer, 7 ) ) {
              $country = substr( $buffer, 0, 2 );
              $iprange = baseX2dec( substr( $buffer, 2 ) );
              last if $ipnb >= $iprange;
          }
      }
  
      if ( $this->{ cache } ) {
          if( $this->{ CACHE_COUNT } > $cache_expire ) {
              keys %{ $this->{ CACHE } };
              my( $d_key ) = each( %{ $this->{ CACHE } } );
              delete $this->{ CACHE }{ $d_key };
          }
          else {
              $this->{ CACHE_COUNT }++;
          }
          $this->{ CACHE }{ $ip_class } = [ $country, $countrys{ $country } ];
      }
  
      return ( $country, $countrys{ $country }, $ip_class );
  }
  
  sub Faster {
      my $this = shift;
      my $handler = $this->{ handler };
  
      seek( $handler, 0, 0 );                 ## Fix bug on Perl 5.6.0
      seek( $handler, $this->{ start }, 0 );
  
      $this->{ DB } = do { local $/; <$handler>; };
      $this->{ DB_SIZE } = length( $this->{ DB } );
  
      memoize( 'dec2baseX' );
      memoize( 'baseX2dec' );
  
      $this->{ FASTER } = 1;
  }
  
  sub Clean_Cache {
      my $this = shift;
      $this->{ CACHE_COUNT } = 0;
      delete $this->{ CACHE };
      return 1;
  }
  
  sub nslookup {
      my ( $host, $last_lookup ) = @_;
      require Socket;
      my $iaddr = Socket::inet_aton( $host ) || '';
      my @ip = unpack( 'C4', $iaddr );
  
      return nslookup( "www.${host}", 1 ) if !@ip && !$last_lookup;
      return join( '.', @ip );
  }
  
  sub ip2nb {
      my @ip = split( /\./, $_[ 0 ] );
      return ( $ip[ 0 ] << 24 ) + ( $ip[ 1 ] << 16 ) + ( $ip[ 2 ] << 8 )
          + $ip[ 3 ];
  }
  
  sub nb2ip {
      my ( $input ) = @_;
      my @ip;
  
      while ( $input > 1 ) {
          my $int = int( $input / 256 );
          push @ip, $input - ( $int << 8 );
          $input = $int;
      }
  
      push @ip, $input if $input > 0;
      push @ip, ( 0 ) x ( 4 - @ip );
  
      return join( '.', reverse @ip );
  }
  
  sub dec2baseX {
      my ( $dec ) = @_;
      my @base;
  
      while ( $dec > 1 ) {
          my $int = int( $dec / $base );
          push @base, $dec - $int * $base;
          $dec = $int;
      }
  
      push @base, $dec if $dec > 0;
      push @base, ( 0 ) x ( 5 - @base );
  
      return join( '', map { $baseX[ $_ ] } reverse @base );
  }
  
  sub baseX2dec {
      my ( $input ) = @_;
  
      my @digits = reverse split( '', $input );
      my $dec = 0;
  
      foreach ( 0 .. @digits - 1 ) {
          $dec += $baseX{ $digits[ $_ ] } * ( $base**$_ );
      }
  
      return $dec;
  }
  
  1;
  
  __DATA__
  -- N/A
  L0 localhost
  I0 IntraNet
  A1 Anonymous Proxy
  A2 Satellite Provider
  AC Ascension Island
  AD Andorra
  AE United Arab Emirates
  AF Afghanistan
  AG Antigua and Barbuda
  AI Anguilla
  AL Albania
  AM Armenia
  AN Netherlands Antilles
  AO Angola
  AP Asia/Pacific Region
  AQ Antarctica
  AR Argentina
  AS American Samoa
  AT Austria
  AU Australia
  AW Aruba
  AX Aland Islands
  AZ Azerbaijan
  BA Bosnia and Herzegovina
  BB Barbados
  BD Bangladesh
  BE Belgium
  BF Burkina Faso
  BG Bulgaria
  BH Bahrain
  BI Burundi
  BJ Benin
  BL Saint Barthelemy
  BM Bermuda
  BN Brunei Darussalam
  BO Bolivia, Plurinational State of
  BQ Bonaire, Sint Eustatius and Saba
  BR Brazil
  BS Bahamas
  BT Bhutan
  BU Burma
  BV Bouvet Island
  BW Botswana
  BY Belarus
  BZ Belize
  CA Canada
  CC Cocos (Keeling) Islands
  CD Congo, The Democratic Republic of the
  CF Central African Republic
  CG Congo
  CH Switzerland
  CI Cote d'Ivoire
  CK Cook Islands
  CL Chile
  CM Cameroon
  CN China
  CO Colombia
  CP Clipperton Island
  CR Costa Rica
  CS Serbia and Montenegro
  CU Cuba
  CV Cape Verde
  CW Curacao
  CX Christmas Island
  CY Cyprus
  CZ Czech Republic
  DE Germany
  DJ Djibouti
  DK Denmark
  DM Dominica
  DO Dominican Republic
  DZ Algeria
  EC Ecuador
  EE Estonia
  EG Egypt
  EH Western Sahara
  ER Eritrea
  ES Spain
  ET Ethiopia
  EU Europe
  FI Finland
  FJ Fiji
  FK Falkland Islands (Malvinas)
  FM Micronesia, Federated States of
  FO Faroe Islands
  FR France
  FX France Metropolitan
  GA Gabon
  GB United Kingdom
  GD Grenada
  GE Georgia
  GF French Guiana
  GG Guernsey
  GH Ghana
  GI Gibraltar
  GL Greenland
  GM Gambia
  GN Guinea
  GP Guadeloupe
  GQ Equatorial Guinea
  GR Greece
  GS South Georgia and the South Sandwich Islands
  GT Guatemala
  GU Guam
  GW Guinea-Bissau
  GY Guyana
  HK Hong Kong
  HM Heard Island and McDonald Islands
  HN Honduras
  HR Croatia
  HT Haiti
  HU Hungary
  ID Indonesia
  IE Ireland
  IL Israel
  IM Isle of Man
  IN India
  IO British Indian Ocean Territory
  IQ Iraq
  IR Iran, Islamic Republic of
  IS Iceland
  IT Italy
  JE Jersey
  JM Jamaica
  JO Jordan
  JP Japan
  KE Kenya
  KG Kyrgyzstan
  KH Cambodia
  KI Kiribati
  KM Comoros
  KN Saint Kitts and Nevis
  KP Korea, Democratic People's Republic of
  KR Korea, Republic of
  KW Kuwait
  KY Cayman Islands
  KZ Kazakhstan
  LA Lao People's Democratic Republic
  LB Lebanon
  LC Saint Lucia
  LI Liechtenstein
  LK Sri Lanka
  LR Liberia
  LS Lesotho
  LT Lithuania
  LU Luxembourg
  LV Latvia
  LY Libya
  MA Morocco
  MC Monaco
  MD Moldova, Republic of
  ME Montenegro
  MF Saint Martin (French part)
  MG Madagascar
  MH Marshall Islands
  MK Macedonia, the Former Yugoslav Republic of
  ML Mali
  MM Myanmar
  MN Mongolia
  MO Macao
  MP Northern Mariana Islands
  MQ Martinique
  MR Mauritania
  MS Montserrat
  MT Malta
  MU Mauritius
  MV Maldives
  MW Malawi
  MX Mexico
  MY Malaysia
  MZ Mozambique
  NA Namibia
  NC New Caledonia
  NE Niger
  NF Norfolk Island
  NG Nigeria
  NI Nicaragua
  NL Netherlands
  NO Norway
  NP Nepal
  NR Nauru
  NU Niue
  NZ New Zealand
  OM Oman
  PA Panama
  PE Peru
  PF French Polynesia
  PG Papua New Guinea
  PH Philippines
  PK Pakistan
  PL Poland
  PM Saint Pierre and Miquelon
  PN Pitcairn
  PR Puerto Rico
  PS Palestine, State of
  PT Portugal
  PW Palau
  PY Paraguay
  QA Qatar
  RE Reunion
  RO Romania
  RS Serbia
  RU Russian Federation
  RW Rwanda
  SA Saudi Arabia
  SB Solomon Islands
  SC Seychelles
  SD Sudan
  SE Sweden
  SF Finland
  SG Singapore
  SH Saint Helena, Ascension and Tristan da Cunha
  SI Slovenia
  SJ Svalbard and Jan Mayen
  SK Slovakia
  SL Sierra Leone
  SM San Marino
  SN Senegal
  SO Somalia
  SR Suriname
  SS South Sudan
  ST Sao Tome and Principe
  SV El Salvador
  SX Sint Maarten (Dutch part)
  SY Syrian Arab Republic
  SZ Swaziland
  TC Turks and Caicos Islands
  TD Chad
  TF French Southern Territories
  TG Togo
  TH Thailand
  TJ Tajikistan
  TK Tokelau
  TL Timor-Leste
  TM Turkmenistan
  TN Tunisia
  TO Tonga
  TP East Timor
  TR Turkey
  TT Trinidad and Tobago
  TV Tuvalu
  TW Taiwan, Province of China
  TZ Tanzania, United Republic of
  UA Ukraine
  UG Uganda
  UK United Kingdom
  UM United States Minor Outlying Islands
  US United States
  UY Uruguay
  UZ Uzbekistan
  VA Holy See (Vatican City State)
  VC Saint Vincent and the Grenadines
  VE Venezuela, Bolivarian Republic of
  VG Virgin Islands, British
  VI Virgin Islands, U.S.
  VN Viet Nam
  VU Vanuatu
  WF Wallis and Futuna
  WS Samoa
  YE Yemen
  YT Mayotte
  YU Serbia and Montenegro (Formally Yugoslavia)
  ZA South Africa
  ZM Zambia
  ZR Zaire
  ZW Zimbabwe
  ZZ Reserved for private IP addresses
  __END__
  
  =head1 NAME
  
  Geo::IPfree - Look up the country of an IPv4 address
  
  =head1 SYNOPSIS
  
      use Geo::IPfree;
      
      my $geo = Geo::IPfree->new;
      my( $code1, $name1 ) = $geo->LookUp( '200.176.3.142' );
      
      # use memory to speed things up
      $geo->Faster;
      
      # lookup by hostname
      my( $code2, $name2, $ip2 ) = $geo->LookUp( 'www.cnn.com' );
  
  =head1 DESCRIPTION
  
  Geo::IPfree is a Perl module that determines the originating country of an
  arbitrary IPv4 address. It uses a local file-based database to provide basic
  geolocation services.
  
  An updated version of the database can be obtained by visiting the Webnet77 
  website: L<http://software77.net/geo-ip/>.
    
  =head1 METHODS
  
  =head2 new( [$db] )
  
  Creates a new Geo::IPfree instance. Optionally, a database filename may be
  passed in to load a custom data set rather than the version shipped with the
  module.
  
  =head2 LoadDB( $filename )
  
  Load a specific database to use to look up the IP addresses.
  
  =head2 LookUp( $ip | $hostname )
  
  Given an IP address or a hostname, this function returns three things:
  
  =over 4
  
  =item * The ISO 3166 country code (2 chars)
  
  =item * The country name
  
  =item * The IP address resolved
  
  =back
  
  B<NB:> In order to use the location services on a hostname, you will need
  to have an internet connection to resolve a host to an IP address.
  
  If you pass a private IP address (for example 192.168.0.1), you'll get back a country
  code of ZZ, and country name of "Reserved for private IP addresses".
  
  =head2 Clean_Cache( )
  
  Clears any cached lookup data.
  
  =head2 Faster( )
  
  Make the LookUp() faster, which is good if you're going to be calling Lookup() many times. This will load the entire DB into memory and read from there,
  not from disk (good way for slow disk or network disks), but use more memory. The module "Memoize" will be enabled for some internal functions too.
  
  Note that if you call Lookup() many times, you'll end up using a lot of memory anyway, so you'll be better off using a lot of memory from the start by calling Faster(),
  and getting an improvement for all calls.
  
  =head2 nslookup( $host, [$last_lookup] )
  
  Attempts to resolve a hostname to an IP address. If it fails on the first pass
  it will attempt to resolve the same hostname with 'www.' prepended. C<$last_lookup>
  is used to suppress this behavior.
  
  =head2 ip2nb( $ip )
  
  Encodes C<$ip> into a numerical representation.
  
  =head2 nb2ip( $number )
  
  Decodes C<$number> back to an IP address.
  
  =head2 dec2baseX( $number )
  
  Converts a base 10 (decimal) number to base 86.
  
  =head2 baseX2dec( $number )
  
  Converts a base 86 number to base 10 (decimal).
  
  =head1 VARS
  
  =over 4
  
  =item $GeoIP->{db}
  
  The database file in use.
  
  =item $GeoIP->{handler}
  
  The database file handler.
  
  =item $GeoIP->{dbfile}
  
  The database file path.
  
  =item $GeoIP->{cache} BOOLEAN
  
  Set/tell if the cache of LookUp() is on. If it's on it will cache the last 5000 queries. Default: 1
  
  The cache is good when you are parsing a list of IPs, generally a web log.
  If in the log you have many lines with the same IP, GEO::IPfree won't have to make a full search for each query,
  it will cache the last 5000 different IPs. After 5000 IPs an existing IP is removed from the cache and the new
  data is stored.
  
  Note that the Lookup make the query without the last IP number (xxx.xxx.xxx.0),
  then the cache for the IP 192.168.0.1 will be the same for 192.168.0.2 (they are the same query, 192.168.0.0).
  
  =back
  
  =head1 DB FORMAT
  
  The data file has a list of IP ranges & countries, for example, from 200.128.0.0 to
  200.103.255.255 the IPs are from BR. To make a fast access to the DB the format
  tries to use less bytes per input (block). The file was in ASCII and in blocks
  of 7 bytes: XXnnnnn
  
    XX    -> the country code (BR,US...)
    nnnnn -> the IP range using a base of 85 digits
             (not in dec or hex to get space).
  
  See CPAN for updates of the DB...
  
  =head1 NOTES
  
  The file ipscountry.dat is a dedicated format for Geo::IPfree.
  To convert it see the tool "ipct2txt.pl" in the C<misc> directoy.
  
  The module looks for C<ipscountry.dat> in the following locations:
  
  =over 4
  
  =item * /usr/local/share
  
  =item * /usr/local/share/GeoIPfree
  
  =item * through @INC (as well as all @INC directories plus "/Geo")
  
  =item * from the same location that IPfree.pm was loaded
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item * http://software77.net/geo-ip/
  
  =back
  
  =head1 AUTHOR
  
  Graciliano M. P. E<lt>gm@virtuasites.com.brE<gt>
  
  =head1 MAINTAINER
  
  Brian Cassidy E<lt>bricas@cpan.orgE<gt>
  
  =head1 THANK YOU
  
  Thanks to Laurent Destailleur (author of AWStats) that tested it on many OS and
  fixed bugs for them, like the not portable sysread, and asked for some speed improvement.
  
  =head1 COPYRIGHT & LICENSE
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
PERL5_GEO_IPFREE

$fatpacked{"perl5/Geography/Countries.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_GEOGRAPHY_COUNTRIES';
  package Geography::Countries;
  
  use 5.006;
  
  use strict;
  use warnings;
  no  warnings 'syntax';
  
  use Exporter ();
  
  our @ISA         = qw /Exporter/;
  our @EXPORT      = qw /country/;
  our @EXPORT_OK   = qw /code2         code3       numcode       countries
                         CNT_I_CODE2   CNT_I_CODE3 CNT_I_NUMCODE CNT_I_COUNTRY
                         CNT_I_FLAG
                         CNT_F_REGULAR CNT_F_OLD   CNT_F_REGION  CNT_F_ANY/;
  our %EXPORT_TAGS = (LISTS   => [qw /code2 code3   numcode     countries/],
                      INDICES => [qw /CNT_I_CODE2   CNT_I_CODE3 CNT_I_NUMCODE
                                      CNT_I_COUNTRY CNT_I_FLAG/],
                      FLAGS   => [qw /CNT_F_REGULAR CNT_F_OLD
                                      CNT_F_REGION  CNT_F_ANY/],);
  
  our $VERSION     = '2009041301';
  
  
  use constant CNT_I_CODE2   =>    0;
  use constant CNT_I_CODE3   =>    1;
  use constant CNT_I_NUMCODE =>    2;
  use constant CNT_I_COUNTRY =>    3;
  use constant CNT_I_FLAG    =>    4;
  
  use constant CNT_F_REGULAR => 0x01;
  use constant CNT_F_OLD     => 0x02;
  use constant CNT_F_REGION  => 0x04;
  use constant CNT_F_ANY     => CNT_F_REGULAR | CNT_F_OLD | CNT_F_REGION;
  
  my (%info, @code2, @code3, @numcode, @countries);
  
  sub norm ($) {
      my $query = shift;
      die "Illegal argument to norm\n" unless defined $query;
      return sprintf "%03d" => $query  unless $query =~ /\D/;
      $query =  lc $query;
      $query =~ s/\s+//g;
  
      $query;
  }
  
  binmode (DATA, ':encoding(iso-8859-1)') if $] >= 5.008;
  
  my $flag;
  my %flags   = (
      Regular => CNT_F_REGULAR,
      Old     => CNT_F_OLD,
      Region  => CNT_F_REGION,
  );
  while (<DATA>) {
      chomp;
      last if $_ eq '__END__';
      s/#.*//;
      next unless /\S/;
      if (/^%%\s*(\S.*\S)\s*%%$/) {
          $flag = $flags {$1} or
                   die "Found illegal flag ``$1'' while parsing __DATA__\n";
          next;
      }
      my $code2   = substr $_,  0, 2;  $code2   = undef if $code2   =~ /\s/;
      my $code3   = substr $_,  3, 3;  $code3   = undef if $code3   =~ /\s/;
      my $numcode = substr $_,  7, 3;  $numcode = undef if $numcode =~ /\s/;
      my $country = substr $_, 11;
  
      push @code2     =>  $code2   if defined $code2;
      push @code3     =>  $code3   if defined $code3;
      push @numcode   =>  $numcode if defined $numcode;
      push @countries =>  $country;
  
      my $info    = [$code2, $code3, $numcode, $country, $flag];
  
      $info {norm $code2}   =  $info if defined $code2  ;
      $info {norm $code3}   =  $info if defined $code3  ;
      $info {$numcode}      =  $info if defined $numcode;
  
      $info {norm $country} =  $info;
  }
  
  @code2     = sort @code2;
  @code3     = sort @code3;
  @numcode   = sort @numcode;
  @countries = sort @countries;
  
  sub code2     {@code2}
  sub code3     {@code3}
  sub numcode   {@numcode}
  sub countries {@countries}
  
  
  sub country ($;$) {
      my $sub = (caller (0)) [3];
  
      die "No arguments for $sub.\n"           unless @_;
      die "Too many arguments for $sub.\n"     unless @_ <= 2;
  
      my ($query, $flags) = @_;
  
      die "Undefined argument for $sub.\n"     unless defined $query;
  
      $flags ||=  CNT_F_REGULAR;
  
      die "Illegal second argument to $sub.\n" if $flags =~ /\D/;
  
      my $info =  $info {norm $query} or return;
  
      return unless $info -> [CNT_I_FLAG] & $flags;
  
      wantarray ? @$info : $info -> [CNT_I_COUNTRY];
  
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  Geography::Countries - 2-letter, 3-letter, and numerical codes for countries.
  
  =head1 SYNOPSIS
  
      use Geography::Countries;
  
      $country = country 'DE';  # 'Germany'
      @list    = country  666;  # ('PM', 'SPM', 666,
                                #  'Saint Pierre and Miquelon', 1)
  
  =head1 DESCRIPTION
  
  This module maps country names, and their 2-letter, 3-letter and
  numerical codes, as defined by the ISO-3166 maintenance agency [1],
  and defined by the UNSD.
  
  =head2 The C<country> subroutine.
  
  This subroutine is exported by default. It takes a 2-letter, 3-letter or
  numerical code, or a country name as argument. In scalar context, it will
  return the country name, in list context, it will return a list consisting
  of the 2-letter code, the 3-letter code, the numerical code, the country
  name, and a flag, which is explained below. Note that not all countries
  have all 3 codes; if a code is unknown, the undefined value is returned.
  
  There are 3 categories of countries. The largest category are the 
  current countries. Then there is a small set of countries that no
  longer exist. The final set consists of areas consisting of multiple
  countries, like I<Africa>. No 2-letter or 3-letter codes are available
  for the second two sets. (ISO 3166-3 [3] defines 4 letter codes for the
  set of countries that no longer exist, but the author of this module
  was unable to get her hands on that standard.) By default, C<country>
  only returns countries from the first set, but this can be changed
  by giving C<country> an optional second argument.
  
  The module optionally exports the constants C<CNT_F_REGULAR>,
  C<CNT_F_OLD>, C<CNT_F_REGION> and C<CNT_F_ANY>. These constants can also
  be important all at once by using the tag C<:FLAGS>. C<CNT_F_ANY> is just
  the binary or of the three other flags. The second argument of C<country>
  should be the binary or of a subset of the flags C<CNT_F_REGULAR>,
  C<CNT_F_OLD>, and C<CNT_F_REGION> - if no, or a false, second argument is
  given, C<CNT_F_REGULAR> is assumed. If C<CNT_F_REGULAR> is set, regular
  (current) countries will be returned; if C<CNT_F_OLD> is set, old,
  no longer existing, countries will be returned, while C<CNT_F_REGION>
  is used in case a region (not necessarely) a country might be returned.
  If C<country> is used in list context, the fifth returned element is
  one of C<CNT_F_REGULAR>, C<CNT_F_OLD> and C<CNT_F_REGION>, indicating
  whether the result is a regular country, an old country, or a region.
  
  In list context, C<country> returns a 5 element list. To avoid having
  to remember which element is in which index, the constants C<CNT_I_CODE2>,
  C<CNT_I_CODE3>, C<CNT_I_NUMCODE>, C<CNT_I_COUNTRY> and C<CNT_I_FLAG>
  can be imported. Those constants contain the indices of the 2-letter code,
  the 3-letter code, the numerical code, the country, and the flag explained
  above, respectively. All index constants can be imported by using the
  C<:INDICES> tag.
  
  =head2 The C<code2>, C<code3>, C<numcode> and C<countries> routines.
  
  All known 2-letter codes, 3-letter codes, numerical codes and country
  names can be returned by the routines C<code2>, C<code3>, C<numcode> and
  C<countries>. None of these methods is exported by default; all need to
  be imported if one wants to use them. The tag C<:LISTS> imports them 
  all. In scalar context, the number of known codes or countries is returned.
  
  =head1 REFERENCES
  
  The 2-letter codes come from the ISO 3166-1:1997 standard [2]. ISO 3166
  bases its list of country names on the list of names published by
  the United Nations. This list is published by the Statistical Division
  of the United Nations [4]. The UNSD uses 3-letter codes, and numerical
  codes [5]. The information about old countries [6] and regions [7] also
  comes from the United Nations.
  
  In a few cases, there was a conflict between the way how the United 
  Nations spelled a name, and how ISO 3166 spells it. In most cases,
  is was word order (for instance whether I<The republic of> should
  preceed the name, or come after the name. A few cases had minor
  spelling variations. In all such cases, the method in which the UN
  spelled the name was choosen; ISO 3166 claims to take the names from
  the UN, so we consider the UN authoritative.
  
  =over 4
  
  =item [1]
  
  ISO Maintenance Agency (ISO 3166/MA)
  I<http://www.din.de/gremien/nas/nabd/iso3166ma/index.html>.
  
  =item [2]
  
  I<Country codes>,
  I<http://www.din.de/gremien/nas/nabd/iso3166ma/codlstp1.html>,
  7 September 1999.
  
  =item [3]
  
  ISO 3166-3, I<Code for formerly used country names>.
  I<http://www.din.de/gremien/nas/nabd/iso3166ma/info_pt3.html>.
  
  =item [4]
  
  United Nations, Statistics Division.
  I<http://www.un.org/Depts/unsd/statdiv.htm>.
  
  =item [5]
  
  I<Country or area codes in alphabetical order>.
  I<http://www.un.org/Depts/unsd/methods/m49alpha.htm>,
  26 August 1999.
  
  =item [6]
  
  I<Codes added or changed>.
  I<http://www.un.org/Depts/unsd/methods/m49chang.htm>,
  26 August 1999.
  
  =item [7]
  
  I<Geographical regions>.
  I<http://www.un.org/Depts/unsd/methods/m49regin.htm>,
  26 August 1999.
  
  =back
  
  =head1 BUGS
  
  Looking up information using country names is far from perfect.
  Except for case and the amount of white space, the exact name as it
  appears on the list has to be given. I<USA> will not return anything,
  but I<United States> will.
  
  =head1 DEVELOPMENT
      
  The current sources of this module are found on github,
  L<< git://github.com/Abigail/geography--countries.git >>.
      
  =head1 AUTHOR
      
  Abigail L<< mailto:geography-countries@abigail.be >>.
      
  =head1 COPYRIGHT and LICENSE
         
  Copyright (C) 1999, 2009 by Abigail
      
  Permission is hereby granted, free of charge, to any person obtaining a
  copy of this software and associated documentation files (the "Software"),
  to deal in the Software without restriction, including without limitation
  the rights to use, copy, modify, merge, publish, distribute, sublicense,
  and/or sell copies of the Software, and to permit persons to whom the
  Software is furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included
  in all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
  THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
  OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
  
  =cut
  
  __DATA__
  %% Regular %%
  AF AFG 004 Afghanistan
  AL ALB 008 Albania
  DZ DZA 012 Algeria
  AS ASM 016 American Samoa
  AD AND 020 Andorra
  AO AGO 024 Angola
  AI AIA 660 Anguilla
  AQ         Antarctica
  AG ATG 028 Antigua and Barbuda
         896 Areas not elsewhere specified
         898 Areas not specified
  AR ARG 032 Argentina
  AM ARM 051 Armenia
  AW ABW 533 Aruba
  AU AUS 036 Australia
  AT AUT 040 Austria
  AZ AZE 031 Azerbaijan
  BS BHS 044 Bahamas
  BH BHR 048 Bahrain
  BD BGD 050 Bangladesh
  BB BRB 052 Barbados
  BY BLR 112 Belarus
  BE BEL 056 Belgium
  BZ BLZ 084 Belize
  BJ BEN 204 Benin
  BM BMU 060 Bermuda
  BT BTN 064 Bhutan
  BO BOL 068 Bolivia
  BA BIH 070 Bosnia and Herzegovina
  BW BWA 072 Botswana
  BV         Bouvet Island
  BR BRA 076 Brazil
  IO         British Indian Ocean Territory
  VG VGB 092 British Virgin Islands
  BN BRN 096 Brunei Darussalam
  BG BGR 100 Bulgaria
  BF BFA 854 Burkina Faso
  BI BDI 108 Burundi
  KH KHM 116 Cambodia
  CM CMR 120 Cameroon
  CA CAN 124 Canada
  CV CPV 132 Cape Verde
  KY CYM 136 Cayman Islands
  CF CAF 140 Central African Republic
  TD TCD 148 Chad
         830 Channel Islands
  CL CHL 152 Chile
  CN CHN 156 China
  CX         Christmas Island
  CC         Cocos (keeling) Islands
  CO COL 170 Colombia
  KM COM 174 Comoros
  CG COG 178 Congo
  CK COK 184 Cook Islands
  CR CRI 188 Costa Rica
  CI CIV 384 Cte d'Ivoire
  HR HRV 191 Croatia
  CU CUB 192 Cuba
  CY CYP 196 Cyprus
  CZ CZE 203 Czech Republic
  KP PRK 408 Democratic People's Republic of Korea
  CD COD 180 Democratic Republic of the Congo
  DK DNK 208 Denmark
  DJ DJI 262 Djibouti
  DM DMA 212 Dominica
  DO DOM 214 Dominican Republic
  TP TMP 626 East Timor
  EC ECU 218 Ecuador
  EG EGY 818 Egypt
  SV SLV 222 El Salvador
  GQ GNQ 226 Equatorial Guinea
  ER ERI 232 Eritrea
  EE EST 233 Estonia
  ET ETH 231 Ethiopia
  FO FRO 234 Faeroe Islands
  FK FLK 238 Falkland Islands (Malvinas)
  FM FSM 583 Micronesia, Federated States of
  FJ FJI 242 Fiji
  FI FIN 246 Finland
  MK MKD 807 The former Yugoslav Republic of Macedonia
  FR FRA 250 France
  GF GUF 254 French Guiana
  PF PYF 258 French Polynesia
  TF         French Southern Territories
  GA GAB 266 Gabon
  GM GMB 270 Gambia
  GE GEO 268 Georgia
  DE DEU 276 Germany
  GH GHA 288 Ghana
  GI GIB 292 Gibraltar
  GR GRC 300 Greece
  GL GRL 304 Greenland
  GD GRD 308 Grenada
  GP GLP 312 Guadeloupe
  GU GUM 316 Guam
  GT GTM 320 Guatemala
  GN GIN 324 Guinea
  GW GNB 624 Guinea-Bissau
  GY GUY 328 Guyana
  HT HTI 332 Haiti
  HM         Heard Island And Mcdonald Islands
  VA VAT 336 Holy See
  HN HND 340 Honduras
  HK HKG 344 Hong Kong Special Administrative Region of China
  HU HUN 348 Hungary
  IS ISL 352 Iceland
  IN IND 356 India
  ID IDN 360 Indonesia
  IR IRN 364 Iran (Islamic Republic of)
  IQ IRQ 368 Iraq
  IE IRL 372 Ireland
     IMY 833 Isle of Man
  IL ISR 376 Israel
  IT ITA 380 Italy
  JM JAM 388 Jamaica
  JP JPN 392 Japan
  JO JOR 400 Jordan
  KZ KAZ 398 Kazakhstan
  KE KEN 404 Kenya
  KI KIR 296 Kiribati
  KW KWT 414 Kuwait
  KG KGZ 417 Kyrgyzstan
  LA LAO 418 Lao People's Democratic Republic
  LV LVA 428 Latvia
  LB LBN 422 Lebanon
  LS LSO 426 Lesotho
  LR LBR 430 Liberia
  LY LBY 434 Libyan Arab Jamahiriya
  LI LIE 438 Liechtenstein
  LT LTU 440 Lithuania
  LU LUX 442 Luxembourg
  MO MAC 446 Macau
  MG MDG 450 Madagascar
  MW MWI 454 Malawi
  MY MYS 458 Malaysia
  MV MDV 462 Maldives
  ML MLI 466 Mali
  MT MLT 470 Malta
  MH MHL 584 Marshall Islands
  MQ MTQ 474 Martinique
  MR MRT 478 Mauritania
  MU MUS 480 Mauritius
  YT         Mayotte
  MX MEX 484 Mexico
  MC MCO 492 Monaco
  MN MNG 496 Mongolia
  MS MSR 500 Montserrat
  MA MAR 504 Morocco
  MZ MOZ 508 Mozambique
  MM MMR 104 Myanmar
  NA NAM 516 Namibia
  NR NRU 520 Nauru
  NP NPL 524 Nepal
  NL NLD 528 Netherlands
  AN ANT 530 Netherlands Antilles
  NC NCL 540 New Caledonia
  NZ NZL 554 New Zealand
  NI NIC 558 Nicaragua
  NE NER 562 Niger
  NG NGA 566 Nigeria
  NU NIU 570 Niue
  NF NFK 574 Norfolk Island
  MP MNP 580 Northern Mariana Islands
  NO NOR 578 Norway
     PSE 275 Occupied Palestinian Territory
  OM OMN 512 Oman
  PK PAK 586 Pakistan
  PW PLW 585 Palau
  PA PAN 591 Panama
  PG PNG 598 Papua New Guinea
  PY PRY 600 Paraguay
  PE PER 604 Peru
  PH PHL 608 Philippines
  PN PCN 612 Pitcairn
  PL POL 616 Poland
  PT PRT 620 Portugal
  PR PRI 630 Puerto Rico
  QA QAT 634 Qatar
  KR KOR 410 Republic of Korea
  MD MDA 498 Republic of Moldova
  RO ROM 642 Romania
  RE REU 638 Runion
  RU RUS 643 Russian Federation
  RW RWA 646 Rwanda
  SH SHN 654 Saint Helena
  KN KNA 659 Saint Kitts and Nevis
  LC LCA 662 Saint Lucia
  PM SPM 666 Saint Pierre and Miquelon
  VC VCT 670 Saint Vincent and the Grenadines
  WS WSM 882 Samoa
  SM SMR 674 San Marino
  ST STP 678 Sao Tome and Principe
  SA SAU 682 Saudi Arabia
  SN SEN 686 Senegal
  SC SYC 690 Seychelles
  SL SLE 694 Sierra Leone
  SG SGP 702 Singapore
  SK SVK 703 Slovakia
  SI SVN 705 Slovenia
  SB SLB 090 Solomon Islands
  SO SOM 706 Somalia
  ZA ZAF 710 South Africa
  GS         South Georgia And The South Sandwich Islands
  ES ESP 724 Spain
  LK LKA 144 Sri Lanka
  SD SDN 736 Sudan
  SR SUR 740 Suriname
  SJ SJM 744 Svalbard and Jan Mayen Islands
  SZ SWZ 748 Swaziland
  SE SWE 752 Sweden
  CH CHE 756 Switzerland
  SY SYR 760 Syrian Arab Republic
  TW TWN 158 Taiwan Province of China
  TJ TJK 762 Tajikistan
  TH THA 764 Thailand
  TG TGO 768 Togo
  TK TKL 772 Tokelau
  TO TON 776 Tonga
  TT TTO 780 Trinidad and Tobago
  TN TUN 788 Tunisia
  TR TUR 792 Turkey
  TM TKM 795 Turkmenistan
  TC TCA 796 Turks and Caicos Islands
  TV TUV 798 Tuvalu
  UG UGA 800 Uganda
  UA UKR 804 Ukraine
  AE ARE 784 United Arab Emirates
  GB GBR 826 United Kingdom
  TZ TZA 834 United Republic of Tanzania
  US USA 840 United States
  UM         United States Minor Outlying Islands
  VI VIR 850 United States Virgin Islands
  UY URY 858 Uruguay
  UZ UZB 860 Uzbekistan
  VU VUT 548 Vanuatu
  VE VEN 862 Venezuela
  VN VNM 704 Viet Nam
  WF WLF 876 Wallis and Futuna Islands
  EH ESH 732 Western Sahara
  YE YEM 887 Yemen
  YU YUG 891 Yugoslavia
  ZM ZMB 894 Zambia
  ZW ZWE 716 Zimbabwe
  %% Old %%
         810 Union of Soviet Socialist Republics
         532 Netherlands Antilles
         890 Socialist Federal Republic of Yugoslavia
         200 Czechoslovakia
         278 German Democratic Republic
         280 Federal Republic of Germany
         582 Pacific Islands (Trust Territory)
         720 Democratic Yemen
         886 Yemen
         230 Ethiopia
         104 Burma
         116 Democratic Kampuchea
         180 Zaire
         384 Ivory Coast
         854 Upper Volta
  %% Region %%
         002 Africa
         014 Eastern Africa
         017 Middle Africa
         015 Northern Africa
         018 Southern Africa
         011 Western Africa
         019 Americas
         419 Latin America and the Caribbean
         029 Caribbean
         013 Central America
         005 South America
         021 Northern America
         142 Asia
         030 Eastern Asia
         062 South-central Asia
         035 South-eastern Asia
         145 Western Asia
         150 Europe
         151 Eastern Europe
         154 Northern Europe
         039 Southern Europe
         155 Western Europe
         009 Oceania
         053 Australia and New Zealand
         054 Melanesia
         055 Micronesia-Polynesia
         057 Micronesia
         061 Polynesia
  __END__
PERL5_GEOGRAPHY_COUNTRIES

$fatpacked{"perl5/IP/Authority.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_IP_AUTHORITY';
  package IP::Authority;
  use strict;
  use warnings;
  use Socket qw ( inet_aton );
  
  use vars qw ( $VERSION );
  $VERSION = '1305.001'; # MAY 2013, version 0.01
  
  my $singleton = undef;
  my $ip_db;
  my $null = substr(pack('N',0),0,1);
  my $nullnullnull = $null . $null . $null;
  my %auth;
  my $ip_match = qr/^(\d|[01]?\d\d|2[0-4]\d|25[0-5])\.(\d|[01]?\d\d|2[0-4]\d|25[0-5])\.(\d|[01]?\d\d|2[0-4]\d|25[0-5])\.(\d|[01]?\d\d|2[0-4]\d|25[0-5])$/o;
  
  my $bit0;
  my $bit1;
  my @mask;
  my @dtoc;
  {
      $bit0 = substr(pack('N',2 ** 31),0,1);
      $bit1 = substr(pack('N',2 ** 30),0,1);
  
      for (my $i = 0; $i <= 31; $i++){
  	$mask[$i] = pack('N',2 ** (31 - $i));
      }
  
      for (my $i = 0; $i <= 255; $i++){
  	$dtoc[$i] = substr(pack('N',$i),3,1);
      }
      (my $module_dir = __FILE__) =~ s/\.pm$//;
  
      local $/;   # set it so <> reads all the file at once
  
      open (AUTH, "< $module_dir/auth.gif")
  	or die ("couldn't read authority database: $!");
      binmode AUTH;
      my $auth_ultra = <AUTH>;  # read in the file
      close AUTH;
      my $auth_num = (length $auth_ultra) / 3;
      for (my $i = 0; $i < $auth_num; $i++){
  	my $auth = substr($auth_ultra,3 * $i + 1,2);
  	$auth = undef if ($auth eq '--');
  	$auth{substr($auth_ultra,3 * $i,1)} = $auth;
      }
  
      open (IP, "< $module_dir/ipauth.gif")
  	or die ("couldn't read IP database: $!");
      binmode IP;
      $ip_db = <IP>;
      close IP;
  }
  
  sub new ()
  {
      my $caller = shift;
      unless (defined $singleton){
          my $class = ref($caller) || $caller;
  	$singleton = bless {}, $class;
      }
      return $singleton;
  }
  
  sub inet_atoauth
  {
      my $inet_a = $_[1];
      if ($inet_a =~ $ip_match){
  	return inet_ntoauth($dtoc[$1].$dtoc[$2].$dtoc[$3].$dtoc[$4]);
      } else {
  	if (defined (my $n = inet_aton($inet_a))){
  	    return inet_ntoauth($n);
  	} else {
  	    return undef;
  	}
      }
  }
  
  sub db_time
  {
      return unpack("N",substr($ip_db,0,4));
  }
  
  sub inet_ntoauth
  {
      my $inet_n = $_[1] || $_[0];
  
      my $pos = 4;
      my $byte_zero = substr($ip_db,$pos,1);
      # loop through bits of IP address
      for (my $i = 0; $i <= 31; $i++){
  
  	if (($inet_n & $mask[$i]) eq $mask[$i]){
  	    # bit[$i] is set [binary one]
  	    # - jump to next node
  	    # (start of child[1] node)
  	    if (($byte_zero & $bit1) eq $bit1){
  		$pos = $pos + 1 + unpack('N', $nullnullnull . ($byte_zero ^ $bit1));
  	    } else {
  		$pos = $pos + 3 + unpack('N', $null . substr($ip_db,$pos,3));
  	    }
  	} else {
  	    # bit[$i] is unset [binary zero]
  	    # jump to end of this node
  	    # (start of child[0] node)
  	    if (($byte_zero & $bit1) eq $bit1){
  		$pos = $pos + 1;
  	    } else {
  		$pos = $pos + 3;
  	    }
  	}
  	
  	# all terminal nodes of the tree start with zeroth bit 
  	# set to zero. the first bit can then be used to indicate
  	# whether we're using the first or second byte to store the
  	# country code
  	$byte_zero = substr($ip_db,$pos,1);
  	if (($byte_zero & $bit0) eq $bit0){ # country code
  	    if (($byte_zero & $bit1) eq $bit1){
  		# unpopular country code - stored in second byte
  		return $auth{substr($ip_db,$pos+1,1)};
  	    } else {
  		# popular country code - stored in bits 2-7
  		# (we already know that bit 1 is not set, so
  		# just need to unset bit 1)
  		return $auth{$byte_zero ^ $bit0};
  	    }
  	}
      }
  }
  
  1;
  __END__
  
  =head1 NAME
  
  IP::Authority - fast lookup of authority by IP address
  
  =head1 SYNOPSIS
  
    use IP::Authority;
    my $reg = IP::Authority->new();
    print $reg->inet_atoauth('212.67.197.128')   ."\n";
    print $reg->inet_atoauth('www.slashdot.org') ."\n";
  
  =head1 DESCRIPTION
  
  Historically, the former InterNIC  managed (under the auspices of IANA)
  the allocation of IP numbers to ISPs and other organizations. This changed
  somewhat when the Regional Internet Registry system was started, with the
  creation of three (and later, four) Regional Internet Registries (RIRs)
  around the world, each managing the allocation of IP addresses to 
  organizations within differing physical areas (see also RFC2050).
  
  This means that there is no central whois database for IP numbers.
  
  This module allows the user to lookup the RIR who has authority for a 
  particular IP address. After finding out the authority for an IP address,
  it is possible to use the authority's whois server to lookup the netblock owner.
  
  =head1 CONSTRUCTOR
  
  The constructor takes no arguments.
  
    use IP::Authority;
    my $reg = IP::Authority->new();
  
  =head1 OBJECT METHODS
  
  All object methods are designed to be used in an object-oriented fashion.
  
    $result = $object->foo_method($bar,$baz);
  
  Using the module in a procedural fashion (without the arrow syntax) won't work.
  
  =over 4
  
  =item $auth = $reg-E<gt>inet_atoauth(HOSTNAME)
  
  Takes a string giving the name of a host, and translates that to an
  two-letter string representing the regional Internet registry that has authority
  of that IP address:
  
    AR = ARIN (North America)
    RI = RIPE (Europe)
    LA = LACNIC (Latin America)
    AP = APNIC (Asia-Pacific)
    AF = AFRINIC (Africa and Indian Ocean)
    IA = IANA (see RFC3330)
    
  Takes arguments of both the 'rtfm.mit.edu' type and '18.181.0.24'. If the 
  host name cannot be resolved, returns undef. If the resolved IP address is not 
  contained within the database, returns undef. For multi-homed hosts (hosts 
  with more than one address), the first address found is returned.
  
  =item $auth = $reg-E<gt>inet_ntoauth(IP_ADDRESS)
  
  Takes a string (an opaque string as returned by Socket::inet_aton()) 
  and translates it into a two-letter string representing the regional Internet 
  registry that has authority of that IP address:
  
    AR = ARIN (North America)
    RI = RIPE (Europe)
    LA = LACNIC (Latin America)
    AP = APNIC (Asia-Pacific)
    AF = AFRINIC (Africa and Indian Ocean)
    IA = IANA (see RFC3330)
    
  If the IP address is not contained within the database, returns undef.
  
  =item $t = $reg-E<gt>db_time()
  
  Returns the creation date of the database, measured as number of seconds 
  since the Unix epoch (00:00:00 GMT, January 1, 1970). Suitable for feeding 
  to "gmtime" and "localtime".
  
  =back
  
  =head1 BUGS/LIMITATIONS
  
  Only works with IPv4 addresses and ASCII hostnames.
  
  =head1 SEE ALSO
  
  L<IP::Country> - fast lookup of country codes from IP address.
  
  L<http://www.apnic.net> - Asia-Pacific
  
  L<http://www.ripe.net> - Europe
  
  L<http://www.arin.net> - North America
  
  L<http://www.lacnic.net> - Latin America
  
  L<http://www.afrinic.net> - Africa and Indian Ocean
  
  =head1 COPYRIGHT
  
  Copyright (C) 2002-2005 Nigel Wetters Gourlay. All Rights Reserved.
  
  NO WARRANTY. This module is free software; you can redistribute 
  it and/or modify it under the same terms as Perl itself.
  
  Some parts of this software distribution are derived from the APNIC,
  LACNIC, ARIN, AFRINIC and RIPE databases (copyright details below).
  I am not a lawyer, so please direct questions about the RIR's 
  licenses to them, not me.
  
  =head1 APNIC conditions of use
  
  The files are freely available for download and use on the condition 
  that APNIC will not be held responsible for any loss or damage 
  arising from the application of the information contained in these 
  reports.
  
  APNIC endeavours to the best of its ability to ensure the accuracy 
  of these reports; however, APNIC makes no guarantee in this regard.
  
  In particular, it should be noted that these reports seek to 
  indicate the country where resources were first allocated or 
  assigned. It is not intended that these reports be considered 
  as an authoritative statement of the location in which any specific 
  resource may currently be in use.
  
  =head1 ARIN database copyright
  
  Copyright (c) American Registry for Internet Numbers. All rights reserved.
  
  The ARIN WHOIS data is for Internet operational or technical research
  purposes pertaining to Internet operations only.  It may not be used for
  advertising, direct marketing, marketing research, or similar purposes.
  Use of the ARIN WHOIS data for these activities is explicitly forbidden.
  ARIN requests to be notified of any such activities or suspicions thereof.
  
  =head1 RIPE database copyright
  
  The information in the RIPE Database is available to the public 
  for agreed Internet operation purposes, but is under copyright.
  The copyright statement is:
  
  "Except for agreed Internet operational purposes, no part of this 
  publication may be reproduced, stored in a retrieval system, or transmitted, 
  in any form or by any means, electronic, mechanical, recording, or 
  otherwise, without prior permission of the RIPE NCC on behalf of the 
  copyright holders. Any use of this material to target advertising 
  or similar activities is explicitly forbidden and may be prosecuted. 
  The RIPE NCC requests to be notified of any such activities or 
  suspicions thereof."
  
  =head1 LACNIC database copyright
  
  Copyright (c) Latin American and Caribbean IP address Regional Registry. All rights reserved.
  
  =head1 AFRINIC copyright
  
  Seems to be the RIPE copyright. I'm sure they'll correct this in due course.
  
  =cut
PERL5_IP_AUTHORITY

$fatpacked{"perl5/IP/Country.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_IP_COUNTRY';
  package IP::Country;
  use IP::Country::Fast;
  @IP::Country::ISA = qw ( IP::Country::Fast );
  $IP::Country::VERSION = '2.28';
  1;
  __END__
  
  =head1 NAME
  
  IP::Country - fast lookup of country codes from IP addresses
  
  =head1 SYNOPSIS
  
    use IP::Country::Fast;
    my $reg = IP::Country::Fast->new();
    print $reg->inet_atocc('212.67.197.128')   ."\n";
    print $reg->inet_atocc('www.slashdot.org') ."\n";
    print $reg->db_time() ."\n"; # revision date
  
  =head1 DESCRIPTION
  
  Finding the home country of a client using only the IP address can be difficult.
  Looking up the domain name associated with that address can provide some help,
  but many IP address are not reverse mapped to any useful domain, and the
  most common domain (.com) offers no help when looking for country.
  
  This module comes bundled with a database of countries where various IP addresses
  have been assigned. Although the country of assignment will probably be the
  country associated with a large ISP rather than the client herself, this is
  probably good enough for most log analysis applications, and under test has proved
  to be as accurate as reverse-DNS and WHOIS lookup.
  
  =head1 CONSTRUCTOR
  
  The constructor takes no arguments.
  
    use IP::Country::Fast;
    my $reg = IP::Country::Fast->new();
  
  =head1 OBJECT METHODS
  
  All object methods are designed to be used in an object-oriented fashion.
  
    $result = $object->foo_method($bar,$baz);
  
  Using the module in a procedural fashion (without the arrow syntax) won't work.
  
  =over 4
  
  =item $cc = $reg-E<gt>inet_atocc(HOSTNAME)
  
  Takes a string giving the name of a host, and translates that to an
  two-letter country code. Takes arguments of both the 'rtfm.mit.edu' 
  type and '18.181.0.24'. If the host name cannot be resolved, returns undef. 
  If the resolved IP address is not contained within the database, returns undef.
  For multi-homed hosts (hosts with more than one address), the first 
  address found is returned. For private Internet addresses (see RFC1918), 
  returns two asterisks '**'.
  
  =item $cc = $reg-E<gt>inet_ntocc(IP_ADDRESS)
  
  Takes a string (an opaque string as returned by Socket::inet_aton()) 
  and translates it into a two-letter country code. If the IP address is 
  not contained within the database, returns undef.
  
  =item $cc = $reg-E<gt>db_time()
  
  Returns the creation date of the database, measured as number of seconds 
  since the Unix epoch (00:00:00 GMT, January 1, 1970). Suitable for feeding 
  to "gmtime" and "localtime". When used with IP::Country::Medium or Slow objects,
  returns zero.
  
  =back
  
  =head1 PERFORMANCE
  
  With a random selection of 65,000 IP addresses, the module can look up
  over 15,000 IP addresses per second on a 730MHz PIII (Coppermine) and
  over 25,000 IP addresses per second on a 1.3GHz Athlon. Out of this random 
  selection of IP addresses, 43% had an associated country code. Please let 
  me know if you've run this against a set of 'real' IP addresses from your
  log files, and have details of the proportion of IPs that had associated
  country codes.
  
  =head1 IP::Country::Slow warning
  
  During tests of this module, it was found that there was no measurable advantage in using
  this module in preference to IP::Country::Medium or IP::Country::Fast. You should
  use IP::Country::Medium is the majority of your lookups are of the form 'rtfm.mit.edu'
  (domain names), and IP::Country::Fast if the majority of your lookups are of the form
  '18.181.0.24' (IP addresses).
  
  IP::Country::Medium caches domain-name lookups, whereas IP::Country::Fast does not.
  
  It is *very* rare for a domain-name lookup to differ from the database used by
  IP::Country::Fast. Thus, there is no good reason to prefer a slow domain-name 
  lookup to a fast database lookup. Nor is there any significant difference in
  coverage between the domain-name system and database. If you can find a real reason
  to use IP::Country::Slow, let me know.
  
  =head1 COUNTRY CODES
  
  You'll probably want some kind of country code -E<gt> country name conversion
  utility: you should use L<Geography::Countries> from CPAN.
  
  However, you should note the circumstances where the country code returned by
  IP::Country will deviate from those used by L<Geography::Countries>:
  
    AP - non-specific Asia-Pacific location
    CS - Czechoslovakia (former)
    EU - non-specific European Union location
    FX - France, Metropolitan
    PS - Palestinian Territory, Occupied
    ** - intranet address
    undef - not in database
  
  =head1 BUGS/LIMITATIONS
  
  Only works with IPv4 addresses and ASCII hostnames.
  
  =head1 SEE ALSO
  
  L<IP::Country::Fast> - recommended for lookups of hostnames which are mostly
  in the dotted-quad form ('213.45.67.89').
  
  L<IP::Country::Medium> - recommended for lookups of hostnames which are mostly
  in the domain-name form ('www.yahoo.com'). Caches domain-name lookups.
  
  L<IP::Country::Slow> - NOT RECOMMENDED. Only included for completeness. Prefers
  domain-name lookups to database lookups, which is an expensive strategy of
  no benefit.
  
  L<Geo::IP> - wrapper around the geoip C libraries. Less portable. Not measurably 
  faster than these native Perl modules. Paid subscription required for database
  updates.
  
  L<http://www.apnic.net> - Asia pacific
  
  L<http://www.ripe.net> - Europe
  
  L<http://www.arin.net> - North America
  
  L<http://www.lacnic.net> - Latin America
  
  L<http://www.afrinic.net> - Africa and Indian Ocean
  
  =head1 COPYRIGHT
  
  Copyright (C) 2002-2005 Nigel Wetters Gourlay. All Rights Reserved.
  
  NO WARRANTY. This module is free software; you can redistribute 
  it and/or modify it under the same terms as Perl itself.
  
  Some parts of this software distribution are derived from the APNIC,
  LACNIC, ARIN, AFRINIC and RIPE databases (copyright details below).
  I am not a lawyer, so please direct questions about the RIR's 
  licenses to them, not me.
  
  =head1 APNIC conditions of use
  
  The files are freely available for download and use on the condition 
  that APNIC will not be held responsible for any loss or damage 
  arising from the application of the information contained in these 
  reports.
  
  APNIC endeavours to the best of its ability to ensure the accuracy 
  of these reports; however, APNIC makes no guarantee in this regard.
  
  In particular, it should be noted that these reports seek to 
  indicate the country where resources were first allocated or 
  assigned. It is not intended that these reports be considered 
  as an authoritative statement of the location in which any specific 
  resource may currently be in use.
  
  =head1 ARIN database copyright
  
  Copyright (c) American Registry for Internet Numbers. All rights reserved.
  
  The ARIN WHOIS data is for Internet operational or technical research
  purposes pertaining to Internet operations only.  It may not be used for
  advertising, direct marketing, marketing research, or similar purposes.
  Use of the ARIN WHOIS data for these activities is explicitly forbidden.
  ARIN requests to be notified of any such activities or suspicions thereof.
  
  =head1 RIPE database copyright
  
  The information in the RIPE Database is available to the public 
  for agreed Internet operation purposes, but is under copyright.
  The copyright statement is:
  
  "Except for agreed Internet operational purposes, no part of this 
  publication may be reproduced, stored in a retrieval system, or transmitted, 
  in any form or by any means, electronic, mechanical, recording, or 
  otherwise, without prior permission of the RIPE NCC on behalf of the 
  copyright holders. Any use of this material to target advertising 
  or similar activities is explicitly forbidden and may be prosecuted. 
  The RIPE NCC requests to be notified of any such activities or 
  suspicions thereof."
  
  =head1 LACNIC database copyright
  
  Copyright (c) Latin American and Caribbean IP address Regional Registry. All rights reserved.
  
  =head1 AFRINIC copyright
  
  Seems to be the RIPE copyright. I'm sure they'll correct this in due course.
  
  =cut
PERL5_IP_COUNTRY

$fatpacked{"perl5/IP/Country/Fast.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_IP_COUNTRY_FAST';
  package IP::Country::Fast;
  use strict;
  use warnings;
  use Socket qw ( inet_aton );
  
  use vars qw ( $VERSION );
  $VERSION = '604.001'; # APR 2006, version 001
  
  my $singleton = undef;
  my $ip_db;
  my $null = substr(pack('N',0),0,1);
  my $nullnullnull = $null . $null . $null;
  my %cc;
  my $tld_match = qr/\.([a-zA-Z][a-zA-Z])$/o;
  my $ip_match = qr/^(\d|[01]?\d\d|2[0-4]\d|25[0-5])\.(\d|[01]?\d\d|2[0-4]\d|25[0-5])\.(\d|[01]?\d\d|2[0-4]\d|25[0-5])\.(\d|[01]?\d\d|2[0-4]\d|25[0-5])$/o;
  
  my $bit0;
  my $bit1;
  my @mask;
  my @dtoc;
  {
      $bit0 = substr(pack('N',2 ** 31),0,1);
      $bit1 = substr(pack('N',2 ** 30),0,1);
  
      for (my $i = 0; $i <= 31; $i++){
  	$mask[$i] = pack('N',2 ** (31 - $i));
      }
  
      for (my $i = 0; $i <= 255; $i++){
  	$dtoc[$i] = substr(pack('N',$i),3,1);
      }
      (my $module_dir = __FILE__) =~ s/\.pm$//;
  
      local $/;   # set it so <> reads all the file at once
  
      open (CC, "< $module_dir/cc.gif")
  	or die ("couldn't read country database: $!");
      binmode CC;
      my $cc_ultra = <CC>;  # read in the file
      close CC;
      my $cc_num = (length $cc_ultra) / 3;
      for (my $i = 0; $i < $cc_num; $i++){
  	my $cc = substr($cc_ultra,3 * $i + 1,2);
  	$cc = undef if ($cc eq '--');
  	$cc{substr($cc_ultra,3 * $i,1)} = $cc;
      }
  
      open (IP, "< $module_dir/ip.gif")
  	or die ("couldn't read IP database: $!");
      binmode IP;
      $ip_db = <IP>;
      close IP;
  }
  
  sub new ()
  {
      my $caller = shift;
      unless (defined $singleton){
          my $class = ref($caller) || $caller;
  	$singleton = bless {}, $class;
      }
      return $singleton;
  }
  
  sub db_time
  {
      return unpack("N",substr($ip_db,0,4));
  }
  
  sub inet_atocc
  {
      my $inet_a = $_[1];
      if ($inet_a =~ $ip_match){
  	return inet_ntocc($dtoc[$1].$dtoc[$2].$dtoc[$3].$dtoc[$4]);
      } else {
  	if (defined (my $n = inet_aton($inet_a))){
  	    return inet_ntocc($n);
  	} else {
  	    return undef;
  	}
      }
  }
  
  sub inet_ntocc
  {
      # FORMATTING OF EACH NODE IN $ip_db
      # bit0 - true if this is a country code, false if this
      #        is a jump to the next node
      #
      # country codes:
      #   bit1 - true if the country code is stored in bits 2-7
      #          of this byte, false if the country code is
      #          stored in bits 0-7 of the next byte
      #   bits 2-7 or bits 0-7 of next byte contain country code
      #
      # jumps:
      #   bytes 0-3 jump distance (only first byte used if
      #          distance < 64)
  
      my $inet_n = $_[1] || $_[0];
  
      my $pos = 4;
      my $byte_zero = substr($ip_db,$pos,1);
      # loop through bits of IP address
      for (my $i = 0; $i <= 31; $i++){
  
  	if (($inet_n & $mask[$i]) eq $mask[$i]){
  	    # bit[$i] is set [binary one]
  	    # - jump to next node
  	    # (start of child[1] node)
  	    if (($byte_zero & $bit1) eq $bit1){
  		$pos = $pos + 1 + unpack('N', $nullnullnull . ($byte_zero ^ $bit1));
  	    } else {
  		$pos = $pos + 3 + unpack('N', $null . substr($ip_db,$pos,3));
  	    }
  	} else {
  	    # bit[$i] is unset [binary zero]
  	    # jump to end of this node
  	    # (start of child[0] node)
  	    if (($byte_zero & $bit1) eq $bit1){
  		$pos = $pos + 1;
  	    } else {
  		$pos = $pos + 3;
  	    }
  	}
  	
  	# all terminal nodes of the tree start with zeroth bit 
  	# set to zero. the first bit can then be used to indicate
  	# whether we're using the first or second byte to store the
  	# country code
  	$byte_zero = substr($ip_db,$pos,1);
  	if (($byte_zero & $bit0) eq $bit0){ # country code
  	    if (($byte_zero & $bit1) eq $bit1){
  		# unpopular country code - stored in second byte
  		return $cc{substr($ip_db,$pos+1,1)};
  	    } else {
  		# popular country code - stored in bits 2-7
  		# (we already know that bit 1 is not set, so
  		# just need to unset bit 1)
  		return $cc{$byte_zero ^ $bit0};
  	    }
  	}
      }
  }
  
  1;
  __END__
  
  =head1 NAME
  
  IP::Country::Fast - fast lookup of country codes by IP address
  
  =head1 SYNOPSIS
  
    use IP::Country::Fast;
  
  =head1 DESCRIPTION
  
  See documentation for IP::Country.
  
  =cut
PERL5_IP_COUNTRY_FAST

$fatpacked{"perl5/IP/Country/MaxMind.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_IP_COUNTRY_MAXMIND';
  package IP::Country::MaxMind;
  use strict;
  use warnings;
  use Socket qw ( inet_ntoa );
  
  use vars qw ( @ISA $VERSION @EXPORT );
  require Exporter;
  
  $VERSION = 1.0;
  
  @ISA = qw( Exporter );
  @EXPORT = qw( GEOIP_STANDARD GEOIP_MEMORY_CACHE GEOIP_CHECK_CACHE );
  
  my $MM;
  BEGIN
  {
      eval 'use Geo::IP';
      if($@){
  	eval 'use Geo::IP::PurePerl';
  	if($@){
  	    die($@);
  	} else {
  	    $MM = 'Geo::IP::PurePerl';
  	}
      } else {
  	$MM = 'Geo::IP';
      }
  }
  
  my $ip_match = qr/^(\d|[01]?\d\d|2[0-4]\d|25[0-5])\.(\d|[01]?\d\d|2[0-4]\d|25[0-5])\.(\d|[01]?\d\d|2[0-4]\d|25[0-5])\.(\d|[01]?\d\d|2[0-4]\d|25[0-5])$/o;
  
  sub new
  {
      my($caller,$flags) = @_;
      my $class = ref($caller) || $caller;
      $flags = GEOIP_STANDARD unless (defined $flags);
      my $gi;
      eval "\$gi = $MM->new(\$flags)";
      die($@) if $@;
      bless \$gi,$class;
  }
  
  sub open
  {
      my($caller,$database_filename,$flags) = @_;
      my $class = ref($caller) || $caller;
      $flags = GEOIP_STANDARD unless (defined $flags);
      my $gi;
      eval "\$gi = $MM->open(\$database_filename,\$flags)";
      die($@) if $@;
      bless \$gi,$class;
  }
  
  sub inet_atocc
  {
      my ($gi,$host) = (${$_[0]},$_[1]);
      if($host=~$ip_match){
  	return $gi->country_code_by_addr($host);
      } else {
  	return $gi->country_code_by_name($host);
      }
  }
  
  sub inet_ntocc
  {
      return ${$_[0]}->country_code_by_addr(inet_ntoa($_[1]));
  }
  
  sub db_time
  {
      return 0;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  IP::Country::MaxMind - Look up country by IP Address
  
  =head1 SYNOPSIS
  
    use IP::Country::MaxMind;
  
    my $gi = IP::Country::MaxMind->new(GEOIP_STANDARD);
  
    # look up IP address '65.15.30.247'
    # returns undef if country is unallocated, or not defined in our database
    my $cc1 = $gi->inet_atocc('65.15.30.247');
    my $cc2 = $gi->inet_atocc('yahoo.com');
  
  =head1 DESCRIPTION
  
  This module adapts the Geo::IP module to use the same interface as the IP::Country
  modules; thus allowing users to easily switch between using the two underlying
  databases.
  
  =head1 DATABASE UPDATES
  
  Free monthly updates to the database are available from 
  
    http://www.maxmind.com/download/geoip/database/
  
  If you require greater accuracy, MaxMind offers a Premium database on a paid 
  subscription basis.
  
  The author of this module is in no way associated with MaxMind.
  
  =head1 CLASS METHODS
  
  =over 4
  
  =item $gi = IP::Country::MaxMind-E<gt>new( $flags );
  
  Constructs a new IP::Country::MaxMind object with the default database located 
  inside your system's I<datadir>, typically I</usr/local/share/GeoIP/GeoIP.dat>.
  
  Flags can be set to either GEOIP_STANDARD, or for faster performance
  (at a cost of using more memory), GEOIP_MEMORY_CACHE.  When using memory
  cache you can force a reload if the file is updated by setting GEOIP_CHECK_CACHE.
  
  =item $gi = IP::Country::MaxMind-E<gt>open( $database_filename, $flags );
  
  Constructs a new Geo::IP object with the database located at C<$database_filename>.
  
  =back
  
  =head1 OBJECT METHODS
  
  All object methods are designed to be used in an object-oriented fashion.
  
    $result = $object->foo_method($bar,$baz);
  
  Using the module in a procedural fashion (without the arrow syntax) won't work.
  
  =over 4
  
  =item $cc = $gi-E<gt>inet_atocc(HOSTNAME)
  
  Takes a string giving the name of a host, and translates that to an
  two-letter country code. Takes arguments of both the 'rtfm.mit.edu' 
  type and '18.181.0.24'. If the host name cannot be resolved, returns undef. 
  If the resolved IP address is not contained within the database, returns undef.
  
  =item $cc = $gi-E<gt>inet_ntocc(IP_ADDRESS)
  
  Takes a string (an opaque string as returned by Socket::inet_aton()) 
  and translates it into a two-letter country code. If the IP address is 
  not contained within the database, returns undef.
  
  =item $cc = $gi-E<gt>db_time()
  
  Returns zero. For compatibility only.
  
  =back
  
  
  =head1 COPYRIGHT
  
  Copyright (C) 2002,2003 Nigel Wetters Gourlay. All Rights Reserved.
  
  NO WARRANTY. This module is free software; you can redistribute 
  it and/or modify it under the same terms as Perl itself.
  
  =cut
PERL5_IP_COUNTRY_MAXMIND

$fatpacked{"perl5/IP/Country/Medium.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_IP_COUNTRY_MEDIUM';
  package IP::Country::Medium;
  use strict;
  use Carp;
  use Socket qw ( inet_aton inet_ntoa AF_INET );
  use IP::Country::Fast;
  
  use vars qw ( $VERSION );
  $VERSION = '0.05';
  
  my $singleton = undef;
  
  my $ip_match = qr/^(\d|[01]?\d\d|2[0-4]\d|25[0-5])\.(\d|[01]?\d\d|2[0-4]\d|25[0-5])\.(\d|[01]?\d\d|2[0-4]\d|25[0-5])\.(\d|[01]?\d\d|2[0-4]\d|25[0-5])$/o;
  my $private_ip = qr/^(10\.|172\.(1[6-9]|2\d|3[01])\.|192\.168\.)/o; # RFC1918
  my $tld_match = qr/\.([a-zA-Z][a-zA-Z])$/o;
  
  my %cache;
  my $cache = 1; # cache is switched on
  
  sub new
  {
      my $caller = shift;
      unless (defined $singleton){
          my $class = ref($caller) || $caller;
  	$singleton = bless {}, $class;
      }
      return $singleton;
  }
  
  sub cache
  {
      my $bool = defined $_[1] ? $_[1] : $_[0];
      if ($bool){
  	$cache = 1;
      } else {
  	$cache = 0;
  	%cache = ();
      }
  }
  
  sub db_time
  {
      return 0;
  }
  
  sub inet_atocc
  {
      my $hostname = $_[1] || $_[0];
      if ($hostname =~ $ip_match){
  	# IP address
  	return inet_ntocc(inet_aton($hostname));
      } else {
  	# assume domain name
  	if ($cache && exists $cache{$hostname}){
  	    return $cache{$hostname};
  	} else {
  	    if ($hostname =~ $tld_match){
  		return uc($1);
  	    } else {
  		my $cc =  IP::Country::Fast::inet_atocc($hostname);
  		$cache{$hostname} = $cc if $cache;
  		return $cc;
  	    }
  	}
      }
  }
  
  sub inet_ntocc
  {
      my $ip_addr = $_[1] || $_[0];
      if ($cache && exists $cache{$ip_addr}){
  	return $cache{$ip_addr};
      } else {
  	my $ip_dotted = inet_ntoa($ip_addr);
  	return undef if ($ip_dotted =~ $private_ip);
  
  	if (my $cc = IP::Country::Fast::inet_ntocc($ip_addr)){
  	    return $cc;
  	} elsif (gethostbyaddr($ip_addr, AF_INET) =~ $tld_match){
  	    my $cc = uc($1);
  	    $cache{$ip_addr} = $cc if $cache;
  	    return $cc;
  	} else {
  	}
      }
      return undef;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  IP::Country::Medium - cached lookup of country codes by IP address and domain name
  
  =head1 SYNOPSIS
  
    use IP::Country::Medium;
  
  =head1 DESCRIPTION
  
  See documentation for IP::Country. In addition, IP::Country::Medium objects have
  a cache() method, which controls whether hostname->cc lookups are cached (on by
  default).
  
  =over 4
  
  =item $ic-E<gt>cache(BOOLEAN)
  
  By default, the module caches results of country-code lookups. This feature 
  can be switched off by setting cache to a false value (zero, empty string or 
  undef), and can be switched on again by setting cache to a true value (anything
  which isn't false).
  
    $ic->cache(0); # clears and disables cache
    $ic->cache(1); # enables the cache
  
  The cache is formed at the class level, so any change in caching in one object
  will affect all objectcs of this class. Turning off the cache also clears the
  cache.
  
  =back
  
  =cut
PERL5_IP_COUNTRY_MEDIUM

$fatpacked{"perl5/IP/Country/Slow.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_IP_COUNTRY_SLOW';
  package IP::Country::Slow;
  use strict;
  use Carp;
  use Socket qw ( inet_aton inet_ntoa AF_INET );
  use IP::Country::Fast;
  
  use vars qw ( $VERSION );
  $VERSION = '0.04';
  
  my $singleton = undef;
  
  my $ip_match = qr/^(\d|[01]?\d\d|2[0-4]\d|25[0-5])\.(\d|[01]?\d\d|2[0-4]\d|25[0-5])\.(\d|[01]?\d\d|2[0-4]\d|25[0-5])\.(\d|[01]?\d\d|2[0-4]\d|25[0-5])$/o;
  my $private_ip = qr/^(10\.|172\.(1[6-9]|2\d|3[01])\.|192\.168\.)/o; # RFC1918
  my $tld_match = qr/\.([a-zA-Z][a-zA-Z])$/o;
  
  my %cache;
  my $cache = 1; # cache is switched on
  
  sub new
  {
      my $caller = shift;
      unless (defined $singleton){
          my $class = ref($caller) || $caller;
  	$singleton = bless {}, $class;
      }
      return $singleton;
  }
  
  sub db_time
  {
       return 0;
  }
  
  sub cache
  {
      my $bool = defined $_[1] ? $_[1] : $_[0];
      if ($bool){
  	$cache = 1;
      } else {
  	$cache = 0;
  	%cache = ();
      }
  }
  
  sub inet_atocc
  {
      my $hostname = $_[1] || $_[0];
      if ($hostname =~ $ip_match){
  	# IP address
  	return inet_ntocc(inet_aton($hostname));
      } else {
  	# assume domain name
  	if ($cache && exists $cache{$hostname}){
  	    return $cache{$hostname};
  	} else {
  	    if (my $cc = _get_cc_from_tld($hostname)){
  		return $cc;
  	    } else {
  		my $cc =  IP::Country::Fast::inet_atocc($hostname);
  		$cache{$hostname} = $cc if $cache;
  		return $cc;
  	    }
  	}
      }
  }
  
  sub inet_ntocc
  {
      my $ip_addr = $_[1] || $_[0];
      if ($cache && exists $cache{$ip_addr}){
  	return $cache{$ip_addr};
      } else {
  	my $ip_dotted = inet_ntoa($ip_addr);
  	return undef if $ip_dotted =~ $private_ip;
  	if (my $hostname = gethostbyaddr($ip_addr, AF_INET)){
  	    if (my $cc = _get_cc_from_tld($hostname)){
  		$cache{$ip_addr} = $cc if $cache;
  		return $cc;
  	    }
  	}
  	my $cc = IP::Country::Fast::inet_ntocc($ip_addr);
  	$cache{$ip_addr} = $cc if $cache;
  	return $cc;
      }
  }
  
  sub _get_cc_from_tld ($)
  {
      my $hostname = shift;
      if ($hostname =~ $tld_match){
  	return uc $1;
      } else {
  	return undef;
      }
  }
  
  
  1;
  __END__
  
  =head1 NAME
  
  IP::Country::Slow - cached lookup of country codes by domain name and IP address
  
  =cut
PERL5_IP_COUNTRY_SLOW

$fatpacked{"perl5/Memoize.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_MEMOIZE';
  # -*- mode: perl; perl-indent-level: 2; -*-
  # Memoize.pm
  #
  # Transparent memoization of idempotent functions
  #
  # Copyright 1998, 1999, 2000, 2001, 2012 M. J. Dominus.
  # You may copy and distribute this program under the
  # same terms as Perl itself.  If in doubt, 
  # write to mjd-perl-memoize+@plover.com for a license.
  
  package Memoize;
  $VERSION = '1.03';
  
  # Compile-time constants
  sub SCALAR () { 0 } 
  sub LIST () { 1 } 
  
  
  #
  # Usage memoize(functionname/ref,
  #               { NORMALIZER => coderef, INSTALL => name,
  #                 LIST_CACHE => descriptor, SCALAR_CACHE => descriptor }
  #
  
  use Carp;
  use Exporter;
  use vars qw($DEBUG);
  use Config;                     # Dammit.
  @ISA = qw(Exporter);
  @EXPORT = qw(memoize);
  @EXPORT_OK = qw(unmemoize flush_cache);
  use strict;
  
  my %memotable;
  my %revmemotable;
  my @CONTEXT_TAGS = qw(MERGE TIE MEMORY FAULT HASH);
  my %IS_CACHE_TAG = map {($_ => 1)} @CONTEXT_TAGS;
  
  # Raise an error if the user tries to specify one of thesepackage as a
  # tie for LIST_CACHE
  
  my %scalar_only = map {($_ => 1)} qw(DB_File GDBM_File SDBM_File ODBM_File NDBM_File);
  
  sub memoize {
    my $fn = shift;
    my %options = @_;
    my $options = \%options;
    
    unless (defined($fn) && 
  	  (ref $fn eq 'CODE' || ref $fn eq '')) {
      croak "Usage: memoize 'functionname'|coderef {OPTIONS}";
    }
  
    my $uppack = caller;		# TCL me Elmo!
    my $cref;			# Code reference to original function
    my $name = (ref $fn ? undef : $fn);
  
    # Convert function names to code references
    $cref = &_make_cref($fn, $uppack);
  
    # Locate function prototype, if any
    my $proto = prototype $cref;
    if (defined $proto) { $proto = "($proto)" }
    else { $proto = "" }
  
    # I would like to get rid of the eval, but there seems not to be any
    # other way to set the prototype properly.  The switch here for
    # 'usethreads' works around a bug in threadperl having to do with
    # magic goto.  It would be better to fix the bug and use the magic
    # goto version everywhere.
    my $wrapper = 
        $Config{usethreads} 
          ? eval "sub $proto { &_memoizer(\$cref, \@_); }" 
          : eval "sub $proto { unshift \@_, \$cref; goto &_memoizer; }";
  
    my $normalizer = $options{NORMALIZER};
    if (defined $normalizer  && ! ref $normalizer) {
      $normalizer = _make_cref($normalizer, $uppack);
    }
    
    my $install_name;
    if (defined $options->{INSTALL}) {
      # INSTALL => name
      $install_name = $options->{INSTALL};
    } elsif (! exists $options->{INSTALL}) {
      # No INSTALL option provided; use original name if possible
      $install_name = $name;
    } else {
      # INSTALL => undef  means don't install
    }
  
    if (defined $install_name) {
      $install_name = $uppack . '::' . $install_name
  	unless $install_name =~ /::/;
      no strict;
      local($^W) = 0;	       # ``Subroutine $install_name redefined at ...''
      *{$install_name} = $wrapper; # Install memoized version
    }
  
    $revmemotable{$wrapper} = "" . $cref; # Turn code ref into hash key
  
    # These will be the caches
    my %caches;
    for my $context (qw(SCALAR LIST)) {
      # suppress subsequent 'uninitialized value' warnings
      $options{"${context}_CACHE"} ||= ''; 
  
      my $cache_opt = $options{"${context}_CACHE"};
      my @cache_opt_args;
      if (ref $cache_opt) {
        @cache_opt_args = @$cache_opt;
        $cache_opt = shift @cache_opt_args;
      }
      if ($cache_opt eq 'FAULT') { # no cache
        $caches{$context} = undef;
      } elsif ($cache_opt eq 'HASH') { # user-supplied hash
        my $cache = $cache_opt_args[0];
        my $package = ref(tied %$cache);
        if ($context eq 'LIST' && $scalar_only{$package}) {
          croak("You can't use $package for LIST_CACHE because it can only store scalars");
        }
        $caches{$context} = $cache;
      } elsif ($cache_opt eq '' ||  $IS_CACHE_TAG{$cache_opt}) {
        # default is that we make up an in-memory hash
        $caches{$context} = {};
        # (this might get tied later, or MERGEd away)
      } else {
        croak "Unrecognized option to `${context}_CACHE': `$cache_opt' should be one of (@CONTEXT_TAGS); aborting";
      }
    }
  
    # Perhaps I should check here that you didn't supply *both* merge
    # options.  But if you did, it does do something reasonable: They
    # both get merged to the same in-memory hash.
    if ($options{SCALAR_CACHE} eq 'MERGE' || $options{LIST_CACHE} eq 'MERGE') {
      $options{MERGED} = 1;
      $caches{SCALAR} = $caches{LIST};
    }
  
    # Now deal with the TIE options
    {
      my $context;
      foreach $context (qw(SCALAR LIST)) {
        # If the relevant option wasn't `TIE', this call does nothing.
        _my_tie($context, $caches{$context}, $options);  # Croaks on failure
      }
    }
    
    # We should put some more stuff in here eventually.
    # We've been saying that for serveral versions now.
    # And you know what?  More stuff keeps going in!
    $memotable{$cref} = 
    {
      O => $options,  # Short keys here for things we need to access frequently
      N => $normalizer,
      U => $cref,
      MEMOIZED => $wrapper,
      PACKAGE => $uppack,
      NAME => $install_name,
      S => $caches{SCALAR},
      L => $caches{LIST},
    };
  
    $wrapper			# Return just memoized version
  }
  
  # This function tries to load a tied hash class and tie the hash to it.
  sub _my_tie {
    my ($context, $hash, $options) = @_;
    my $fullopt = $options->{"${context}_CACHE"};
  
    # We already checked to make sure that this works.
    my $shortopt = (ref $fullopt) ? $fullopt->[0] : $fullopt;
    
    return unless defined $shortopt && $shortopt eq 'TIE';
    carp("TIE option to memoize() is deprecated; use HASH instead")
        if $^W;
  
    my @args = ref $fullopt ? @$fullopt : ();
    shift @args;
    my $module = shift @args;
    if ($context eq 'LIST' && $scalar_only{$module}) {
      croak("You can't use $module for LIST_CACHE because it can only store scalars");
    }
    my $modulefile = $module . '.pm';
    $modulefile =~ s{::}{/}g;
    eval { require $modulefile };
    if ($@) {
      croak "Memoize: Couldn't load hash tie module `$module': $@; aborting";
    }
    my $rc = (tie %$hash => $module, @args);
    unless ($rc) {
      croak "Memoize: Couldn't tie hash to `$module': $!; aborting";
    }
    1;
  }
  
  sub flush_cache {
    my $func = _make_cref($_[0], scalar caller);
    my $info = $memotable{$revmemotable{$func}};
    die "$func not memoized" unless defined $info;
    for my $context (qw(S L)) {
      my $cache = $info->{$context};
      if (tied %$cache && ! (tied %$cache)->can('CLEAR')) {
        my $funcname = defined($info->{NAME}) ? 
            "function $info->{NAME}" : "anonymous function $func";
        my $context = {S => 'scalar', L => 'list'}->{$context};
        croak "Tied cache hash for $context-context $funcname does not support flushing";
      } else {
        %$cache = ();
      }
    }
  }
  
  # This is the function that manages the memo tables.
  sub _memoizer {
    my $orig = shift;		# stringized version of ref to original func.
    my $info = $memotable{$orig};
    my $normalizer = $info->{N};
    
    my $argstr;
    my $context = (wantarray() ? LIST : SCALAR);
  
    if (defined $normalizer) { 
      no strict;
      if ($context == SCALAR) {
        $argstr = &{$normalizer}(@_);
      } elsif ($context == LIST) {
        ($argstr) = &{$normalizer}(@_);
      } else {
        croak "Internal error \#41; context was neither LIST nor SCALAR\n";
      }
    } else {                      # Default normalizer
      local $^W = 0;
      $argstr = join chr(28),@_;  
    }
  
    if ($context == SCALAR) {
      my $cache = $info->{S};
      _crap_out($info->{NAME}, 'scalar') unless $cache;
      if (exists $cache->{$argstr}) { 
        return $info->{O}{MERGED}
          ? $cache->{$argstr}[0] : $cache->{$argstr};
      } else {
        my $val = &{$info->{U}}(@_);
        # Scalars are considered to be lists; store appropriately
        if ($info->{O}{MERGED}) {
  	$cache->{$argstr} = [$val];
        } else {
  	$cache->{$argstr} = $val;
        }
        $val;
      }
    } elsif ($context == LIST) {
      my $cache = $info->{L};
      _crap_out($info->{NAME}, 'list') unless $cache;
      if (exists $cache->{$argstr}) {
        return @{$cache->{$argstr}};
      } else {
        my @q = &{$info->{U}}(@_);
        $cache->{$argstr} = \@q;
        @q;
      }
    } else {
      croak "Internal error \#42; context was neither LIST nor SCALAR\n";
    }
  }
  
  sub unmemoize {
    my $f = shift;
    my $uppack = caller;
    my $cref = _make_cref($f, $uppack);
  
    unless (exists $revmemotable{$cref}) {
      croak "Could not unmemoize function `$f', because it was not memoized to begin with";
    }
    
    my $tabent = $memotable{$revmemotable{$cref}};
    unless (defined $tabent) {
      croak "Could not figure out how to unmemoize function `$f'";
    }
    my $name = $tabent->{NAME};
    if (defined $name) {
      no strict;
      local($^W) = 0;	       # ``Subroutine $install_name redefined at ...''
      *{$name} = $tabent->{U}; # Replace with original function
    }
    undef $memotable{$revmemotable{$cref}};
    undef $revmemotable{$cref};
  
    # This removes the last reference to the (possibly tied) memo tables
    # my ($old_function, $memotabs) = @{$tabent}{'U','S','L'};
    # undef $tabent; 
  
  #  # Untie the memo tables if they were tied.
  #  my $i;
  #  for $i (0,1) {
  #    if (tied %{$memotabs->[$i]}) {
  #      warn "Untying hash #$i\n";
  #      untie %{$memotabs->[$i]};
  #    }
  #  }
  
    $tabent->{U};
  }
  
  sub _make_cref {
    my $fn = shift;
    my $uppack = shift;
    my $cref;
    my $name;
  
    if (ref $fn eq 'CODE') {
      $cref = $fn;
    } elsif (! ref $fn) {
      if ($fn =~ /::/) {
        $name = $fn;
      } else {
        $name = $uppack . '::' . $fn;
      }
      no strict;
      if (defined $name and !defined(&$name)) {
        croak "Cannot operate on nonexistent function `$fn'";
      }
  #    $cref = \&$name;
      $cref = *{$name}{CODE};
    } else {
      my $parent = (caller(1))[3]; # Function that called _make_cref
      croak "Usage: argument 1 to `$parent' must be a function name or reference.\n";
    }
    $DEBUG and warn "${name}($fn) => $cref in _make_cref\n";
    $cref;
  }
  
  sub _crap_out {
    my ($funcname, $context) = @_;
    if (defined $funcname) {
      croak "Function `$funcname' called in forbidden $context context; faulting";
    } else {
      croak "Anonymous function called in forbidden $context context; faulting";
    }
  }
  
  1;
  
  
  
  
  
  =head1 NAME
  
  Memoize - Make functions faster by trading space for time
  
  =head1 SYNOPSIS
  
          # This is the documentation for Memoize 1.03
  	use Memoize;
  	memoize('slow_function');
  	slow_function(arguments);    # Is faster than it was before
  
  
  This is normally all you need to know.  However, many options are available:
  
  	memoize(function, options...);
  
  Options include:
  
  	NORMALIZER => function
  	INSTALL => new_name
  
  	SCALAR_CACHE => 'MEMORY'
          SCALAR_CACHE => ['HASH', \%cache_hash ]
  	SCALAR_CACHE => 'FAULT'
  	SCALAR_CACHE => 'MERGE'
  
  	LIST_CACHE => 'MEMORY'
          LIST_CACHE => ['HASH', \%cache_hash ]
  	LIST_CACHE => 'FAULT'
  	LIST_CACHE => 'MERGE'
  
  =head1 DESCRIPTION
  
  `Memoizing' a function makes it faster by trading space for time.  It
  does this by caching the return values of the function in a table.
  If you call the function again with the same arguments, C<memoize>
  jumps in and gives you the value out of the table, instead of letting
  the function compute the value all over again.
  
  Here is an extreme example.  Consider the Fibonacci sequence, defined
  by the following function:
  
  	# Compute Fibonacci numbers
  	sub fib {
  	  my $n = shift;
  	  return $n if $n < 2;
  	  fib($n-1) + fib($n-2);
  	}
  
  This function is very slow.  Why?  To compute fib(14), it first wants
  to compute fib(13) and fib(12), and add the results.  But to compute
  fib(13), it first has to compute fib(12) and fib(11), and then it
  comes back and computes fib(12) all over again even though the answer
  is the same.  And both of the times that it wants to compute fib(12),
  it has to compute fib(11) from scratch, and then it has to do it
  again each time it wants to compute fib(13).  This function does so
  much recomputing of old results that it takes a really long time to
  run---fib(14) makes 1,200 extra recursive calls to itself, to compute
  and recompute things that it already computed.
  
  This function is a good candidate for memoization.  If you memoize the
  `fib' function above, it will compute fib(14) exactly once, the first
  time it needs to, and then save the result in a table.  Then if you
  ask for fib(14) again, it gives you the result out of the table.
  While computing fib(14), instead of computing fib(12) twice, it does
  it once; the second time it needs the value it gets it from the table.
  It doesn't compute fib(11) four times; it computes it once, getting it
  from the table the next three times.  Instead of making 1,200
  recursive calls to `fib', it makes 15.  This makes the function about
  150 times faster.
  
  You could do the memoization yourself, by rewriting the function, like
  this:
  
  	# Compute Fibonacci numbers, memoized version
  	{ my @fib;
    	  sub fib {
  	    my $n = shift;
  	    return $fib[$n] if defined $fib[$n];
  	    return $fib[$n] = $n if $n < 2;
  	    $fib[$n] = fib($n-1) + fib($n-2);
  	  }
          }
  
  Or you could use this module, like this:
  
  	use Memoize;
  	memoize('fib');
  
  	# Rest of the fib function just like the original version.
  
  This makes it easy to turn memoizing on and off.
  
  Here's an even simpler example: I wrote a simple ray tracer; the
  program would look in a certain direction, figure out what it was
  looking at, and then convert the `color' value (typically a string
  like `red') of that object to a red, green, and blue pixel value, like
  this:
  
      for ($direction = 0; $direction < 300; $direction++) {
        # Figure out which object is in direction $direction
        $color = $object->{color};
        ($r, $g, $b) = @{&ColorToRGB($color)};
        ...
      }
  
  Since there are relatively few objects in a picture, there are only a
  few colors, which get looked up over and over again.  Memoizing
  C<ColorToRGB> sped up the program by several percent.
  
  =head1 DETAILS
  
  This module exports exactly one function, C<memoize>.  The rest of the
  functions in this package are None of Your Business.
  
  You should say
  
  	memoize(function)
  
  where C<function> is the name of the function you want to memoize, or
  a reference to it.  C<memoize> returns a reference to the new,
  memoized version of the function, or C<undef> on a non-fatal error.
  At present, there are no non-fatal errors, but there might be some in
  the future.
  
  If C<function> was the name of a function, then C<memoize> hides the
  old version and installs the new memoized version under the old name,
  so that C<&function(...)> actually invokes the memoized version.
  
  =head1 OPTIONS
  
  There are some optional options you can pass to C<memoize> to change
  the way it behaves a little.  To supply options, invoke C<memoize>
  like this:
  
  	memoize(function, NORMALIZER => function,
  			  INSTALL => newname,
                            SCALAR_CACHE => option,
  	                  LIST_CACHE => option
  			 );
  
  Each of these options is optional; you can include some, all, or none
  of them.
  
  =head2 INSTALL
  
  If you supply a function name with C<INSTALL>, memoize will install
  the new, memoized version of the function under the name you give.
  For example, 
  
  	memoize('fib', INSTALL => 'fastfib')
  
  installs the memoized version of C<fib> as C<fastfib>; without the
  C<INSTALL> option it would have replaced the old C<fib> with the
  memoized version.  
  
  To prevent C<memoize> from installing the memoized version anywhere, use
  C<INSTALL =E<gt> undef>.
  
  =head2 NORMALIZER
  
  Suppose your function looks like this:
  
  	# Typical call: f('aha!', A => 11, B => 12);
  	sub f {
  	  my $a = shift;
  	  my %hash = @_;
  	  $hash{B} ||= 2;  # B defaults to 2
  	  $hash{C} ||= 7;  # C defaults to 7
  
  	  # Do something with $a, %hash
  	}
  
  Now, the following calls to your function are all completely equivalent:
  
  	f(OUCH);
  	f(OUCH, B => 2);
  	f(OUCH, C => 7);
  	f(OUCH, B => 2, C => 7);
  	f(OUCH, C => 7, B => 2);
  	(etc.)
  
  However, unless you tell C<Memoize> that these calls are equivalent,
  it will not know that, and it will compute the values for these
  invocations of your function separately, and store them separately.
  
  To prevent this, supply a C<NORMALIZER> function that turns the
  program arguments into a string in a way that equivalent arguments
  turn into the same string.  A C<NORMALIZER> function for C<f> above
  might look like this:
  
  	sub normalize_f {
  	  my $a = shift;
  	  my %hash = @_;
  	  $hash{B} ||= 2;
  	  $hash{C} ||= 7;
  
  	  join(',', $a, map ($_ => $hash{$_}) sort keys %hash);
  	}
  
  Each of the argument lists above comes out of the C<normalize_f>
  function looking exactly the same, like this:
  
  	OUCH,B,2,C,7
  
  You would tell C<Memoize> to use this normalizer this way:
  
  	memoize('f', NORMALIZER => 'normalize_f');
  
  C<memoize> knows that if the normalized version of the arguments is
  the same for two argument lists, then it can safely look up the value
  that it computed for one argument list and return it as the result of
  calling the function with the other argument list, even if the
  argument lists look different.
  
  The default normalizer just concatenates the arguments with character
  28 in between.  (In ASCII, this is called FS or control-\.)  This
  always works correctly for functions with only one string argument,
  and also when the arguments never contain character 28.  However, it
  can confuse certain argument lists:
  
  	normalizer("a\034", "b")
  	normalizer("a", "\034b")
  	normalizer("a\034\034b")
  
  for example.
  
  Since hash keys are strings, the default normalizer will not
  distinguish between C<undef> and the empty string.  It also won't work
  when the function's arguments are references.  For example, consider a
  function C<g> which gets two arguments: A number, and a reference to
  an array of numbers:
  
  	g(13, [1,2,3,4,5,6,7]);
  
  The default normalizer will turn this into something like
  C<"13\034ARRAY(0x436c1f)">.  That would be all right, except that a
  subsequent array of numbers might be stored at a different location
  even though it contains the same data.  If this happens, C<Memoize>
  will think that the arguments are different, even though they are
  equivalent.  In this case, a normalizer like this is appropriate:
  
  	sub normalize { join ' ', $_[0], @{$_[1]} }
  
  For the example above, this produces the key "13 1 2 3 4 5 6 7".
  
  Another use for normalizers is when the function depends on data other
  than those in its arguments.  Suppose you have a function which
  returns a value which depends on the current hour of the day:
  
  	sub on_duty {
            my ($problem_type) = @_;
  	  my $hour = (localtime)[2];
            open my $fh, "$DIR/$problem_type" or die...;
            my $line;
            while ($hour-- > 0)
              $line = <$fh>;
            } 
  	  return $line;
  	}
  
  At 10:23, this function generates the 10th line of a data file; at
  3:45 PM it generates the 15th line instead.  By default, C<Memoize>
  will only see the $problem_type argument.  To fix this, include the
  current hour in the normalizer:
  
          sub normalize { join ' ', (localtime)[2], @_ }
  
  The calling context of the function (scalar or list context) is
  propagated to the normalizer.  This means that if the memoized
  function will treat its arguments differently in list context than it
  would in scalar context, you can have the normalizer function select
  its behavior based on the results of C<wantarray>.  Even if called in
  a list context, a normalizer should still return a single string.
  
  =head2 C<SCALAR_CACHE>, C<LIST_CACHE>
  
  Normally, C<Memoize> caches your function's return values into an
  ordinary Perl hash variable.  However, you might like to have the
  values cached on the disk, so that they persist from one run of your
  program to the next, or you might like to associate some other
  interesting semantics with the cached values.
  
  There's a slight complication under the hood of C<Memoize>: There are
  actually I<two> caches, one for scalar values and one for list values.
  When your function is called in scalar context, its return value is
  cached in one hash, and when your function is called in list context,
  its value is cached in the other hash.  You can control the caching
  behavior of both contexts independently with these options.
  
  The argument to C<LIST_CACHE> or C<SCALAR_CACHE> must either be one of
  the following four strings:
  
  	MEMORY
  	FAULT
  	MERGE
          HASH
  
  or else it must be a reference to an array whose first element is one of
  these four strings, such as C<[HASH, arguments...]>.
  
  =over 4
  
  =item C<MEMORY>
  
  C<MEMORY> means that return values from the function will be cached in
  an ordinary Perl hash variable.  The hash variable will not persist
  after the program exits.  This is the default.
  
  =item C<HASH>
  
  C<HASH> allows you to specify that a particular hash that you supply
  will be used as the cache.  You can tie this hash beforehand to give
  it any behavior you want.
  
  A tied hash can have any semantics at all.  It is typically tied to an
  on-disk database, so that cached values are stored in the database and
  retrieved from it again when needed, and the disk file typically
  persists after your program has exited.  See C<perltie> for more
  complete details about C<tie>.
  
  A typical example is:
  
          use DB_File;
          tie my %cache => 'DB_File', $filename, O_RDWR|O_CREAT, 0666;
          memoize 'function', SCALAR_CACHE => [HASH => \%cache];
  
  This has the effect of storing the cache in a C<DB_File> database
  whose name is in C<$filename>.  The cache will persist after the
  program has exited.  Next time the program runs, it will find the
  cache already populated from the previous run of the program.  Or you
  can forcibly populate the cache by constructing a batch program that
  runs in the background and populates the cache file.  Then when you
  come to run your real program the memoized function will be fast
  because all its results have been precomputed.
  
  Another reason to use C<HASH> is to provide your own hash variable.
  You can then inspect or modify the contents of the hash to gain finer
  control over the cache management.
  
  =item C<TIE>
  
  This option is no longer supported.  It is still documented only to
  aid in the debugging of old programs that use it.  Old programs should
  be converted to use the C<HASH> option instead.
  
          memoize ... ['TIE', PACKAGE, ARGS...]
  
  is merely a shortcut for
  
          require PACKAGE;
  	{ tie my %cache, PACKAGE, ARGS...;
            memoize ... [HASH => \%cache];
          }
  
  =item C<FAULT>
  
  C<FAULT> means that you never expect to call the function in scalar
  (or list) context, and that if C<Memoize> detects such a call, it
  should abort the program.  The error message is one of
  
  	`foo' function called in forbidden list context at line ...
  	`foo' function called in forbidden scalar context at line ...
  
  =item C<MERGE>
  
  C<MERGE> normally means that the memoized function does not
  distinguish between list and sclar context, and that return values in
  both contexts should be stored together.  Both C<LIST_CACHE =E<gt>
  MERGE> and C<SCALAR_CACHE =E<gt> MERGE> mean the same thing.
  
  Consider this function:
  
  	sub complicated {
            # ... time-consuming calculation of $result
            return $result;
          }
  
  The C<complicated> function will return the same numeric C<$result>
  regardless of whether it is called in list or in scalar context.
  
  Normally, the following code will result in two calls to C<complicated>, even
  if C<complicated> is memoized:
  
      $x = complicated(142);
      ($y) = complicated(142);
      $z = complicated(142);
  
  The first call will cache the result, say 37, in the scalar cache; the
  second will cach the list C<(37)> in the list cache.  The third call
  doesn't call the real C<complicated> function; it gets the value 37
  from the scalar cache.
  
  Obviously, the second call to C<complicated> is a waste of time, and
  storing its return value is a waste of space.  Specifying C<LIST_CACHE
  =E<gt> MERGE> will make C<memoize> use the same cache for scalar and
  list context return values, so that the second call uses the scalar
  cache that was populated by the first call.  C<complicated> ends up
  being called only once, and both subsequent calls return C<3> from the
  cache, regardless of the calling context.
  
  =head3 List values in scalar context
  
  Consider this function:
  
      sub iota { return reverse (1..$_[0]) }
  
  This function normally returns a list.  Suppose you memoize it and
  merge the caches:
  
      memoize 'iota', SCALAR_CACHE => 'MERGE';
  
      @i7 = iota(7);
      $i7 = iota(7);
  
  Here the first call caches the list (1,2,3,4,5,6,7).  The second call
  does not really make sense. C<Memoize> cannot guess what behavior
  C<iota> should have in scalar context without actually calling it in
  scalar context.  Normally C<Memoize> I<would> call C<iota> in scalar
  context and cache the result, but the C<SCALAR_CACHE =E<gt> 'MERGE'>
  option says not to do that, but to use the cache list-context value
  instead. But it cannot return a list of seven elements in a scalar
  context. In this case C<$i7> will receive the B<first element> of the
  cached list value, namely 7.
  
  =head3 Merged disk caches
  
  Another use for C<MERGE> is when you want both kinds of return values
  stored in the same disk file; this saves you from having to deal with
  two disk files instead of one.  You can use a normalizer function to
  keep the two sets of return values separate.  For example:
  
          tie my %cache => 'MLDBM', 'DB_File', $filename, ...;
  
  	memoize 'myfunc',
  	  NORMALIZER => 'n',
  	  SCALAR_CACHE => [HASH => \%cache],
  	  LIST_CACHE => 'MERGE',
  	;
  
  	sub n {
  	  my $context = wantarray() ? 'L' : 'S';
  	  # ... now compute the hash key from the arguments ...
  	  $hashkey = "$context:$hashkey";
  	}
  
  This normalizer function will store scalar context return values in
  the disk file under keys that begin with C<S:>, and list context
  return values under keys that begin with C<L:>.
  
  =back
  
  =head1 OTHER FACILITIES
  
  =head2 C<unmemoize>
  
  There's an C<unmemoize> function that you can import if you want to.
  Why would you want to?  Here's an example: Suppose you have your cache
  tied to a DBM file, and you want to make sure that the cache is
  written out to disk if someone interrupts the program.  If the program
  exits normally, this will happen anyway, but if someone types
  control-C or something then the program will terminate immediately
  without synchronizing the database.  So what you can do instead is
  
      $SIG{INT} = sub { unmemoize 'function' };
  
  C<unmemoize> accepts a reference to, or the name of a previously
  memoized function, and undoes whatever it did to provide the memoized
  version in the first place, including making the name refer to the
  unmemoized version if appropriate.  It returns a reference to the
  unmemoized version of the function.
  
  If you ask it to unmemoize a function that was never memoized, it
  croaks.
  
  =head2 C<flush_cache>
  
  C<flush_cache(function)> will flush out the caches, discarding I<all>
  the cached data.  The argument may be a function name or a reference
  to a function.  For finer control over when data is discarded or
  expired, see the documentation for C<Memoize::Expire>, included in
  this package.
  
  Note that if the cache is a tied hash, C<flush_cache> will attempt to
  invoke the C<CLEAR> method on the hash.  If there is no C<CLEAR>
  method, this will cause a run-time error.
  
  An alternative approach to cache flushing is to use the C<HASH> option
  (see above) to request that C<Memoize> use a particular hash variable
  as its cache.  Then you can examine or modify the hash at any time in
  any way you desire.  You may flush the cache by using C<%hash = ()>. 
  
  =head1 CAVEATS
  
  Memoization is not a cure-all:
  
  =over 4
  
  =item *
  
  Do not memoize a function whose behavior depends on program
  state other than its own arguments, such as global variables, the time
  of day, or file input.  These functions will not produce correct
  results when memoized.  For a particularly easy example:
  
  	sub f {
  	  time;
  	}
  
  This function takes no arguments, and as far as C<Memoize> is
  concerned, it always returns the same result.  C<Memoize> is wrong, of
  course, and the memoized version of this function will call C<time> once
  to get the current time, and it will return that same time
  every time you call it after that.
  
  =item *
  
  Do not memoize a function with side effects.
  
  	sub f {
  	  my ($a, $b) = @_;
            my $s = $a + $b;
  	  print "$a + $b = $s.\n";
  	}
  
  This function accepts two arguments, adds them, and prints their sum.
  Its return value is the numuber of characters it printed, but you
  probably didn't care about that.  But C<Memoize> doesn't understand
  that.  If you memoize this function, you will get the result you
  expect the first time you ask it to print the sum of 2 and 3, but
  subsequent calls will return 1 (the return value of
  C<print>) without actually printing anything.
  
  =item *
  
  Do not memoize a function that returns a data structure that is
  modified by its caller.
  
  Consider these functions:  C<getusers> returns a list of users somehow,
  and then C<main> throws away the first user on the list and prints the
  rest:
  
  	sub main {
  	  my $userlist = getusers();
  	  shift @$userlist;
  	  foreach $u (@$userlist) {
  	    print "User $u\n";
  	  }
  	}
  
  	sub getusers {
  	  my @users;
  	  # Do something to get a list of users;
  	  \@users;  # Return reference to list.
  	}
  
  If you memoize C<getusers> here, it will work right exactly once.  The
  reference to the users list will be stored in the memo table.  C<main>
  will discard the first element from the referenced list.  The next
  time you invoke C<main>, C<Memoize> will not call C<getusers>; it will
  just return the same reference to the same list it got last time.  But
  this time the list has already had its head removed; C<main> will
  erroneously remove another element from it.  The list will get shorter
  and shorter every time you call C<main>.
  
  Similarly, this:
  
  	$u1 = getusers();    
  	$u2 = getusers();    
  	pop @$u1;
  
  will modify $u2 as well as $u1, because both variables are references
  to the same array.  Had C<getusers> not been memoized, $u1 and $u2
  would have referred to different arrays.
  
  =item * 
  
  Do not memoize a very simple function.
  
  Recently someone mentioned to me that the Memoize module made his
  program run slower instead of faster.  It turned out that he was
  memoizing the following function:
  
      sub square {
        $_[0] * $_[0];
      }
  
  I pointed out that C<Memoize> uses a hash, and that looking up a
  number in the hash is necessarily going to take a lot longer than a
  single multiplication.  There really is no way to speed up the
  C<square> function.
  
  Memoization is not magical.
  
  =back
  
  =head1 PERSISTENT CACHE SUPPORT
  
  You can tie the cache tables to any sort of tied hash that you want
  to, as long as it supports C<TIEHASH>, C<FETCH>, C<STORE>, and
  C<EXISTS>.  For example,
  
          tie my %cache => 'GDBM_File', $filename, O_RDWR|O_CREAT, 0666;
          memoize 'function', SCALAR_CACHE => [HASH => \%cache];
  
  works just fine.  For some storage methods, you need a little glue.
  
  C<SDBM_File> doesn't supply an C<EXISTS> method, so included in this
  package is a glue module called C<Memoize::SDBM_File> which does
  provide one.  Use this instead of plain C<SDBM_File> to store your
  cache table on disk in an C<SDBM_File> database:
  
          tie my %cache => 'Memoize::SDBM_File', $filename, O_RDWR|O_CREAT, 0666;
          memoize 'function', SCALAR_CACHE => [HASH => \%cache];
  
  C<NDBM_File> has the same problem and the same solution.  (Use
  C<Memoize::NDBM_File instead of plain NDBM_File.>)
  
  C<Storable> isn't a tied hash class at all.  You can use it to store a
  hash to disk and retrieve it again, but you can't modify the hash while
  it's on the disk.  So if you want to store your cache table in a
  C<Storable> database, use C<Memoize::Storable>, which puts a hashlike
  front-end onto C<Storable>.  The hash table is actually kept in
  memory, and is loaded from your C<Storable> file at the time you
  memoize the function, and stored back at the time you unmemoize the
  function (or when your program exits):
  
          tie my %cache => 'Memoize::Storable', $filename;
  	memoize 'function', SCALAR_CACHE => [HASH => \%cache];
  
          tie my %cache => 'Memoize::Storable', $filename, 'nstore';
  	memoize 'function', SCALAR_CACHE => [HASH => \%cache];
  
  Include the `nstore' option to have the C<Storable> database written
  in `network order'.  (See L<Storable> for more details about this.)
  
  The C<flush_cache()> function will raise a run-time error unless the
  tied package provides a C<CLEAR> method.
  
  =head1 EXPIRATION SUPPORT
  
  See Memoize::Expire, which is a plug-in module that adds expiration
  functionality to Memoize.  If you don't like the kinds of policies
  that Memoize::Expire implements, it is easy to write your own plug-in
  module to implement whatever policy you desire.  Memoize comes with
  several examples.  An expiration manager that implements a LRU policy
  is available on CPAN as Memoize::ExpireLRU.
  
  =head1 BUGS
  
  The test suite is much better, but always needs improvement.
  
  There is some problem with the way C<goto &f> works under threaded
  Perl, perhaps because of the lexical scoping of C<@_>.  This is a bug
  in Perl, and until it is resolved, memoized functions will see a
  slightly different C<caller()> and will perform a little more slowly
  on threaded perls than unthreaded perls.
  
  Some versions of C<DB_File> won't let you store data under a key of
  length 0.  That means that if you have a function C<f> which you
  memoized and the cache is in a C<DB_File> database, then the value of
  C<f()> (C<f> called with no arguments) will not be memoized.  If this
  is a big problem, you can supply a normalizer function that prepends
  C<"x"> to every key.
  
  =head1 MAILING LIST
  
  To join a very low-traffic mailing list for announcements about
  C<Memoize>, send an empty note to C<mjd-perl-memoize-request@plover.com>.
  
  =head1 AUTHOR
  
  Mark-Jason Dominus (C<mjd-perl-memoize+@plover.com>), Plover Systems co.
  
  See the C<Memoize.pm> Page at http://perl.plover.com/Memoize/
  for news and upgrades.  Near this page, at
  http://perl.plover.com/MiniMemoize/ there is an article about
  memoization and about the internals of Memoize that appeared in The
  Perl Journal, issue #13.  (This article is also included in the
  Memoize distribution as `article.html'.)
  
  The author's book I<Higher-Order Perl> (2005, ISBN 1558607013, published
  by Morgan Kaufmann) discusses memoization (and many other 
  topics) in tremendous detail. It is available on-line for free.
  For more information, visit http://hop.perl.plover.com/ .
  
  To join a mailing list for announcements about C<Memoize>, send an
  empty message to C<mjd-perl-memoize-request@plover.com>.  This mailing
  list is for announcements only and has extremely low traffic---fewer than
  two messages per year.
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 1998, 1999, 2000, 2001, 2012  by Mark Jason Dominus
  
  This library is free software; you may redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 THANK YOU
  
  Many thanks to Florian Ragwitz for administration and packaging
  assistance, to John Tromp for bug reports, to Jonathan Roy for bug reports
  and suggestions, to Michael Schwern for other bug reports and patches,
  to Mike Cariaso for helping me to figure out the Right Thing to Do
  About Expiration, to Joshua Gerth, Joshua Chamas, Jonathan Roy
  (again), Mark D. Anderson, and Andrew Johnson for more suggestions
  about expiration, to Brent Powers for the Memoize::ExpireLRU module,
  to Ariel Scolnicov for delightful messages about the Fibonacci
  function, to Dion Almaer for thought-provoking suggestions about the
  default normalizer, to Walt Mankowski and Kurt Starsinic for much help
  investigating problems under threaded Perl, to Alex Dudkevich for
  reporting the bug in prototyped functions and for checking my patch,
  to Tony Bass for many helpful suggestions, to Jonathan Roy (again) for
  finding a use for C<unmemoize()>, to Philippe Verdret for enlightening
  discussion of C<Hook::PrePostCall>, to Nat Torkington for advice I
  ignored, to Chris Nandor for portability advice, to Randal Schwartz
  for suggesting the 'C<flush_cache> function, and to Jenda Krynicky for
  being a light in the world.
  
  Special thanks to Jarkko Hietaniemi, the 5.8.0 pumpking, for including
  this module in the core and for his patient and helpful guidance
  during the integration process.
  
  =cut
PERL5_MEMOIZE

$fatpacked{"perl5/Memoize/AnyDBM_File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_MEMOIZE_ANYDBM_FILE';
  package Memoize::AnyDBM_File;
  
  =head1 NAME
  
  Memoize::AnyDBM_File - glue to provide EXISTS for AnyDBM_File for Storable use
  
  =head1 DESCRIPTION
  
  See L<Memoize>.
  
  =cut
  
  use vars qw(@ISA $VERSION);
  $VERSION = '1.03';
  @ISA = qw(DB_File GDBM_File Memoize::NDBM_File Memoize::SDBM_File ODBM_File) unless @ISA;
  
  my $verbose = 1;
  
  my $mod;
  for $mod (@ISA) {
  #  (my $truemod = $mod) =~ s/^Memoize:://;
  #  my $file = "$mod.pm";
  #  $file =~ s{::}{/}g;
    if (eval "require $mod") {
      print STDERR "AnyDBM_File => Selected $mod.\n" if $Verbose;
      @ISA = ($mod);	# if we leave @ISA alone, warnings abound
      return 1;
    }
  }
  
  die "No DBM package was successfully found or installed";
PERL5_MEMOIZE_ANYDBM_FILE

$fatpacked{"perl5/Memoize/Expire.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_MEMOIZE_EXPIRE';
  
  package Memoize::Expire;
  # require 5.00556;
  use Carp;
  $DEBUG = 0;
  $VERSION = '1.03';
  
  # This package will implement expiration by prepending a fixed-length header
  # to the font of the cached data.  The format of the header will be:
  # (4-byte number of last-access-time)  (For LRU when I implement it)
  # (4-byte expiration time: unsigned seconds-since-unix-epoch)
  # (2-byte number-of-uses-before-expire)
  
  sub _header_fmt () { "N N n" }
  sub _header_size () { length(_header_fmt) }
  
  # Usage:  memoize func 
  #         TIE => [Memoize::Expire, LIFETIME => sec, NUM_USES => n,
  #                 TIE => [...] ]
  
  BEGIN {
    eval {require Time::HiRes};
    unless ($@) {
      Time::HiRes->import('time');
    }
  }
  
  sub TIEHASH {
    my ($package, %args) = @_;
    my %cache;
    if ($args{TIE}) {
      my ($module, @opts) = @{$args{TIE}};
      my $modulefile = $module . '.pm';
      $modulefile =~ s{::}{/}g;
      eval { require $modulefile };
      if ($@) {
        croak "Memoize::Expire: Couldn't load hash tie module `$module': $@; aborting";
      }
      my $rc = (tie %cache => $module, @opts);
      unless ($rc) {
        croak "Memoize::Expire: Couldn't tie hash to `$module': $@; aborting";
      }
    }
    $args{LIFETIME} ||= 0;
    $args{NUM_USES} ||= 0;
    $args{C} = \%cache;
    bless \%args => $package;
  }
  
  sub STORE {
    $DEBUG and print STDERR " >> Store $_[1] $_[2]\n";
    my ($self, $key, $value) = @_;
    my $expire_time = $self->{LIFETIME} > 0 ? $self->{LIFETIME} + time : 0;
    # The call that results in a value to store into the cache is the
    # first of the NUM_USES allowed calls.
    my $header = _make_header(time, $expire_time, $self->{NUM_USES}-1);
    $self->{C}{$key} = $header . $value;
    $value;
  }
  
  sub FETCH {
    $DEBUG and print STDERR " >> Fetch cached value for $_[1]\n";
    my ($data, $last_access, $expire_time, $num_uses_left) = _get_item($_[0]{C}{$_[1]});
    $DEBUG and print STDERR " >>   (ttl: ", ($expire_time-time()), ", nuses: $num_uses_left)\n";
    $num_uses_left--;
    $last_access = time;
    _set_header(@_, $data, $last_access, $expire_time, $num_uses_left);
    $data;
  }
  
  sub EXISTS {
    $DEBUG and print STDERR " >> Exists $_[1]\n";
    unless (exists $_[0]{C}{$_[1]}) {
      $DEBUG and print STDERR "    Not in underlying hash at all.\n";
      return 0;
    }
    my $item = $_[0]{C}{$_[1]};
    my ($last_access, $expire_time, $num_uses_left) = _get_header($item);
    my $ttl = $expire_time - time;
    if ($DEBUG) {
      $_[0]{LIFETIME} and print STDERR "    Time to live for this item: $ttl\n";
      $_[0]{NUM_USES} and print STDERR "    Uses remaining: $num_uses_left\n";
    }
    if (   (! $_[0]{LIFETIME} || $expire_time > time)
        && (! $_[0]{NUM_USES} || $num_uses_left > 0 )) {
  	    $DEBUG and print STDERR "    (Still good)\n";
      return 1;
    } else {
      $DEBUG and print STDERR "    (Expired)\n";
      return 0;
    }
  }
  
  # Arguments: last access time, expire time, number of uses remaining
  sub _make_header {
    pack "N N n", @_;
  }
  
  sub _strip_header {
    substr($_[0], 10);
  }
  
  # Arguments: last access time, expire time, number of uses remaining
  sub _set_header {
    my ($self, $key, $data, @header) = @_;
    $self->{C}{$key} = _make_header(@header) . $data;
  }
  
  sub _get_item {
    my $data = substr($_[0], 10);
    my @header = unpack "N N n", substr($_[0], 0, 10);
  #  print STDERR " >> _get_item: $data => $data @header\n";
    ($data, @header);
  }
  
  # Return last access time, expire time, number of uses remaining
  sub _get_header  {
    unpack "N N n", substr($_[0], 0, 10);
  }
  
  1;
  
  =head1 NAME 
  
  Memoize::Expire - Plug-in module for automatic expiration of memoized values
  
  =head1 SYNOPSIS
  
    use Memoize;
    use Memoize::Expire;
    tie my %cache => 'Memoize::Expire',
  	  	     LIFETIME => $lifetime,    # In seconds
  		     NUM_USES => $n_uses;
  
    memoize 'function', SCALAR_CACHE => [HASH => \%cache ];
  
  =head1 DESCRIPTION
  
  Memoize::Expire is a plug-in module for Memoize.  It allows the cached
  values for memoized functions to expire automatically.  This manual
  assumes you are already familiar with the Memoize module.  If not, you
  should study that manual carefully first, paying particular attention
  to the HASH feature.
  
  Memoize::Expire is a layer of software that you can insert in between
  Memoize itself and whatever underlying package implements the cache.
  The layer presents a hash variable whose values expire whenever they
  get too old, have been used too often, or both. You tell C<Memoize> to
  use this forgetful hash as its cache instead of the default, which is
  an ordinary hash.
  
  To specify a real-time timeout, supply the C<LIFETIME> option with a
  numeric value.  Cached data will expire after this many seconds, and
  will be looked up afresh when it expires.  When a data item is looked
  up afresh, its lifetime is reset.
  
  If you specify C<NUM_USES> with an argument of I<n>, then each cached
  data item will be discarded and looked up afresh after the I<n>th time
  you access it.  When a data item is looked up afresh, its number of
  uses is reset.
  
  If you specify both arguments, data will be discarded from the cache
  when either expiration condition holds.
  
  Memoize::Expire uses a real hash internally to store the cached data.
  You can use the C<HASH> option to Memoize::Expire to supply a tied
  hash in place of the ordinary hash that Memoize::Expire will normally
  use.  You can use this feature to add Memoize::Expire as a layer in
  between a persistent disk hash and Memoize.  If you do this, you get a
  persistent disk cache whose entries expire automatically.  For
  example:
  
    #   Memoize
    #      |
    #   Memoize::Expire  enforces data expiration policy
    #      |
    #   DB_File  implements persistence of data in a disk file
    #      |
    #   Disk file
  
    use Memoize;
    use Memoize::Expire;
    use DB_File;
  
    # Set up persistence
    tie my %disk_cache => 'DB_File', $filename, O_CREAT|O_RDWR, 0666];
  
    # Set up expiration policy, supplying persistent hash as a target
    tie my %cache => 'Memoize::Expire', 
  	  	     LIFETIME => $lifetime,    # In seconds
  		     NUM_USES => $n_uses,
                       HASH => \%disk_cache; 
  
    # Set up memoization, supplying expiring persistent hash for cache
    memoize 'function', SCALAR_CACHE => [ HASH => \%cache ];
  
  =head1 INTERFACE
  
  There is nothing special about Memoize::Expire.  It is just an
  example.  If you don't like the policy that it implements, you are
  free to write your own expiration policy module that implements
  whatever policy you desire.  Here is how to do that.  Let us suppose
  that your module will be named MyExpirePolicy.
  
  Short summary: You need to create a package that defines four methods:
  
  =over 4
  
  =item 
  TIEHASH
  
  Construct and return cache object.
  
  =item 
  EXISTS
  
  Given a function argument, is the corresponding function value in the
  cache, and if so, is it fresh enough to use?
  
  =item
  FETCH
  
  Given a function argument, look up the corresponding function value in
  the cache and return it.
  
  =item 
  STORE
  
  Given a function argument and the corresponding function value, store
  them into the cache.
  
  =item
  CLEAR
  
  (Optional.)  Flush the cache completely.
  
  =back
  
  The user who wants the memoization cache to be expired according to
  your policy will say so by writing
  
    tie my %cache => 'MyExpirePolicy', args...;
    memoize 'function', SCALAR_CACHE => [HASH => \%cache];
  
  This will invoke C<< MyExpirePolicy->TIEHASH(args) >>.
  MyExpirePolicy::TIEHASH should do whatever is appropriate to set up
  the cache, and it should return the cache object to the caller.
  
  For example, MyExpirePolicy::TIEHASH might create an object that
  contains a regular Perl hash (which it will to store the cached
  values) and some extra information about the arguments and how old the
  data is and things like that.  Let us call this object `C'.
  
  When Memoize needs to check to see if an entry is in the cache
  already, it will invoke C<< C->EXISTS(key) >>.  C<key> is the normalized
  function argument.  MyExpirePolicy::EXISTS should return 0 if the key
  is not in the cache, or if it has expired, and 1 if an unexpired value
  is in the cache.  It should I<not> return C<undef>, because there is a
  bug in some versions of Perl that will cause a spurious FETCH if the
  EXISTS method returns C<undef>.
  
  If your EXISTS function returns true, Memoize will try to fetch the
  cached value by invoking C<< C->FETCH(key) >>.  MyExpirePolicy::FETCH should
  return the cached value.  Otherwise, Memoize will call the memoized
  function to compute the appropriate value, and will store it into the
  cache by calling C<< C->STORE(key, value) >>.
  
  Here is a very brief example of a policy module that expires each
  cache item after ten seconds.
  
  	package Memoize::TenSecondExpire;
  
  	sub TIEHASH {
  	  my ($package, %args) = @_;
            my $cache = $args{HASH} || {};
  	  bless $cache => $package;
  	}
  
  	sub EXISTS {
  	  my ($cache, $key) = @_;
  	  if (exists $cache->{$key} && 
                $cache->{$key}{EXPIRE_TIME} > time) {
  	    return 1
  	  } else {
  	    return 0;  # Do NOT return `undef' here.
  	  }
  	}
  
  	sub FETCH {
  	  my ($cache, $key) = @_;
  	  return $cache->{$key}{VALUE};
  	}
  
  	sub STORE {
  	  my ($cache, $key, $newvalue) = @_;
  	  $cache->{$key}{VALUE} = $newvalue;
  	  $cache->{$key}{EXPIRE_TIME} = time + 10;
  	}
  
  To use this expiration policy, the user would say
  
  	use Memoize;
          tie my %cache10sec => 'Memoize::TenSecondExpire';
  	memoize 'function', SCALAR_CACHE => [HASH => \%cache10sec];
  
  Memoize would then call C<function> whenever a cached value was
  entirely absent or was older than ten seconds.
  
  You should always support a C<HASH> argument to C<TIEHASH> that ties
  the underlying cache so that the user can specify that the cache is
  also persistent or that it has some other interesting semantics.  The
  example above demonstrates how to do this, as does C<Memoize::Expire>.
  
  Another sample module, L<Memoize::Saves>, is available in a separate
  distribution on CPAN.  It implements a policy that allows you to
  specify that certain function values would always be looked up afresh.
  See the documentation for details.
  
  =head1 ALTERNATIVES
  
  Brent Powers has a C<Memoize::ExpireLRU> module that was designed to
  work with Memoize and provides expiration of least-recently-used data.
  The cache is held at a fixed number of entries, and when new data
  comes in, the least-recently used data is expired.  See
  L<http://search.cpan.org/search?mode=module&query=ExpireLRU>.
  
  Joshua Chamas's Tie::Cache module may be useful as an expiration
  manager.  (If you try this, let me know how it works out.)
  
  If you develop any useful expiration managers that you think should be
  distributed with Memoize, please let me know.
  
  =head1 CAVEATS
  
  This module is experimental, and may contain bugs.  Please report bugs
  to the address below.
  
  Number-of-uses is stored as a 16-bit unsigned integer, so can't exceed
  65535.
  
  Because of clock granularity, expiration times may occur up to one
  second sooner than you expect.  For example, suppose you store a value
  with a lifetime of ten seconds, and you store it at 12:00:00.998 on a
  certain day.  Memoize will look at the clock and see 12:00:00.  Then
  9.01 seconds later, at 12:00:10.008 you try to read it back.  Memoize
  will look at the clock and see 12:00:10 and conclude that the value
  has expired.  This will probably not occur if you have
  C<Time::HiRes> installed.
  
  =head1 AUTHOR
  
  Mark-Jason Dominus (mjd-perl-memoize+@plover.com)
  
  Mike Cariaso provided valuable insight into the best way to solve this
  problem.
  
  =head1 SEE ALSO
  
  perl(1)
  
  The Memoize man page.
  
  http://www.plover.com/~mjd/perl/Memoize/  (for news and updates)
  
  I maintain a mailing list on which I occasionally announce new
  versions of Memoize.  The list is for announcements only, not
  discussion.  To join, send an empty message to
  mjd-perl-memoize-request@Plover.com.
  
  =cut
PERL5_MEMOIZE_EXPIRE

$fatpacked{"perl5/Memoize/ExpireFile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_MEMOIZE_EXPIREFILE';
  package Memoize::ExpireFile;
  
  =head1 NAME
  
  Memoize::ExpireFile - test for Memoize expiration semantics
  
  =head1 DESCRIPTION
  
  See L<Memoize::Expire>.
  
  =cut
  
  $VERSION = '1.03';
  use Carp;
  
  my $Zero = pack("N", 0);
  
  sub TIEHASH {
    my ($package, %args) = @_;
    my $cache = $args{HASH} || {};
    bless {ARGS => \%args, C => $cache} => $package;
  }
  
  
  sub STORE {
  #  print "Expiry manager STORE handler\n";
    my ($self, $key, $data) = @_;
    my $cache = $self->{C};
    my $cur_date = pack("N", (stat($key))[9]);
    $cache->{"C$key"} = $data;
    $cache->{"T$key"} = $cur_date;
  }
  
  sub FETCH {
    my ($self, $key) = @_;
    $self->{C}{"C$key"};
  }
  
  sub EXISTS {
  #  print "Expiry manager EXISTS handler\n";
    my ($self, $key) = @_;
    my $cache_date = $self->{C}{"T$key"} || $Zero;
    my $file_date = pack("N", (stat($key))[9]);#
  #  if ($self->{ARGS}{CHECK_DATE} && $old_date gt $cur_date) {
  #    return $self->{ARGS}{CHECK_DATE}->($key, $old_date, $cur_date);
  #  } 
    my $res = $cache_date ge $file_date;
  #  print $res ? "... still good\n" : "... expired\n";
    $res;
  }
  
  1;
PERL5_MEMOIZE_EXPIREFILE

$fatpacked{"perl5/Memoize/ExpireTest.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_MEMOIZE_EXPIRETEST';
  package Memoize::ExpireTest;
  
  =head1 NAME
  
  Memoize::ExpireTest - test for Memoize expiration semantics
  
  =head1 DESCRIPTION
  
  This module is just for testing expiration semantics.  It's not a very
  good example of how to write an expiration module.
  
  If you are looking for an example, I recommend that you look at the
  simple example in the Memoize::Expire documentation, or at the code
  for Memoize::Expire itself.
  
  If you have questions, I will be happy to answer them if you send them
  to mjd-perl-memoize+@plover.com.
  
  =cut
  
  $VERSION = '1.03';
  my %cache;
  
  sub TIEHASH {	
    my ($pack) = @_;
    bless \%cache => $pack;
  }
  
  sub EXISTS {
    my ($cache, $key) = @_;
    exists $cache->{$key} ? 1 : 0;
  }
  
  sub FETCH {
    my ($cache, $key) = @_;
    $cache->{$key};
  }
  
  sub STORE {
    my ($cache, $key, $val) = @_;
    $cache->{$key} = $val;
  }
  
  sub expire {
    my ($key) = @_;
    delete $cache{$key};
  }
  
  1;
PERL5_MEMOIZE_EXPIRETEST

$fatpacked{"perl5/Memoize/NDBM_File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_MEMOIZE_NDBM_FILE';
  package Memoize::NDBM_File;
  
  =head1 NAME
  
  Memoize::NDBM_File - glue to provide EXISTS for NDBM_File for Storable use
  
  =head1 DESCRIPTION
  
  See L<Memoize>.
  
  =cut
  
  use NDBM_File;
  @ISA = qw(NDBM_File);
  $VERSION = '1.03';
  
  $Verbose = 0;
  
  sub AUTOLOAD {
    warn "Nonexistent function $AUTOLOAD invoked in Memoize::NDBM_File\n";
  }
  
  sub import {
    warn "Importing Memoize::NDBM_File\n" if $Verbose;
  }
  
  
  my %keylist;
  
  # This is so ridiculous...
  sub _backhash {
    my $self = shift;
    my %fakehash;
    my $k; 
    for ($k = $self->FIRSTKEY(); defined $k; $k = $self->NEXTKEY($k)) {
      $fakehash{$k} = undef;
    }
    $keylist{$self} = \%fakehash;
  }
  
  sub EXISTS {
    warn "Memoize::NDBM_File EXISTS (@_)\n" if $Verbose;
    my $self = shift;
    _backhash($self)  unless exists $keylist{$self};
    my $r = exists $keylist{$self}{$_[0]};
    warn "Memoize::NDBM_File EXISTS (@_) ==> $r\n" if $Verbose;
    $r;
  }
  
  sub DEFINED {
    warn "Memoize::NDBM_File DEFINED (@_)\n" if $Verbose;
    my $self = shift;
    _backhash($self)  unless exists $keylist{$self};
    defined $keylist{$self}{$_[0]};
  }
  
  sub DESTROY {
    warn "Memoize::NDBM_File DESTROY (@_)\n" if $Verbose;
    my $self = shift;
    delete $keylist{$self};   # So much for reference counting...
    $self->SUPER::DESTROY(@_);
  }
  
  # Maybe establish the keylist at TIEHASH time instead?
  
  sub STORE {
    warn "Memoize::NDBM_File STORE (@_)\n" if $VERBOSE;
    my $self = shift;
    $keylist{$self}{$_[0]} = undef;
    $self->SUPER::STORE(@_);
  }
  
  
  
  # Inherit FETCH and TIEHASH
  
  1;
PERL5_MEMOIZE_NDBM_FILE

$fatpacked{"perl5/Memoize/SDBM_File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_MEMOIZE_SDBM_FILE';
  package Memoize::SDBM_File;
  
  =head1 NAME
  
  Memoize::SDBM_File - glue to provide EXISTS for SDBM_File for Storable use
  
  =head1 DESCRIPTION
  
  See L<Memoize>.
  
  =cut
  
  use SDBM_File;
  @ISA = qw(SDBM_File);
  $VERSION = '1.03';
  
  $Verbose = 0;
  
  sub AUTOLOAD {
    warn "Nonexistent function $AUTOLOAD invoked in Memoize::SDBM_File\n";
  }
  
  sub import {
    warn "Importing Memoize::SDBM_File\n" if $Verbose;
  }
  
  
  my %keylist;
  
  # This is so ridiculous...
  sub _backhash {
    my $self = shift;
    my %fakehash;
    my $k; 
    for ($k = $self->FIRSTKEY(); defined $k; $k = $self->NEXTKEY($k)) {
      $fakehash{$k} = undef;
    }
    $keylist{$self} = \%fakehash;
  }
  
  sub EXISTS {
    warn "Memoize::SDBM_File EXISTS (@_)\n" if $Verbose;
    my $self = shift;
    _backhash($self)  unless exists $keylist{$self};
    my $r = exists $keylist{$self}{$_[0]};
    warn "Memoize::SDBM_File EXISTS (@_) ==> $r\n" if $Verbose;
    $r;
  }
  
  sub DEFINED {
    warn "Memoize::SDBM_File DEFINED (@_)\n" if $Verbose;
    my $self = shift;
    _backhash($self)  unless exists $keylist{$self};
    defined $keylist{$self}{$_[0]};
  }
  
  sub DESTROY {
    warn "Memoize::SDBM_File DESTROY (@_)\n" if $Verbose;
    my $self = shift;
    delete $keylist{$self};   # So much for reference counting...
    $self->SUPER::DESTROY(@_);
  }
  
  # Maybe establish the keylist at TIEHASH time instead?
  
  sub STORE {
    warn "Memoize::SDBM_File STORE (@_)\n" if $VERBOSE;
    my $self = shift;
    $keylist{$self}{$_[0]} = undef;
    $self->SUPER::STORE(@_);
  }
  
  # Inherit FETCH and TIEHASH
  
  1;
PERL5_MEMOIZE_SDBM_FILE

$fatpacked{"perl5/Memoize/Storable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_MEMOIZE_STORABLE';
  package Memoize::Storable;
  
  =head1 NAME
  
  Memoize::Storable - store Memoized data in Storable database
  
  =head1 DESCRIPTION
  
  See L<Memoize>.
  
  =cut
  
  use Storable ();
  $VERSION = '1.03';
  $Verbose = 0;
  
  sub TIEHASH {
    require Carp if $Verbose;
    my $package = shift;
    my $filename = shift;
    my $truehash = (-e $filename) ? Storable::retrieve($filename) : {};
    my %options;
    print STDERR "Memoize::Storable::TIEHASH($filename, @_)\n" if $Verbose;
    @options{@_} = ();
    my $self = 
      {FILENAME => $filename, 
       H => $truehash, 
       OPTIONS => \%options
      };
    bless $self => $package;
  }
  
  sub STORE {
    require Carp if $Verbose;
    my $self = shift;
    print STDERR "Memoize::Storable::STORE(@_)\n" if $Verbose;
    $self->{H}{$_[0]} = $_[1];
  }
  
  sub FETCH {
    require Carp if $Verbose;
    my $self = shift;
    print STDERR "Memoize::Storable::FETCH(@_)\n" if $Verbose;
    $self->{H}{$_[0]};
  }
  
  sub EXISTS {
    require Carp if $Verbose;
    my $self = shift;
    print STDERR "Memoize::Storable::EXISTS(@_)\n" if $Verbose;
    exists $self->{H}{$_[0]};
  }
  
  sub DESTROY {
    require Carp if $Verbose;
    my $self= shift;
    print STDERR "Memoize::Storable::DESTROY(@_)\n" if $Verbose;
    if ($self->{OPTIONS}{'nstore'}) {
      Storable::nstore($self->{H}, $self->{FILENAME});
    } else {
      Storable::store($self->{H}, $self->{FILENAME});
    }
  }
  
  sub FIRSTKEY {
    'Fake hash from Memoize::Storable';
  }
  
  sub NEXTKEY {
    undef;
  }
  1;
PERL5_MEMOIZE_STORABLE

$fatpacked{"perl5/Regexp/Common.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_REGEXP_COMMON';
  package Regexp::Common;
  
  use 5.00473;
  use strict;
  
  BEGIN {
      # This makes sure 'use warnings' doesn't bomb out on 5.005_*;
      # warnings won't be enabled on those old versions though.
      # Since all other files use this file, we can use 'use warnings'
      # elsewhere as well, but *AFTER* 'use Regexp::Common'.
      if ($] < 5.006) {
          $INC {"warnings.pm"} = 1;
          no strict 'refs';
          *{"warnings::unimport"} = sub {0};
      }
  }
  
  use warnings;
  use vars qw /$VERSION %RE %sub_interface $AUTOLOAD/;
  
  $VERSION = '2016020301';
  
  
  sub _croak {
      require Carp;
      goto &Carp::croak;
  }
  
  sub _carp {
      require Carp;
      goto &Carp::carp;
  }
  
  sub new {
      my ($class, @data) = @_;
      my %self;
      tie %self, $class, @data;
      return \%self;
  }
  
  sub TIEHASH {
      my ($class, @data) = @_;
      bless \@data, $class;
  }
  
  sub FETCH {
      my ($self, $extra) = @_;
      return bless ref($self)->new(@$self, $extra), ref($self);
  }
  
  my %imports = map {$_ => "Regexp::Common::$_"}
                qw /balanced CC     comment   delimited lingua list
                    net      number profanity SEN       URI    whitespace
                    zip/;
  
  sub import {
      shift;  # Shift off the class.
      tie %RE, __PACKAGE__;
      {
          no strict 'refs';
          *{caller() . "::RE"} = \%RE;
      }
  
      my $saw_import;
      my $no_defaults;
      my %exclude;
      foreach my $entry (grep {!/^RE_/} @_) {
          if ($entry eq 'pattern') {
              no strict 'refs';
              *{caller() . "::pattern"} = \&pattern;
              next;
          }
          # This used to prevent $; from being set. We still recognize it,
          # but we won't do anything.
          if ($entry eq 'clean') {
              next;
          }
          if ($entry eq 'no_defaults') {
              $no_defaults ++;
              next;
          }
          if (my $module = $imports {$entry}) {
              $saw_import ++;
              eval "require $module;";
              die $@ if $@;
              next;
          }
          if ($entry =~ /^!(.*)/ && $imports {$1}) {
              $exclude {$1} ++;
              next;
          }
          # As a last resort, try to load the argument.
          my $module = $entry =~ /^Regexp::Common/
                              ? $entry
                              : "Regexp::Common::" . $entry;
          eval "require $module;";
          die $@ if $@;
      }
  
      unless ($saw_import || $no_defaults) {
          foreach my $module (values %imports) {
              next if $exclude {$module};
              eval "require $module;";
              die $@ if $@;
          }
      }
  
      my %exported;
      foreach my $entry (grep {/^RE_/} @_) {
          if ($entry =~ /^RE_(\w+_)?ALL$/) {
              my $m  = defined $1 ? $1 : "";
              my $re = qr /^RE_${m}.*$/;
              while (my ($sub, $interface) = each %sub_interface) {
                  next if $exported {$sub};
                  next unless $sub =~ /$re/;
                  {
                      no strict 'refs';
                      *{caller() . "::$sub"} = $interface;
                  }
                  $exported {$sub} ++;
              }
          }
          else {
              next if $exported {$entry};
              _croak "Can't export unknown subroutine &$entry"
                  unless $sub_interface {$entry};
              {
                  no strict 'refs';
                  *{caller() . "::$entry"} = $sub_interface {$entry};
              }
              $exported {$entry} ++;
          }
      }
  }
  
  sub AUTOLOAD { _croak "Can't $AUTOLOAD" }
  
  sub DESTROY {}
  
  my %cache;
  
  my $fpat = qr/^(-\w+)/;
  
  sub _decache {
          my @args = @{tied %{$_[0]}};
          my @nonflags = grep {!/$fpat/} @args;
          my $cache = get_cache(@nonflags);
          _croak "Can't create unknown regex: \$RE{"
              . join("}{",@args) . "}"
                  unless exists $cache->{__VAL__};
          _croak "Perl $] does not support the pattern "
              . "\$RE{" . join("}{",@args)
              . "}.\nYou need Perl $cache->{__VAL__}{version} or later"
                  unless ($cache->{__VAL__}{version}||0) <= $];
          my %flags = ( %{$cache->{__VAL__}{default}},
                        map { /$fpat\Q$;\E(.*)/ ? ($1 => $2)
                            : /$fpat/           ? ($1 => undef)
                            :                     ()
                            } @args);
          $cache->{__VAL__}->_clone_with(\@args, \%flags);
  }
  
  use overload q{""} => \&_decache;
  
  
  sub get_cache {
          my $cache = \%cache;
          foreach (@_) {
                  $cache = $cache->{$_}
                        || ($cache->{$_} = {});
          }
          return $cache;
  }
  
  sub croak_version {
          my ($entry, @args) = @_;
  }
  
  sub pattern {
          my %spec = @_;
          _croak 'pattern() requires argument: name => [ @list ]'
                  unless $spec{name} && ref $spec{name} eq 'ARRAY';
          _croak 'pattern() requires argument: create => $sub_ref_or_string'
                  unless $spec{create};
  
          if (ref $spec{create} ne "CODE") {
                  my $fixed_str = "$spec{create}";
                  $spec{create} = sub { $fixed_str }
          }
  
          my @nonflags;
          my %default;
          foreach ( @{$spec{name}} ) {
                  if (/$fpat=(.*)/) {
                          $default{$1} = $2;
                  }
                  elsif (/$fpat\s*$/) {
                          $default{$1} = undef;
                  }
                  else {
                          push @nonflags, $_;
                  }
          }
  
          my $entry = get_cache(@nonflags);
  
          if ($entry->{__VAL__}) {
                  _carp "Overriding \$RE{"
                     . join("}{",@nonflags)
                     . "}";
          }
  
          $entry->{__VAL__} = bless {
                                  create  => $spec{create},
                                  match   => $spec{match} || \&generic_match,
                                  subs    => $spec{subs}  || \&generic_subs,
                                  version => $spec{version},
                                  default => \%default,
                              }, 'Regexp::Common::Entry';
  
          foreach (@nonflags) {s/\W/X/g}
          my $subname = "RE_" . join ("_", @nonflags);
          $sub_interface{$subname} = sub {
                  push @_ => undef if @_ % 2;
                  my %flags = @_;
                  my $pat = $spec{create}->($entry->{__VAL__},
                                 {%default, %flags}, \@nonflags);
                  if (exists $flags{-keep}) { $pat =~ s/\Q(?k:/(/g; }
                  else { $pat =~ s/\Q(?k:/(?:/g; }
                  return exists $flags {-i} ? qr /(?i:$pat)/ : qr/$pat/;
          };
  
          return 1;
  }
  
  sub generic_match {$_ [1] =~  /$_[0]/}
  sub generic_subs  {$_ [1] =~ s/$_[0]/$_[2]/}
  
  sub matches {
          my ($self, $str) = @_;
          my $entry = $self -> _decache;
          $entry -> {match} -> ($entry, $str);
  }
  
  sub subs {
          my ($self, $str, $newstr) = @_;
          my $entry = $self -> _decache;
          $entry -> {subs} -> ($entry, $str, $newstr);
          return $str;
  }
  
  
  package Regexp::Common::Entry;
  # use Carp;
  
  use overload
      q{""} => sub {
          my ($self) = @_;
          my $pat = $self->{create}->($self, $self->{flags}, $self->{args});
          if (exists $self->{flags}{-keep}) {
              $pat =~ s/\Q(?k:/(/g;
          }
          else {
              $pat =~ s/\Q(?k:/(?:/g;
          }
          if (exists $self->{flags}{-i})   { $pat = "(?i)$pat" }
          return $pat;
      };
  
  sub _clone_with {
      my ($self, $args, $flags) = @_;
      bless { %$self, args=>$args, flags=>$flags }, ref $self;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common - Provide commonly requested regular expressions
  
  =head1 SYNOPSIS
  
   # STANDARD USAGE 
  
   use Regexp::Common;
  
   while (<>) {
       /$RE{num}{real}/               and print q{a number};
       /$RE{quoted}/                  and print q{a ['"`] quoted string};
       /$RE{delimited}{-delim=>'/'}/  and print q{a /.../ sequence};
       /$RE{balanced}{-parens=>'()'}/ and print q{balanced parentheses};
       /$RE{profanity}/               and print q{a #*@%-ing word};
   }
  
  
   # SUBROUTINE-BASED INTERFACE
  
   use Regexp::Common 'RE_ALL';
  
   while (<>) {
       $_ =~ RE_num_real()              and print q{a number};
       $_ =~ RE_quoted()                and print q{a ['"`] quoted string};
       $_ =~ RE_delimited(-delim=>'/')  and print q{a /.../ sequence};
       $_ =~ RE_balanced(-parens=>'()'} and print q{balanced parentheses};
       $_ =~ RE_profanity()             and print q{a #*@%-ing word};
   }
  
  
   # IN-LINE MATCHING...
  
   if ( $RE{num}{int}->matches($text) ) {...}
  
  
   # ...AND SUBSTITUTION
  
   my $cropped = $RE{ws}{crop}->subs($uncropped);
  
  
   # ROLL-YOUR-OWN PATTERNS
  
   use Regexp::Common 'pattern';
  
   pattern name   => ['name', 'mine'],
           create => '(?i:J[.]?\s+A[.]?\s+Perl-Hacker)',
           ;
  
   my $name_matcher = $RE{name}{mine};
  
   pattern name    => [ 'lineof', '-char=_' ],
           create  => sub {
                          my $flags = shift;
                          my $char = quotemeta $flags->{-char};
                          return '(?:^$char+$)';
                      },
           match   => sub {
                          my ($self, $str) = @_;
                          return $str !~ /[^$self->{flags}{-char}]/;
                      },
           subs   => sub {
                          my ($self, $str, $replacement) = @_;
                          $_[1] =~ s/^$self->{flags}{-char}+$//g;
                     },
           ;
  
   my $asterisks = $RE{lineof}{-char=>'*'};
  
   # DECIDING WHICH PATTERNS TO LOAD.
  
   use Regexp::Common qw /comment number/;  # Comment and number patterns.
   use Regexp::Common qw /no_defaults/;     # Don't load any patterns.
   use Regexp::Common qw /!delimited/;      # All, but delimited patterns.
  
  
  =head1 DESCRIPTION
  
  By default, this module exports a single hash (C<%RE>) that stores or generates
  commonly needed regular expressions (see L<"List of available patterns">).
  
  There is an alternative, subroutine-based syntax described in
  L<"Subroutine-based interface">.
  
  
  =head2 General syntax for requesting patterns
  
  To access a particular pattern, C<%RE> is treated as a hierarchical hash of
  hashes (of hashes...), with each successive key being an identifier. For
  example, to access the pattern that matches real numbers, you 
  specify:
  
          $RE{num}{real}
          
  and to access the pattern that matches integers: 
  
          $RE{num}{int}
  
  Deeper layers of the hash are used to specify I<flags>: arguments that
  modify the resulting pattern in some way. The keys used to access these
  layers are prefixed with a minus sign and may have a value; if a value
  is given, it's done by using a multidimensional key.
  For example, to access the pattern that
  matches base-2 real numbers with embedded commas separating
  groups of three digits (e.g. 10,101,110.110101101):
  
          $RE{num}{real}{-base => 2}{-sep => ','}{-group => 3}
  
  Through the magic of Perl, these flag layers may be specified in any order
  (and even interspersed through the identifier keys!)
  so you could get the same pattern with:
  
          $RE{num}{real}{-sep => ','}{-group => 3}{-base => 2}
  
  or:
  
          $RE{num}{-base => 2}{real}{-group => 3}{-sep => ','}
  
  or even:
  
          $RE{-base => 2}{-group => 3}{-sep => ','}{num}{real}
  
  etc.
  
  Note, however, that the relative order of amongst the identifier keys
  I<is> significant. That is:
  
          $RE{list}{set}
  
  would not be the same as:
  
          $RE{set}{list}
  
  =head2 Flag syntax
  
  In versions prior to 2.113, flags could also be written as
  C<{"-flag=value"}>. This no longer works, although C<{"-flag$;value"}>
  still does. However, C<< {-flag => 'value'} >> is the preferred syntax.
  
  =head2 Universal flags
  
  Normally, flags are specific to a single pattern.
  However, there is two flags that all patterns may specify.
  
  =over 4
  
  =item C<-keep>
  
  By default, the patterns provided by C<%RE> contain no capturing
  parentheses. However, if the C<-keep> flag is specified (it requires
  no value) then any significant substrings that the pattern matches
  are captured. For example:
  
          if ($str =~ $RE{num}{real}{-keep}) {
                  $number   = $1;
                  $whole    = $3;
                  $decimals = $5;
          }
  
  Special care is needed if a "kept" pattern is interpolated into a
  larger regular expression, as the presence of other capturing
  parentheses is likely to change the "number variables" into which significant
  substrings are saved.
  
  See also L<"Adding new regular expressions">, which describes how to create
  new patterns with "optional" capturing brackets that respond to C<-keep>.
  
  =item C<-i>
  
  Some patterns or subpatterns only match lowercase or uppercase letters.
  If one wants the do case insensitive matching, one option is to use
  the C</i> regexp modifier, or the special sequence C<(?i)>. But if the
  functional interface is used, one does not have this option. The 
  C<-i> switch solves this problem; by using it, the pattern will do
  case insensitive matching.
  
  =back
  
  =head2 OO interface and inline matching/substitution
  
  The patterns returned from C<%RE> are objects, so rather than writing:
  
          if ($str =~ /$RE{some}{pattern}/ ) {...}
  
  you can write:
  
          if ( $RE{some}{pattern}->matches($str) ) {...}
  
  For matching this would seem to have no great advantage apart from readability
  (but see below).
  
  For substitutions, it has other significant benefits. Frequently you want to
  perform a substitution on a string without changing the original. Most people
  use this:
  
          $changed = $original;
          $changed =~ s/$RE{some}{pattern}/$replacement/;
  
  The more adept use:
  
          ($changed = $original) =~ s/$RE{some}{pattern}/$replacement/;
  
  Regexp::Common allows you do write this:
  
          $changed = $RE{some}{pattern}->subs($original=>$replacement);
  
  Apart from reducing precedence-angst, this approach has the added
  advantages that the substitution behaviour can be optimized from the 
  regular expression, and the replacement string can be provided by
  default (see L<"Adding new regular expressions">).
  
  For example, in the implementation of this substitution:
  
          $cropped = $RE{ws}{crop}->subs($uncropped);
  
  the default empty string is provided automatically, and the substitution is
  optimized to use:
  
          $uncropped =~ s/^\s+//;
          $uncropped =~ s/\s+$//;
  
  rather than:
  
          $uncropped =~ s/^\s+|\s+$//g;
  
  
  =head2 Subroutine-based interface
  
  The hash-based interface was chosen because it allows regexes to be
  effortlessly interpolated, and because it also allows them to be
  "curried". For example:
  
          my $num = $RE{num}{int};
  
          my $commad     = $num->{-sep=>','}{-group=>3};
          my $duodecimal = $num->{-base=>12};
  
  
  However, the use of tied hashes does make the access to Regexp::Common
  patterns slower than it might otherwise be. In contexts where impatience
  overrules laziness, Regexp::Common provides an additional
  subroutine-based interface.
  
  For each (sub-)entry in the C<%RE> hash (C<$RE{key1}{key2}{etc}>), there
  is a corresponding exportable subroutine: C<RE_key1_key2_etc()>. The name of
  each subroutine is the underscore-separated concatenation of the I<non-flag>
  keys that locate the same pattern in C<%RE>. Flags are passed to the subroutine
  in its argument list. Thus:
  
          use Regexp::Common qw( RE_ws_crop RE_num_real RE_profanity );
  
          $str =~ RE_ws_crop() and die "Surrounded by whitespace";
  
          $str =~ RE_num_real(-base=>8, -sep=>" ") or next;
  
          $offensive = RE_profanity(-keep);
          $str =~ s/$offensive/$bad{$1}++; "<expletive deleted>"/ge;
  
  Note that, unlike the hash-based interface (which returns objects), these
  subroutines return ordinary C<qr>'d regular expressions. Hence they do not
  curry, nor do they provide the OO match and substitution inlining described
  in the previous section.
  
  It is also possible to export subroutines for all available patterns like so:
  
          use Regexp::Common 'RE_ALL';
  
  Or you can export all subroutines with a common prefix of keys like so:
  
          use Regexp::Common 'RE_num_ALL';
  
  which will export C<RE_num_int> and C<RE_num_real> (and if you have
  create more patterns who have first key I<num>, those will be exported
  as well). In general, I<RE_key1_..._keyn_ALL> will export all subroutines
  whose pattern names have first keys I<key1> ... I<keyn>.
  
  
  =head2 Adding new regular expressions
  
  You can add your own regular expressions to the C<%RE> hash at run-time,
  using the exportable C<pattern> subroutine. It expects a hash-like list of 
  key/value pairs that specify the behaviour of the pattern. The various
  possible argument pairs are:
  
  =over 4
  
  =item C<name =E<gt> [ @list ]>
  
  A required argument that specifies the name of the pattern, and any
  flags it may take, via a reference to a list of strings. For example:
  
           pattern name => [qw( line of -char )],
                   # other args here
                   ;
  
  This specifies an entry C<$RE{line}{of}>, which may take a C<-char> flag.
  
  Flags may also be specified with a default value, which is then used whenever
  the flag is specified without an explicit value (but not when the flag is
  omitted). For example:
  
           pattern name => [qw( line of -char=_ )],
                   # default char is '_'
                   # other args here
                   ;
  
  
  =item C<create =E<gt> $sub_ref_or_string>
  
  A required argument that specifies either a string that is to be returned
  as the pattern:
  
          pattern name    => [qw( line of underscores )],
                  create  => q/(?:^_+$)/
                  ;
  
  or a reference to a subroutine that will be called to create the pattern:
  
          pattern name    => [qw( line of -char=_ )],
                  create  => sub {
                                  my ($self, $flags) = @_;
                                  my $char = quotemeta $flags->{-char};
                                  return '(?:^$char+$)';
                              },
                  ;
  
  If the subroutine version is used, the subroutine will be called with 
  three arguments: a reference to the pattern object itself, a reference
  to a hash containing the flags and their values,
  and a reference to an array containing the non-flag keys. 
  
  Whatever the subroutine returns is stringified as the pattern.
  
  No matter how the pattern is created, it is immediately postprocessed to
  include or exclude capturing parentheses (according to the value of the
  C<-keep> flag). To specify such "optional" capturing parentheses within
  the regular expression associated with C<create>, use the notation
  C<(?k:...)>. Any parentheses of this type will be converted to C<(...)>
  when the C<-keep> flag is specified, or C<(?:...)> when it is not.
  It is a Regexp::Common convention that the outermost capturing parentheses
  always capture the entire pattern, but this is not enforced.
  
  
  =item C<match =E<gt> $sub_ref>
  
  An optional argument that specifies a subroutine that is to be called when
  the C<$RE{...}-E<gt>matches(...)> method of this pattern is invoked.
  
  The subroutine should expect two arguments: a reference to the pattern object
  itself, and the string to be matched against.
  
  It should return the same types of values as a C<m/.../> does.
  
       pattern name    => [qw( line of -char )],
               create  => sub {...},
               match   => sub {
                               my ($self, $str) = @_;
                               $str !~ /[^$self->{flags}{-char}]/;
                          },
               ;
  
  
  =item C<subs =E<gt> $sub_ref>
  
  An optional argument that specifies a subroutine that is to be called when
  the C<$RE{...}-E<gt>subs(...)> method of this pattern is invoked.
  
  The subroutine should expect three arguments: a reference to the pattern object
  itself, the string to be changed, and the value to be substituted into it.
  The third argument may be C<undef>, indicating the default substitution is
  required.
  
  The subroutine should return the same types of values as an C<s/.../.../> does.
  
  For example:
  
       pattern name    => [ 'lineof', '-char=_' ],
               create  => sub {...},
               subs    => sub {
                            my ($self, $str, $ignore_replacement) = @_;
                            $_[1] =~ s/^$self->{flags}{-char}+$//g;
                          },
               ;
  
  Note that such a subroutine will almost always need to modify C<$_[1]> directly.
  
  
  =item C<version =E<gt> $minimum_perl_version>
  
  If this argument is given, it specifies the minimum version of perl required
  to use the new pattern. Attempts to use the pattern with earlier versions of
  perl will generate a fatal diagnostic.
  
  =back
  
  =head2 Loading specific sets of patterns.
  
  By default, all the sets of patterns listed below are made available.
  However, it is possible to indicate which sets of patterns should
  be made available - the wanted sets should be given as arguments to
  C<use>. Alternatively, it is also possible to indicate which sets of
  patterns should not be made available - those sets will be given as
  argument to the C<use> statement, but are preceded with an exclaimation
  mark. The argument I<no_defaults> indicates none of the default patterns
  should be made available. This is useful for instance if all you want
  is the C<pattern()> subroutine.
  
  Examples:
  
   use Regexp::Common qw /comment number/;  # Comment and number patterns.
   use Regexp::Common qw /no_defaults/;     # Don't load any patterns.
   use Regexp::Common qw /!delimited/;      # All, but delimited patterns.
  
  It's also possible to load your own set of patterns. If you have a
  module C<Regexp::Common::my_patterns> that makes patterns available,
  you can have it made available with
  
   use Regexp::Common qw /my_patterns/;
  
  Note that the default patterns will still be made available - only if
  you use I<no_defaults>, or mention one of the default sets explicitly,
  the non mentioned defaults aren't made available.
  
  =head2 List of available patterns
  
  The patterns listed below are currently available. Each set of patterns
  has its own manual page describing the details. For each pattern set
  named I<name>, the manual page I<Regexp::Common::name> describes the
  details.
  
  Currently available are:
  
  =over 4
  
  =item Regexp::Common::balanced
  
  Provides regexes for strings with balanced parenthesized delimiters.
  
  =item Regexp::Common::comment
  
  Provides regexes for comments of various languages (43 languages
  currently).
  
  =item Regexp::Common::delimited
  
  Provides regexes for delimited strings.
  
  =item Regexp::Common::lingua
  
  Provides regexes for palindromes.
  
  =item Regexp::Common::list
  
  Provides regexes for lists.
  
  =item Regexp::Common::net
  
  Provides regexes for IPv4 addresses and MAC addresses.
  
  =item Regexp::Common::number
  
  Provides regexes for numbers (integers and reals).
  
  =item Regexp::Common::profanity
  
  Provides regexes for profanity.
  
  =item Regexp::Common::whitespace
  
  Provides regexes for leading and trailing whitespace.
  
  =item Regexp::Common::zip
  
  Provides regexes for zip codes.
  
  =back
  
  =head2 Forthcoming patterns and features
  
  Future releases of the module will also provide patterns for the following:
  
          * email addresses 
          * HTML/XML tags
          * more numerical matchers,
          * mail headers (including multiline ones),
          * more URLS
          * telephone numbers of various countries
          * currency (universal 3 letter format, Latin-1, currency names)
          * dates
          * binary formats (e.g. UUencoded, MIMEd)
  
  If you have other patterns or pattern generators that you think would be
  generally useful, please send them to the maintainer -- preferably as source
  code using the C<pattern> subroutine. Submissions that include a set of
  tests will be especially welcome.
  
  
  =head1 DIAGNOSTICS
  
  =over 4
  
  =item C<Can't export unknown subroutine %s>
  
  The subroutine-based interface didn't recognize the requested subroutine.
  Often caused by a spelling mistake or an incompletely specified name.
  
          
  =item C<Can't create unknown regex: $RE{...}>
  
  Regexp::Common doesn't have a generator for the requested pattern.
  Often indicates a misspelt or missing parameter.
  
  =item
  C<Perl %f does not support the pattern $RE{...}.
  You need Perl %f or later>
  
  The requested pattern requires advanced regex features (e.g. recursion)
  that not available in your version of Perl. Time to upgrade.
  
  =item C<< pattern() requires argument: name => [ @list ] >>
  
  Every user-defined pattern specification must have a name.
  
  =item C<< pattern() requires argument: create => $sub_ref_or_string >>
  
  Every user-defined pattern specification must provide a pattern creation
  mechanism: either a pattern string or a reference to a subroutine that
  returns the pattern string.
  
  =item C<Base must be between 1 and 36>
  
  The C<< $RE{num}{real}{-base=>'I<N>'} >> pattern uses the characters [0-9A-Z]
  to represent the digits of various bases. Hence it only produces
  regular expressions for bases up to hexatricensimal.
  
  =item C<Must specify delimiter in $RE{delimited}>
  
  The pattern has no default delimiter.
  You need to write: C<< $RE{delimited}{-delim=>I<X>'} >> for some character I<X>
  
  =back
  
  =head1 ACKNOWLEDGEMENTS
  
  Deepest thanks to the many people who have encouraged and contributed to this
  project, especially: Elijah, Jarkko, Tom, Nat, Ed, and Vivek.
  
  Further thanks go to: Alexandr Ciornii, Blair Zajac, Bob Stockdale,
  Charles Thomas, Chris Vertonghen, the CPAN Testers, David Hand,
  Fany, Geoffrey Leach, Hermann-Marcus Behrens, Jerome Quelin, Jim Cromie,
  Lars Wilke, Linda Julien, Mike Arms, Mike Castle, Mikko, Murat Uenalan,
  RafaE<235>l Garcia-Suarez, Ron Savage, Sam Vilain, Slaven Rezic, Smylers,
  Tim Maher, and all the others I've forgotten.
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  For a start, there are many common regexes missing.
  Send them in to I<regexp-common@abigail.be>.
  
  There are some POD issues when installing this module using a pre-5.6.0 perl;
  some manual pages may not install, or may not install correctly using a perl
  that is that old. You might consider upgrading your perl.
  
  =head1 NOT A BUG
  
  =over 4
  
  =item *
  
  The various patterns are not anchored. That is, a pattern like 
  C<< $RE {num} {int} >> will match against "abc4def", because a 
  substring of the subject matches. This is by design, and not a
  bug. If you want the pattern to be anchored, use something like:
  
   my $integer = $RE {num} {int};
   $subj =~ /^$integer$/ and print "Matches!\n";
  
  =back
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2011, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
PERL5_REGEXP_COMMON

$fatpacked{"perl5/Regexp/Common/CC.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_REGEXP_COMMON_CC';
  package Regexp::Common::CC;
  
  use Regexp::Common qw /pattern clean no_defaults/;
  use Regexp::Common::_support qw /luhn/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2016020301';
  
  my @cards = (
      # Name           Prefix                    Length           mod 10
      [Mastercard   =>   '5[1-5]',                16,                1],
      [Visa         =>   '4',                     [13, 16],          1],
      [Amex         =>   '3[47]',                 15,                1],
     # Carte Blanche
     ['Diners Club' =>   '3(?:0[0-5]|[68])',      14,                1],
      [Discover     =>   '6011',                  16,                1],
      [enRoute      =>   '2(?:014|149)',          15,                0],
      [JCB          => [['3',                     16,                1],
                        ['2131|1800',             15,                1]]],
  );
  
  
  foreach my $card (@cards) {
      my ($name, $prefix, $length, $mod) = @$card;
  
      # Skip the harder ones for now.
      next if ref $prefix || ref $length;
      next unless $mod;
  
      my $times = $length + $mod;
      pattern name    => [CC => $name],
              version => 5.006,
              create  => sub {
                  use re 'eval';
                  qr <((?=($prefix))[0-9]{$length})
                      (?(?{Regexp::Common::_support::luhn $1})|(?!))>x
              }
      ;
  }
  
  
  
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::CC -- provide patterns for credit card numbers.
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /CC/;
  
      while (<>) {
          /^$RE{CC}{Mastercard}$/   and  print "Mastercard card number\n";
      }
  
  =head1 DESCRIPTION
  
  Please consult the manual of L<Regexp::Common> for a general description
  of the works of this interface.
  
  Do not use this module directly, but load it via I<Regexp::Common>.
  
  This module offers patterns for credit card numbers of several major
  credit card types. Currently, the supported cards are: I<Mastercard>,
  I<Amex>, I<Diners Club>, and I<Discover>.
  
  
  =head1 SEE ALSO
  
  L<Regexp::Common> for a general description of how to use this interface.
  
  =over 4
  
  =item L<http://www.beachnet.com/~hstiles/cardtype.html>
  
  Credit Card Validation - Check Digits 
  
  =item L<http://euro.ecom.cmu.edu/resources/elibrary/everycc.htm>
  
  Everything you ever wanted to know about CC's
  
  =item L<http://www.webopedia.com/TERM/L/Luhn_formula.html>
  
  Luhn formula
  
  =back
  
  =head1 AUTHORS
  
  Damian Conway S<(I<damian@conway.org>)> and
  Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty. Send them in to S<I<regexp-common@abigail.be>>.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
PERL5_REGEXP_COMMON_CC

$fatpacked{"perl5/Regexp/Common/Exim.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_REGEXP_COMMON_EXIM';
  package Regexp::Common::Exim;
  
  use strict;
  use warnings;
  
  use Regexp::Common qw(pattern clean no_defaults);
  
  use vars qw/$VERSION/;
  $VERSION = '2015122201';
  
  pattern name => [ qw(exim message) ],
        create => q/^((?:\S+) (?:\S+)) (?:(\S+) (<=|=>|->|>>|\*>|\*\*|==|Completed|SMTP connection outbound)(?:$| ))(.*)/;
  
  pattern name => [ qw(exim exec) ],
        create => q/((\S+) (\d+) args: (.*))/;
  
  pattern name => [ qw(exim inbound) ],
        create => q/((\S+\s*(<[^>]+>)?) (.*))/;
  
  pattern name => [ qw(exim inbound local) ],
        create => q/(^(\S+\s*(<[^>]+>)?) ((?:(?:R=\S+) )?(?:U=\S+) (?:P=local) (?:S=\d+)(?: (?:id=\S+))?(?: (?:T=".*"))?))/;
  
  pattern name => [ qw(exim inbound remote) ],
        create => q/(^(\S+\s*(<[^>]+>)?) ((?:H=.*? \[[^\]]+\]:\d+) (?:I=\[[^\]]+\]:\d+) (?:P=\S+)(?: (?:X=\S+)(?: (?:DN=".*?"))?)?(?: (?:A=dovecot_[^:]+:\S+))?(?: (?:S=\d+))?(?: (?:id=\S+))?(?: (?:T=".*"))?))/;
  
  pattern name => [ qw(exim outbound) ],
        create => q/((\d+) (\S+) (\S+) (<?[^>\s]+>?) ((?:I=\S+) (?:S=\S+) (?:F=.*)))/;
  
  pattern name => [ qw(exim delivery) ],
        create => q/(^(.*?\s*(?:\([^\)]+?\)?)?(?: <[^>]+>)?) ((?:F=\S+) (?:R=\S+) (?:T=\S+)(?: (?:S=\d+)(?: (?:H=.*? \[([^\]]+)\])(?: (?:X=\S+)(?: (?:DN=".*"))?)?)?(?: (?:C=".*"))?)?))/;
  
  pattern name => [ qw(exim delivery failure) ],
        create => q/(^(\S+\s*(<[^>]+>)?) (.*?): (.*))/;
  
  pattern name => [ qw(exim delivery pipe) ],
        create => q/(^\|(.*?) \(([^\)]+?)\) <([^>]+)>)/;
  
  pattern name => [ qw(exim info address) ],
        create => q/(^([^@+]+[@+]\S+)(?: <([^>]+)>)?)/;
  
  pattern name => [ qw(exim info host) ],
        create => q/(^(\S*\s*\([\)]+\)) (\[[^\]]+\]:\d+))/;
  
  pattern name => [ qw(exim info timestamp) ],
        create => q/(^(\d{4})-(\d{2})-(\d{2})\s(\d{2}):(\d{2}):(\d{2}))/;
  
  pattern name => [ qw(exim info HELO) ],
        create => q/(^(\S+)?\s*\(([^\)]+)\))/;
  
  pattern name => [ qw(exim info network) ],
        create => q/(^\[([^:]+)\]:(\d+)$)/;
  
  pattern name => [ qw(exim info login) ],
        create => q/(A=dovecot_([^:]+):(\S+))/;
  
  pattern name => [ qw(exim fields) ],
        create => q/((\w+=(?:".*"|\S+))\s*)/;
  
  pattern name => [ qw(exim info fields) ],
        create => q/((\w+)=(?:"(.*)"|(\S+))\s*)/;
  
  pattern name => [ qw(exim info cron) ],
        create => q,^\S+ \S+ cwd=\S+ 9 args: /usr/sbin/sendmail -FCronDaemon -i -odi -oem -oi -t -f (\S+)$,;
  
  pattern name => [ qw(exim info script) ],
        create => q,^\S+ \S+ cwd=(/home\S+)(?!.*-FCronDaemon.*$),;
  
  1;
PERL5_REGEXP_COMMON_EXIM

$fatpacked{"perl5/Regexp/Common/Maillog.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_REGEXP_COMMON_MAILLOG';
  package Regexp::Common::Maillog;
  
  use strict;
  use warnings;
  
  use Regexp::Common qw(pattern clean no_defaults);
  
  use vars qw/$VERSION/;
  $VERSION = '2015122201';
  
  pattern name => [ qw(mail login) ],
        create => q/^((?:\w{3})\s{1,2}(?:\d{1,2})\s(?:\d{2}):(?:\d{2}):(?:\d{2})) \S+ \S+ ([^-]+)-login: Login: (.*)/;
  
  pattern name => [ qw(mail login timestamp) ],
        create => q/^(\w{3})\s{1,2}(\d{1,2})\s(\d{2}):(\d{2}):(\d{2})$/;
  
  pattern name => [ qw(mail login info) ],
        create => q/^user=<([^>]+)>.*?rip=([^,]+), lip=([^,]+),.*/;
  
  1;
PERL5_REGEXP_COMMON_MAILLOG

$fatpacked{"perl5/Regexp/Common/SEN.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_REGEXP_COMMON_SEN';
  package Regexp::Common::SEN;
  
  use Regexp::Common qw /pattern clean no_defaults/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2016020301';
  
  =begin does_not_exist
  
  sub par11 {
      my $string = shift;
      my $sum    = 0;
      for my $i (0 .. length ($string) - 1) {
          my $c = substr ($string, $i, 1);
          $sum += $c * (length ($string) - $i)
      }
      !($sum % 11)
  }
  
  =end does_not_exist
  =cut
  
  # http://www.ssa.gov/history/ssn/geocard.html
  pattern name   => [qw /SEN USA SSN -sep=-/],
          create => sub {
              my $sep = $_ [1] {-sep};
              "(?k:(?k:[1-9][0-9][0-9]|0[1-9][0-9]|00[1-9])$sep"   .
                  "(?k:[1-9][0-9]|0[1-9])$sep"                     .
                  "(?k:[1-9][0-9][0-9][0-9]|0[1-9][0-9][0-9]|"     .
                                           "00[1-9][0-9]|000[1-9]))"
          },
          ;
  
  =begin does_not_exist
  
  It's not clear whether this is the right checksum.
  
  # http://www.google.nl/search?q=cache:8m1zKNYrEO0J:www.enschede.nl/nieuw/projecten/aanbesteding/integratie/pve%2520Bijlage%25207.5.doc+Sofi+nummer+formaat&hl=en&start=56&lr=lang_en|lang_nl&ie=UTF-8
  pattern name   => [qw /SEN Netherlands SoFi/],
          create => sub {
              # 9 digits (d1 d2 d3 d4 d5 d6 d7 d8 d9)
              # 9*d1 + 8*d2 + 7*d3 + 6*d4 + 5*d5 + 4*d6 + 3*d7 + 2*d8 + 1*d9 
              # == 0 mod 11.
              qr /([0-9]{9})(?(?{par11 ($^N)})|(?!))/;
          }
          ;
  
  =end does_not_exist
  =cut
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::SEN -- provide regexes for Social-Economical Numbers.
  
  =head1 SYNOPSIS
  
   use Regexp::Common qw /SEN/;
  
   while (<>) {
       /^$RE{SEN}{USA}{SSN}$/    and  print "Social Security Number\n";
   }
  
  
  =head1 DESCRIPTION
  
  Please consult the manual of L<Regexp::Common> for a general description
  of the works of this interface.
  
  Do not use this module directly, but load it via I<Regexp::Common>.
  
  =head2 C<$RE{SEN}{USA}{SSN}{-sep}>
  
  Returns a pattern that matches an American Social Security Number (SSN).
  SSNs consist of three groups of numbers, separated by a hypen (C<->).
  This pattern only checks for a valid structure, that is, it validates
  whether a number is valid SSN, was a valid SSN, or maybe a valid SSN
  in the future. There are almost a billion possible SSNs, and about 
  400 million are in use, or have been in use. 
  
  If C<-sep=I<P>> is specified, the pattern I<P> is used as the
  separator between the groups of numbers.
  
  Under C<-keep> (see L<Regexp::Common>):
  
  =over 4
  
  =item $1
  
  captures the entire SSN.
  
  =item $2
  
  captures the first group of digits (the area number).
  
  =item $3
  
  captures the second group of digits (the group number).
  
  =item $4
  
  captures the third group of digits (the serial number).
  
  =back
  
  =head1 SEE ALSO
  
  L<Regexp::Common> for a general description of how to use this interface.
  
  =head1 AUTHORS
  
  Damian Conway and Abigail.
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  For a start, there are many common regexes missing.
  Send them in to I<regexp-common@abigail.be>.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
PERL5_REGEXP_COMMON_SEN

$fatpacked{"perl5/Regexp/Common/SpamReport.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_REGEXP_COMMON_SPAMREPORT';
  package Regexp::Common::SpamReport;
  
  use strict;
  use warnings;
  
  use Regexp::Common qw(pattern clean no_defaults);
  
  use vars qw/$VERSION/;
  $VERSION = '2015122201';
  
  pattern name => [ qw(spam common_scraped) ],
      create => q/((?:spam|abuse|nobody|void|noreply|info|_)@.*|.*(?:mai\.com|\.gov|\.mil))/;
  
  pattern name => [ qw(spam hi_destination) ],
      create => q/\.?(aol|aim|amazon(?:aws)?|att(?:global|ymail)?|comcast|compuserve|cox(?:inet)?|earthlink|g(?:oogle)?mail|hostmail|(?:windows)?live|mindspring|msn|outlook|prodigy|qwest|rocketmail|rr|swbell|terra|twc|y(?:ahoo(?:fs)?|mail)|verizon(?:mail)?|virgin(?:broadband)?)/;
  
  pattern name => [ qw(spam hi_source) ],
      create => q/\.?(altavista|angelfire|aol|aim|amazon(?:aws)?|att(?:global|ymail)?|bigpond|charter|chooseyourmail|cia|comcast|compuserve|cox(?:inet)?|earthlink|email(?:2me|4u|account|engine|user|x)|excite|email|facebook|falseaddress|fast(?:-?e?mail(?:er)?(?:box)?|imap|messaging)|fbi|fmail|free(?:mail|net)|geocities|ghostmail|gmx|g(?:oogle)?mail|hotmail|hush(?:mail)?|icq(?:mail)?|juno|(?:windows)?live|lycos|msn|mindspring|outlook|prodigy|qwest|rocketmail|swbell|terra|twc|rr|usa|vahoo|verizon(?:mail)?|virgin(?:broadband)?|vnn|y(?:ahoo(?:fs)?|mail)|yandex|zmail)\.(?:com?(?:\.[^.]+)?|[^.]+)/;
  
  pattern name => [ qw(spam spammy_tld) ],
      create => q/\.(cn|hu|br|co\.za|sg|hk|ph|jp|ru|tk|ar|de|gr|vn|kr|cc|co|pw|eu|mx|no|my|se|tw|us|zip|review|country|kim|cricket|science|space|work|party|gq|link|xyz|top|click|win|biz|bid|download|trade|webcam|date|review|faith|racing)(\.|$)/;
  
  pattern name => [ qw(cpanel addpop) ],
      create => q/^(\S+)\s(?:\S+)\s(\S+)\s\[([^\]]+)\]\s"GET\s\/.*?\?(.*?&?cpanel_jsonapi_func=addpop&?.*?)\sHTTP\/1\.\d"/;
  
  pattern name => [ qw(apache timestamp) ],
      create => q/(\d{2})\/(\d{2})\/(\d{4}):(\d{2}):(\d{2}):(\d{2})\s(-?\d{4})/;
  
  1;
PERL5_REGEXP_COMMON_SPAMREPORT

$fatpacked{"perl5/Regexp/Common/URI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_REGEXP_COMMON_URI';
  package Regexp::Common::URI;
  
  use Regexp::Common qw /pattern clean no_defaults/;
  
  use strict;
  use warnings;
  
  use Exporter ();
  use vars qw /@EXPORT_OK @ISA/;
  
  @ISA       = qw /Exporter/;
  @EXPORT_OK = qw /register_uri/;
  
  use Regexp::Common qw /pattern clean no_defaults/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2016020301';
  
  # Use 'require' here, not 'use', so we delay running them after we are compiled.
  # We also do it using an 'eval'; this saves us from have repeated similar
  # lines. The eval is further explained in 'perldoc -f require'.
  my @uris = qw /fax file ftp gopher http pop prospero news tel telnet tv wais/;
  foreach my $uri (@uris) {
      eval "require Regexp::Common::URI::$uri";
      die $@ if $@;
  }
  
  my %uris;
  
  sub register_uri {
      my ($scheme, $uri) = @_;
      $uris {$scheme} = $uri;
  }
  
  pattern name    => [qw (URI)],
          create  => sub {my $uri =  join '|' => values %uris;
                             $uri =~ s/\(\?k:/(?:/g;
                        "(?k:$uri)";
          },
          ;
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::URI -- provide patterns for URIs.
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /URI/;
  
      while (<>) {
          /$RE{URI}{HTTP}/       and  print "Contains an HTTP URI.\n";
      }
  
  =head1 DESCRIPTION
  
  Patterns for the following URIs are supported: fax, file, FTP, gopher,
  HTTP, news, NTTP, pop, prospero, tel, telnet, tv and WAIS.
  Each is documented in the I<Regexp::Common::URI::B<scheme>>,
  manual page, for the appropriate scheme (in lowercase), except for
  I<NNTP> URIs which are found in I<Regexp::Common::URI::news>.
  
  =head2 C<$RE{URI}>
  
  Return a pattern that recognizes any of the supported URIs. With
  C<{-keep}>, only the entire URI is returned (in C<$1>).
  
  =head1 REFERENCES
  
  =over 4
  
  =item B<[DRAFT-URI-TV]>
  
  Zigmond, D. and Vickers, M: I<Uniform Resource Identifiers for
  Television Broadcasts>. December 2000.
  
  =item B<[DRAFT-URL-FTP]>
  
  Casey, James: I<A FTP URL Format>. November 1996.
  
  =item B<[RFC 1035]>
  
  Mockapetris, P.: I<DOMAIN NAMES - IMPLEMENTATION AND SPECIFICATION>.
  November 1987.
  
  =item B<[RFC 1738]>
  
  Berners-Lee, Tim, Masinter, L., McCahill, M.: I<Uniform Resource
  Locators (URL)>. December 1994.
  
  =item B<[RFC 2396]>
  
  Berners-Lee, Tim, Fielding, R., and Masinter, L.: I<Uniform Resource
  Identifiers (URI): Generic Syntax>. August 1998.
  
  =item B<[RFC 2616]>
  
  Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., 
  Leach, P. and Berners-Lee, Tim: I<Hypertext Transfer Protocol -- HTTP/1.1>.
  June 1999.
  
  =item B<[RFC 2806]>
  
  Vaha-Sipila, A.: I<URLs for Telephone Calls>. April 2000.
  
  =back
  
  =head1 SEE ALSO
  
  L<Regexp::Common> for a general description of how to use this interface.
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  For a start, there are many common regexes missing.
  Send them in to I<regexp-common@abigail.be>.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
PERL5_REGEXP_COMMON_URI

$fatpacked{"perl5/Regexp/Common/URI/RFC1035.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_REGEXP_COMMON_URI_RFC1035';
  package Regexp::Common::URI::RFC1035;
  
  use Regexp::Common qw /pattern clean no_defaults/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2016020301';
  
  use vars qw /@EXPORT @EXPORT_OK %EXPORT_TAGS @ISA/;
  
  use Exporter ();
  @ISA = qw /Exporter/;
  
  my %vars;
  
  BEGIN {
      $vars {low}     = [qw /$digit $letter $let_dig $let_dig_hyp $ldh_str/];
      $vars {parts}   = [qw /$label $subdomain/];
      $vars {domain}  = [qw /$domain/];
  }
  
  use vars map {@$_} values %vars;
  
  @EXPORT      = qw /$host/;
  @EXPORT_OK   = map {@$_} values %vars;
  %EXPORT_TAGS = (%vars, ALL => [@EXPORT_OK]);
  
  # RFC 1035.
  $digit             = "[0-9]";
  $letter            = "[A-Za-z]";
  $let_dig           = "[A-Za-z0-9]";
  $let_dig_hyp       = "[-A-Za-z0-9]";
  $ldh_str           = "(?:[-A-Za-z0-9]+)";
  $label             = "(?:$letter(?:(?:$ldh_str){0,61}$let_dig)?)";
  $subdomain         = "(?:$label(?:[.]$label)*)";
  $domain            = "(?: |(?:$subdomain))";
  
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::URI::RFC1035 -- Definitions from RFC1035;
  
  =head1 SYNOPSIS
  
      use Regexp::Common::URI::RFC1035 qw /:ALL/;
  
  =head1 DESCRIPTION
  
  This package exports definitions from RFC1035. It's intended
  usage is for Regexp::Common::URI submodules only. Its interface
  might change without notice.
  
  =head1 REFERENCES
  
  =over 4
  
  =item B<[RFC 1035]>
  
  Mockapetris, P.: I<DOMAIN NAMES - IMPLEMENTATION AND SPECIFICATION>.
  November 1987.
  
  =back
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
PERL5_REGEXP_COMMON_URI_RFC1035

$fatpacked{"perl5/Regexp/Common/URI/RFC1738.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_REGEXP_COMMON_URI_RFC1738';
  package Regexp::Common::URI::RFC1738;
  
  use Regexp::Common qw /pattern clean no_defaults/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2016020301';
  
  use vars qw /@EXPORT @EXPORT_OK %EXPORT_TAGS @ISA/;
  
  use Exporter ();
  @ISA = qw /Exporter/;
  
  
  my %vars;
  
  BEGIN {
      $vars {low}     = [qw /$digit $digits $hialpha $lowalpha $alpha $alphadigit
                             $safe $extra $national $punctuation $unreserved
                             $unreserved_range $reserved $uchar $uchars $xchar
                             $xchars $hex $escape/];
  
      $vars {connect} = [qw /$port $hostnumber $toplabel $domainlabel $hostname
                             $host $hostport $user $password $login/];
  
      $vars {parts}   = [qw /$fsegment $fpath $group $article $grouppart
                             $search $database $wtype $wpath $psegment
                             $fieldname $fieldvalue $fieldspec $ppath/];
  }
  
  use vars map {@$_} values %vars;
  
  @EXPORT      = qw /$host/;
  @EXPORT_OK   = map {@$_} values %vars;
  %EXPORT_TAGS = (%vars, ALL => [@EXPORT_OK]);
  
  # RFC 1738, base definitions.
  
  # Lowlevel definitions.
  $digit             =  '[0-9]';
  $digits            =  '[0-9]+';
  $hialpha           =  '[A-Z]';
  $lowalpha          =  '[a-z]';
  $alpha             =  '[a-zA-Z]';                 # lowalpha | hialpha
  $alphadigit        =  '[a-zA-Z0-9]';              # alpha    | digit
  $safe              =  '[-$_.+]';
  $extra             =  "[!*'(),]";
  $national          =  '[][{}|\\^~`]';
  $punctuation       =  '[<>#%"]';
  $unreserved_range  = q [-a-zA-Z0-9$_.+!*'(),];  # alphadigit | safe | extra
  $unreserved        =  "[$unreserved_range]";
  $reserved          =  '[;/?:@&=]';
  $hex               =  '[a-fA-F0-9]';
  $escape            =  "(?:%$hex$hex)";
  $uchar             =  "(?:$unreserved|$escape)";
  $uchars            =  "(?:(?:$unreserved|$escape)*)";
  $xchar             =  "(?:[$unreserved_range;/?:\@&=]|$escape)";
  $xchars            =  "(?:(?:[$unreserved_range;/?:\@&=]|$escape)*)";
  
  # Connection related stuff.
  $port              =  "(?:$digits)";
  $hostnumber        =  "(?:$digits\[.]$digits\[.]$digits\[.]$digits)";
  $toplabel          =  "(?:$alpha\[-a-zA-Z0-9]*$alphadigit|$alpha)";
  $domainlabel       =  "(?:(?:$alphadigit\[-a-zA-Z0-9]*)?$alphadigit)";
  $hostname          =  "(?:(?:$domainlabel\[.])*$toplabel)";
  $host              =  "(?:$hostname|$hostnumber)";
  $hostport          =  "(?:$host(?::$port)?)";
  
  $user              =  "(?:(?:[$unreserved_range;?&=]|$escape)*)";
  $password          =  "(?:(?:[$unreserved_range;?&=]|$escape)*)";
  $login             =  "(?:(?:$user(?::$password)?\@)?$hostport)";
  
  # Parts (might require more if we add more URIs).
  
  # FTP/file
  $fsegment          =  "(?:(?:[$unreserved_range:\@&=]|$escape)*)";
  $fpath             =  "(?:$fsegment(?:/$fsegment)*)";
  
  # NNTP/news.
  $group             =  "(?:$alpha\[-A-Za-z0-9.+_]*)";
  $article           =  "(?:(?:[$unreserved_range;/?:&=]|$escape)+" .
                        '@' . "$host)";
  $grouppart         =  "(?:[*]|$article|$group)"; # It's important that
                                                   # $article goes before
                                                   # $group.
  
  # WAIS.
  $search            =  "(?:(?:[$unreserved_range;:\@&=]|$escape)*)";
  $database          =  $uchars;
  $wtype             =  $uchars;
  $wpath             =  $uchars;
  
  # prospero
  $psegment          =  "(?:(?:[$unreserved_range?:\@&=]|$escape)*)";
  $fieldname         =  "(?:(?:[$unreserved_range?:\@&]|$escape)*)";
  $fieldvalue        =  "(?:(?:[$unreserved_range?:\@&]|$escape)*)";
  $fieldspec         =  "(?:;$fieldname=$fieldvalue)";
  $ppath             =  "(?:$psegment(?:/$psegment)*)";
  
  #
  # The various '(?:(?:[$unreserved_range ...]|$escape)*)' above need
  # some loop unrolling to speed up the match.
  #
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::URI::RFC1738 -- Definitions from RFC1738;
  
  =head1 SYNOPSIS
  
      use Regexp::Common::URI::RFC1738 qw /:ALL/;
  
  =head1 DESCRIPTION
  
  This package exports definitions from RFC1738. It's intended
  usage is for Regexp::Common::URI submodules only. Its interface
  might change without notice.
  
  =head1 REFERENCES
  
  =over 4
  
  =item B<[RFC 1738]>
  
  Berners-Lee, Tim, Masinter, L., McCahill, M.: I<Uniform Resource
  Locators (URL)>. December 1994.
  
  =back
  
  =head1 AUTHOR
  
  Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
PERL5_REGEXP_COMMON_URI_RFC1738

$fatpacked{"perl5/Regexp/Common/URI/RFC1808.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_REGEXP_COMMON_URI_RFC1808';
  package Regexp::Common::URI::RFC1808;
  
  BEGIN {
      # This makes sure 'use warnings' doesn't bomb out on 5.005_*;
      # warnings won't be enabled on those old versions though.
      if ($] < 5.006 && !exists $INC {"warnings.pm"}) {
          $INC {"warnings.pm"} = 1;
          no strict 'refs';
          *{"warnings::unimport"} = sub {0};
      }
  }
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2016020301';
  
  use vars qw /@EXPORT @EXPORT_OK %EXPORT_TAGS @ISA/;
  
  use Exporter ();
  @ISA = qw /Exporter/;
  
  
  my %vars;
  
  BEGIN {
      $vars {low}     = [qw /$punctuation $reserved_range $reserved $national
                             $extra $safe $digit $digits $hialpha $lowalpha
                             $alpha $alphadigit $hex $escape $unreserved_range
                             $unreserved $uchar $uchars $pchar_range $pchar
                             $pchars/],
  
      $vars {parts}   = [qw /$fragment $query $param $params $segment
                             $fsegment $path $net_loc $scheme $rel_path
                             $abs_path $net_path $relativeURL $generic_RL
                             $absoluteURL $URL/],
  }
  
  use vars map {@$_} values %vars;
  
  @EXPORT      = qw /$host/;
  @EXPORT_OK   = map {@$_} values %vars;
  %EXPORT_TAGS = (%vars, ALL => [@EXPORT_OK]);
  
  # RFC 1808, base definitions.
  
  # Lowlevel definitions.
  $punctuation       =  '[<>#%"]';
  $reserved_range    = q [;/?:@&=];
  $reserved          =  "[$reserved_range]";
  $national          =  '[][{}|\\^~`]';
  $extra             =  "[!*'(),]";
  $safe              =  '[-$_.+]';
  
  $digit             =  '[0-9]';
  $digits            =  '[0-9]+';
  $hialpha           =  '[A-Z]';
  $lowalpha          =  '[a-z]';
  $alpha             =  '[a-zA-Z]';                 # lowalpha | hialpha
  $alphadigit        =  '[a-zA-Z0-9]';              # alpha    | digit
  
  $hex               =  '[a-fA-F0-9]';
  $escape            =  "(?:%$hex$hex)";
  
  $unreserved_range  = q [-a-zA-Z0-9$_.+!*'(),];  # alphadigit | safe | extra
  $unreserved        =  "[$unreserved_range]";
  $uchar             =  "(?:$unreserved|$escape)";
  $uchars            =  "(?:(?:$unreserved+|$escape)*)";
  
  $pchar_range       = qq [$unreserved_range:\@&=];
  $pchar             =  "(?:[$pchar_range]|$escape)";
  $pchars            =  "(?:(?:[$pchar_range]+|$escape)*)";
  
  
  # Parts
  $fragment          =  "(?:(?:[$unreserved_range$reserved_range]+|$escape)*)";
  $query             =  "(?:(?:[$unreserved_range$reserved_range]+|$escape)*)";
  
  $param             =  "(?:(?:[$pchar_range/]+|$escape)*)";
  $params            =  "(?:$param(?:;$param)*)";
  
  $segment           =  "(?:(?:[$pchar_range]+|$escape)*)";
  $fsegment          =  "(?:(?:[$pchar_range]+|$escape)+)";
  $path              =  "(?:$fsegment(?:/$segment)*)";
  
  $net_loc           =  "(?:(?:[$pchar_range;?]+|$escape)*)";
  $scheme            =  "(?:(?:[-a-zA-Z0-9+.]+|$escape)+)";
  
  $rel_path          =  "(?:$path?(?:;$params)?(?:?$query)?)";
  $abs_path          =  "(?:/$rel_path)";
  $net_path          =  "(?://$net_loc$abs_path?)";
  
  $relativeURL       =  "(?:$net_path|$abs_path|$rel_path)";
  $generic_RL        =  "(?:$scheme:$relativeURL)";
  $absoluteURL       =  "(?:$generic_RL|" .
                  "(?:$scheme:(?:[$unreserved_range$reserved_range]+|$escape)*))";
  $URL               =  "(?:(?:$absoluteURL|$relativeURL)(?:#$fragment)?)";
  
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::URI::RFC1808 -- Definitions from RFC1808;
  
  =head1 SYNOPSIS
  
      use Regexp::Common::URI::RFC1808 qw /:ALL/;
  
  =head1 DESCRIPTION
  
  This package exports definitions from RFC1808. It's intended
  usage is for Regexp::Common::URI submodules only. Its interface
  might change without notice.
  
  =head1 REFERENCES
  
  =over 4
  
  =item B<[RFC 1808]>
  
  Fielding, R.: I<Relative Uniform Resource Locators (URL)>. June 1995.
  
  =back
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
PERL5_REGEXP_COMMON_URI_RFC1808

$fatpacked{"perl5/Regexp/Common/URI/RFC2384.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_REGEXP_COMMON_URI_RFC2384';
  package Regexp::Common::URI::RFC2384;
  
  
  use Regexp::Common qw /pattern clean no_defaults/;
  use Regexp::Common::URI::RFC1738 qw /$unreserved_range $escape $hostport/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2016020301';
  
  use vars qw /@EXPORT @EXPORT_OK %EXPORT_TAGS @ISA/;
  
  use Exporter ();
  @ISA = qw /Exporter/;
  
  
  my %vars;
  
  BEGIN {
      $vars {low}     = [qw /$achar_range $achar $achars $achar_more/];
      $vars {connect} = [qw /$enc_sasl $enc_user $enc_ext $enc_auth_type $auth
                             $user_auth $server/];
      $vars {parts}   = [qw /$pop_url/];
  }
  
  use vars map {@$_} values %vars;
  
  @EXPORT      = qw /$host/;
  @EXPORT_OK   = map {@$_} values %vars;
  %EXPORT_TAGS = (%vars, ALL => [@EXPORT_OK]);
  
  # RFC 2384, POP3.
  
  # Lowlevel definitions.
  $achar_range       =  "$unreserved_range&=~";
  $achar             =  "(?:[$achar_range]|$escape)";
  $achars            =  "(?:(?:[$achar_range]+|$escape)*)";
  $achar_more        =  "(?:(?:[$achar_range]+|$escape)+)";
  $enc_sasl          =  $achar_more;
  $enc_user          =  $achar_more;
  $enc_ext           =  "(?:[+](?:APOP|$achar_more))";
  $enc_auth_type     =  "(?:$enc_sasl|$enc_ext)";
  $auth              =  "(?:;AUTH=(?:[*]|$enc_auth_type))";
  $user_auth         =  "(?:$enc_user$auth?)";
  $server            =  "(?:(?:$user_auth\@)?$hostport)";
  $pop_url           =  "(?:pop://$server)";
  
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::URI::RFC2384 -- Definitions from RFC2384;
  
  =head1 SYNOPSIS
  
      use Regexp::Common::URI::RFC2384 qw /:ALL/;
  
  =head1 DESCRIPTION
  
  This package exports definitions from RFC2384. It's intended
  usage is for Regexp::Common::URI submodules only. Its interface
  might change without notice.
  
  =head1 REFERENCES
  
  =over 4
  
  =item B<[RFC 2384]>
  
  Gellens, R.: I<POP URL scheme> August 1998.
  
  =back
  
  =head1 AUTHOR
  
  Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
PERL5_REGEXP_COMMON_URI_RFC2384

$fatpacked{"perl5/Regexp/Common/URI/RFC2396.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_REGEXP_COMMON_URI_RFC2396';
  package Regexp::Common::URI::RFC2396;
  
  use Regexp::Common qw /pattern clean no_defaults/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2016020301';
  
  use vars qw /@EXPORT @EXPORT_OK %EXPORT_TAGS @ISA/;
  
  use Exporter ();
  @ISA = qw /Exporter/;
  
  
  my %vars;
  
  BEGIN {
      $vars {low}     = [qw /$digit $upalpha $lowalpha $alpha $alphanum $hex
                             $escaped $mark $unreserved $reserved $pchar $uric
                             $urics $userinfo $userinfo_no_colon $uric_no_slash/];
      $vars {parts}   = [qw /$query $fragment $param $segment $path_segments
                             $ftp_segments $rel_segment $abs_path $rel_path
                             $path/];
      $vars {connect} = [qw /$port $IPv4address $toplabel $domainlabel $hostname
                             $host $hostport $server $reg_name $authority/];
      $vars {URI}     = [qw /$scheme $net_path $opaque_part $hier_part
                             $relativeURI $absoluteURI $URI_reference/];
  }
  
  use vars map {@$_} values %vars;
  
  @EXPORT      = ();
  @EXPORT_OK   = map {@$_} values %vars;
  %EXPORT_TAGS = (%vars, ALL => [@EXPORT_OK]);
  
  # RFC 2396, base definitions.
  $digit             =  '[0-9]';
  $upalpha           =  '[A-Z]';
  $lowalpha          =  '[a-z]';
  $alpha             =  '[a-zA-Z]';                # lowalpha | upalpha
  $alphanum          =  '[a-zA-Z0-9]';             # alpha    | digit
  $hex               =  '[a-fA-F0-9]';
  $escaped           =  "(?:%$hex$hex)";
  $mark              =  "[\\-_.!~*'()]";
  $unreserved        =  "[a-zA-Z0-9\\-_.!~*'()]";  # alphanum | mark
                        # %61-%7A, %41-%5A, %30-%39
                        #  a - z    A - Z    0 - 9
                        # %21, %27, %28, %29, %2A, %2D, %2E, %5F, %7E
                        #  !    '    (    )    *    -    .    _    ~
  $reserved          =  "[;/?:@&=+\$,]";
  $pchar             =  "(?:[a-zA-Z0-9\\-_.!~*'():\@&=+\$,]|$escaped)";
                                        # unreserved | escaped | [:@&=+$,]
  $uric              =  "(?:[;/?:\@&=+\$,a-zA-Z0-9\\-_.!~*'()]|$escaped)";
                                        # reserved | unreserved | escaped
  $urics             =  "(?:(?:[;/?:\@&=+\$,a-zA-Z0-9\\-_.!~*'()]+|"     .
                        "$escaped)*)";
  
  $query             =  $urics;
  $fragment          =  $urics;
  $param             =  "(?:(?:[a-zA-Z0-9\\-_.!~*'():\@&=+\$,]+|$escaped)*)";
  $segment           =  "(?:$param(?:;$param)*)";
  $path_segments     =  "(?:$segment(?:/$segment)*)";
  $ftp_segments      =  "(?:$param(?:/$param)*)";   # NOT from RFC 2396.
  $rel_segment       =  "(?:(?:[a-zA-Z0-9\\-_.!~*'();\@&=+\$,]*|$escaped)+)";
  $abs_path          =  "(?:/$path_segments)";
  $rel_path          =  "(?:$rel_segment(?:$abs_path)?)";
  $path              =  "(?:(?:$abs_path|$rel_path)?)";
  
  $port              =  "(?:$digit*)";
  $IPv4address       =  "(?:$digit+[.]$digit+[.]$digit+[.]$digit+)";
  $toplabel          =  "(?:$alpha"."[-a-zA-Z0-9]*$alphanum|$alpha)";
  $domainlabel       =  "(?:(?:$alphanum"."[-a-zA-Z0-9]*)?$alphanum)";
  $hostname          =  "(?:(?:$domainlabel\[.])*$toplabel\[.]?)";
  $host              =  "(?:$hostname|$IPv4address)";
  $hostport          =  "(?:$host(?::$port)?)";
  
  $userinfo          =  "(?:(?:[a-zA-Z0-9\\-_.!~*'();:&=+\$,]+|$escaped)*)";
  $userinfo_no_colon =  "(?:(?:[a-zA-Z0-9\\-_.!~*'();&=+\$,]+|$escaped)*)";
  $server            =  "(?:(?:$userinfo\@)?$hostport)";
  
  $reg_name          =  "(?:(?:[a-zA-Z0-9\\-_.!~*'()\$,;:\@&=+]*|$escaped)+)";
  $authority         =  "(?:$server|$reg_name)";
  
  $scheme            =  "(?:$alpha"."[a-zA-Z0-9+\\-.]*)";
  
  $net_path          =  "(?://$authority$abs_path?)";
  $uric_no_slash     =  "(?:[a-zA-Z0-9\\-_.!~*'();?:\@&=+\$,]|$escaped)";
  $opaque_part       =  "(?:$uric_no_slash$urics)";
  $hier_part         =  "(?:(?:$net_path|$abs_path)(?:[?]$query)?)";
  
  $relativeURI       =  "(?:(?:$net_path|$abs_path|$rel_path)(?:[?]$query)?";
  $absoluteURI       =  "(?:$scheme:(?:$hier_part|$opaque_part))";
  $URI_reference     =  "(?:(?:$absoluteURI|$relativeURI)?(?:#$fragment)?)";
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::URI::RFC2396 -- Definitions from RFC2396;
  
  =head1 SYNOPSIS
  
      use Regexp::Common::URI::RFC2396 qw /:ALL/;
  
  =head1 DESCRIPTION
  
  This package exports definitions from RFC2396. It's intended
  usage is for Regexp::Common::URI submodules only. Its interface
  might change without notice.
  
  =head1 REFERENCES
  
  =over 4
  
  =item B<[RFC 2396]>
  
  Berners-Lee, Tim, Fielding, R., and Masinter, L.: I<Uniform Resource
  Identifiers (URI): Generic Syntax>. August 1998.
  
  =back
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
PERL5_REGEXP_COMMON_URI_RFC2396

$fatpacked{"perl5/Regexp/Common/URI/RFC2806.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_REGEXP_COMMON_URI_RFC2806';
  package Regexp::Common::URI::RFC2806;
  
  use Regexp::Common::URI::RFC1035 qw /$domain/;
  use Regexp::Common::URI::RFC2396 qw /$unreserved $escaped $hex/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2016020301';
  
  use vars qw /@EXPORT @EXPORT_OK %EXPORT_TAGS @ISA/;
  
  use Exporter ();
  @ISA = qw /Exporter/;
  
  
  my %vars;
  
  BEGIN {
      $vars {low}     = [qw /$dtmf_digit $wait_for_dial_tone $one_second_pause
                             $pause_character $visual_separator $phonedigit
                             $escaped_no_dquote $quoted_string $token_char
                             $token_chars/];
      $vars {parts}   = [qw /$future_extension/];
      $vars {connect} = [qw /$provider_hostname $provider_tag $service_provider
                             $private_prefix $local_network_prefix 
                             $global_network_prefix $network_prefix/];
      $vars {phone}   = [qw /$phone_context_ident $phone_context_tag
                             $area_specifier $post_dial $isdn_subaddress
                             $t33_subaddress $local_phone_number
                             $local_phone_number_no_future
                             $base_phone_number $global_phone_number
                             $global_phone_number_no_future $telephone_subscriber
                             $telephone_subscriber_no_future/];
      $vars {fax}     = [qw /$fax_local_phone $fax_local_phone_no_future
                             $fax_global_phone $fax_global_phone_no_future
                             $fax_subscriber $fax_subscriber_no_future/];
      $vars {modem}   = [qw //];
  }
  
  use vars map {@$_} values %vars;
  
  @EXPORT      = ();
  @EXPORT_OK   = map {@$_} values %vars;
  %EXPORT_TAGS = (%vars, ALL => [@EXPORT_OK]);
  
  
  # RFC 2806, URIs for tel, fax & modem.
  $dtmf_digit        =  "(?:[*#ABCD])";
  $wait_for_dial_tone=  "(?:w)";
  $one_second_pause  =  "(?:p)";
  $pause_character   =  "(?:[wp])";   # wait_for_dial_tone | one_second_pause.
  $visual_separator  =  "(?:[\\-.()])";
  $phonedigit        =  "(?:[0-9\\-.()])";  # DIGIT | visual_separator
  $escaped_no_dquote =  "(?:%(?:[01]$hex)|2[013-9A-Fa-f]|[3-9A-Fa-f]$hex)";
  $quoted_string     =  "(?:%22(?:(?:%5C(?:$unreserved|$escaped))|" .
                                "$unreserved+|$escaped_no_dquote)*%22)";
                        # It is unclear wether we can allow only unreserved
                        # characters to unescaped, or can we also use uric
                        # characters that are unescaped? Or pchars?
  $token_char        =  "(?:[!'*\\-.0-9A-Z_a-z~]|" .
                            "%(?:2[13-7ABDEabde]|3[0-9]|4[1-9A-Fa-f]|" .
                                "5[AEFaef]|6[0-9A-Fa-f]|7[0-9ACEace]))";
                        # Only allowing unreserved chars to be unescaped.
  $token_chars       =  "(?:(?:[!'*\\-.0-9A-Z_a-z~]+|"                   .
                              "%(?:2[13-7ABDEabde]|3[0-9]|4[1-9A-Fa-f]|" .
                                  "5[AEFaef]|6[0-9A-Fa-f]|7[0-9ACEace]))*)";
  $future_extension  =  "(?:;$token_chars"                       .
                        "(?:=(?:(?:$token_chars(?:[?]$token_chars)?)|" .
                        "$quoted_string))?)";
  $provider_hostname =   $domain;
  $provider_tag      =  "(?:tsp)";
  $service_provider  =  "(?:;$provider_tag=$provider_hostname)";
  $private_prefix    =  "(?:(?:[!'E-OQ-VX-Z_e-oq-vx-z~]|"                   .
                           "(?:%(?:2[124-7CFcf]|3[AC-Fac-f]|4[05-9A-Fa-f]|" .
                                  "5[1-689A-Fa-f]|6[05-9A-Fa-f]|"           .
                                  "7[1-689A-Ea-e])))"                       .
                           "(?:[!'()*\\-.0-9A-Z_a-z~]+|"                    .
                           "(?:%(?:2[1-9A-Fa-f]|3[AC-Fac-f]|"               .
                              "[4-6][0-9A-Fa-f]|7[0-9A-Ea-e])))*)";
  $local_network_prefix
                     =  "(?:[0-9\\-.()*#ABCDwp]+)";
  $global_network_prefix
                     =  "(?:[+][0-9\\-.()]+)";
  $network_prefix    =  "(?:$global_network_prefix|$local_network_prefix)";
  $phone_context_ident
                     =  "(?:$network_prefix|$private_prefix)";
  $phone_context_tag =  "(?:phone-context)";
  $area_specifier    =  "(?:;$phone_context_tag=$phone_context_ident)";
  $post_dial         =  "(?:;postd=[0-9\\-.()*#ABCDwp]+)";
  $isdn_subaddress   =  "(?:;isub=[0-9\\-.()]+)";
  $t33_subaddress    =  "(?:;tsub=[0-9\\-.()]+)";
  
  $local_phone_number=  "(?:[0-9\\-.()*#ABCDwp]+$isdn_subaddress?"      .
                           "$post_dial?$area_specifier"                 .
                           "(?:$area_specifier|$service_provider|"      .
                              "$future_extension)*)";
  $local_phone_number_no_future
                     =  "(?:[0-9\\-.()*#ABCDwp]+$isdn_subaddress?"      .
                           "$post_dial?$area_specifier"                 .
                           "(?:$area_specifier|$service_provider)*)";
  $fax_local_phone   =  "(?:[0-9\\-.()*#ABCDwp]+$isdn_subaddress?"      .
                           "$t33_subaddress?$post_dial?$area_specifier" .
                           "(?:$area_specifier|$service_provider|"      .
                              "$future_extension)*)";
  $fax_local_phone_no_future
                     =  "(?:[0-9\\-.()*#ABCDwp]+$isdn_subaddress?"      .
                           "$t33_subaddress?$post_dial?$area_specifier" .
                           "(?:$area_specifier|$service_provider)*)";
  $base_phone_number =  "(?:[0-9\\-.()]+)";
  $global_phone_number
                     =  "(?:[+]$base_phone_number$isdn_subaddress?"     .
                                                "$post_dial?"           .
                           "(?:$area_specifier|$service_provider|"      .
                              "$future_extension)*)";
  $global_phone_number_no_future
                     =  "(?:[+]$base_phone_number$isdn_subaddress?"     .
                                                "$post_dial?"           .
                           "(?:$area_specifier|$service_provider)*)";
  $fax_global_phone  =  "(?:[+]$base_phone_number$isdn_subaddress?"     .
                                "$t33_subaddress?$post_dial?"           .
                           "(?:$area_specifier|$service_provider|"      .
                              "$future_extension)*)";
  $fax_global_phone_no_future
                     =  "(?:[+]$base_phone_number$isdn_subaddress?"     .
                                "$t33_subaddress?$post_dial?"           .
                           "(?:$area_specifier|$service_provider)*)";
  $telephone_subscriber
                     =  "(?:$global_phone_number|$local_phone_number)";
  $telephone_subscriber_no_future
                     =  "(?:$global_phone_number_no_future|" .
                           "$local_phone_number_no_future)";
  $fax_subscriber    =  "(?:$fax_global_phone|$fax_local_phone)";
  $fax_subscriber_no_future
                     =  "(?:$fax_global_phone_no_future|"    .
                           "$fax_local_phone_no_future)";
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::URI::RFC2806 -- Definitions from RFC2806;
  
  =head1 SYNOPSIS
  
      use Regexp::Common::URI::RFC2806 qw /:ALL/;
  
  =head1 DESCRIPTION
  
  This package exports definitions from RFC2806. It's intended
  usage is for Regexp::Common::URI submodules only. Its interface
  might change without notice.
  
  =head1 REFERENCES
  
  =over 4
  
  =item B<[RFC 2616]>
  
  Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., 
  Leach, P. and Berners-Lee, Tim: I<Hypertext Transfer Protocol -- HTTP/1.1>.
  June 1999.
  
  =back
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
PERL5_REGEXP_COMMON_URI_RFC2806

$fatpacked{"perl5/Regexp/Common/URI/fax.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_REGEXP_COMMON_URI_FAX';
  package Regexp::Common::URI::fax;
  
  use Regexp::Common               qw /pattern clean no_defaults/;
  use Regexp::Common::URI          qw /register_uri/;
  use Regexp::Common::URI::RFC2806 qw /$fax_subscriber 
                                       $fax_subscriber_no_future/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2016020301';
  
  
  my $fax_scheme  = 'fax';
  my $fax_uri     = "(?k:(?k:$fax_scheme):(?k:$fax_subscriber))";
  my $fax_uri_nf  = "(?k:(?k:$fax_scheme):(?k:$fax_subscriber_no_future))";
  
  register_uri $fax_scheme => $fax_uri;
  
  pattern name    => [qw (URI fax)],
          create  => $fax_uri
          ;
  
  pattern name    => [qw (URI fax nofuture)],
          create  => $fax_uri_nf
          ;
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::URI::fax -- Returns a pattern for fax URIs.
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /URI/;
  
      while (<>) {
          /$RE{URI}{fax}/       and  print "Contains a fax URI.\n";
      }
  
  =head1 DESCRIPTION
  
  =head2 $RE{URI}{fax}
  
  Returns a pattern that matches I<fax> URIs, as defined by RFC 2806.
  Under C<{-keep}>, the following are returned:
  
  =over 4
  
  =item $1
  
  The complete URI.
  
  =item $2
  
  The scheme.
  
  =item $3
  
  The phone number, including any possible add-ons like ISDN subaddress,
  a post dial part, area specifier, service provider, etc.
  
  =back
  
  =head2 C<$RE{URI}{fax}{nofuture}>
  
  As above (including what's returned by C<{-keep}>), with the exception
  that I<future extensions> are not allowed. Without allowing 
  those I<future extensions>, it becomes much easier to check a URI if
  the correct syntax for post dial, service provider, phone context,
  etc has been used - otherwise the regex could always classify them
  as a I<future extension>.
  
  =head1 REFERENCES
  
  =over 4
  
  =item B<[RFC 1035]>
  
  Mockapetris, P.: I<DOMAIN NAMES - IMPLEMENTATION AND SPECIFICATION>.
  November 1987.
  
  =item B<[RFC 2396]>
  
  Berners-Lee, Tim, Fielding, R., and Masinter, L.: I<Uniform Resource
  Identifiers (URI): Generic Syntax>. August 1998.
  
  =item B<[RFC 2806]>
  
  Vaha-Sipila, A.: I<URLs for Telephone Calls>. April 2000.
  
  =back
  
  =head1 SEE ALSO
  
  L<Regexp::Common::URI> for other supported URIs.
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
PERL5_REGEXP_COMMON_URI_FAX

$fatpacked{"perl5/Regexp/Common/URI/file.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_REGEXP_COMMON_URI_FILE';
  package Regexp::Common::URI::file;
  
  use Regexp::Common               qw /pattern clean no_defaults/;
  use Regexp::Common::URI          qw /register_uri/;
  use Regexp::Common::URI::RFC1738 qw /$host $fpath/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2016020301';
  
  
  my $scheme = 'file';
  my $uri    = "(?k:(?k:$scheme)://(?k:(?k:(?:$host|localhost)?)" .
               "(?k:/(?k:$fpath))))";
  
  register_uri $scheme => $uri;
  
  pattern name    => [qw (URI file)],
          create  => $uri,
          ;
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::URI::file -- Returns a pattern for file URIs.
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /URI/;
  
      while (<>) {
          /$RE{URI}{file}/       and  print "Contains a file URI.\n";
      }
  
  =head1 DESCRIPTION
  
  =head2 $RE{URI}{file}
  
  Returns a pattern that matches I<file> URIs, as defined by RFC 1738.
  File URIs have the form:
  
      "file:" "//" [ host | "localhost" ] "/" fpath
  
  Under C<{-keep}>, the following are returned:
  
  =over 4
  
  =item $1
  
  The complete URI.
  
  =item $2
  
  The scheme.
  
  =item $3
  
  The part of the URI following "file://".
  
  =item $4
  
  The hostname.
  
  =item $5
  
  The path name, including the leading slash.
  
  =item $6
  
  The path name, without the leading slash.
  
  =back
  
  =head1 REFERENCES
  
  =over 4
  
  =item B<[RFC 1738]>
  
  Berners-Lee, Tim, Masinter, L., McCahill, M.: I<Uniform Resource
  Locators (URL)>. December 1994.
  
  =back
  
  =head1 SEE ALSO
  
  L<Regexp::Common::URI> for other supported URIs.
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
PERL5_REGEXP_COMMON_URI_FILE

$fatpacked{"perl5/Regexp/Common/URI/ftp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_REGEXP_COMMON_URI_FTP';
  package Regexp::Common::URI::ftp;
  
  use Regexp::Common               qw /pattern clean no_defaults/;
  use Regexp::Common::URI          qw /register_uri/;
  use Regexp::Common::URI::RFC2396 qw /$host $port $ftp_segments $userinfo
                                       $userinfo_no_colon/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2016020301';
  
  
  my $ftp_uri = "(?k:(?k:ftp)://(?:(?k:$userinfo)(?k:)\@)?(?k:$host)" .
                "(?::(?k:$port))?(?k:/(?k:(?k:$ftp_segments)"         .
                "(?:;type=(?k:[AIai]))?))?)";
  
  my $ftp_uri_password =
                "(?k:(?k:ftp)://(?:(?k:$userinfo_no_colon)"           .
                "(?::(?k:$userinfo_no_colon))?\@)?(?k:$host)"         .
                "(?::(?k:$port))?(?k:/(?k:(?k:$ftp_segments)"         .
                "(?:;type=(?k:[AIai]))?))?)";
  
  register_uri FTP => $ftp_uri;
  
  pattern name    => [qw (URI FTP), "-type=[AIai]", "-password="],
          create  => sub {
              my $uri    =  exists $_ [1] -> {-password} &&
                          !defined $_ [1] -> {-password} ? $ftp_uri_password
                                                         : $ftp_uri;
              my $type   =  $_ [1] -> {-type};
              $uri       =~ s/\[AIai\]/$type/;
              $uri;
          }
          ;
  
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::URI::ftp -- Returns a pattern for FTP URIs.
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /URI/;
  
      while (<>) {
          /$RE{URI}{FTP}/       and  print "Contains an FTP URI.\n";
      }
  
  =head1 DESCRIPTION
  
  =head2 $RE{URI}{FTP}{-type}{-password};
  
  Returns a regex for FTP URIs. Note: FTP URIs are not formally defined.
  RFC 1738 defines FTP URLs, but parts of that RFC have been obsoleted
  by RFC 2396. However, the differences between RFC 1738 and RFC 2396 
  are such that they aren't applicable straightforwardly to FTP URIs.
  
  There are two main problems:
  
  =over 4
  
  =item Passwords.
  
  RFC 1738 allowed an optional username and an optional password (separated
  by a colon) in the FTP URL. Hence, colons were not allowed in either the
  username or the password. RFC 2396 strongly recommends passwords should
  not be used in URIs. It does allow for I<userinfo> instead. This userinfo
  part may contain colons, and hence contain more than one colon. The regexp
  returned follows the RFC 2396 specification, unless the I<{-password}>
  option is given; then the regex allows for an optional username and
  password, separated by a colon.
  
  =item The ;type specifier.
  
  RFC 1738 does not allow semi-colons in FTP path names, because a semi-colon
  is a reserved character for FTP URIs. The semi-colon is used to separate
  the path from the option I<type> specifier. However, in RFC 2396, paths
  consist of slash separated segments, and each segment is a semi-colon 
  separated group of parameters. Straigthforward application of RFC 2396
  would mean that a trailing I<type> specifier couldn't be distinguished
  from the last segment of the path having a two parameters, the last one
  starting with I<type=>. Therefore we have opted to disallow a semi-colon
  in the path part of an FTP URI.
  
  Furthermore, RFC 1738 allows three values for the type specifier, I<A>,
  I<I> and I<D> (either upper case or lower case). However, the internet
  draft about FTP URIs B<[DRAFT-FTP-URL]> (which expired in May 1997) notes
  the lack of consistent implementation of the I<D> parameter and drops I<D>
  from the set of possible values. We follow this practise; however, RFC 1738
  behaviour can be archieved by using the I<-type => "[ADIadi]"> parameter.
  
  =back
  
  FTP URIs have the following syntax:
  
      "ftp:" "//" [ userinfo "@" ] host [ ":" port ]
                  [ "/" path [ ";type=" value ]]
  
  When using I<{-password}>, we have the syntax:
  
      "ftp:" "//" [ user [ ":" password ] "@" ] host [ ":" port ]
                  [ "/" path [ ";type=" value ]]
  
  Under C<{-keep}>, the following are returned:
  
  =over 4
  
  =item $1
  
  The complete URI.
  
  =item $2
  
  The scheme.
  
  =item $3
  
  The userinfo, or if I<{-password}> is used, the username.
  
  =item $4
  
  If I<{-password}> is used, the password, else C<undef>.
  
  =item $5
  
  The hostname or IP address.
  
  =item $6
  
  The port number.
  
  =item $7
  
  The full path and type specification, including the leading slash.
  
  =item $8
  
  The full path and type specification, without the leading slash.
  
  =item $9
  
  The full path, without the type specification nor the leading slash.
  
  =item $10
  
  The value of the type specification.
  
  =back
  
  =head1 REFERENCES
  
  =over 4
  
  =item B<[DRAFT-URL-FTP]>
  
  Casey, James: I<A FTP URL Format>. November 1996.
  
  =item B<[RFC 1738]>
  
  Berners-Lee, Tim, Masinter, L., McCahill, M.: I<Uniform Resource
  Locators (URL)>. December 1994.
  
  =item B<[RFC 2396]>
  
  Berners-Lee, Tim, Fielding, R., and Masinter, L.: I<Uniform Resource
  Identifiers (URI): Generic Syntax>. August 1998.
  
  =back
  
  =head1 SEE ALSO
  
  L<Regexp::Common::URI> for other supported URIs.
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
PERL5_REGEXP_COMMON_URI_FTP

$fatpacked{"perl5/Regexp/Common/URI/gopher.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_REGEXP_COMMON_URI_GOPHER';
  package Regexp::Common::URI::gopher;
  
  use Regexp::Common               qw /pattern clean no_defaults/;
  use Regexp::Common::URI          qw /register_uri/;
  use Regexp::Common::URI::RFC1738 qw /$host $port $uchars/;
  use Regexp::Common::URI::RFC1808 qw /$pchars $pchar_range/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2016020301';
  
  
  my $pchars_notab      = "(?:(?:[$pchar_range]+|" . 
                          "%(?:[1-9a-fA-F][0-9a-fA-F]|0[0-8a-fA-F]))*)";
  
  my $gopherplus_string = $pchars;
  my $search            = $pchars;
  my $search_notab      = $pchars_notab;
  my $selector          = $pchars;
  my $selector_notab    = $pchars_notab;
  my $gopher_type       = "(?:[0-9+IgT])";
  
  my $scheme     = "gopher";
  my $uri        = "(?k:(?k:$scheme)://(?k:$host)(?::(?k:$port))?" .
                   "/(?k:(?k:$gopher_type)(?k:$selector)))";
  my $uri_notab  = "(?k:(?k:$scheme)://(?k:$host)(?::(?k:$port))?"              .
                   "/(?k:(?k:$gopher_type)(?k:$selector_notab)"                 .
                   "(?:%09(?k:$search_notab)(?:%09(?k:$gopherplus_string))?)?))";
  
  register_uri $scheme => $uri;
  
  pattern name    => [qw (URI gopher -notab=)],
          create  => sub { exists $_ [1] {-notab} &&
                         !defined $_ [1] {-notab} ? $uri_notab : $uri},
          ;
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::URI::gopher -- Returns a pattern for gopher URIs.
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /URI/;
  
      while (<>) {
          /$RE{URI}{gopher}/       and  print "Contains a gopher URI.\n";
      }
  
  =head1 DESCRIPTION
  
  =head2 $RE{URI}{gopher}{-notab}
  
  Gopher URIs are poorly defined. Originally, RFC 1738 defined gopher URIs,
  but they were later redefined in an internet draft. One that was expired
  in June 1997.
  
  The internet draft for gopher URIs defines them as follows:
  
      "gopher:" "//" host [ ":" port ] "/" gopher-type selector
                          [ "%09" search [ "%09" gopherplus_string ]]
  
  Unfortunally, a I<selector> is defined in such a way that characters
  may be escaped using the URI escape mechanism. This includes tabs,
  which escaped are C<%09>. Hence, the syntax cannot distinguish between
  a URI that has both a I<selector> and a I<search> part, and an URI
  where the I<selector> includes an escaped tab. (The text of the draft
  forbids tabs to be present in the I<selector> though).
  
  C<$RE{URI}{gopher}> follows the defined syntax. To disallow escaped
  tabs in the I<selector> and I<search> parts, use C<$RE{URI}{gopher}{-notab}>.
  
  There are other differences between the text and the given syntax.
  According to the text, selector strings cannot have tabs, linefeeds
  or carriage returns in them. The text also allows the entire I<gopher-path>,
  (the part after the slash following the hostport) to be empty; if this
  is empty the slash may be omitted as well. However, this isn't reflected
  in the syntax.
  
  Under C<{-keep}>, the following are returned:
  
  =over 4
  
  =item $1
  
  The entire URI.
  
  =item $2
  
  The scheme.
  
  =item $3
  
  The host (name or address).
  
  =item $4
  
  The port (if any).
  
  =item $5
  
  The "gopher-path", the part after the / following the host and port.
  
  =item $6
  
  The gopher-type.
  
  =item $7
  
  The selector. (When no C<{-notab}> is used, this includes the search
  and gopherplus_string, including the separating escaped tabs).
  
  =item $8
  
  The search, if given. (Only when C<{-notab}> is given).
  
  =item $9
  
  The gopherplus_string, if given. (Only when C<{-notab}> is given).
  
  =back
  
  head1 REFERENCES
  
  =over 4
  
  =item B<[RFC 1738]>
  
  Berners-Lee, Tim, Masinter, L., McCahill, M.: I<Uniform Resource
  Locators (URL)>. December 1994.
  
  =item B<[RFC 1808]>
  
  Fielding, R.: I<Relative Uniform Resource Locators (URL)>. June 1995.
  
  =item B<[GOPHER URL]>
  
  Krishnan, Murali R., Casey, James: "A Gopher URL Format". Expired
  Internet draft I<draft-murali-url-gopher>. December 1996.
  
  =back
  
  =head1 SEE ALSO
  
  L<Regexp::Common::URI> for other supported URIs.
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
PERL5_REGEXP_COMMON_URI_GOPHER

$fatpacked{"perl5/Regexp/Common/URI/http.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_REGEXP_COMMON_URI_HTTP';
  package Regexp::Common::URI::http;
  
  use Regexp::Common               qw /pattern clean no_defaults/;
  use Regexp::Common::URI          qw /register_uri/;
  use Regexp::Common::URI::RFC2396 qw /$host $port $path_segments $query/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2016020301';
  
  
  my $http_uri = "(?k:(?k:http)://(?k:$host)(?::(?k:$port))?"           .
                 "(?k:/(?k:(?k:$path_segments)(?:[?](?k:$query))?))?)";
  
  my $https_uri = $http_uri; $https_uri =~ s/http/https?/;
  
  register_uri HTTP => $https_uri;
  
  pattern name    => [qw (URI HTTP), "-scheme=http"],
          create  => sub {
              my $scheme =  $_ [1] -> {-scheme};
              my $uri    =  $http_uri;
                 $uri    =~ s/http/$scheme/;
              $uri;
          }
          ;
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::URI::http -- Returns a pattern for HTTP URIs.
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /URI/;
  
      while (<>) {
          /$RE{URI}{HTTP}/       and  print "Contains an HTTP URI.\n";
      }
  
  =head1 DESCRIPTION
  
  =head2 $RE{URI}{HTTP}{-scheme}
  
  Provides a regex for an HTTP URI as defined by RFC 2396 (generic syntax)
  and RFC 2616 (HTTP).
  
  If C<< -scheme => I<P> >> is specified the pattern I<P> is used as the scheme.
  By default I<P> is C<qr/http/>. C<https> and C<https?> are reasonable
  alternatives.
  
  The syntax for an HTTP URI is:
  
      "http:" "//" host [ ":" port ] [ "/" path [ "?" query ]]
  
  Under C<{-keep}>, the following are returned:
  
  =over 4
  
  =item $1
  
  The entire URI.
  
  =item $2
  
  The scheme.
  
  =item $3
  
  The host (name or address).
  
  =item $4
  
  The port (if any).
  
  =item $5
  
  The absolute path, including the query and leading slash.
  
  =item $6
  
  The absolute path, including the query, without the leading slash.
  
  =item $7
  
  The absolute path, without the query or leading slash.
  
  =item $8
  
  The query, without the question mark.
  
  =back
  
  =head1 REFERENCES
  
  =over 4
  
  =item B<[RFC 2396]>
  
  Berners-Lee, Tim, Fielding, R., and Masinter, L.: I<Uniform Resource
  Identifiers (URI): Generic Syntax>. August 1998.
  
  =item B<[RFC 2616]>
  
  Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., 
  Leach, P. and Berners-Lee, Tim: I<Hypertext Transfer Protocol -- HTTP/1.1>.
  June 1999.
  
  =back
  
  =head1 SEE ALSO
  
  L<Regexp::Common::URI> for other supported URIs.
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
PERL5_REGEXP_COMMON_URI_HTTP

$fatpacked{"perl5/Regexp/Common/URI/news.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_REGEXP_COMMON_URI_NEWS';
  package Regexp::Common::URI::news;
  
  use Regexp::Common               qw /pattern clean no_defaults/;
  use Regexp::Common::URI          qw /register_uri/;
  use Regexp::Common::URI::RFC1738 qw /$grouppart $group $article
                                       $host $port $digits/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2016020301';
  
  
  my $news_scheme = 'news';
  my $news_uri    = "(?k:(?k:$news_scheme):(?k:$grouppart))";
  
  my $nntp_scheme = 'nntp';
  my $nntp_uri    = "(?k:(?k:$nntp_scheme)://(?k:(?k:(?k:$host)(?::(?k:$port))?)" 
                  . "/(?k:$group)(?:/(?k:$digits))?))";
  
  register_uri $news_scheme => $news_uri;
  register_uri $nntp_scheme => $nntp_uri;
  
  pattern name    => [qw (URI news)],
          create  => $news_uri,
          ;
  
  pattern name    => [qw (URI NNTP)],
          create  => $nntp_uri,
          ;
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::URI::news -- Returns a pattern for file URIs.
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /URI/;
  
      while (<>) {
          /$RE{URI}{news}/       and  print "Contains a news URI.\n";
      }
  
  =head1 DESCRIPTION
  
  =head2 $RE{URI}{news}
  
  Returns a pattern that matches I<news> URIs, as defined by RFC 1738.
  News URIs have the form:
  
      "news:" ( "*" | group | article "@" host )
  
  Under C<{-keep}>, the following are returned:
  
  =over 4
  
  =item $1
  
  The complete URI.
  
  =item $2
  
  The scheme.
  
  =item $3
  
  The part of the URI following "news://".
  
  =back
  
  =head2 $RE{URI}{NNTP}
  
  Returns a pattern that matches I<NNTP> URIs, as defined by RFC 1738.
  NNTP URIs have the form:
  
      "nntp://" host [ ":" port ] "/" group [ "/" digits ]
  
  Under C<{-keep}>, the following are returned:
  
  =over 4
  
  =item $1
  
  The complete URI.
  
  =item $2
  
  The scheme.
  
  =item $3
  
  The part of the URI following "nntp://".
  
  =item $4
  
  The host and port, separated by a colon. If no port was given, just
  the host.
  
  =item $5
  
  The host.
  
  =item $6
  
  The port, if given.
  
  =item $7
  
  The group.
  
  =item $8
  
  The digits, if given.
  
  =back
  
  =head1 REFERENCES
  
  =over 4
  
  =item B<[RFC 1738]>
  
  Berners-Lee, Tim, Masinter, L., McCahill, M.: I<Uniform Resource
  Locators (URL)>. December 1994.
  
  =back
  
  =head1 SEE ALSO
  
  L<Regexp::Common::URI> for other supported URIs.
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
PERL5_REGEXP_COMMON_URI_NEWS

$fatpacked{"perl5/Regexp/Common/URI/pop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_REGEXP_COMMON_URI_POP';
  package Regexp::Common::URI::pop;
  
  use Regexp::Common               qw /pattern clean no_defaults/;
  use Regexp::Common::URI          qw /register_uri/;
  use Regexp::Common::URI::RFC1738 qw /$host $port/;
  use Regexp::Common::URI::RFC2384 qw /$enc_user $enc_auth_type/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2016020301';
  
  
  my $scheme = "pop";
  my $uri    = "(?k:(?k:$scheme)://(?:(?k:$enc_user)"     .  
               "(?:;AUTH=(?k:[*]|$enc_auth_type))?\@)?"   .
               "(?k:$host)(?::(?k:$port))?)";
  
  register_uri $scheme => $uri;
  
  pattern name    => [qw (URI POP)],
          create  => $uri,
          ;
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::URI::pop -- Returns a pattern for POP URIs.
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /URI/;
  
      while (<>) {
          /$RE{URI}{POP}/       and  print "Contains a POP URI.\n";
      }
  
  =head1 DESCRIPTION
  
  =head2 $RE{URI}{POP}
  
  Returns a pattern that matches I<POP> URIs, as defined by RFC 2384.
  POP URIs have the form:
  
      "pop:" "//" [ user [ ";AUTH" ( "*" | auth_type ) ] "@" ]
                    host [ ":" port ]
  
  Under C<{-keep}>, the following are returned:
  
  =over 4
  
  =item $1
  
  The complete URI.
  
  =item $2
  
  The I<scheme>.
  
  =item $3
  
  The I<user>, if given.
  
  =item $4
  
  The I<authentication type>, if given (could be a I<*>).
  
  =item $5
  
  The I<host>.
  
  =item $6
  
  The I<port>, if given.
  
  =back
  
  =head1 REFERENCES
  
  =over 4
  
  =item B<[RFC 2384]>
  
  Gellens, R.: I<POP URL Scheme>. August 1998.
  
  =back
  
  =head1 SEE ALSO
  
  L<Regexp::Common::URI> for other supported URIs.
  
  =head1 AUTHOR
  
  Abigail. (I<regexp-common@abigail.be>).
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
PERL5_REGEXP_COMMON_URI_POP

$fatpacked{"perl5/Regexp/Common/URI/prospero.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_REGEXP_COMMON_URI_PROSPERO';
  package Regexp::Common::URI::prospero;
  
  use Regexp::Common               qw /pattern clean no_defaults/;
  use Regexp::Common::URI          qw /register_uri/;
  use Regexp::Common::URI::RFC1738 qw /$host $port $ppath $fieldname $fieldvalue
                                       $fieldspec/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2016020301';
  
  
  my $scheme = 'prospero';
  my $uri    = "(?k:(?k:$scheme)://(?k:$host)(?::(?k:$port))?" .
               "/(?k:$ppath)(?k:$fieldspec*))";
  
  register_uri $scheme => $uri;
  
  pattern name    => [qw (URI prospero)],
          create  => $uri,
          ;
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::URI::prospero -- Returns a pattern for prospero URIs.
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /URI/;
  
      while (<>) {
          /$RE{URI}{prospero}/ and print "Contains a prospero URI.\n";
      }
  
  =head1 DESCRIPTION
  
  =head2 $RE{URI}{prospero}
  
  Returns a pattern that matches I<prospero> URIs, as defined by RFC 1738.
  prospero URIs have the form:
  
      "prospero:" "//" host [ ":" port ] "/" path [ fieldspec ] *
  
  Under C<{-keep}>, the following are returned:
  
  =over 4
  
  =item $1
  
  The complete URI.
  
  =item $2
  
  The I<scheme>.
  
  =item $3
  
  The I<hostname>.
  
  =item $4
  
  The I<port>, if given.
  
  =item $5
  
  The propero path.
  
  =item $6
  
  The field specifications, if given. There can be more field specifications;
  they will all be returned in C<$6>.
  
  =back
  
  =head1 REFERENCES
  
  =over 4
  
  =item B<[RFC 1738]>
  
  Berners-Lee, Tim, Masinter, L., McCahill, M.: I<Uniform Resource
  Locators (URL)>. December 1994.
  
  =back
  
  =head1 SEE ALSO
  
  L<Regexp::Common::URI> for other supported URIs.
  
  =head1 AUTHOR
  
  Abigail. (I<regexp-common@abigail.be>).
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
PERL5_REGEXP_COMMON_URI_PROSPERO

$fatpacked{"perl5/Regexp/Common/URI/tel.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_REGEXP_COMMON_URI_TEL';
  package Regexp::Common::URI::tel;
  
  use Regexp::Common               qw /pattern clean no_defaults/;
  use Regexp::Common::URI          qw /register_uri/;
  use Regexp::Common::URI::RFC2806 qw /$telephone_subscriber 
                                       $telephone_subscriber_no_future/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2016020301';
  
  
  my $tel_scheme  = 'tel';
  my $tel_uri     = "(?k:(?k:$tel_scheme):(?k:$telephone_subscriber))";
  my $tel_uri_nf  = "(?k:(?k:$tel_scheme):(?k:$telephone_subscriber_no_future))";
  
  register_uri $tel_scheme => $tel_uri;
  
  pattern name    => [qw (URI tel)],
          create  => $tel_uri
          ;
  
  pattern name    => [qw (URI tel nofuture)],
          create  => $tel_uri_nf
          ;
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::URI::tel -- Returns a pattern for telephone URIs.
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /URI/;
  
      while (<>) {
          /$RE{URI}{tel}/       and  print "Contains a telephone URI.\n";
      }
  
  =head1 DESCRIPTION
  
  =head2 $RE{URI}{tel}
  
  Returns a pattern that matches I<tel> URIs, as defined by RFC 2806.
  Under C<{-keep}>, the following are returned:
  
  =over 4
  
  =item $1
  
  The complete URI.
  
  =item $2
  
  The scheme.
  
  =item $3
  
  The phone number, including any possible add-ons like ISDN subaddress,
  a post dial part, area specifier, service provider, etc.
  
  =back
  
  =head2 C<$RE{URI}{tel}{nofuture}>
  
  As above (including what's returned by C<{-keep}>), with the exception
  that I<future extensions> are not allowed. Without allowing 
  those I<future extensions>, it becomes much easier to check a URI if
  the correct syntax for post dial, service provider, phone context,
  etc has been used - otherwise the regex could always classify them
  as a I<future extension>.
  
  =head1 REFERENCES
  
  =over 4
  
  =item B<[RFC 1035]>
  
  Mockapetris, P.: I<DOMAIN NAMES - IMPLEMENTATION AND SPECIFICATION>.
  November 1987.
  
  =item B<[RFC 2396]>
  
  Berners-Lee, Tim, Fielding, R., and Masinter, L.: I<Uniform Resource
  Identifiers (URI): Generic Syntax>. August 1998.
  
  =item B<[RFC 2806]>
  
  Vaha-Sipila, A.: I<URLs for Telephone Calls>. April 2000.
  
  =back
  
  =head1 SEE ALSO
  
  L<Regexp::Common::URI> for other supported URIs.
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
PERL5_REGEXP_COMMON_URI_TEL

$fatpacked{"perl5/Regexp/Common/URI/telnet.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_REGEXP_COMMON_URI_TELNET';
  package Regexp::Common::URI::telnet;
  
  use Regexp::Common               qw /pattern clean no_defaults/;
  use Regexp::Common::URI          qw /register_uri/;
  use Regexp::Common::URI::RFC1738 qw /$user $password $host $port/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2016020301';
  
  
  my $telnet_uri = "(?k:(?k:telnet)://(?:(?k:(?k:$user)(?::(?k:$password))?)\@)?" 
                 . "(?k:(?k:$host)(?::(?k:$port))?)(?k:/)?)";
  
  register_uri telnet => $telnet_uri;
  
  pattern name    => [qw (URI telnet)],
          create  => $telnet_uri,
          ;
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::URI::telnet -- Returns a pattern for telnet URIs.
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /URI/;
  
      while (<>) {
          /$RE{URI}{telnet}/       and  print "Contains a telnet URI.\n";
      }
  
  =head1 DESCRIPTION
  
  =head2 $RE{URI}{telnet}
  
  Returns a pattern that matches I<telnet> URIs, as defined by RFC 1738.
  Telnet URIs have the form:
  
      "telnet:" "//" [ user [ ":" password ] "@" ] host [ ":" port ] [ "/" ]
  
  Under C<{-keep}>, the following are returned:
  
  =over 4
  
  =item $1
  
  The complete URI.
  
  =item $2
  
  The scheme.
  
  =item $3
  
  The username:password combo, or just the username if there is no password.
  
  =item $4
  
  The username, if given.
  
  =item $5
  
  The password, if given.
  
  =item $6
  
  The host:port combo, or just the host if there's no port.
  
  =item $7
  
  The host.
  
  =item $8
  
  The port, if given.
  
  =item $9
  
  The trailing slash, if any.
  
  =back
  
  =head1 REFERENCES
  
  =over 4
  
  =item B<[RFC 1738]>
  
  Berners-Lee, Tim, Masinter, L., McCahill, M.: I<Uniform Resource
  Locators (URL)>. December 1994.
  
  =back
  
  =head1 SEE ALSO
  
  L<Regexp::Common::URI> for other supported URIs.
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
PERL5_REGEXP_COMMON_URI_TELNET

$fatpacked{"perl5/Regexp/Common/URI/tv.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_REGEXP_COMMON_URI_TV';
  # TV URLs. 
  # Internet draft: draft-zigmond-tv-url-03.txt
  
  package Regexp::Common::URI::tv;
  
  use Regexp::Common               qw /pattern clean no_defaults/;
  use Regexp::Common::URI          qw /register_uri/;
  use Regexp::Common::URI::RFC2396 qw /$hostname/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2016020301';
  
  
  my $tv_scheme = 'tv';
  my $tv_url    = "(?k:(?k:$tv_scheme):(?k:$hostname)?)";
  
  register_uri $tv_scheme => $tv_url;
  
  pattern name    => [qw (URI tv)],
          create  => $tv_url,
          ;
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::URI::tv -- Returns a pattern for tv URIs.
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /URI/;
  
      while (<>) {
          /$RE{URI}{tv}/       and  print "Contains a tv URI.\n";
      }
  
  =head1 DESCRIPTION
  
  =head2 C<$RE{URI}{tv}>
  
  Returns a pattern that recognizes TV uris as per an Internet draft
  [DRAFT-URI-TV].
  
  Under C<{-keep}>, the following are returned:
  
  =over 4
  
  =item $1
  
  The entire URI.
  
  =item $2
  
  The scheme.
  
  =item $3
  
  The host.
  
  =back
  
  =head1 REFERENCES
  
  =over 4
  
  =item B<[DRAFT-URI-TV]>
  
  Zigmond, D. and Vickers, M: I<Uniform Resource Identifiers for
  Television Broadcasts>. December 2000.
  
  =item B<[RFC 2396]>
  
  Berners-Lee, Tim, Fielding, R., and Masinter, L.: I<Uniform Resource
  Identifiers (URI): Generic Syntax>. August 1998.
  
  =back
  
  =head1 SEE ALSO
  
  L<Regexp::Common::URI> for other supported URIs.
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
PERL5_REGEXP_COMMON_URI_TV

$fatpacked{"perl5/Regexp/Common/URI/wais.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_REGEXP_COMMON_URI_WAIS';
  package Regexp::Common::URI::wais;
  
  use Regexp::Common               qw /pattern clean no_defaults/;
  use Regexp::Common::URI          qw /register_uri/;
  use Regexp::Common::URI::RFC1738 qw /$host $port
                                       $search $database $wtype $wpath/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2016020301';
  
  
  my $scheme = 'wais';
  my $uri    = "(?k:(?k:$scheme)://(?k:$host)(?::(?k:$port))?/(?k:(?k:$database)" 
             . "(?k:[?](?k:$search)|/(?k:$wtype)/(?k:$wpath))?))";
  
  register_uri $scheme => $uri;
  
  pattern name    => [qw (URI WAIS)],
          create  => $uri,
          ;
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::URI::wais -- Returns a pattern for WAIS URIs.
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /URI/;
  
      while (<>) {
          /$RE{URI}{WAIS}/       and  print "Contains a WAIS URI.\n";
      }
  
  =head1 DESCRIPTION
  
  =head2 $RE{URI}{WAIS}
  
  Returns a pattern that matches I<WAIS> URIs, as defined by RFC 1738.
  WAIS URIs have the form:
  
      "wais:" "//" host [ ":" port ] "/" database
                        [ ( "?" search ) | ( "/" wtype "/" wpath ) ]
  
  Under C<{-keep}>, the following are returned:
  
  =over 4
  
  =item $1
  
  The complete URI.
  
  =item $2
  
  The I<scheme>.
  
  =item $3
  
  The I<hostname>.
  
  =item $4
  
  The I<port>, if given.
  
  =item $5
  
  The I<database>, followed by I<search> or I<wtype/wpath>, if given.
  
  =item $6
  
  The I<database>.
  
  =item $7
  
  The part following the I<database> if given, including the question mark 
  or slash.
  
  =item $8
  
  The I<search> part, if given.
  
  =item $9
  
  The I<wtype>, if given.
  
  =item $10
  
  The I<wpath>, if given.
  
  =back
  
  =head1 REFERENCES
  
  =over 4
  
  =item B<[RFC 1738]>
  
  Berners-Lee, Tim, Masinter, L., McCahill, M.: I<Uniform Resource
  Locators (URL)>. December 1994.
  
  =back
  
  =head1 SEE ALSO
  
  L<Regexp::Common::URI> for other supported URIs.
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
PERL5_REGEXP_COMMON_URI_WAIS

$fatpacked{"perl5/Regexp/Common/_support.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_REGEXP_COMMON__SUPPORT';
  package Regexp::Common::_support;
  
  BEGIN {
      # This makes sure 'use warnings' doesn't bomb out on 5.005_*;
      # warnings won't be enabled on those old versions though.
      if ($] < 5.006 && !exists $INC {"warnings.pm"}) {
          $INC {"warnings.pm"} = 1;
          no strict 'refs';
          *{"warnings::unimport"} = sub {0};
      }
  }
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2016020301';
  
  #
  # Returns true/false, depending whether the given the argument
  # satisfies the LUHN checksum.
  # See http://www.webopedia.com/TERM/L/Luhn_formula.html.
  #
  # Note that this function is intended to be called from regular
  # expression, so it should NOT use a regular expression in any way.
  #
  sub luhn {
      my $arg  = shift;
      my $even = 0;
      my $sum  = 0;
      while (length $arg) {
          my $num = chop $arg;
          return if $num lt '0' || $num gt '9';
          if ($even && (($num *= 2) > 9)) {$num = 1 + ($num % 10)}
          $even = 1 - $even;
          $sum += $num;
      }
      !($sum % 10)
  }
  
  sub import {
      my $pack   = shift;
      my $caller = caller;
      no strict 'refs';
      *{$caller . "::" . $_} = \&{$pack . "::" . $_} for @_;
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::support -- Support functions for Regexp::Common.
  
  =head1 SYNOPSIS
  
      use Regexp::Common::_support qw /luhn/;
  
      luhn ($number)    # Returns true/false.
  
  
  =head1 DESCRIPTION
  
  This module contains some subroutines to be used by other C<Regexp::Common>
  modules. It's not intended to be used directly. Subroutines from the 
  module may disappear without any notice, or their meaning or interface
  may change without notice.
  
  =over 4
  
  =item luhn
  
  This subroutine returns true if its argument passes the luhn checksum test.
  
  =back
  
  =head1 SEE ALSO
  
  L<http://www.webopedia.com/TERM/L/Luhn_formula.html>.
  
  =head1 AUTHOR
  
  Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
PERL5_REGEXP_COMMON__SUPPORT

$fatpacked{"perl5/Regexp/Common/balanced.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_REGEXP_COMMON_BALANCED';
  package Regexp::Common::balanced; {
  
  use Regexp::Common qw /pattern clean no_defaults/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2016020301';
  
  my %closer = ( '{'=>'}', '('=>')', '['=>']', '<'=>'>' );
  my %cache;
  
  sub nested {
      my ($start, $finish) = @_;
  
      return $cache {$start} {$finish} if exists $cache {$start} {$finish};
  
      my @starts   = map {s/\\(.)/$1/g; $_} grep {length}
                          $start  =~ /([^|\\]+|\\.)+/gs;
      my @finishes = map {s/\\(.)/$1/g; $_} grep {length}
                          $finish =~ /([^|\\]+|\\.)+/gs;
  
      push @finishes => ($finishes [-1]) x (@starts - @finishes);
  
      my @re;
      local $" = "|";
      foreach my $begin (@starts) {
          my $end = shift @finishes;
  
          my $qb  = quotemeta $begin;
          my $qe  = quotemeta $end;
          my $fb  = quotemeta substr $begin => 0, 1;
          my $fe  = quotemeta substr $end   => 0, 1;
  
          my $tb  = quotemeta substr $begin => 1;
          my $te  = quotemeta substr $end   => 1;
  
          my $add;
          if ($fb eq $fe) {
              push @re =>
                     qq /(?:$qb(?:(?>[^$fb]+)|$fb(?!$tb)(?!$te)|(?-1))*$qe)/;
          }
          else {
              my   @clauses =  "(?>[^$fb$fe]+)";
              push @clauses => "$fb(?!$tb)" if length $tb;
              push @clauses => "$fe(?!$te)" if length $te;
              push @clauses => "(?-1)";
              push @re      =>  qq /(?:$qb(?:@clauses)*$qe)/;
          }
      }
  
      $cache {$start} {$finish} = qr /(@re)/;
  }
  
  
  pattern name    => [qw /balanced -parens=() -begin= -end=/],
          create  => sub {
              my $flag = $_[1];
              unless (defined $flag -> {-begin} && length $flag -> {-begin} &&
                      defined $flag -> {-end}   && length $flag -> {-end}) {
                  my @open  = grep {index ($flag->{-parens}, $_) >= 0}
                               ('[','(','{','<');
                  my @close = map {$closer {$_}} @open;
                  $flag -> {-begin} = join "|" => @open;
                  $flag -> {-end}   = join "|" => @close;
              }
              return nested @$flag {qw /-begin -end/};
          },
          version => 5.010,
          ;
  
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::balanced -- provide regexes for strings with balanced
  parenthesized delimiters or arbitrary delimiters.
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /balanced/;
  
      while (<>) {
          /$RE{balanced}{-parens=>'()'}/
                                     and print q{balanced parentheses\n};
      }
  
  
  =head1 DESCRIPTION
  
  Please consult the manual of L<Regexp::Common> for a general description
  of the works of this interface.
  
  Do not use this module directly, but load it via I<Regexp::Common>.
  
  =head2 C<$RE{balanced}{-parens}>
  
  Returns a pattern that matches a string that starts with the nominated
  opening parenthesis or bracket, contains characters and properly nested
  parenthesized subsequences, and ends in the matching parenthesis.
  
  More than one type of parenthesis can be specified:
  
          $RE{balanced}{-parens=>'(){}'}
  
  in which case all specified parenthesis types must be correctly balanced within
  the string.
  
  Since version 2013030901, C<< $1 >> will always be set (to the entire
  matched substring), regardless whether C<< {-keep} >> is used or not.
  
  =head2 C<< $RE{balanced}{-begin => "begin"}{-end => "end"} >>
  
  Returns a pattern that matches a string that is properly balanced
  using the I<begin> and I<end> strings as start and end delimiters.
  Multiple sets of begin and end strings can be given by separating
  them by C<|>s (which can be escaped with a backslash).
  
      qr/$RE{balanced}{-begin => "do|if|case"}{-end => "done|fi|esac"}/
  
  will match properly balanced strings that either start with I<do> and
  end with I<done>, start with I<if> and end with I<fi>, or start with
  I<case> and end with I<esac>.
  
  If I<-end> contains less cases than I<-begin>, the last case of I<-end>
  is repeated. If it contains more cases than I<-begin>, the extra cases
  are ignored. If either of I<-begin> or I<-end> isn't given, or is empty,
  I<< -begin => '(' >> and I<< -end => ')' >> are assumed.
  
  Since version 2013030901, C<< $1 >> will always be set (to the entire
  matched substring), regardless whether C<< {-keep} >> is used or not.
  
  =head2 Note
  
  Since version 2013030901 the pattern will make of the recursive construct
  C<< (?-1) >>, instead of using the problematic C<< (??{ }) >> construct.
  This fixes an problem that was introduced in the 5.17 development track.
  This also means the pattern is no longer available for Perls older than 5.010.
  
  =head1 SEE ALSO
  
  L<Regexp::Common> for a general description of how to use this interface.
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  For a start, there are many common regexes missing.
  Send them in to I<regexp-common@abigail.be>.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2013, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
PERL5_REGEXP_COMMON_BALANCED

$fatpacked{"perl5/Regexp/Common/comment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_REGEXP_COMMON_COMMENT';
  package Regexp::Common::comment;
  
  use Regexp::Common qw /pattern clean no_defaults/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2016020301';
  
  my @generic = (
      {languages => [qw /ABC Forth/],
       to_eol    => ['\\\\']},   # This is for just a *single* backslash.
  
      {languages => [qw /Ada Alan Eiffel lua/],
       to_eol    => ['--']},
  
      {languages => [qw /Advisor/],
       to_eol    => ['#|//']},
  
      {languages => [qw /Advsys CQL Lisp LOGO M MUMPS REBOL Scheme
                         SMITH zonefile/],
       to_eol    => [';']},
  
      {languages => ['Algol 60'],
       from_to   => [[qw /comment ;/]]},
  
      {languages => [qw {ALPACA B C C-- LPC PL/I}],
       from_to   => [[qw {/* */}]]},
  
      {languages => [qw /awk fvwm2 Icon m4 mutt Perl Python QML
                         R Ruby shell Tcl/],
       to_eol    => ['#']},
  
      {languages => [[BASIC => 'mvEnterprise']],
       to_eol    => ['[*!]|REM']},
  
      {languages => [qw /Befunge-98 Funge-98 Shelta/],
       id        => [';']},
  
      {languages => ['beta-Juliet', 'Crystal Report', 'Portia', 'Ubercode'],
       to_eol    => ['//']},
  
      {languages => ['BML'],
       from_to   => [['<?_c', '_c?>']],
      },
  
      {languages => [qw /C++/, 'C#', qw /Cg ECMAScript FPL Java JavaScript/],
       to_eol    => ['//'],
       from_to   => [[qw {/* */}]]},
  
      {languages => [qw /CLU LaTeX slrn TeX/],
       to_eol    => ['%']},
  
      {languages => [qw /False/],
       from_to   => [[qw !{ }!]]},
  
      {languages => [qw /Fortran/],
       to_eol    => ['!']},
  
      {languages => [qw /Haifu/],
       id        => [',']},
  
      {languages => [qw /ILLGOL/],
       to_eol    => ['NB']},
  
      {languages => [qw /INTERCAL/],
       to_eol    => [q{(?:(?:PLEASE(?:\s+DO)?|DO)\s+)?(?:NOT|N'T)}]},
  
      {languages => [qw /J/],
       to_eol    => ['NB[.]']},
  
      {languages => [qw /JavaDoc/],
       from_to   => [[qw {/** */}]]},
  
      {languages => [qw /Nickle/],
       to_eol    => ['#'],
       from_to   => [[qw {/* */}]]},
  
      {languages => [qw /Oberon/],
       from_to   => [[qw /(* *)/]]},
       
      {languages => [[qw /Pascal Delphi/], [qw /Pascal Free/], [qw /Pascal GPC/]],
       to_eol    => ['//'],
       from_to   => [[qw !{ }!], [qw !(* *)!]]},
  
      {languages => [[qw /Pascal Workshop/]],
       id        => [qw /"/],
       from_to   => [[qw !{ }!], [qw !(* *)!], [qw !/* */!]]},
  
      {languages => [qw /PEARL/],
       to_eol    => ['!'],
       from_to   => [[qw {/* */}]]},
  
      {languages => [qw /PHP/],
       to_eol    => ['#', '//'],
       from_to   => [[qw {/* */}]]},
  
      {languages => [qw !PL/B!],
       to_eol    => ['[.;]']},
  
      {languages => [qw !PL/SQL!],
       to_eol    => ['--'],
       from_to   => [[qw {/* */}]]},
  
      {languages => [qw /Q-BAL/],
       to_eol    => ['`']},
  
      {languages => [qw /Smalltalk/],
       id        => ['"']},
  
      {languages => [qw /SQL/],
       to_eol    => ['-{2,}']},
  
      {languages => [qw /troff/],
       to_eol    => ['\\\"']},
  
      {languages => [qw /vi/],
       to_eol    => ['"']},
  
      {languages => [qw /*W/],
       from_to   => [[qw {|| !!}]]},
  
      {languages => [qw /ZZT-OOP/],
       to_eol    => ["'"]},
  );
  
  my @plain_or_nested = (
     [Caml         =>  undef,       "(*"  => "*)"],
     [Dylan        =>  "//",        "/*"  => "*/"],
     [Haskell      =>  "-{2,}",     "{-"  => "-}"],
     [Hugo         =>  "!(?!\\\\)", "!\\" => "\\!"],
     [SLIDE        =>  "#",         "(*"  => "*)"],
    ['Modula-2'    =>  undef,       "(*"  => "*)"],
    ['Modula-3'    =>  undef,       "(*"  => "*)"],
  );
  
  #
  # Helper subs.
  #
  
  sub combine      {
      local $_ = join "|", @_;
      if (@_ > 1) {
          s/\(\?k:/(?:/g;
          $_ = "(?k:$_)";
      }
      $_
  }
  
  sub to_eol  ($)  {"(?k:(?k:$_[0])(?k:[^\\n]*)(?k:\\n))"}
  sub id      ($)  {"(?k:(?k:$_[0])(?k:[^$_[0]]*)(?k:$_[0]))"}  # One char only!
  sub from_to      {
      my ($begin, $end) = @_;
  
      my $qb  = quotemeta $begin;
      my $qe  = quotemeta $end;
      my $fe  = quotemeta substr $end   => 0, 1;
      my $te  = quotemeta substr $end   => 1;
  
      "(?k:(?k:$qb)(?k:(?:[^$fe]+|$fe(?!$te))*)(?k:$qe))";
  }
  
  
  my $count = 0;
  sub nested {
      my ($begin, $end) = @_;
  
      $count ++;
      my $r = '(??{$Regexp::Common::comment ['. $count . ']})';
  
      my $qb  = quotemeta $begin;
      my $qe  = quotemeta $end;
      my $fb  = quotemeta substr $begin => 0, 1;
      my $fe  = quotemeta substr $end   => 0, 1;
  
      my $tb  = quotemeta substr $begin => 1;
      my $te  = quotemeta substr $end   => 1;
  
      use re 'eval';
  
      my $re;
      if ($fb eq $fe) {
          $re = qr /(?:$qb(?:(?>[^$fb]+)|$fb(?!$tb)(?!$te)|$r)*$qe)/;
      }
      else {
          local $"      =  "|";
          my   @clauses =  "(?>[^$fb$fe]+)";
          push @clauses => "$fb(?!$tb)" if length $tb;
          push @clauses => "$fe(?!$te)" if length $te;
          push @clauses =>  $r;
          $re           =   qr /(?:$qb(?:@clauses)*$qe)/;
      }
  
      $Regexp::Common::comment [$count] = qr/$re/;
  }
  
  #
  # Process data.
  #
  
  foreach my $info (@plain_or_nested) {
      my ($language, $mark, $begin, $end) = @$info;
      pattern name    => [comment => $language],
              create  =>
                  sub {my $re     = nested $begin => $end;
                       my $prefix = defined $mark ? $mark . "[^\n]*\n|" : "";
                       exists $_ [1] -> {-keep} ? qr /($prefix$re)/
                                                : qr  /$prefix$re/
                  },
              version => 5.006,
              ;
  }
  
  
  foreach my $group (@generic) {
      my $pattern = combine +(map {to_eol   $_} @{$group -> {to_eol}}),
                             (map {from_to @$_} @{$group -> {from_to}}),
                             (map {id       $_} @{$group -> {id}}),
                    ;
      foreach my $language  (@{$group -> {languages}}) {
          pattern name    => [comment => ref $language ? @$language : $language],
                  create  => $pattern,
                  ;
      }
  }
                  
  
      
  #
  # Other languages.
  #
  
  # http://www.pascal-central.com/docs/iso10206.txt
  pattern name    => [qw /comment Pascal/],
          create  => '(?k:' . '(?k:[{]|[(][*])'
                            . '(?k:[^}*]*(?:[*](?![)])[^}*]*)*)'
                            . '(?k:[}]|[*][)])'
                            . ')'
          ;
  
  # http://www.templetons.com/brad/alice/language/
  pattern name    =>  [qw /comment Pascal Alice/],
          create  =>  '(?k:(?k:[{])(?k:[^}\n]*)(?k:[}]))'
          ;
  
  
  # http://westein.arb-phys.uni-dortmund.de/~wb/a68s.txt
  pattern name    => [qw (comment), 'Algol 68'],
          create  => q {(?k:(?:#[^#]*#)|}                           .
                     q {(?:\bco\b(?:[^c]+|\Bc|\bc(?!o\b))*\bco\b)|} .
                     q {(?:\bcomment\b(?:[^c]+|\Bc|\bc(?!omment\b))*\bcomment\b))}
          ;
  
  
  # See rules 91 and 92 of ISO 8879 (SGML).
  # Charles F. Goldfarb: "The SGML Handbook".
  # Oxford: Oxford University Press. 1990. ISBN 0-19-853737-9.
  # Ch. 10.3, pp 390.
  pattern name    => [qw (comment HTML)],
          create  => q {(?k:(?k:<!)(?k:(?:--(?k:[^-]*(?:-[^-]+)*)--\s*)*)(?k:>))},
          ;
  
  
  pattern name    => [qw /comment SQL MySQL/],
          create  => q {(?k:(?:#|-- )[^\n]*\n|} .
                     q {/\*(?:(?>[^*;"']+)|"[^"]*"|'[^']*'|\*(?!/))*(?:;|\*/))},
          ;
  
  # Anything that isn't <>[]+-.,
  # http://home.wxs.nl/~faase009/Ha_BF.html
  pattern name    => [qw /comment Brainfuck/],
          create  => '(?k:[^<>\[\]+\-.,]+)'
          ;
  
  # Squeak is a variant of Smalltalk-80.
  # http://www.squeak.
  # http://mucow.com/squeak-qref.html
  pattern name    => [qw /comment Squeak/],
          create  => '(?k:(?k:")(?k:[^"]*(?:""[^"]*)*)(?k:"))'
          ;
  
  #
  # Scores of less than 5 or above 17....
  # http://www.cliff.biffle.org/esoterica/beatnik.html
  @Regexp::Common::comment::scores = (1,  3,  3,  2,  1,  4,  2,  4,  1,  8,
                                      5,  1,  3,  1,  1,  3, 10,  1,  1,  1,
                                      1,  4,  4,  8,  4, 10);
  {
  my ($s, $x);
  pattern name    =>  [qw /comment Beatnik/],
          create  =>  sub {
              use re 'eval';
              my $re = qr {\b([A-Za-z]+)\b
                           (?(?{($s, $x) = (0, lc $^N);
                                $s += $Regexp::Common::comment::scores
                                      [ord (chop $x) - ord ('a')] while length $x;
                                $s  >= 5 && $s < 18})XXX|)}x;
              $re;
          },
          version  => 5.008,
          ;
  }
  
  
  # http://www.cray.com/craydoc/manuals/007-3692-005/html-007-3692-005/
  #  (Goto table of contents/3.3 Source Form)
  # Fortran, in fixed format. Comments start with a C, c or * in the first
  # column, or a ! anywhere, but the sixth column. Then end with a newline.
  pattern name    =>  [qw /comment Fortran fixed/],
          create  =>  '(?k:(?k:(?:^[Cc*]|(?<!^.....)!))(?k:[^\n]*)(?k:\n))'
          ;
  
  
  # http://www.csis.ul.ie/cobol/Course/COBOLIntro.htm
  # Traditionally, comments in COBOL were indicated with an asteriks in
  # the seventh column. Modern compilers may be more lenient.
  pattern name    =>  [qw /comment COBOL/],
          create  =>  '(?<=^......)(?k:(?k:[*])(?k:[^\n]*)(?k:\n))',
          version =>  '5.008',
          ;
  
  1;
  
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::comment -- provide regexes for comments.
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /comment/;
  
      while (<>) {
          /$RE{comment}{C}/       and  print "Contains a C comment\n";
          /$RE{comment}{C++}/     and  print "Contains a C++ comment\n";
          /$RE{comment}{PHP}/     and  print "Contains a PHP comment\n";
          /$RE{comment}{Java}/    and  print "Contains a Java comment\n";
          /$RE{comment}{Perl}/    and  print "Contains a Perl comment\n";
          /$RE{comment}{awk}/     and  print "Contains an awk comment\n";
          /$RE{comment}{HTML}/    and  print "Contains an HTML comment\n";
      }
  
      use Regexp::Common qw /comment RE_comment_HTML/;
  
      while (<>) {
          $_ =~ RE_comment_HTML() and  print "Contains an HTML comment\n";
      }
  
  =head1 DESCRIPTION
  
  Please consult the manual of L<Regexp::Common> for a general description
  of the works of this interface.
  
  Do not use this module directly, but load it via I<Regexp::Common>.
  
  This modules gives you regular expressions for comments in various
  languages.
  
  =head2 THE LANGUAGES
  
  Below, the comments of each of the languages are described.
  The patterns are available as C<$RE{comment}{I<LANG>}>, foreach
  language I<LANG>. Some languages have variants; it's described
  at the individual languages how to get the patterns for the variants.
  Unless mentioned otherwise,
  C<{-keep}> sets C<$1>, C<$2>, C<$3> and C<$4> to the entire comment,
  the opening marker, the content of the comment, and the closing marker
  (for many languages, the latter is a newline) respectively.
  
  =over 4
  
  =item ABC
  
  Comments in I<ABC> start with a backslash (C<\>), and last till
  the end of the line.
  See L<http://homepages.cwi.nl/%7Esteven/abc/>.
  
  =item Ada
  
  Comments in I<Ada> start with C<-->, and last till the end of the line.
  
  =item Advisor
  
  I<Advisor> is a language used by the HP product I<glance>. Comments for
  this language start with either C<#> or C<//>, and last till the
  end of the line.
  
  =item Advsys
  
  Comments for the I<Advsys> language start with C<;> and last till
  the end of the line. See also L<http://www.wurb.com/if/devsys/12>.
  
  =item Alan
  
  I<Alan> comments start with C<-->, and last till the end of the line.
  See also L<http://w1.132.telia.com/~u13207378/alan/manual/alanTOC.html>.
  
  =item Algol 60
  
  Comments in the I<Algol 60> language start with the keyword C<comment>,
  and end with a C<;>. See L<http://www.masswerk.at/algol60/report.htm>.
  
  =item Algol 68
  
  In I<Algol 68>, comments are either delimited by C<#>, or by one of the
  keywords C<co> or C<comment>. The keywords should not be part of another
  word. See L<http://westein.arb-phys.uni-dortmund.de/~wb/a68s.txt>.
  With C<{-keep}>, only C<$1> will be set, returning the entire comment.
  
  =item ALPACA
  
  The I<ALPACA> language has comments starting with C</*> and ending with C<*/>.
  
  =item awk
  
  The I<awk> programming language uses comments that start with C<#>
  and end at the end of the line.
  
  =item B
  
  The I<B> language has comments starting with C</*> and ending with C<*/>.
  
  =item BASIC
  
  There are various forms of BASIC around. Currently, we only support the
  variant supported by I<mvEnterprise>, whose pattern is available as
  C<$RE{comment}{BASIC}{mvEnterprise}>. Comments in this language start with a
  C<!>, a C<*> or the keyword C<REM>, and end till the end of the line. See
  L<http://www.rainingdata.com/products/beta/docs/mve/50/ReferenceManual/Basic.pdf>.
  
  =item Beatnik
  
  The esotoric language I<Beatnik> only uses words consisting of letters.
  Words are scored according to the rules of Scrabble. Words scoring less
  than 5 points, or 18 points or more are considered comments (although
  the compiler might mock at you if you score less than 5 points).
  Regardless whether C<{-keep}>, C<$1> will be set, and set to the
  entire comment. This pattern requires I<perl 5.8.0> or newer.
  
  =item beta-Juliet
  
  The I<beta-Juliet> programming language has comments that start with
  C<//> and that continue till the end of the line. See also
  L<http://www.catseye.mb.ca/esoteric/b-juliet/index.html>.
  
  =item Befunge-98
  
  The esotoric language I<Befunge-98> uses comments that start and end
  with a C<;>. See L<http://www.catseye.mb.ca/esoteric/befunge/98/spec98.html>.
  
  =item BML                 
  
  I<BML>, or I<Better Markup Language> is an HTML templating language that
  uses comments starting with C<< <?c_ >>, and ending with C<< c_?> >>.
  See L<http://www.livejournal.com/doc/server/bml.index.html>.               
  
  =item Brainfuck
  
  The minimal language I<Brainfuck> uses only eight characters, 
  C<E<lt>>, C<E<gt>>, C<[>, C<]>, C<+>, C<->, C<.> and C<,>.
  Any other characters are considered comments. With C<{-keep}>,
  C<$1> is set to the entire comment.
  
  =item C
  
  The I<C> language has comments starting with C</*> and ending with C<*/>.
  
  =item C--
  
  The I<C--> language has comments starting with C</*> and ending with C<*/>.
  See L<http://cs.uas.arizona.edu/classes/453/programs/C--Spec.html>.
  
  =item C++
  
  The I<C++> language has two forms of comments. Comments that start with
  C<//> and last till the end of the line, and comments that start with
  C</*>, and end with C<*/>. If C<{-keep}> is used, only C<$1> will be
  set, and set to the entire comment.
  
  =item C#
  
  The I<C#> language has two forms of comments. Comments that start with
  C<//> and last till the end of the line, and comments that start with
  C</*>, and end with C<*/>. If C<{-keep}> is used, only C<$1> will be
  set, and set to the entire comment.
  See L<http://msdn.microsoft.com/library/default.asp?url=/library/en-us/csspec/html/vclrfcsharpspec_C.asp>.
  
  =item Caml
  
  Comments in I<Caml> start with C<(*>, end with C<*)>, and can be nested.
  See L<http://www.cs.caltech.edu/courses/cs134/cs134b/book.pdf> and
  L<http://pauillac.inria.fr/caml/index-eng.html>.
  
  =item Cg
  
  The I<Cg> language has two forms of comments. Comments that start with
  C<//> and last till the end of the line, and comments that start with
  C</*>, and end with C<*/>. If C<{-keep}> is used, only C<$1> will be
  set, and set to the entire comment.
  See L<http://developer.nvidia.com/attach/3722>.
  
  =item CLU
  
  In C<CLU>, a comment starts with a procent sign (C<%>), and ends with the
  next newline. See L<ftp://ftp.lcs.mit.edu:/pub/pclu/CLU-syntax.ps> and
  L<http://www.pmg.lcs.mit.edu/CLU.html>.
  
  =item COBOL
  
  Traditionally, comments in I<COBOL> are indicated by an asteriks in the
  seventh column. This is what the pattern matches. Modern compiler may
  more lenient though. See L<http://www.csis.ul.ie/cobol/Course/COBOLIntro.htm>,
  and L<http://www.csis.ul.ie/cobol/default.htm>. Due to a bug in the regexp
  engine of perl 5.6.x, this regexp is only available in version 5.8.0 and up.
  
  =item CQL
  
  Comments in the chess query language (I<CQL>) start with a semi colon
  (C<;>) and last till the end of the line. See L<http://www.rbnn.com/cql/>.
  
  =item Crystal Report
  
  The formula editor in I<Crystal Reports> uses comments that start
  with C<//>, and end with the end of the line.
  
  =item Dylan
  
  There are two types of comments in I<Dylan>. They either start with
  C<//>, or are nested comments, delimited with C</*> and C<*/>.
  Under C<{-keep}>, only C<$1> will be set, returning the entire comment.
  This pattern requires I<perl 5.6.0> or newer.
  
  =item ECMAScript
  
  The I<ECMAScript> language has two forms of comments. Comments that start with
  C<//> and last till the end of the line, and comments that start with
  C</*>, and end with C<*/>. If C<{-keep}> is used, only C<$1> will be
  set, and set to the entire comment. I<JavaScript> is Netscapes implementation
  of I<ECMAScript>. See
  L<http://www.ecma-international.org/publications/files/ecma-st/Ecma-262.pdf>,
  and L<http://www.ecma-international.org/publications/standards/Ecma-262.htm>.
  
  =item Eiffel
  
  I<Eiffel> comments start with C<-->, and last till the end of the line.
  
  =item False
  
  In I<False>, comments start with C<{> and end with C<}>.
  See L<http://wouter.fov120.com/false/false.txt>
  
  =item FPL
  
  The I<FPL> language has two forms of comments. Comments that start with
  C<//> and last till the end of the line, and comments that start with
  C</*>, and end with C<*/>. If C<{-keep}> is used, only C<$1> will be
  set, and set to the entire comment.
  
  =item Forth
  
  Comments in Forth start with C<\>, and end with the end of the line.
  See also L<http://docs.sun.com/sb/doc/806-1377-10>.
  
  =item Fortran
  
  There are two forms of I<Fortran>. There's free form I<Fortran>, which
  has comments that start with C<!>, and end at the end of the line.
  The pattern for this is given by C<$RE{Fortran}>. Fixed form I<Fortran>,
  which has been obsoleted, has comments that start with C<C>, C<c> or
  C<*> in the first column, or with C<!> anywhere, but the sixth column.
  The pattern for this are given by C<$RE{Fortran}{fixed}>.
  
  See also L<http://www.cray.com/craydoc/manuals/007-3692-005/html-007-3692-005/>.
  
  =item Funge-98
  
  The esotoric language I<Funge-98> uses comments that start and end with
  a C<;>.
  
  =item fvwm2
  
  Configuration files for I<fvwm2> have comments starting with a
  C<#> and lasting the rest of the line.
  
  =item Haifu
  
  I<Haifu>, an esotoric language using haikus, has comments starting and
  ending with a C<,>.
  See L<http://www.dangermouse.net/esoteric/haifu.html>.
  
  =item Haskell
  
  There are two types of comments in I<Haskell>. They either start with
  at least two dashes, or are nested comments, delimited with C<{-> and C<-}>.
  Under C<{-keep}>, only C<$1> will be set, returning the entire comment.
  This pattern requires I<perl 5.6.0> or newer.
  
  =item HTML
  
  In I<HTML>, comments only appear inside a I<comment declaration>.
  A comment declaration starts with a C<E<lt>!>, and ends with a
  C<E<gt>>. Inside this declaration, we have zero or more comments.
  Comments starts with C<--> and end with C<-->, and are optionally
  followed by whitespace. The pattern C<$RE{comment}{HTML}> recognizes
  those comment declarations (and hence more than a comment).
  Note that this is not the same as something that starts with
  C<E<lt>!--> and ends with C<--E<gt>>, because the following will
  be matched completely:
  
      <!--  First  Comment   --
        --> Second Comment <!--
        --  Third  Comment   -->
  
  Do not be fooled by what your favourite browser thinks is an HTML
  comment.
  
  If C<{-keep}> is used, the following are returned:
  
  =over 4
  
  =item $1
  
  captures the entire comment declaration.
  
  =item $2
  
  captures the MDO (markup declaration open), C<E<lt>!>.
  
  =item $3
  
  captures the content between the MDO and the MDC.
  
  =item $4
  
  captures the (last) comment, without the surrounding dashes.
  
  =item $5
  
  captures the MDC (markup declaration close), C<E<gt>>.
  
  =back
  
  =item Hugo
  
  There are two types of comments in I<Hugo>. They either start with
  C<!> (which cannot be followed by a C<\>), or are nested comments,
  delimited with C<!\> and C<\!>.
  Under C<{-keep}>, only C<$1> will be set, returning the entire comment.
  This pattern requires I<perl 5.6.0> or newer.
  
  =item Icon
  
  I<Icon> has comments that start with C<#> and end at the next new line.
  See L<http://www.toolsofcomputing.com/IconHandbook/IconHandbook.pdf>,
  L<http://www.cs.arizona.edu/icon/index.htm>, and
  L<http://burks.bton.ac.uk/burks/language/icon/index.htm>.
  
  =item ILLGOL
  
  The esotoric language I<ILLGOL> uses comments starting with I<NB> and lasting
  till the end of the line.
  See L<http://www.catseye.mb.ca/esoteric/illgol/index.html>.
  
  =item INTERCAL
  
  Comments in INTERCAL are single line comments. They start with one of
  the keywords C<NOT> or C<N'T>, and can optionally be preceded by the
  keywords C<DO> and C<PLEASE>. If both keywords are used, C<PLEASE>
  precedes C<DO>. Keywords are separated by whitespace.
  
  =item J
  
  The language I<J> uses comments that start with C<NB.>, and that last till
  the end of the line. See
  L<http://www.jsoftware.com/books/help/primer/contents.htm>, and
  L<http://www.jsoftware.com/>.
  
  =item Java
  
  The I<Java> language has two forms of comments. Comments that start with
  C<//> and last till the end of the line, and comments that start with
  C</*>, and end with C<*/>. If C<{-keep}> is used, only C<$1> will be
  set, and set to the entire comment.
  
  =item JavaDoc
  
  The I<Javadoc> documentation syntax is demarked with a subset of
  ordinary Java comments to separate it from code.  Comments start with
  C</**> end with C<*/>.  If C<{-keep}> is used, only C<$1> will be set,
  and set to the entire comment. See
  L<http://www.oracle.com/technetwork/java/javase/documentation/index-137868.html#format>.
  
  =item JavaScript
  
  The I<JavaScript> language has two forms of comments. Comments that start with
  C<//> and last till the end of the line, and comments that start with
  C</*>, and end with C<*/>. If C<{-keep}> is used, only C<$1> will be
  set, and set to the entire comment. I<JavaScript> is Netscapes implementation
  of I<ECMAScript>.
  See L<http://www.mozilla.org/js/language/E262-3.pdf>,
  and L<http://www.mozilla.org/js/language/>.
  
  =item LaTeX
  
  The documentation language I<LaTeX> uses comments starting with C<%>
  and ending at the end of the line.
  
  =item Lisp
  
  Comments in I<Lisp> start with a semi-colon (C<;>) and last till the
  end of the line.
  
  =item LPC
  
  The I<LPC> language has comments starting with C</*> and ending with C<*/>.
  
  =item LOGO
  
  Comments for the language I<LOGO> start with C<;>, and last till the end
  of the line.
  
  =item lua
  
  Comments for the I<lua> language start with C<-->, and last till the end
  of the line. See also L<http://www.lua.org/manual/manual.html>.
  
  =item M, MUMPS
  
  In C<M> (aka C<MUMPS>), comments start with a semi-colon, and last
  till the end of a line. The language specification requires the 
  semi-colon to be preceded by one or more I<linestart character>s.
  Those characters default to a space, but that's configurable. This
  requirement, of preceding the comment with linestart characters is
  B<not> tested for. See
  L<ftp://ftp.intersys.com/pub/openm/ism/ism64docs.zip>,
  L<http://mtechnology.intersys.com/mproducts/openm/index.html>, and
  L<http://mcenter.com/mtrc/index.html>.
  
  =item m4
  
  By default, the preprocessor language I<m4> uses single line comments,
  that start with a C<#> and continue to the end of the line, including
  the newline. The pattern C<$RE {comment} {m4}> matches such comments.
  In I<m4>, it is possible to change the starting token though.
  See L<http://wolfram.schneider.org/bsd/7thEdManVol2/m4/m4.pdf>,
  L<http://www.cs.stir.ac.uk/~kjt/research/pdf/expl-m4.pdf>, and
  L<http://www.gnu.org/software/m4/manual/>.
  
  =item Modula-2
  
  In C<Modula-2>, comments start with C<(*>, and end with C<*)>. Comments
  may be nested. See L<http://www.modula2.org/>.
  
  =item Modula-3
  
  In C<Modula-3>, comments start with C<(*>, and end with C<*)>. Comments
  may be nested. See L<http://www.m3.org/>.
  
  =item mutt
  
  Configuration files for I<mutt> have comments starting with a
  C<#> and lasting the rest of the line.
  
  =item Nickle
  
  The I<Nickle> language has one line comments starting with C<#>
  (like Perl), or multiline comments delimited by C</*> and C<*/>
  (like C). Under C<-keep>, only C<$1> will be set. See also
  L<http://www.nickle.org>.
  
  =item Oberon
  
  Comments in I<Oberon> start with C<(*> and end with C<*)>.
  See L<http://www.oberon.ethz.ch/oreport.html>.
  
  =item Pascal
  
  There are many implementations of Pascal. This modules provides
  pattern for comments of several implementations.
  
  =over 4
  
  =item C<$RE{comment}{Pascal}>
  
  This is the pattern that recognizes comments according to the Pascal ISO 
  standard. This standard says that comments start with either C<{>, or
  C<(*>, and end with C<}> or C<*)>. This means that C<{*)> and C<(*}>
  are considered to be comments. Many Pascal applications don't allow this.
  See L<http://www.pascal-central.com/docs/iso10206.txt>
  
  =item C<$RE{comment}{Pascal}{Alice}>
  
  The I<Alice Pascal> compiler accepts comments that start with C<{>
  and end with C<}>. Comments are not allowed to contain newlines.
  See L<http://www.templetons.com/brad/alice/language/>.
  
  =item C<$RE{comment}{Pascal}{Delphi}>, C<$RE{comment}{Pascal}{Free}>
  and C<$RE{comment}{Pascal}{GPC}>
  
  The I<Delphi Pascal>, I<Free Pascal> and the I<Gnu Pascal Compiler>
  implementations of Pascal all have comments that either start with
  C<//> and last till the end of the line, are delimited with C<{>
  and C<}> or are delimited with C<(*> and C<*)>. Patterns for those
  comments are given by C<$RE{comment}{Pascal}{Delphi}>, 
  C<$RE{comment}{Pascal}{Free}> and C<$RE{comment}{Pascal}{GPC}>
  respectively. These patterns only set C<$1> when C<{-keep}> is used,
  which will then include the entire comment.
  
  See L<http://info.borland.com/techpubs/delphi5/oplg/>, 
  L<http://www.freepascal.org/docs-html/ref/ref.html> and
  L<http://www.gnu-pascal.de/gpc/>.
  
  =item C<$RE{comment}{Pascal}{Workshop}>
  
  The I<Workshop Pascal> compiler, from SUN Microsystems, allows comments
  that are delimited with either C<{> and C<}>, delimited with
  C<(*)> and C<*>), delimited with C</*>, and C<*/>, or starting
  and ending with a double quote (C<">). When C<{-keep}> is used,
  only C<$1> is set, and returns the entire comment.
  
  See L<http://docs.sun.com/db/doc/802-5762>.
  
  =back
  
  =item PEARL
  
  Comments in I<PEARL> start with a C<!> and last till the end of the
  line, or start with C</*> and end with C<*/>. With C<{-keep}>, 
  C<$1> will be set to the entire comment.
  
  =item PHP
  
  Comments in I<PHP> start with either C<#> or C<//> and last till the
  end of the line, or are delimited by C</*> and C<*/>. With C<{-keep}>,
  C<$1> will be set to the entire comment.
  
  =item PL/B
  
  In I<PL/B>, comments start with either C<.> or C<;>, and end with the 
  next newline. See L<http://www.mmcctech.com/pl-b/plb-0010.htm>.
  
  =item PL/I
  
  The I<PL/I> language has comments starting with C</*> and ending with C<*/>.
  
  =item PL/SQL
  
  In I<PL/SQL>, comments either start with C<--> and run till the end
  of the line, or start with C</*> and end with C<*/>.
  
  =item Perl
  
  I<Perl> uses comments that start with a C<#>, and continue till the end
  of the line.
  
  =item Portia
  
  The I<Portia> programming language has comments that start with C<//>,
  and last till the end of the line.
  
  =item Python
  
  I<Python> uses comments that start with a C<#>, and continue till the end
  of the line.
  
  =item Q-BAL
  
  Comments in the I<Q-BAL> language start with C<`> (a backtick), and
  contine till the end of the line.
  
  =item QML
  
  In C<QML>, comments start with C<#> and last till the end of the line.
  See L<http://www.questionmark.com/uk/qml/overview.doc>.
  
  =item R
  
  The statistical language I<R> uses comments that start with a C<#> and
  end with the following new line. See L<http://www.r-project.org/>.
  
  =item REBOL
  
  Comments for the I<REBOL> language start with C<;> and last till the
  end of the line.
  
  =item Ruby
  
  Comments in I<Ruby> start with C<#> and last till the end of the time.
  
  =item Scheme
  
  I<Scheme> comments start with C<;>, and last till the end of the line.
  See L<http://schemers.org/>.
  
  =item shell
  
  Comments in various I<shell>s start with a C<#> and end at the end of
  the line.
  
  =item Shelta
  
  The esotoric language I<Shelta> uses comments that start and end with
  a C<;>. See L<http://www.catseye.mb.ca/esoteric/shelta/index.html>.
  
  =item SLIDE
  
  The I<SLIDE> language has two froms of comments. First there is the
  line comment, which starts with a C<#> and includes the rest of the
  line (just like Perl). Second, there is the multiline, nested comment,
  which are delimited by C<(*> and C<*)>. Under C{-keep}>, only 
  C<$1> is set, and is set to the entire comment. This pattern needs
  at least Perl version 5.6.0. See
  L<http://www.cs.berkeley.edu/~ug/slide/docs/slide/spec/spec_frame_intro.shtml>.
  
  =item slrn
  
  Configuration files for I<slrn> have comments starting with a
  C<%> and lasting the rest of the line.
  
  =item Smalltalk
  
  I<Smalltalk> uses comments that start and end with a double quote, C<">.
  
  =item SMITH
  
  Comments in the I<SMITH> language start with C<;>, and last till the
  end of the line.
  
  =item Squeak
  
  In the Smalltalk variant I<Squeak>, comments start and end with
  C<">. Double quotes can appear inside comments by doubling them.
  
  =item SQL
  
  Standard I<SQL> uses comments starting with two or more dashes, and
  ending at the end of the line. 
  
  I<MySQL> does not follow the standard. Instead, it allows comments
  that start with a C<#> or C<-- > (that's two dashes and a space)
  ending with the following newline, and comments starting with 
  C</*>, and ending with the next C<;> or C<*/> that isn't inside
  single or double quotes. A pattern for this is returned by
  C<$RE{comment}{SQL}{MySQL}>. With C<{-keep}>, only C<$1> will
  be set, and it returns the entire comment.
  
  =item Tcl
  
  In I<Tcl>, comments start with C<#> and continue till the end of the line.
  
  =item TeX
  
  The documentation language I<TeX> uses comments starting with C<%>
  and ending at the end of the line.
  
  =item troff
  
  The document formatting language I<troff> uses comments starting
  with C<\">, and continuing till the end of the line.
  
  =item Ubercode
  
  The Windows programming language I<Ubercode> uses comments that start with
  C<//> and continue to the end of the line. See L<http://www.ubercode.com>.
  
  =item vi
  
  In configuration files for the editor I<vi>, one can use comments
  starting with C<">, and ending at the end of the line.
  
  =item *W
  
  In the language I<*W>, comments start with C<||>, and end with C<!!>.
  
  =item zonefile
  
  Comments in DNS I<zonefile>s start with C<;>, and continue till the
  end of the line.
  
  =item ZZT-OOP
  
  The in-game language I<ZZT-OOP> uses comments that start with a C<'> 
  character, and end at the following newline. See
  L<http://dave2.rocketjump.org/rad/zzthelp/lang.html>.
  
  =back
  
  =head1 REFERENCES
  
  =over 4
  
  =item B<[Go 90]>
  
  Charles F. Goldfarb: I<The SGML Handbook>. Oxford: Oxford University
  Press. B<1990>. ISBN 0-19-853737-9. Ch. 10.3, pp 390-391.
  
  =back
  
  =head1 SEE ALSO
  
  L<Regexp::Common> for a general description of how to use this interface.
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  For a start, there are many common regexes missing.
  Send them in to I<regexp-common@abigail.be>.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
PERL5_REGEXP_COMMON_COMMENT

$fatpacked{"perl5/Regexp/Common/delimited.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_REGEXP_COMMON_DELIMITED';
  package Regexp::Common::delimited;
  
  use Regexp::Common qw /pattern clean no_defaults/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2016020301';
  
  sub gen_delimited {
  
      my ($dels, $escs) = @_;
      # return '(?:\S*)' unless $dels =~ /\S/;
      if (length $escs) {
          $escs .= substr ($escs, -1) x (length ($dels) - length ($escs));
      }
      my @pat = ();
      my $i;
      for ($i=0; $i < length $dels; $i++) {
          my $del = quotemeta substr ($dels, $i, 1);
          my $esc = length($escs) ? quotemeta substr ($escs, $i, 1) : "";
          if ($del eq $esc) {
              push @pat,
                   "(?k:$del)(?k:[^$del]*(?:(?:$del$del)[^$del]*)*)(?k:$del)";
          }
          elsif (length $esc) {
              push @pat,
                   "(?k:$del)(?k:[^$esc$del]*(?:$esc.[^$esc$del]*)*)(?k:$del)";
          }
          else {
              push @pat, "(?k:$del)(?k:[^$del]*)(?k:$del)";
          }
      }
      my $pat = join '|', @pat;
      return "(?k:$pat)";
  }
  
  sub _croak {
      require Carp;
      goto &Carp::croak;
  }
  
  pattern name   => [qw( delimited -delim= -esc=\\ )],
          create => sub {my $flags = $_[1];
                         _croak 'Must specify delimiter in $RE{delimited}'
                               unless length $flags->{-delim};
                         return gen_delimited (@{$flags}{-delim, -esc});
                    },
          ;
  
  pattern name   => [qw( quoted -esc=\\ )],
          create => sub {my $flags = $_[1];
                         return gen_delimited (q{"'`}, $flags -> {-esc});
                    },
          ;
  
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::delimited -- provides a regex for delimited strings
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /delimited/;
  
      while (<>) {
          /$RE{delimited}{-delim=>'"'}/  and print 'a \" delimited string';
          /$RE{delimited}{-delim=>'/'}/  and print 'a \/ delimited string';
      }
  
  
  =head1 DESCRIPTION
  
  Please consult the manual of L<Regexp::Common> for a general description
  of the works of this interface.
  
  Do not use this module directly, but load it via I<Regexp::Common>.
  
  =head2 C<$RE{delimited}{-delim}{-esc}>
  
  Returns a pattern that matches a single-character-delimited substring,
  with optional internal escaping of the delimiter.
  
  When C<-delim=I<S>> is specified, each character in the sequence I<S> is
  a possible delimiter. There is no default delimiter, so this flag must always
  be specified.
  
  If C<-esc=I<S>> is specified, each character in the sequence I<S> is
  the delimiter for the corresponding character in the C<-delim=I<S>> list.
  The default escape is backslash.
  
  For example:
  
     $RE{delimited}{-delim=>'"'}            # match "a \" delimited string"
     $RE{delimited}{-delim=>'"'}{-esc=>'"'} # match "a "" delimited string"
     $RE{delimited}{-delim=>'/'}            # match /a \/ delimited string/
     $RE{delimited}{-delim=>q{'"}}          # match "string" or 'string'
  
  Under C<-keep> (See L<Regexp::Common>):
  
  =over 4
  
  =item $1
  
  captures the entire match
  
  =item $2
  
  captures the opening delimiter (provided only one delimiter was specified)
  
  =item $3
  
  captures delimited portion of the string (provided only one delimiter was
  specified)
  
  =item $4
  
  captures the closing delimiter (provided only one delimiter was specified)
  
  =back
  
  =head2 $RE{quoted}{-esc}
  
  A synonym for C<$RE{delimited}{q{-delim='"`}{...}}>
  
  =head1 SEE ALSO
  
  L<Regexp::Common> for a general description of how to use this interface.
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  For a start, there are many common regexes missing.
  Send them in to I<regexp-common@abigail.be>.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
PERL5_REGEXP_COMMON_DELIMITED

$fatpacked{"perl5/Regexp/Common/lingua.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_REGEXP_COMMON_LINGUA';
  package Regexp::Common::lingua;
  
  use Regexp::Common qw /pattern clean no_defaults/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2016020301';
  
  
  pattern name    => [qw /lingua palindrome -chars=[A-Za-z]/],
          create  => sub {
              use re 'eval';
              my $keep = exists $_ [1] -> {-keep};
              my $ch   = $_ [1] -> {-chars};
              my $idx  = $keep ? "1:$ch" : "0:$ch";
              my $r    = "(??{\$Regexp::Common::lingua::pd{'" . $idx . "'}})";
              $Regexp::Common::lingua::pd {$idx} = 
                      $keep ? qr /($ch|($ch)($r)?\2)/ : qr  /$ch|($ch)($r)?\1/;
          #   print "[$ch]: ", $Regexp::Common::lingua::pd {$idx}, "\n";
          #   $Regexp::Common::lingua::pd {$idx};
          },
          version => 5.006
          ;
  
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::lingua -- provide regexes for language related stuff.
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /lingua/;
  
      while (<>) {
          /^$RE{lingua}{palindrome}$/    and  print "is a palindrome\n";
      }
  
  
  =head1 DESCRIPTION
  
  Please consult the manual of L<Regexp::Common> for a general description
  of the works of this interface.
  
  Do not use this module directly, but load it via I<Regexp::Common>.
  
  =head2 C<$RE{lingua}{palindrome}>
  
  Returns a pattern that recognizes a palindrome, a string that is the
  same if you reverse it. By default, it only matches strings consisting
  of letters, but this can be changed using the C<{-chars}> option.
  This option takes a character class (default is C<[A-Za-z]>) as
  argument.
  
  If C<{-keep}> is used, only C<$1> will be set, and set to the entire
  match. 
  
  This pattern requires at least perl 5.6.0.
  
  =head1 SEE ALSO
  
  L<Regexp::Common> for a general description of how to use this interface.
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Many regexes are missing.
  Send them in to I<regexp-common@abigail.be>.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
PERL5_REGEXP_COMMON_LINGUA

$fatpacked{"perl5/Regexp/Common/list.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_REGEXP_COMMON_LIST';
  package Regexp::Common::list;
  
  use Regexp::Common qw /pattern clean no_defaults/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2016020301';
  
  sub gen_list_pattern {
      my ($pat, $sep, $lsep) = @_;
      $lsep = $sep unless defined $lsep;
      return "(?k:(?:(?:$pat)(?:$sep))*(?:$pat)(?k:$lsep)(?:$pat))";
  }
  
  my $defpat = '.*?\S';
  my $defsep = '\s*,\s*';
  
  pattern name   => ['list', "-pat=$defpat", "-sep=$defsep", '-lastsep'],
          create => sub {gen_list_pattern (@{$_[1]}{-pat, -sep, -lastsep})},
          ;
  
  pattern name   => ['list', 'conj', '-word=(?:and|or)'],
          create => sub {gen_list_pattern($defpat, $defsep,
                                          '\s*,?\s*'.$_[1]->{-word}.'\s*');
                    },
          ;
  
  pattern name   => ['list', 'and'],
          create => sub {gen_list_pattern ($defpat, $defsep, '\s*,?\s*and\s*')},
          ;
  
  pattern name   => ['list', 'or'],
          create => sub {gen_list_pattern ($defpat, $defsep, '\s*,?\s*or\s*')},
          ;
  
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::list -- provide regexes for lists
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /list/;
  
      while (<>) {
          /$RE{list}{-pat => '\w+'}/          and print "List of words";
          /$RE{list}{-pat => $RE{num}{real}}/ and print "List of numbers";
      }
  
  
  =head1 DESCRIPTION
  
  Please consult the manual of L<Regexp::Common> for a general description
  of the works of this interface.
  
  Do not use this module directly, but load it via I<Regexp::Common>.
  
  =head2 C<$RE{list}{-pat}{-sep}{-lastsep}>
  
  Returns a pattern matching a list of (at least two) substrings.
  
  If C<-pat=I<P>> is specified, it defines the pattern for each substring
  in the list. By default, I<P> is C<qr/.*?\S/>. In Regexp::Common 0.02
  or earlier, the default pattern was C<qr/.*?/>. But that will match
  a single space, causing unintended parsing of C<a, b, and c> as a
  list of four elements instead of 3 (with C<-word> being C<(?:and)>).
  One consequence is that a list of the form "a,,b" will no longer be
  parsed. Use the pattern C<qr /.*?/> to be able to parse this, but see
  the previous remark.
  
  If C<-sep=I<P>> is specified, it defines the pattern I<P> to be used as
  a separator between each pair of substrings in the list, except the final two.
  By default I<P> is C<qr/\s*,\s*/>.
  
  If C<-lastsep=I<P>> is specified, it defines the pattern I<P> to be used as
  a separator between the final two substrings in the list.
  By default I<P> is the same as the pattern specified by the C<-sep> flag.
  
  For example:
  
        $RE{list}{-pat=>'\w+'}                # match a list of word chars
        $RE{list}{-pat=>$RE{num}{real}}       # match a list of numbers
        $RE{list}{-sep=>"\t"}                 # match a tab-separated list
        $RE{list}{-lastsep=>',\s+and\s+'}     # match a proper English list
  
  Under C<-keep>:
  
  =over 4
  
  =item $1
  
  captures the entire list
  
  =item $2
  
  captures the last separator
  
  =back
  
  =head2 C<$RE{list}{conj}{-word=I<PATTERN>}>
  
  An alias for C<< $RE{list}{-lastsep=>'\s*,?\s*I<PATTERN>\s*'} >>
  
  If C<-word> is not specified, the default pattern is C<qr/and|or/>.
  
  For example:
  
        $RE{list}{conj}{-word=>'et'}        # match Jean, Paul, et Satre
        $RE{list}{conj}{-word=>'oder'}      # match Bonn, Koln oder Hamburg
  
  =head2 C<$RE{list}{and}>
  
  An alias for C<< $RE{list}{conj}{-word=>'and'} >>
  
  =head2 C<$RE{list}{or}>
  
  An alias for C<< $RE{list}{conj}{-word=>'or'} >>
  
  =head1 SEE ALSO
  
  L<Regexp::Common> for a general description of how to use this interface.
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  For a start, there are many common regexes missing.
  Send them in to I<regexp-common@abigail.be>.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
PERL5_REGEXP_COMMON_LIST

$fatpacked{"perl5/Regexp/Common/net.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_REGEXP_COMMON_NET';
  package Regexp::Common::net;
  
  use Regexp::Common qw /pattern clean no_defaults/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2016020301';
  
  
  my %IPunit = (
      dec => q{(?k:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})},
      oct => q{(?k:[0-3]?[0-7]{1,2})},
      hex => q{(?k:[0-9a-fA-F]{1,2})},
      bin => q{(?k:[0-1]{1,8})},
  );
  my %MACunit = (
      %IPunit,
      hex => q{(?k:[0-9a-fA-F]{1,2})},
  );
  
  my %IPv6unit = (
      hex => q {(?k:[0-9a-f]{1,4})},
      HEX => q {(?k:[0-9A-F]{1,4})},
      HeX => q {(?k:[0-9a-fA-F]{1,4})},
  );
  
  sub dec {$_};
  sub bin {oct "0b$_"}
  
  my $IPdefsep   = '[.]';
  my $MACdefsep  =  ':';
  my $IPv6defsep =  ':';
  
  pattern name   => [qw (net IPv4)],
          create => "(?k:$IPunit{dec}$IPdefsep$IPunit{dec}$IPdefsep" .
                        "$IPunit{dec}$IPdefsep$IPunit{dec})",
          ;
  
  pattern name   => [qw (net MAC)],
          create => "(?k:" . join ($MACdefsep => ($MACunit{hex}) x 6) . ")",
          subs   => sub {
              $_ [1] = join ":" => map {sprintf "%02x" => hex}
                                   split /$MACdefsep/ => $_ [1]
                       if $_ [1] =~ /$_[0]/
          },
          ;
  
  foreach my $type (qw /dec oct hex bin/) {
      pattern name   => [qw (net IPv4), $type, "-sep=$IPdefsep"],
              create => sub {my $sep = $_ [1] -> {-sep};
                             "(?k:$IPunit{$type}$sep$IPunit{$type}$sep" .
                                 "$IPunit{$type}$sep$IPunit{$type})"
                        },
              ;
  
      pattern name   => [qw (net MAC), $type, "-sep=$MACdefsep"],
              create => sub {my $sep = $_ [1] -> {-sep};
                             "(?k:" . join ($sep => ($MACunit{$type}) x 6) . ")",
                        },
              subs   => sub {
                  return if $] < 5.006 and $type eq 'bin';
                  $_ [1] = join ":" => map {sprintf "%02x" => eval $type}
                                       $2, $3, $4, $5, $6, $7
                           if $_ [1] =~ $RE {net} {MAC} {$type}
                                            {-sep => $_ [0] -> {flags} {-sep}}
                                            {-keep};
              },
              ;
  
  }
  
  
  my %cache6;
  pattern name   => [qw (net IPv6), "-sep=$IPv6defsep", "-style=HeX"],
          create => sub {
              my $style = $_ [1] {-style};
              my $sep   = $_ [1] {-sep};
  
              return $cache6 {$style, $sep} if $cache6 {$style, $sep};
  
              my @re;
  
              die "Impossible style '$style'\n" unless exists $IPv6unit {$style};
  
              #
              # Nothing missing
              #
              push @re => join $sep => ($IPv6unit {$style}) x 8;
  
              #
              # For "double colon" representations, at least 2 units must
              # be omitted, leaving us with at most 6 units. 0 units is also
              # possible. Note we can have at most one double colon.
              #
              for (my $l = 0; $l <= 6; $l ++) {
                  #
                  # We prefer to do longest match, so larger $r gets priority
                  #
                  for (my $r = 6 - $l; $r >= 0; $r --) {
                      #
                      # $l is the number of blocks left of the double colon,
                      # $r is the number of blocks left of the double colon,
                      # $m is the number of omitted blocks
                      #
                      my $m    = 8 - $l - $r;
                      my $patl = $l ? ($IPv6unit {$style} . $sep) x $l : $sep;
                      my $patr = $r ? ($sep . $IPv6unit {$style}) x $r : $sep;
                      my $patm = "(?k:)" x $m;
                      my $pat  = $patl . $patm . $patr;
                      push @re => "(?:$pat)";
                  }
              }
              local $" = "|";
              $cache6 {$style, $sep} = qq /(?k:(?|@re))/;
          },
          version => 5.010
  ;
  
  
  my $letter      =  "[A-Za-z]";
  my $let_dig     =  "[A-Za-z0-9]";
  my $let_dig_hyp = "[-A-Za-z0-9]";
  
  # Domain names, from RFC 1035.
  pattern name   => [qw (net domain -nospace= -rfc1101=)],
          create => sub {
              my $rfc1101 = exists $_ [1] {-rfc1101} &&
                          !defined $_ [1] {-rfc1101};
  
              my $lead = $rfc1101 ? "(?!$RE{net}{IPv4}(?:[.]|\$))$let_dig"
                                  : $letter;
  
              if (exists $_ [1] {-nospace} && !defined $_ [1] {-nospace}) {
                  return "(?k:$lead(?:(?:$let_dig_hyp){0,61}$let_dig)?" .
                         "(?:\\.$lead(?:(?:$let_dig_hyp){0,61}$let_dig)?)*)"
              }
              else {
                  return "(?k: |(?:$lead(?:(?:$let_dig_hyp){0,61}$let_dig)?" .
                         "(?:\\.$lead(?:(?:$let_dig_hyp){0,61}$let_dig)?)*))"
              }
          },
          ;
  
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  Regexp::Common::net -- provide regexes for IPv4 addresses.
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /net/;
  
      while (<>) {
          /$RE{net}{IPv4}/       and print "Dotted decimal IP address";
          /$RE{net}{IPv4}{hex}/  and print "Dotted hexadecimal IP address";
          /$RE{net}{IPv4}{oct}{-sep => ':'}/ and
                                 print "Colon separated octal IP address";
          /$RE{net}{IPv4}{bin}/  and print "Dotted binary IP address";
          /$RE{net}{MAC}/        and print "MAC address";
          /$RE{net}{MAC}{oct}{-sep => " "}/ and
                                 print "Space separated octal MAC address";
      }
  
  =head1 DESCRIPTION
  
  Please consult the manual of L<Regexp::Common> for a general description
  of the works of this interface.
  
  Do not use this module directly, but load it via I<Regexp::Common>.
  
  This modules gives you regular expressions for various style IPv4 
  and MAC (or ethernet) addresses.
  
  =head2 C<$RE{net}{IPv4}>
  
  Returns a pattern that matches a valid IP address in "dotted decimal".
  Note that while C<318.99.183.11> is not a valid IP address, it does
  match C</$RE{net}{IPv4}/>, but this is because C<318.99.183.11> contains
  a valid IP address, namely C<18.99.183.11>. To prevent the unwanted
  matching, one needs to anchor the regexp: C</^$RE{net}{IPv4}$/>.
  
  For this pattern and the next four, under C<-keep> (See L<Regexp::Common>):
  
  =over 4
  
  =item $1
  
  captures the entire match
  
  =item $2
  
  captures the first component of the address
  
  =item $3
  
  captures the second component of the address
  
  =item $4
  
  captures the third component of the address
  
  =item $5
  
  captures the final component of the address
  
  =back
  
  =head2 C<$RE{net}{IPv4}{dec}{-sep}>
  
  Returns a pattern that matches a valid IP address in "dotted decimal"
  
  If C<< -sep=I<P> >> is specified the pattern I<P> is used as the separator.
  By default I<P> is C<qr/[.]/>. 
  
  =head2 C<$RE{net}{IPv4}{hex}{-sep}>
  
  Returns a pattern that matches a valid IP address in "dotted hexadecimal",
  with the letters C<A> to C<F> capitalized.
  
  If C<< -sep=I<P> >> is specified the pattern I<P> is used as the separator.
  By default I<P> is C<qr/[.]/>. C<< -sep="" >> and
  C<< -sep=" " >> are useful alternatives.
  
  =head2 C<$RE{net}{IPv4}{oct}{-sep}>
  
  Returns a pattern that matches a valid IP address in "dotted octal"
  
  If C<< -sep=I<P> >> is specified the pattern I<P> is used as the separator.
  By default I<P> is C<qr/[.]/>.
  
  =head2 C<$RE{net}{IPv4}{bin}{-sep}>
  
  Returns a pattern that matches a valid IP address in "dotted binary"
  
  If C<< -sep=I<P> >> is specified the pattern I<P> is used as the separator.
  By default I<P> is C<qr/[.]/>.
  
  =head2 C<$RE{net}{MAC}>
  
  Returns a pattern that matches a valid MAC or ethernet address as
  colon separated hexadecimals.
  
  For this pattern, and the next four, under C<-keep> (See L<Regexp::Common>):
  
  =over 4
  
  =item $1
  
  captures the entire match
  
  =item $2
  
  captures the first component of the address
  
  =item $3
  
  captures the second component of the address
  
  =item $4
  
  captures the third component of the address
  
  =item $5
  
  captures the fourth component of the address
  
  =item $6
  
  captures the fifth component of the address
  
  =item $7
  
  captures the sixth and final component of the address
  
  =back
  
  This pattern, and the next four, have a C<subs> method as well, which
  will transform a matching MAC address into so called canonical format.
  Canonical format means that every component of the address will be
  exactly two hexadecimals (with a leading zero if necessary), and the
  components will be separated by a colon.
  
  The C<subs> method will not work for binary MAC addresses if the
  Perl version predates 5.6.0.
  
  =head2 C<$RE{net}{MAC}{dec}{-sep}>
  
  Returns a pattern that matches a valid MAC address as colon separated
  decimals.
  
  If C<< -sep=I<P> >> is specified the pattern I<P> is used as the separator.
  By default I<P> is C<qr/:/>. 
  
  =head2 C<$RE{net}{MAC}{hex}{-sep}>
  
  Returns a pattern that matches a valid MAC address as colon separated
  hexadecimals, with the letters C<a> to C<f> in lower case.
  
  If C<< -sep=I<P> >> is specified the pattern I<P> is used as the separator.
  By default I<P> is C<qr/:/>.
  
  =head2 C<$RE{net}{MAC}{oct}{-sep}>
  
  Returns a pattern that matches a valid MAC address as colon separated
  octals.
  
  If C<< -sep=I<P> >> is specified the pattern I<P> is used as the separator.
  By default I<P> is C<qr/:/>.
  
  =head2 C<$RE{net}{MAC}{bin}{-sep}>
  
  Returns a pattern that matches a valid MAC address as colon separated
  binary numbers.
  
  If C<< -sep=I<P> >> is specified the pattern I<P> is used as the separator.
  By default I<P> is C<qr/:/>.
  
  =head2 C<< $RE{net}{IPv6}{-sep => ':'}{-style => 'HeX'} >>
  
  Returns a pattern matching IPv6 numbers. An IPv6 address consists of
  eigth groups of four hexadecimal digits, separated by colons. In each
  group, leading zeros may be omitted. Two or more consecutive groups
  consisting of only zeros may be omitted (including any colons separating
  them), resulting into two sets of groups, separated by a double colon.
  (Each of the groups may be empty; C<< :: >> is a valid address, equal to
  C<< 0000:0000:0000:0000:0000:0000:0000:0000 >>). The hex numbers may be
  in either case.
  
  If the C<< -sep >> option is used, its argument is a pattern that matches
  the separator that separates groups. This defaults to C<< : >>. The 
  C<< -style >> option is used to denote which case the hex numbers may be.
  The default style, C<< 'HeX' >> indicates both lower case letters C<< 'a' >>
  to C<< 'f' >> and upper case letters C<< 'A' >> to C<< 'F' >> will be 
  matched. The style C<< 'HEX' >> restricts matching to upper case letters,
  and C<< 'hex' >> only matches lower case letters.
  
  If C<< {-keep} >> is used, C<< $1 >> to C<< $9 >> will be set. C<< $1 >>
  will be set to the matched address, while C<< $2 >> to C<< $9 >> will be
  set to each matched group. If a group is omitted because it contains all
  zeros, its matching variable will be the empty string.
  
  Example:
  
    "2001:db8:85a3::8a2e:370:7334" =~ /$RE{net}{IPv6}{-keep}/;
    print $2;    # '2001'
    print $4;    # '85a3'
    print $6;    # Empty string
    print $8;    # '370'
  
  Perl 5.10 (or later) is required for this pattern.
  
  =head2 C<$RE{net}{domain}>
  
  Returns a pattern to match domains (and hosts) as defined in RFC 1035.
  Under I{-keep} only the entire domain name is returned.
  
  RFC 1035 says that a single space can be a domainname too. So, the
  pattern returned by C<$RE{net}{domain}> recognizes a single space
  as well. This is not always what people want. If you want to recognize
  domainnames, but not a space, you can do one of two things, either use
  
      /(?! )$RE{net}{domain}/
  
  or use the C<{-nospace}> option (without an argument).
  
  RFC 1035 does B<not> allow host or domain names to start with a digits;
  however, this restriction is relaxed in RFC 1101; this RFC allows host
  and domain names to start with a digit, as long as the first part of
  a domain does not look like an IP address. If the C<< {-rfc1101} >> option
  is given (as in C<< $RE {net} {domain} {-rfc1101} >>), we will match using
  the relaxed rules.
  
  =head1 REFERENCES
  
  =over 4
  
  =item B<RFC 1035>
  
  Mockapetris, P.: I<DOMAIN NAMES - IMPLEMENTATION AND SPECIFICATION>.
  November 1987.
  
  =item B<RFC 1101>
  
  Mockapetris, P.: I<DNS Encoding of Network Names and Other Types>.
  April 1987.
  
  =back
  
  =head1 SEE ALSO
  
  L<Regexp::Common> for a general description of how to use this interface.
  
  =head1 AUTHOR
  
  Damian Conway I<damian@conway.org>.
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  For a start, there are many common regexes missing.
  Send them in to I<regexp-common@abigail.be>.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2013, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
PERL5_REGEXP_COMMON_NET

$fatpacked{"perl5/Regexp/Common/number.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_REGEXP_COMMON_NUMBER';
  package Regexp::Common::number;
  
  use Config;
  use Regexp::Common qw /pattern clean no_defaults/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2016020301';
  
  
  sub _croak {
      require Carp;
      goto &Carp::croak;
  }
  
  my $digits = join ("", 0 .. 9, "A" .. "Z");
  
  sub int_creator {
      my $flags = $_ [1];
      my ($sep, $group, $base, $places, $sign) =
              @{$flags} {qw /-sep -group -base -places -sign/};
  
      # Deal with the bases.
      _croak "Base must be between 1 and 36" unless $base >=  1 &&
                                                    $base <= 36;
      my $chars = substr $digits, 0, $base;
  
      $sep = ',' if exists $flags -> {-sep} && !defined $flags -> {-sep};
  
      my $max = $group;
         $max = $2 if $group =~ /^\s*(\d+)\s*,\s*(\d+)\s*$/;
  
      my $quant = $places ? "{$places}" : "+";
  
      return $sep ? qq {(?k:(?k:$sign)(?k:[$chars]{1,$max}} .
                    qq {(?:$sep} . qq {[$chars]{$group})*))}
                  : qq {(?k:(?k:$sign)(?k:[$chars]$quant))}
  }
  
  sub real_creator { 
      my ($base, $places, $radix, $sep, $group, $expon, $sign) =
              @{$_[1]}{-base, -places, -radix, -sep, -group, -expon, -sign};
      _croak "Base must be between 1 and 36"
             unless $base >= 1 && $base <= 36;
      $sep = ',' if exists $_[1]->{-sep}
                 && !defined $_[1]->{-sep};
      if ($base > 14 && $expon =~ /^[Ee]$/) {$expon = 'G'}
      foreach ($radix, $sep, $expon) {$_ = "[$_]" if 1 == length}
      my $chars = substr $digits, 0, $base;
      return $sep
             ? qq {(?k:(?i)(?k:$sign)(?k:(?=$radix?[$chars])}              .
               qq {(?k:[$chars]{1,$group}(?:(?:$sep)[$chars]{$group})*)}   .
               qq {(?:(?k:$radix)(?k:[$chars]{$places}))?)}                .
               qq {(?:(?k:$expon)(?k:(?k:$sign)(?k:[$chars]+))|))}
             : qq {(?k:(?i)(?k:$sign)(?k:(?=$radix?[$chars])}              .
               qq {(?k:[$chars]*)(?:(?k:$radix)(?k:[$chars]{$places}))?)}  .
               qq {(?:(?k:$expon)(?k:(?k:$sign)(?k:[$chars]+))|))};
  }
  sub decimal_creator { 
      my ($base, $places, $radix, $sep, $group, $sign) =
              @{$_[1]}{-base, -places, -radix, -sep, -group, -sign};
      _croak "Base must be between 1 and 36"
             unless $base >= 1 && $base <= 36;
      $sep = ',' if exists $_[1]->{-sep}
                 && !defined $_[1]->{-sep};
      foreach ($radix, $sep) {$_ = "[$_]" if 1 == length}
      my $chars = substr $digits, 0, $base;
      return $sep
             ? qq {(?k:(?i)(?k:$sign)(?k:(?=$radix?[$chars])}               .
               qq {(?k:[$chars]{1,$group}(?:(?:$sep)[$chars]{$group})*)}    .
               qq {(?:(?k:$radix)(?k:[$chars]{$places}))?))}
             : qq {(?k:(?i)(?k:$sign)(?k:(?=$radix?[$chars])}               .
               qq {(?k:[$chars]*)(?:(?k:$radix)(?k:[$chars]{$places}))?))}
  }
  
  
  pattern name   => [qw (num int -sep= -base=10 -group=3 -sign=[-+]?)],
          create => \&int_creator,
          ;
  
  pattern name   => [qw (num real -base=10), '-places=0,',
                     qw (-radix=[.] -sep= -group=3 -expon=E -sign=[-+]?)],
          create => \&real_creator,
          ;
  
  pattern name   => [qw (num decimal -base=10), '-places=0,',
                     qw (-radix=[.] -sep= -group=3 -sign=[-+]?)],
          create => \&decimal_creator,
          ;
  
  sub real_synonym {
      my ($name, $base) = @_;
      pattern name   => ['num', $name, '-places=0,', '-radix=[.]',
                         '-sep=', '-group=3', '-expon=E', '-sign=[-+]?'],
              create => sub {my %flags = (%{$_[1]}, -base => $base);
                             real_creator (undef, \%flags);
                        }
              ;
  }
  
  
  real_synonym (hex => 16);
  real_synonym (dec => 10);
  real_synonym (oct =>  8);
  real_synonym (bin =>  2);
  
  
  # 2147483647
  pattern name    => [qw (num square)],
          create  => sub {
              use re 'eval';
              my $sixty_four_bits = $Config {use64bitint};
              #
              # CPAN testers claim it fails on 5.8.8 and darwin 9.0.
              #
              $sixty_four_bits = 0 if $Config {osname} eq 'darwin' &&
                                      $Config {osvers} eq '9.0'    &&
                                      $] == 5.008008;
              my $num = $sixty_four_bits ? '0*[1-8]?[0-9]{1,15}' :
                       '0*(?:2(?:[0-0][0-9]{8}' .
                           '|1(?:[0-3][0-9]{7}' .
                           '|4(?:[0-6][0-9]{6}' .
                           '|7(?:[0-3][0-9]{5}' .
                           '|4(?:[0-7][0-9]{4}' .
                           '|8(?:[0-2][0-9]{3}' .
                           '|3(?:[0-5][0-9]{2}' .
                           '|6(?:[0-3][0-9]{1}' .
                           '|4[0-7])))))))))|1?[0-9]{1,9}';
              qr {($num)(?(?{sqrt ($^N) == int sqrt ($^N)})|(?!))}
          },
          version => 5.008;
          ;
  
  pattern name    => [qw (num roman)],
          create  => '(?xi)(?=[MDCLXVI])
                           (?k:M{0,3}
                              (D?C{0,3}|CD|CM)?
                              (L?X{0,3}|XL|XC)?
                              (V?I{0,3}|IV|IX)?)'
          ;
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::number -- provide regexes for numbers
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /number/;
  
      while (<>) {
          /^$RE{num}{int}$/                and  print "Integer\n";
          /^$RE{num}{real}$/               and  print "Real\n";
          /^$RE{num}{real}{-base => 16}$/  and  print "Hexadecimal real\n";
      }
  
  
  =head1 DESCRIPTION
  
  Please consult the manual of L<Regexp::Common> for a general description
  of the works of this interface.
  
  Do not use this module directly, but load it via I<Regexp::Common>.
  
  =head2 C<$RE{num}{int}{-base}{-sep}{-group}{-places}{-sign}>
  
  Returns a pattern that matches an integer.
  
  If C<< -base => I<B> >> is specified, the integer is in base I<B>, with
  C<< 2 <= I<B> <= 36 >>. For bases larger than 10, upper case letters
  are used. The default base is 10.
  
  If C<< -sep => I<P> >> is specified, the pattern I<P> is required as a
  grouping marker within the number. If this option is not given, no
  grouping marker is used.
  
  If C<< -group => I<N> >> is specified, digits between grouping markers
  must be grouped in sequences of exactly I<N> digits. The default value
  of I<N> is 3.  If C<< -group => I<N,M> >> is specified, digits between
  grouping markers must be grouped in sequences of at least I<N> digits,
  and at most I<M> digits. This option is ignored unless the C<< -sep >>
  option is used.
  
  If C<< -places => I<N> >> is specified, the integer recognized must be
  exactly I<N> digits wide. If C<< -places => I<N,M> >> is specified, the
  integer must be at least I<N> wide, and at most I<M> characters. There
  is no default, which means that integers are unlimited in size. This
  option is ignored if the C<< -sep >> option is used.
  
  If C<< -sign => I<P> >> is used, it's a pattern the leading sign has to
  match. This defaults to C<< [-+]? >>, which means the number is optionally
  preceded by a minus or a plus. If you want to match unsigned integers,
  use C<< $RE{num}{int}{-sign => ''} >>.
  
  For example:
  
   $RE{num}{int}                          # match 1234567
   $RE{num}{int}{-sep=>','}               # match 1,234,567
   $RE{num}{int}{-sep=>',?'}              # match 1234567 or 1,234,567
   $RE{num}{int}{-sep=>'.'}{-group=>4}    # match 1.2345.6789
  
  Under C<-keep> (see L<Regexp::Common>):
  
  =over 4
  
  =item $1
  
  captures the entire number
  
  =item $2
  
  captures the optional sign of the number
  
  =item $3
  
  captures the complete set of digits
  
  =back
  
  =head2 C<$RE{num}{real}{-base}{-radix}{-places}{-sep}{-group}{-expon}>
  
  Returns a pattern that matches a floating-point number.
  
  If C<-base=I<N>> is specified, the number is assumed to be in that base
  (with A..Z representing the digits for 11..36). By default, the base is 10.
  
  If C<-radix=I<P>> is specified, the pattern I<P> is used as the radix point for
  the number (i.e. the "decimal point" in base 10). The default is C<qr/[.]/>.
  
  If C<-places=I<N>> is specified, the number is assumed to have exactly
  I<N> places after the radix point.
  If C<-places=I<M,N>> is specified, the number is assumed to have between
  I<M> and I<N> places after the radix point.
  By default, the number of places is unrestricted.
  
  If C<-sep=I<P>> specified, the pattern I<P> is required as a grouping marker
  within the pre-radix section of the number. By default, no separator is
  allowed.
  
  If C<-group=I<N>> is specified, digits between grouping separators
  must be grouped in sequences of exactly I<N> characters. The default value of
  I<N> is 3.
  
  If C<-expon=I<P>> is specified, the pattern I<P> is used as the exponential
  marker.  The default value of I<P> is C<qr/[Ee]/>.
  
  If C<-sign=I<P>> is specified, the pattern I<P> is used to match the 
  leading sign (and the sign of the exponent). This defaults to C<< [-+]? >>,
  means means that an optional plus or minus sign can be used.
  
  For example:
  
   $RE{num}{real}                  # matches 123.456 or -0.1234567
   $RE{num}{real}{-places=>2}      # matches 123.45 or -0.12
   $RE{num}{real}{-places=>'0,3'}  # matches 123.456 or 0 or 9.8
   $RE{num}{real}{-sep=>'[,.]?'}   # matches 123,456 or 123.456
   $RE{num}{real}{-base=>3'}       # matches 121.102
  
  Under C<-keep>:
  
  =over 4
  
  =item $1
  
  captures the entire match
  
  =item $2
  
  captures the optional sign of the number
  
  =item $3
  
  captures the complete mantissa
  
  =item $4
  
  captures the whole number portion of the mantissa
  
  =item $5
  
  captures the radix point
  
  =item $6
  
  captures the fractional portion of the mantissa
  
  =item $7
  
  captures the optional exponent marker
  
  =item $8
  
  captures the entire exponent value
  
  =item $9
  
  captures the optional sign of the exponent
  
  =item $10
  
  captures the digits of the exponent
  
  =back
  
  =head2 C<$RE{num}{dec}{-radix}{-places}{-sep}{-group}{-expon}>
  
  A synonym for C<< $RE{num}{real}{-base=>10}{...} >>
  
  =head2 C<$RE{num}{oct}{-radix}{-places}{-sep}{-group}{-expon}>
  
  A synonym for C<< $RE{num}{real}{-base=>8}{...} >>
  
  =head2 C<$RE{num}{bin}{-radix}{-places}{-sep}{-group}{-expon}>
  
  A synonym for C<< $RE{num}{real}{-base=>2}{...} >>
  
  =head2 C<$RE{num}{hex}{-radix}{-places}{-sep}{-group}{-expon}>
  
  A synonym for C<< $RE{num}{real}{-base=>16}{...} >>
  
  =head2 C<$RE{num}{decimal}{-base}{-radix}{-places}{-sep}{-group}>
  
  The same as C<$RE{num}{real}>, except that an exponent isn't allowed.
  Hence, this returns a pattern matching I<decimal> numbers.
  
  If C<-base=I<N>> is specified, the number is assumed to be in that base
  (with A..Z representing the digits for 11..36). By default, the base is 10.
  
  If C<-radix=I<P>> is specified, the pattern I<P> is used as the radix point for
  the number (i.e. the "decimal point" in base 10). The default is C<qr/[.]/>.
  
  If C<-places=I<N>> is specified, the number is assumed to have exactly
  I<N> places after the radix point.
  If C<-places=I<M,N>> is specified, the number is assumed to have between
  I<M> and I<N> places after the radix point.
  By default, the number of places is unrestricted.
  
  If C<-sep=I<P>> specified, the pattern I<P> is required as a grouping marker
  within the pre-radix section of the number. By default, no separator is
  allowed.
  
  If C<-group=I<N>> is specified, digits between grouping separators
  must be grouped in sequences of exactly I<N> characters. The default value of
  I<N> is 3.
  
  For example:
  
   $RE{num}{decimal}                  # matches 123.456 or -0.1234567
   $RE{num}{decimal}{-places=>2}      # matches 123.45 or -0.12
   $RE{num}{decimal}{-places=>'0,3'}  # matches 123.456 or 0 or 9.8
   $RE{num}{decimal}{-sep=>'[,.]?'}   # matches 123,456 or 123.456
   $RE{num}{decimal}{-base=>3'}       # matches 121.102
  
  Under C<-keep>:
  
  =over 4
  
  =item $1
  
  captures the entire match
  
  =item $2
  
  captures the optional sign of the number
  
  =item $3
  
  captures the complete mantissa
  
  =item $4
  
  captures the whole number portion of the mantissa
  
  =item $5
  
  captures the radix point
  
  =item $6
  
  captures the fractional portion of the mantissa
  
  =back
  
  =head2 C<$RE{num}{square}>
  
  Returns a pattern that matches a (decimal) square. Because Perl's
  arithmetic is lossy when using integers over about 53 bits, this pattern
  only recognizes numbers less than 9000000000000000, if one uses a
  Perl that is configured to use 64 bit integers. Otherwise, the limit
  is 2147483647. These restrictions were introduced in versions 2.116
  and 2.117 of Regexp::Common. Regardless whether C<-keep> was set,
  the matched number will be returned in C<$1>.
  
  This pattern is available for version 5.008 and up.
  
  =head2 C<$RE{num}{roman}>
  
  Returns a pattern that matches an integer written in Roman numbers.
  Case doesn't matter. Only the more modern style, that is, no more
  than three repetitions of a letter, is recognized. The largest number
  matched is I<MMMCMXCIX>, or 3999. Larger numbers cannot be expressed
  using ASCII characters. A future version will be able to deal with 
  the Unicode symbols to match larger Roman numbers.
  
  Under C<-keep>, the number will be captured in $1.
  
  =head1 SEE ALSO
  
  L<Regexp::Common> for a general description of how to use this interface.
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  For a start, there are many common regexes missing.
  Send them in to I<regexp-common@abigail.be>.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2013, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
PERL5_REGEXP_COMMON_NUMBER

$fatpacked{"perl5/Regexp/Common/profanity.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_REGEXP_COMMON_PROFANITY';
  package Regexp::Common::profanity;
  
  use Regexp::Common qw /pattern clean no_defaults/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2016020301';
  
  my $profanity = '(?:cvff(?:\\ gnxr|\\-gnxr|gnxr|r(?:ef|[feq])|vat|l)?|dhvzf?|fuvg(?:g(?:r(?:ef|[qe])|vat|l)|r(?:ef|[fqel])|vat|[fr])?|g(?:heqf?|jngf?)|jnax(?:r(?:ef|[eq])|vat|f)?|n(?:ef(?:r(?:\\ ubyr|\\-ubyr|ubyr|[fq])|vat|r)|ff(?:\\ ubyrf?|\\-ubyrf?|rq|ubyrf?|vat))|o(?:hyy(?:\\ fuvg(?:g(?:r(?:ef|[qe])|vat)|f)?|\\-fuvg(?:g(?:r(?:ef|[qe])|vat)|f)?|fuvg(?:g(?:r(?:ef|[qe])|vat)|f)?)|ybj(?:\\ wbof?|\\-wbof?|wbof?))|p(?:bpx(?:\\ fhpx(?:ref?|vat)|\\-fhpx(?:ref?|vat)|fhpx(?:ref?|vat))|enc(?:c(?:r(?:ef|[eq])|vat|l)|f)?|h(?:agf?|z(?:vat|zvat|f)))|qvpx(?:\\ urnq|\\-urnq|rq|urnq|vat|yrff|f)|s(?:hpx(?:rq|vat|f)?|neg(?:r[eq]|vat|[fl])?|rygpu(?:r(?:ef|[efq])|vat)?)|un(?:eq[\\-\\ ]?ba|ys(?:\\ n[fe]|\\-n[fe]|n[fe])frq)|z(?:bgure(?:\\ shpx(?:ref?|vat)|\\-shpx(?:ref?|vat)|shpx(?:ref?|vat))|hgu(?:n(?:\\ shpx(?:ref?|vat|[nnn])|\\-shpx(?:ref?|vat|[nnn])|shpx(?:ref?|vat|[nnn]))|re(?:\\ shpx(?:ref?|vat)|\\-shpx(?:ref?|vat)|shpx(?:ref?|vat)))|reqr?))';
  
  my $contextual = '(?:c(?:bex|e(?:bax|vpxf?)|hff(?:vrf|l)|vff(?:\\ gnxr|\\-gnxr|gnxr|r(?:ef|[feq])|vat|l)?)|dhvzf?|ebbg(?:r(?:ef|[eq])|vat|f)?|f(?:bq(?:q(?:rq|vat)|f)?|chax|perj(?:rq|vat|f)?|u(?:nt(?:t(?:r(?:ef|[qe])|vat)|f)?|vg(?:g(?:r(?:ef|[qe])|vat|l)|r(?:ef|[fqel])|vat|[fr])?))|g(?:heqf?|jngf?|vgf?)|jnax(?:r(?:ef|[eq])|vat|f)?|n(?:ef(?:r(?:\\ ubyr|\\-ubyr|ubyr|[fq])|vat|r)|ff(?:\\ ubyrf?|\\-ubyrf?|rq|ubyrf?|vat))|o(?:ba(?:r(?:ef|[fe])|vat|r)|h(?:ttre|yy(?:\\ fuvg(?:g(?:r(?:ef|[qe])|vat)|f)?|\\-fuvg(?:g(?:r(?:ef|[qe])|vat)|f)?|fuvg(?:g(?:r(?:ef|[qe])|vat)|f)?))|n(?:fgneq|yy(?:r(?:ef|[qe])|vat|f)?)|yb(?:bql|j(?:\\ wbof?|\\-wbof?|wbof?)))|p(?:bpx(?:\\ fhpx(?:ref?|vat)|\\-fhpx(?:ref?|vat)|fhpx(?:ref?|vat)|f)?|enc(?:c(?:r(?:ef|[eq])|vat|l)|f)?|h(?:agf?|z(?:vat|zvat|f)))|q(?:batf?|vpx(?:\\ urnq|\\-urnq|rq|urnq|vat|yrff|f)?)|s(?:hpx(?:rq|vat|f)?|neg(?:r[eq]|vat|[fl])?|rygpu(?:r(?:ef|[efq])|vat)?)|u(?:hzc(?:r(?:ef|[eq])|vat|f)?|n(?:eq[\\-\\ ]?ba|ys(?:\\ n[fe]|\\-n[fe]|n[fe])frq))|z(?:bgure(?:\\ shpx(?:ref?|vat)|\\-shpx(?:ref?|vat)|shpx(?:ref?|vat))|hgu(?:n(?:\\ shpx(?:ref?|vat|[nnn])|\\-shpx(?:ref?|vat|[nnn])|shpx(?:ref?|vat|[nnn]))|re(?:\\ shpx(?:ref?|vat)|\\-shpx(?:ref?|vat)|shpx(?:ref?|vat)))|reqr?))';
  
  tr/A-Za-z/N-ZA-Mn-za-m/ foreach $profanity, $contextual;
  
  pattern name   => [qw (profanity)],
          create => '(?:\b(?k:' . $profanity . ')\b)',
          ;
  
  pattern name   => [qw (profanity contextual)],
          create => '(?:\b(?k:' . $contextual . ')\b)',
          ;
  
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::profanity -- provide regexes for profanity
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /profanity/;
  
      while (<>) {
          /$RE{profanity}/               and  print "Contains profanity\n";
      }
  
  
  =head1 DESCRIPTION
  
  Please consult the manual of L<Regexp::Common> for a general description
  of the works of this interface.
  
  Do not use this module directly, but load it via I<Regexp::Common>.
  
  =head2 $RE{profanity}
  
  Returns a pattern matching words -- such as Carlin's "big seven" -- that
  are most likely to give offense. Note that correct anatomical terms are
  deliberately I<not> included in the list.
  
  Under C<-keep> (see L<Regexp::Common>):
  
  =over 4
  
  =item $1
  
  captures the entire word
  
  =back
  
  =head2 C<$RE{profanity}{contextual}>
  
  Returns a pattern matching words that are likely to give offense when
  used in specific contexts, but which also have genuinely
  non-offensive meanings.
  
  Under C<-keep> (see L<Regexp::Common>):
  
  =over 4
  
  =item $1
  
  captures the entire word
  
  =back
  
  =head1 SEE ALSO
  
  L<Regexp::Common> for a general description of how to use this interface.
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  For a start, there are many common regexes missing.
  Send them in to I<regexp-common@abigail.be>.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
PERL5_REGEXP_COMMON_PROFANITY

$fatpacked{"perl5/Regexp/Common/whitespace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_REGEXP_COMMON_WHITESPACE';
  package Regexp::Common::whitespace;
  
  use Regexp::Common qw /pattern clean no_defaults/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2016020301';
  
  pattern name   => [qw (ws crop)],
          create => '(?:^\s+|\s+$)',
          subs   => sub {$_[1] =~ s/^\s+//; $_[1] =~ s/\s+$//;}
          ;
  
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::whitespace -- provides a regex for leading or
  trailing whitescape
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /whitespace/;
  
      while (<>) {
          s/$RE{ws}{crop}//g;           # Delete surrounding whitespace
      }
  
  
  =head1 DESCRIPTION
  
  Please consult the manual of L<Regexp::Common> for a general description
  of the works of this interface.
  
  Do not use this module directly, but load it via I<Regexp::Common>.
  
  
  =head2 C<$RE{ws}{crop}>
  
  Returns a pattern that identifies leading or trailing whitespace.
  
  For example:
  
          $str =~ s/$RE{ws}{crop}//g;     # Delete surrounding whitespace
  
  The call:
  
          $RE{ws}{crop}->subs($str);
  
  is optimized (but probably still slower than doing the s///g explicitly).
  
  This pattern does not capture under C<-keep>.
  
  =head1 SEE ALSO
  
  L<Regexp::Common> for a general description of how to use this interface.
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  For a start, there are many common regexes missing.
  Send them in to I<regexp-common@abigail.be>.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
PERL5_REGEXP_COMMON_WHITESPACE

$fatpacked{"perl5/Regexp/Common/zip.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_REGEXP_COMMON_ZIP';
  package Regexp::Common::zip;
  
  use Regexp::Common qw /pattern clean no_defaults/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2016020301';
  
  
  #
  # Prefer '[0-9]' over \d, because the latter may include more
  # in Unicode string.
  #
  
  my %code = (
      Australia         =>  [qw /AUS? AU AUS/],
      Belgium           =>  [qw /BE?  BE B/],
      Denmark           =>  [qw /DK   DK DK/],
      France            =>  [qw /FR?  FR F/],
      Germany           =>  [qw /DE?  DE D/],
      Greenland         =>  [qw /DK   DK DK/],
      Italy             =>  [qw /IT?  IT I/],
      Netherlands       =>  [qw /NL   NL NL/],
      Norway            =>  [qw /NO?  NO N/],
      Spain             =>  [qw /ES?  ES E/],
      USA               =>  [qw /USA? US USA/],
  );
  
  # Returns the empty string if the argument is undefined, the argument otherwise.
  sub __ {defined $_ [0] ? $_ [0] : ""}
  
  # Used for allowable options. If the value starts with 'y', the option is
  # required ("{1,1}" is returned, if the value starts with 'n', the option
  # is disallowed ("{0,0}" is returned), otherwise, the option is allowed,
  # but not required ("{0,1}" is returned).
  sub _t {
      if (defined $_ [0]) {
          if ($_ [0] =~ /^y/i) {return "{1,1}"}
          if ($_ [0] =~ /^n/i) {return "{0,0}"}
      }
      "{0,1}"
  }
  
  # Returns the (sub)pattern for the country named '$name', and the 
  # -country option '$country'.
  sub _c {
      my ($name, $country) = @_;
      if (defined $country && $country ne "") {
          if ($country eq 'iso')  {return $code {$name} [1]}
          if ($country eq 'cept') {return $code {$name} [2]}
          return $country;
      }
      $code {$name} [0]
  }
  
  
  my %zip = (
      Australia   =>  "(?k:(?k:[1-8][0-9]|9[0-7]|0?[28]|0?9(?=09))(?k:[0-9]{2}))",
                      # Postal codes of the form 'DDDD', with the first
                      # two digits 02, 08 or 20-97. Leading 0 may be omitted.
                      # 909 and 0909 are valid as well - but no other postal
                      # codes starting with 9 or 09.
  
      Belgium     =>  "(?k:(?k:[1-9])(?k:[0-9]{3}))",
                      # Postal codes of the form: 'DDDD', with the first
                      # digit representing the province; the others
                      # distribution sectors. Postal codes do not start
                      # with a zero.
  
      Denmark     =>  "(?k:(?k:[1-9])(?k:[0-9])(?k:[0-9]{2}))",
                      # Postal codes of the form: 'DDDD', with the first
                      # digit representing the distribution region, the
                      # second digit the distribution district. Postal
                      # codes do not start with a zero. Postal codes 
                      # starting with '39' are in Greenland.
  
      France      =>  "(?k:(?k:[0-8][0-9]|9[0-8])(?k:[0-9]{3}))",
                      # Postal codes of the form: 'DDDDD'. All digits are used.
                      # First two digits indicate the department, and range
                      # from 01 to 98, or 00 for army.
  
      Germany     =>  "(?k:(?k:[0-9])(?k:[0-9])(?k:[0-9]{3}))",
                      # Postal codes of the form: 'DDDDD'. All digits are used.
                      # First digit is the distribution zone, second a
                      # distribution region. Other digits indicate the
                      # distribution district and postal town.
  
      Greenland   =>  "(?k:(?k:39)(?k:[0-9]{2}))",
                      # Postal codes of Greenland are part of the Danish
                      # system. Codes in Greenland start with 39.
  
      Italy       =>  "(?k:(?k:[0-9])(?k:[0-9])(?k:[0-9])(?k:[0-9])(?k:[0-9]))",
                      # First digit: region.
                      # Second digit: province.
                      # Third digit: capital/province (odd for capital).
                      # Fourth digit: route.
                      # Fifth digit: place on route (0 for small places)
  
      Norway      =>  "(?k:[0-9]{4})",
                      # Four digits, no significance (??).
  
      Spain       =>  "(?k:(?k:0[1-9]|[1-4][0-9]|5[0-2])(?k:[0-9])(?k:[0-9]{2}))",
                      # Five digits, first two indicate the province.
                      # Third digit: large town, main delivery rounds.
                      # Last 2 digits: delivery area, secondary delivery route
                      #                or link to rural areas.
  
      Switzerland =>  "(?k:[1-9][0-9]{3})",
                      # Four digits, first is district, second is area,
                      # third is route, fourth is post office number.
  );
  
  my %alternatives = (
      Australia    => [qw /Australian/],
      France       => [qw /French/],
      Germany      => [qw /German/],
  );
  
  
  while (my ($country, $zip) = each %zip) {
      my @names = ($country);
      push @names => @{$alternatives {$country}} if $alternatives {$country};
      foreach my $name (@names) {
          my $pat_name = $name eq "Denmark" && $] < 5.00503
                         ?   [zip => $name, qw /-country=/]
                         :   [zip => $name, qw /-prefix= -country=/];
          pattern name    => $pat_name,
                  create  => sub {
                      my $pt  = _t $_ [1] {-prefix};
  
                      my $cn  = _c $country => $_ [1] {-country};
                      my $pfx = "(?:(?k:$cn)-)";
  
                      "(?k:$pfx$pt$zip)";
                  },
                  ;
      }
  }
  
  
  # Postal codes of the form 'DDDD LL', with F, I, O, Q, U and Y not
  # used, SA, SD and SS unused combinations, and the first digit
  # cannot be 0. No specific meaning to the letters or digits.
  foreach my $country (qw /Netherlands Dutch/) {
      pattern name   => ['zip', $country => qw /-prefix= -country=/, "-sep= "],
              create => sub {
                  my $pt  = _t $_ [1] {-prefix};
  
                  # Unused letters: F, I, O, Q, U, Y.
                  # Unused combinations: SA, SD, SS.
                  my $num =  '[1-9][0-9]{3}';
                  my $let =  '[A-EGHJ-NPRTVWXZ][A-EGHJ-NPRSTVWXZ]|' .
                             'S[BCEGHJ-NPRTVWXZ]';
  
                  my $sep = __ $_ [1] {-sep};
                  my $cn  = _c Netherlands => $_ [1] {-country};
                  my $pfx = "(?:(?k:$cn)-)";
  
                  "(?k:$pfx$pt(?k:(?k:$num)(?k:$sep)(?k:$let)))";
              },
              ;
  }
  
  
  # Postal codes of the form 'DDDDD' or 'DDDDD-DDDD'. All digits are used,
  # none carry any specific meaning.
  pattern name    => [qw /zip US -prefix= -country= -extended= -sep=-/],
          create  => sub {
              my $pt  = _t $_ [1] {-prefix};
              my $et  = _t $_ [1] {-extended};
  
              my $sep = __ $_ [1] {-sep};
  
              my $cn  = _c USA => $_ [1] {-country};
              my $pfx = "(?:(?k:$cn)-)";
              # my $zip = "(?k:[0-9]{5})";
              # my $ext = "(?:(?k:$sep)(?k:[0-9]{4}))";
              my $zip = "(?k:(?k:[0-9]{3})(?k:[0-9]{2}))";
              my $ext = "(?:(?k:$sep)(?k:(?k:[0-9]{2})(?k:[0-9]{2})))";
  
              "(?k:$pfx$pt(?k:$zip$ext$et))";
          },
          version => 5.00503,
          ;
  
  
  # pattern name   => [qw /zip British/, "-sep= "],
  #         create => sub {
  #             my $sep     = $_ [1] -> {-sep};
  # 
  #             my $london  = '(?:EC[1-4]|WC[12]|S?W1)[A-Z]';
  #             my $single  = '[BGLMS][0-9]{1,2}';
  #             my $double  = '[A-Z]{2}[0-9]{1,2}';
  # 
  #             my $left    = "(?:$london|$single|$double)";
  #             my $right   = '[0-9][ABD-HJLNP-UW-Z]{2}';
  # 
  #             "(?k:(?k:$left)(?k:$sep)(?k:$right))";
  #         },
  #         ;
  # 
  # pattern name   => [qw /zip Canadian/, "-sep= "],
  #         create => sub {
  #             my $sep     = $_ [1] -> {-sep};
  # 
  #             my $left    = '[A-Z][0-9][A-Z]';
  #             my $right   = '[0-9][A-Z][0-9]';
  # 
  #             "(?k:(?k:$left)(?k:$sep)(?k:$right))";
  #         },
  #         ;
  
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::zip -- provide regexes for postal codes.
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /zip/;
  
      while (<>) {
          /^$RE{zip}{Netherlands}$/   and  print "Dutch postal code\n";
      }
  
  
  =head1 DESCRIPTION
  
  Please consult the manual of L<Regexp::Common> for a general description
  of the works of this interface.
  
  Do not use this module directly, but load it via I<Regexp::Common>.
  
  This module offers patterns for zip or postal codes of many different
  countries. They all have the form C<$RE{zip}{Country}[{options}]>.
  
  The following common options are used:
  
  =head2 C<{-prefix=[yes|no|allow]}> and C<{-country=PAT}>.
  
  Postal codes can be prefixed with a country abbreviation. That is,
  a dutch postal code of B<1234 AB> can also be written as B<NL-1234 AB>.
  By default, all the patterns will allow the prefixes. But this can be
  changed with the C<-prefix> option. With C<-prefix=yes>, the returned
  pattern requires a country prefix, while C<-prefix=no> disallows a
  prefix. Any argument that doesn't start with a C<y> or a C<n> allows a
  country prefix, but doesn't require them.
  
  The prefixes used are, unfortunally, not always the same. Officially,
  ISO country codes need to be used, but the usage of I<CEPT> codes (the
  same ones as used on cars) is common too. By default, each postal code
  will recognize a country prefix that's either the ISO standard or the
  CEPT code. That is, German postal codes may prefixed with either C<DE>
  or C<D>. The recognized prefix can be changed with the C<-country>
  option, which takes a (sub)pattern as argument. The arguments C<iso>
  and C<cept> are special, and indicate the language prefix should be the
  ISO country code, or the CEPT code.
  
  Examples:
   /$RE{zip}{Netherlands}/;
             # Matches '1234 AB' and 'NL-1234 AB'.
   /$RE{zip}{Netherlands}{-prefix => 'no'}/;
             # Matches '1234 AB' but not 'NL-1234 AB'.
   /$RE{zip}{Netherlands}{-prefix => 'yes'}/;
             # Matches 'NL-1234 AB' but not '1234 AB'.
  
   /$RE{zip}{Germany}/;
             # Matches 'DE-12345' and 'D-12345'.
   /$RE{zip}{Germany}{-country => 'iso'}/; 
             # Matches 'DE-12345' but not 'D-12345'.
   /$RE{zip}{Germany}{-country => 'cept'}/;
             # Matches 'D-12345' but not 'DE-12345'.
   /$RE{zip}{Germany}{-country => 'GER'}/;
             # Matches 'GER-12345'.
  
  =head2 C<{-sep=PAT}>
  
  Some countries have postal codes that consist of two parts. Typically
  there is an official way of separating those parts; but in practise
  people tend to use different separators. For instance, if the official
  way to separate parts is to use a space, it happens that the space is
  left off. The C<-sep> option can be given a pattern as argument which
  indicates what to use as a separator between the parts.
  
  Examples:
   /$RE{zip}{Netherlands}/;
             # Matches '1234 AB' but not '1234AB'.
   /$RE{zip}{Netherlands}{-sep => '\s*'}/;
             # Matches '1234 AB' and '1234AB'.
  
  =head2 C<$RE{zip}{Australia}>
  
  Returns a pattern that recognizes Australian postal codes. Australian
  postal codes consist of four digits; the first two digits, which range
  from '10' to '97', indicate the state. Territories use '02' or '08'
  as starting digits; the leading zero is optional. '0909' is the only 
  postal code starting with '09' (the leading zero is optional here as
  well) - this is the postal code for the Nothern Territory University).
  The (optional) country
  prefixes are I<AU> (ISO country code) and I<AUS> (CEPT code).
  Regexp::Common 2.107 and before used C<$RE{zip}{Australia}>. This is
  still supported.
  
  If C<{-keep}> is used, the following variables will be set:
  
  =over 4
  
  =item $1
  
  The entire postal code.
  
  =item $2
  
  The country code prefix.
  
  =item $3
  
  The postal code without the country prefix.
  
  =item $4
  
  The state or territory.
  
  =item $5
  
  The last two digits.
  
  =back
  
  =head2 C<$RE{zip}{Belgium}>
  
  Returns a pattern than recognizes Belgian postal codes. Belgian postal
  codes consist of 4 digits, of which the first indicates the province.
  The (optional) country prefixes are I<BE> (ISO country code) and
  I<B> (CEPT code).
  
  If C<{-keep}> is used, the following variables will be set:
  
  =over 4
  
  =item $1
  
  The entire postal code.
  
  =item $2
  
  The country code prefix.
  
  =item $3
  
  The postal code without the country prefix.
  
  =item $4
  
  The digit indicating the province.
  
  =item $5
  
  The last three digits of the postal code.
  
  =back
  
  
  =head2 C<$RE{zip}{Denmark}>
  
  Returns a pattern that recognizes Danish postal codes. Danish postal
  codes consist of four numbers; the first digit (which cannot be 0),
  indicates the distribution region, the second the distribution
  district. The (optional) country prefix is I<DK>, which is both
  the ISO country code and the CEPT code.
  
  If C<{-keep}> is used, the following variables will be set:
  
  =over 4
  
  =item $1
  
  The entire postal code.
  
  =item $2
  
  The country code prefix.
  
  =item $3
  
  The postal code without the country prefix.
  
  =item $4
  
  The digit indicating the distribution region.
  
  =item $5
  
  The digit indicating the distribution district.
  
  =item $6
  
  The last two digits of the postal code.
  
  =back
  
  
  =head2 C<$RE{zip}{France}>
  
  Returns a pattern that recognizes French postal codes. French postal
  codes consist of five numbers; the first two numbers, which range
  from '01' to '98', indicate the department. The (optional) country
  prefixes are I<FR> (ISO country code) and I<F> (CEPT code).
  Regexp::Common 2.107 and before used C<$RE{zip}{French}>. This is
  still supported.
  
  If C<{-keep}> is used, the following variables will be set:
  
  =over 4
  
  =item $1
  
  The entire postal code.
  
  =item $2
  
  The country code prefix.
  
  =item $3
  
  The postal code without the country prefix.
  
  =item $4
  
  The department.
  
  =item $5
  
  The last three digits.
  
  =back
  
  =head2 C<$RE{zip}{Germany}>
  
  Returns a pattern that recognizes German postal codes. German postal
  codes consist of five numbers; the first number indicating the
  distribution zone, the second the distribution region, while the 
  latter three indicate the distribution district and the postal town.
  The (optional) country prefixes are I<DE> (ISO country code) and
  I<D> (CEPT code).
  Regexp::Common 2.107 and before used C<$RE{zip}{German}>. This is
  still supported.
  
  If C<{-keep}> is used, the following variables will be set:
  
  =over 4
  
  =item $1
  
  The entire postal code.
  
  =item $2
  
  The country code prefix.
  
  =item $3
  
  The postal code without the country prefix.
  
  =item $4
  
  The distribution zone.
  
  =item $5
  
  The distribution region.
  
  =item $6
  
  The distribution district and postal town.
  
  =back
  
  
  =head2 C<$RE{zip}{Greenland}>
  
  Returns a pattern that recognizes postal codes from Greenland.
  Greenland, being part of Denmark, uses Danish postal codes.
  All postal codes of Greenland start with 39.
  The (optional) country prefix is I<DK>, which is both
  the ISO country code and the CEPT code.
  
  If C<{-keep}> is used, the following variables will be set:
  
  =over 4
  
  =item $1
  
  The entire postal code.
  
  =item $2
  
  The country code prefix.
  
  =item $3
  
  The postal code without the country prefix.
  
  =item $4
  
  39, being the distribution region and distribution district for Greenland.
  
  =item $5
  
  The last two digits of the postal code.
  
  =back
  
  =head2 C<$RE{zip}{Italy}>
  
  Returns a pattern recognizing Italian postal codes. Italian postal
  codes consist of 5 digits. The first digit indicates the region, the
  second the province. The third digit is odd for province capitals,
  and even for the province itself. The fourth digit indicates the
  route, and the fifth a place on the route (0 for small places, 
  alphabetically for the rest).
  
  The country prefix is either I<IT> (the ISO country code), or
  I<I> (the CEPT code).
  
  If C<{-keep}> is used, the following variables will be set:
  
  =over 4
  
  =item $1
  
  The entire postal code.
  
  =item $2
  
  The country code prefix.
  
  =item $3
  
  The postal code without the country prefix.
  
  =item $4
  
  The region.
  
  =item $5
  
  The province.
  
  =item $6 
  
  Capital or province.
  
  =item $7
  
  The route.
  
  =item $8
  
  The place on the route.
  
  =back
  
  =head2 C<$RE{zip}{Netherlands}>
  
  Returns a pattern that recognizes Dutch postal codes. Dutch postal
  codes consist of 4 digits and 2 letters, separated by a space.
  The separator can be changed using the C<{-sep}> option, as discussed
  above. The (optional) country prefix is I<NL>, which is both the 
  ISO country code and the CEPT code. Regexp::Common 2.107 and earlier
  used C<$RE{zip}{Dutch}>. This is still supported.
  
  If C<{-keep}> is used, the following variables will be set:
  
  =over 4
  
  =item $1
  
  The entire postal code.
  
  =item $2
  
  The country code prefix.
  
  =item $3
  
  The postal code without the country prefix.
  
  =item $4
  
  The digits part of the postal code.
  
  =item $5
  
  The separator between the digits and the letters.
  
  =item $6 
  
  The letters part of the postal code.
  
  =back
  
  =head2 C<< $RE{zip}{Norway} >>
  
  Returns a pattern that recognizes Norwegian postal codes. Norwegian
  postal codes consist of four digits.
  
  The country prefix is either I<NO> (the ISO country code), or
  I<N> (the CEPT code).
  
  If C<{-keep}> is used, the following variables will be set:
  
  =over 4
  
  =item $1
  
  The entire postal code.
  
  =item $2
  
  The country code prefix.
  
  =item $3
  
  The postal code without the country prefix.
  
  =back
  
  =head2 C<< $RE{zip}{Spain} >>
  
  Returns a pattern that recognizes Spanish postal codes. Spanish postal
  codes consist of 5 digits. The first 2 indicate one of Spains fifties
  provinces (in alphabetical order), starting with C<00>. The third digit
  indicates a main city or the main delivery rounds. The last two digits
  are the delivery area, secondary delivery route or a link to rural areas.
  
  The country prefix is either I<ES> (the ISO country code), or
  I<E> (the CEPT code).
  
  If C<{-keep}> is used, the following variables will be set:
  
  =over 4
  
  =item $1
  
  The entire postal code.
  
  =item $2
  
  The country code prefix.
  
  =item $3
  
  The postal code without the country prefix.
  
  =item $4
  
  The two digits indicating the province.
  
  =item $5
  
  The digit indicating the main city or main delivery route.
  
  =item $6
  
  The digits indicating the delivery area, secondary delivery route
  or a link to rural areas.
  
  =back
  
  =head2 C<< $RE{zip}{Switzerland} >>
  
  Returns a pattern that recognizes Swiss postal codes. Swiss postal
  codes consist of 4 digits. The first indicates the district, starting
  with 1. The second indicates the area, the third, the route, and the
  fourth the post office number.
  
  =head2 C<< $RE{zip}{US}{-extended => [yes|no|allow]} >>
  
  Returns a pattern that recognizes US zip codes. US zip codes consist
  of 5 digits, with an optional 4 digit extension. By default, extensions
  are allowed, but not required. This can be influenced by the 
  C<-extended> option. If its argument starts with a C<y>,
  extensions are required; if the argument starts with a C<n>,
  extensions will not be recognized. If an extension is used, a dash
  is used to separate the main part from the extension, but this can
  be changed with the C<-sep> option.
  
  The country prefix is either I<US> (the ISO country code), or
  I<USA> (the CEPT code).
  
  If C<{-keep}> is being used, the following variables will be set:
  
  =over 4
  
  =item $1
  
  The entire postal code.
  
  =item $2
  
  The country code prefix.
  
  =item $3
  
  The postal code without the country prefix.
  
  =item $4
  
  The first 5 digits of the postal code.
  
  =item $5
  
  The first three digits of the postal code, indicating a sectional
  center or a large city. New in Regexp::Common 2.119.
  
  =item $6
  
  The last 2 digits of the 5 digit part of the postal code, indicating
  a post office facility or delivery area. New in Regexp::Common 2.119.
  
  =item $7
  
  The separator between the 5 digit part and the 4 digit part. Up to 
  Regexp::Common 2.118, this used to be $5.
  
  =item $8
  
  The 4 digit part of the postal code (if any). Up to Regexp::Common 2.118,
  this used to be $6.
  
  =item $9
  
  The first two digits of the 4 digit part of the postal code, indicating
  a sector, or several blocks. New in Regexp::Common 2.119.
  
  =item $10
  
  The last two digits of the 4 digit part of the postal code, indicating
  a segment or one side of a street. New in Regexp::Common 2.119.
  
  =back
  
  You need at least version 5.005_03 to be able to use US postal codes.
  Older versions contain a bug that let the pattern match invalid US
  postal codes.
  
  =head3 Questions
  
  =over 4
  
  =item
  
  Can the 5 digit part of the zip code (in theory) start with 000?
  
  =item
  
  Can the 5 digit part of the zip code (in theory) end with 00?
  
  =item
  
  Can the 4 digit part of the zip code (in theory) start with 00?
  
  =item
  
  Can the 4 digit part of the zip code (in theory) end with 00?
  
  =back
  
  =head1 SEE ALSO
  
  L<Regexp::Common> for a general description of how to use this interface.
  
  =over 4
  
  =item L<http://www.columbia.edu/kermit/postal.html>
  
  Frank's compulsive guide to postal addresses.
  
  =item L<http://www.upu.int/post_code/en/addressing_formats_guide.shtml>
  
  Postal addressing systems.
  
  =item L<http://www.uni-koeln.de/~arcd2/33e.htm>
  
  Postal code information.
  
  =item L<http://www.grcdi.nl/linkspc.htm>
  
  Links to Postcode Pages.
  
  =item L<http://www1.auspost.com.au/postcodes/>
  
  Information about Australian postal codes.
  
  =item L<http://hdusps.esecurecare.net/cgi-bin/hdusps.cfg/php/enduser/std_adp.php?p_faqid=1014>
  
  Information about US postal codes.
  
  =item L<http://en.wikipedia.org/wiki/Postal_code>
  
  =back
  
  =head1 AUTHORS
  
  Damian Conway S<(I<damian@conway.org>)> and
  Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Zip codes for most countries are missing.
  Send them in to I<regexp-common@abigail.be>.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
PERL5_REGEXP_COMMON_ZIP

$fatpacked{"perl5/SpamReport/ANSIColor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_SPAMREPORT_ANSICOLOR';
  package SpamReport::ANSIColor;
  use common::sense;
  use Exporter;
  
  use vars qw($VERSION @ISA @EXPORT);
  $VERSION = '2016022601';
  @ISA = 'Exporter';
  @EXPORT = qw($RED $GREEN $YELLOW $MAGENTA $CYAN $NULL);
  
  our ($RED, $GREEN, $YELLOW, $MAGENTA, $CYAN, $NULL) =
      map { "\e[${_}m" } (31, 32, 33, "35;1", 36, 0);
  
  sub suppress {
      $RED = $GREEN = $YELLOW = $MAGENTA = $CYAN = $NULL = ''
  }
  
  1;
PERL5_SPAMREPORT_ANSICOLOR

$fatpacked{"perl5/SpamReport/Annotate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_SPAMREPORT_ANNOTATE';
  package SpamReport::Annotate;
  use common::sense;
  use SpamReport::Data;
  
  use vars qw/$VERSION %embargo/;
  $VERSION = '2016022601';
  
  use SpamReport::ANSIColor;
  
  sub script {
      my ($script) = @_;
      return $script if -d $script;
      if (-f $script && ((stat($script))[2])&0777) {
          $YELLOW . $script . $NULL
      }
      elsif (-f $script) {
          "$RED$script (DISABLED)$NULL"
      }
      else {
          "$RED$script (GONE)$NULL"
      }
  }
  
  sub owner {
      my ($user, $ownerkey, $resoldkey) = @_;
      my $u = $user;
      my %resolds = map { ($_, $data->{$resoldkey}{$_}) } @{$data->{'owner2user'}{$u}};
      for (grep { defined $_ && $resolds{$_} } (sort { $resolds{$b} <=> $resolds{$a} } keys %resolds)[0..2]) {
          $user .= sprintf(" $CYAN%s$NULL:%.1f%%", $_, 100*$resolds{$_}/$data->{$ownerkey}{$u})
      }
      $user
  }
  
  sub user {
      my ($user) = @_;
      my $u = $user;
      for (SpamReport::Tracking::Suspensions::ticket($u)) {
          $user = "$RED$user $_$NULL"
      }
      if (exists $data->{'in_history'}{$u}) {
          my $delta = (time() - $data->{'in_history'}{$u}) / (24 * 3600);
          if ($delta > 1) {
              $user = sprintf "$MAGENTA%s $MAGENTA(seen: %.1f days)$NULL", $user, $delta
          } else {
              $user = sprintf "$MAGENTA%s $MAGENTA(seen: %.1f hours)$NULL", $user,
                  (time() - $data->{'in_history'}{$u}) / 3600
          }
      }
      if (exists $data->{'young_users'}{$u}) {
          $user = "$YELLOW$user $YELLOW(user age)$NULL";
      }
      if (exists $data->{'indicators'}{$u}) {
          $user = "$user $CYAN@{[join ' ', sort keys %{$data->{'indicators'}{$u}}]}$NULL";
      }
      my $todays_mails;
      my %todays_hours; for my $time (time()) {
          for (map { $time-3600*$_ } 0..23) {
              $todays_hours{POSIX::strftime("%F %H", localtime($_))}++
          }
      }
      for (grep { exists $todays_hours{$_} } keys %{$data->{'hourly_volume'}{$u}}) {
          $todays_mails += $data->{'hourly_volume'}{$u}{$_}
      }
      # assumes default 3-4 day window
      if ($data->{'responsibility'}{$u}) {
          my $recency = $todays_mails / $data->{'responsibility'}{$u};
          if ($recency < 0.1) {
              $user = sprintf("$RED%s $RED(stale: %.1f%%)$NULL", $user, $recency*100)
          }
          elsif ($recency > 0.8) {
              $user = sprintf("$YELLOW%s $YELLOW(recent: %.1f%% = @{[SpamReport::Output::commify($todays_mails)]})$NULL", $user, $recency*100)
          }
      }
      #if (exists $data->{'special_indicators'}{$u}{'hi_malware'}) {
      #    my @urls = sample_urls($u);
      #    if (@urls) {
      #        $user .= join '', map { "\n\t$_"} @urls
      #    }
      #}
      $user
  }
  
  %embargo = qw(
      IR IRAN
      KP NKOREA
      SD SUDAN
      SY SYRIA
  );
  sub country {
      my ($code) = @_;
      if (exists $embargo{$code}) {
          "$RED$embargo{$code}$NULL"
      }
      else {
          "$CYAN$code$NULL"
      }
  }
  
  sub sample_urls {
      my ($user) = @_;
      my %urls;
      for (keys %{$data->{'mail_ids'}}) {
          next unless exists $_->{'mail_ids'}{'in_queue'};
          open my $f, '-|', "exim -Mvb $_" or next;
          my $b = 0;
          for (<$f>) {
              $urls{$1}++ if m,(http://[\x21-\x7f]+),;
              $b += length($_); last if $b > 1024;
          }
          close $f;
      }
      (grep { defined $_ } List::Util::shuffle(keys %urls))[0..3];
  }
  
  1;
  } # end module SpamReport::Annotate
PERL5_SPAMREPORT_ANNOTATE

$fatpacked{"perl5/SpamReport/Cpanel.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_SPAMREPORT_CPANEL';
  package SpamReport::Cpanel;
  
  use strict;
  use warnings;
  
  use vars qw/$VERSION/;
  $VERSION = '2016022601';
  
  use Time::Local;
  use Regexp::Common qw( SpamReport );
  use File::Nonblock;
  use SpamReport::Data;
  
  sub young_users {
      my $time = time();
      for my $user (keys %{$data->{'user2domain'}}) {
          next if $user eq 'nobody';
          open my $f, '<', "/var/cpanel/users/$user"
              or do { warn "Unable to open /var/cpanel/users/$user : $!"; next };
          while ($_ = <$f>) {
              if (/^STARTDATE=(\d+)/ && ($time - $1) < (14 * 3600*24)) {
                  $data->{'young_users'}{$user}++;
                  last
              }
          }
          close $f;
      }
  }
  
  sub map_userdomains {
      my ($userdomains_path) = @_;
  
      my %user2domain = ();
      my %domain2user = ();
  
      open my $fh, '<', $userdomains_path or die "Unable to open $userdomains_path : $!";
      %domain2user = map {
          chomp;
          my ($domain, $user) = split ': ';
          push @{ $user2domain{$user} }, $domain;
          $domain => $user;
      } grep { !m/^(?:#|$)/ } <$fh>;
      close $fh;
  
      return (\%user2domain, \%domain2user);
  }
  
  sub map_userowners {
      my ($trueuserowners_path) = @_;
  
      my %user2owner = ();
      my %owner2user = ();
  
      open my $fh, '<', $trueuserowners_path or die "Unable to open $trueuserowners_path : $!";
      %user2owner = map {
          chomp;
          my ($user, $owner) = split ': ';
          push @{ $owner2user{$owner} }, $user;
          $user => $owner;
      } grep { !m/^(?:#|$)/ } <$fh>;
      close $fh;
  
      return (\%user2owner, \%owner2user);
  }
  
  sub map_valiases {
      my ($valiases_path) = @_;
  
      my %alias2dest = ();
      my %dest2alias = ();
  
      my %temp;
  
      opendir my $vd, $valiases_path or die "Unable to open $valiases_path : $!";
      for my $valias_file ( map { $valiases_path . '/' . $_ } readdir($vd) ) {
          if ( -s $valias_file > 28 ) {
  
              open my $fh, '<', $valias_file;
              %temp = map {
                  chomp;
                  my @line = split ': ';
                  # infiniti had some malformed .bak'd files
                  if (defined $line[1]) {
                      my @destinations = grep { m/^[^|:|"]/ } split /,\s*/, $line[1];
                      $line[0] => \@destinations;
                  } else { () }
              } grep { !m/^(\#|\*|\s*$)/ } <$fh>;
              close $fh;
  
          }
  
          @alias2dest{keys %temp} = values %temp;
          undef %temp;
      }
      closedir $vd;
  
      for my $alias (keys %alias2dest) {
          for my $dest ( @{ $alias2dest{$alias} } ) {
              push @{ $dest2alias{$dest} }, $alias;
          }
      }
  
      return (\%alias2dest, \%dest2alias);
  }
  
  # yes this is necessary :p  http://hgfix.net/paste/view/0766d18b
  our ($safety, $alias_domain, %bad_valiases);
  sub find_offserver {
      my (@aliases) = @_;
      local ($safety) = ($safety + 1);
      my @results;
      if ($safety > 10) {
          warn "[NOTICE] circular definitions found in /etc/valiases/$alias_domain\n"
              unless $bad_valiases{$alias_domain}++;
          return ()
      }
      for (@aliases) {
          if (exists $data->{'alias2dest'}{$_}) {
              push @results, find_offserver(@{$data->{'alias2dest'}{$_}});
          }
          elsif (/[\@+]([^\@+]+)$/ && !exists($data->{'domain2user'}{$1})) {
              push @results, $_
          }
      }
      return @results
  }
  sub offserver_forwarders {
      for my $alias (keys %{$data->{'alias2dest'}}) {
          $alias_domain = '(UNKNOWN)';  $alias_domain = $1 if $alias =~ /[\@+]([^\@+]+)$/;
          next if defined($data->{'OPTS'}{'user'}) &&
              $data->{'domain2user'}{$alias_domain} ne $data->{'OPTS'}{'user'};
          $safety = 0;
          for (find_offserver(@{$data->{'alias2dest'}{$alias}})) {
              $data->{'offserver_forwarders'}{$alias}{$_}++;
          }
      }
  }
  
  my $cpaddpop = qr/$RE{'cpanel'}{'addpop'}/;
  my $aptimest = qr/$RE{'apache'}{'timestamp'}/;
  sub find_email_creation {
      my ($lines, $end_time, @search_list) = @_;
      for my $line ( @{ $lines } ) {
              
          if ( $line =~ $cpaddpop ) {
  
              my %vars = map { split /=/ } split /&/, $4;
              my $login = $vars{'email'} . '@' . $vars{'domain'};
  
              next if ( scalar @search_list and not grep { $_ eq $login } @search_list );
  
              my $ipaddr = $1;
              my $username = $2;
              my $timestamp = 0;
  
              if ( $3 =~ $aptimest ) {
                  $timestamp = timegm($6, $5, $4, $2, $1 - 1, $3 - 1900) - ($7 * 36);
              }
  
              last if ( $timestamp > $end_time );
  
              $data->{'logins'}{$login}{'created_from'} = $ipaddr;
              $data->{'logins'}{$login}{'created_by'} = $username;
              $data->{'logins'}{$login}{'created_on'} = $timestamp;
          }
  
      }
  
      1;
  }
  
  sub next {
      my ($file_handle, $OPTS, $progress_func) = @_;
  
      my $last_timestamp = '';
      my $file_pos = File::Nonblock::tell($file_handle);
      my $fast_forward = 0;
      my $num_lines ||= $OPTS->{'read_lines'} || 100;
  
      while ( not File::Nonblock::eof($file_handle) ) {
  
          my $lines;
          my $log_timestamp;
  
          if ( $file_pos == 0 ) {
              $lines = File::Nonblock::read_lines($file_handle, 1);
              $num_lines--;
          }
          else {
              $lines = File::Nonblock::read_lines($file_handle, $num_lines);
          }
  
          for ( my $n = 0; $n < scalar @{ $lines }; $n++ ) {
  
              if ( $lines->[$n] =~ $cpaddpop ) {
  
                  if ( $3 ne $last_timestamp and $3 =~ $cpaddpop ) {
                      $log_timestamp = timegm($6, $5, $4, $2, $1 - 1, $3 - 1900) - ($7 * 36);
  
                      next if ( $log_timestamp < $OPTS->{'start_time'} );
                      return [ splice @{ $lines }, 0, $n ] if ( $log_timestamp > $OPTS->{'end_time'} );
                      return [ splice @{ $lines }, $n, scalar @{ $lines } - $n ];
                  }
              }
          }
      }
  }
  
  1; # end module SpamReport::Cpanel
PERL5_SPAMREPORT_CPANEL

$fatpacked{"perl5/SpamReport/Data.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_SPAMREPORT_DATA';
  package SpamReport::Data;
  use common::sense;
  use Exporter;
  use Storable qw(lock_store lock_retrieve retrieve);
  use POSIX qw(strftime);
  
  use vars qw($VERSION $data @ISA @EXPORT $MAX_RETAINED $loadcronfail);
  use vars qw($logpath $cronpath);
  $VERSION = '2016022601';
  @ISA = 'Exporter';
  @EXPORT = qw($data);
  $data = {};
  $MAX_RETAINED = 4;
  $loadcronfail = '';
  
  $logpath = "/opt/hgmods/logs/spamreport.dat";
  $cronpath = "/opt/hgmods/logs/spamreportcron.dat";
  
  sub loadcron {
      my ($path) = @_;
      if (defined $path && -e $path) {
          print "Loading $path\n";
          return retrievecron($path)
      }
      elsif (defined $path || ! -e $cronpath) {
          $loadcronfail = "no such file: @{[defined $path ? $path : $cronpath]}";
          return
      }
      else { $path = $cronpath }
      my ($fresh, $date) = _times($path);
      if ($fresh) {
          print "Loading $path ($date)\n";
          return retrievecron($path)
      }
      else {
          rotatecron();
          $loadcronfail = "file is too old: $path ($date)";
      }
      return;
  }
  
  sub _times {
      my ($path) = @_;
      my @time = localtime((stat($path))[9]);
      my $day = POSIX::strftime("%F", @time);
      my $date = POSIX::strftime("%F %T", @time);
      my $fresh = POSIX::strftime("%F", localtime()) eq $day;
      return ($fresh, $date);
  }
  
  my %cronkeys = map { ($_, 1) }
      qw( dest_domains ip_addresses logins mail_ids recipient_domains scriptdirs senders scripts
          responsibility domain_responsibility bounce_responsibility owner_responsibility
          bounce_owner_responsibility mailbox_responsibility forwarder_responsibility
          young_users young_mailboxes outip outscript hourly_volume total_outgoing total_bounce
          OPTS
      );
  sub savecron {
      my %newdata;
      for (keys %cronkeys) {
          $newdata{$_} = $data->{$_}
      }
      lock_store \%newdata, $cronpath;
      #DumpFile($cronpath, \%newdata);
  }
  
  sub exitsavecron {
      for (keys %$data) {
          delete $data->{$_} unless exists $cronkeys{$_}
      }
      #DumpFile($cronpath, $data);
      rotatecron() if -e $cronpath;
      lock_store $data, $cronpath;
      exit
  }
  
  sub retrievecron {
      my ($path) = @_;
      $data = lock_retrieve($path);
      #$data = LoadFile($path)
  }
  
  sub load {
      my ($path) = @_;
      $path = $logpath unless defined $path;
      my ($fresh, $date) = _times($path);
      print "Loading $path ($date)\n";
      #$data = LoadFile($path);
      $data = lock_retrieve($path);
  }
  
  sub save {
      rotate();
      #DumpFile($logpath, $data);
      lock_store $data, $logpath;
  }
  
  sub rotate {
      my ($path) = @_;
      $path = $logpath unless defined $path;
      my @logs = sort { -M $a <=> -M $b } glob "$path*";
      unlink for @logs[$MAX_RETAINED..$#logs];
      for (sort { -M $b <=> -M $a } @logs) {
          next unless /.(\d+)$/;
          my ($this, $next) = ($1, $1 + 1);
          rename "$path.$this", "$path.$next";
      }
      rename $path, "$path.1";
  }
  
  sub rotatecron { rotate($cronpath) }
  
  sub disable {
      *{"SpamReport::Data::load"}
      = *{"SpamReport::Data::save"}
      = *{"SpamReport::Data::retrievecron"}
      = *{"SpamReport::Data::savecron"} = sub { };
      *{"SpamReport::Data::exitsavecron"} = sub { exit };
  }
  
  sub details {
      my ($file) = @_;
      $file =~ m,/([^/]+)$,;
      my %detail = (name => (defined($1) ? $1 : $file));
      my $cache;  eval { $cache = retrieve($file) };
      if ($@) {
          $detail{'status'} = "broken $@";
          return \%detail
      }
      $detail{'type'} = (($file =~ /spamreportcron\.dat/) ? 'cron' : 'cache');
      $detail{'status'} = 'ok';
      $detail{'size'} = -s $file;
      $detail{'emails'} = scalar(keys(%{$cache->{'mail_ids'}}));
      $detail{'outgoing'} = $cache->{'total_outgoing'};
      $detail{'bounces'} = $cache->{'total_bounce'};
      $detail{'OPTS'} = $cache->{'OPTS'};
      return \%detail
  }
  
  # --ls displays files like '.3' '.test' '.1(cron)'.  load these (without (cron)).
  sub resolve {
      my ($name) = @_;
      $logpath .= $name;
      die "Unresolved cache name: $name" unless -f $logpath;
  }
  sub resolvecron {
      my ($name) = @_;
      $cronpath .= $name;
      die "Unresolved croncache name: $name" unless -f $cronpath;
  }
  
  1;
PERL5_SPAMREPORT_DATA

$fatpacked{"perl5/SpamReport/Exim.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_SPAMREPORT_EXIM';
  package SpamReport::Exim;
  use common::sense;
  use SpamReport::Data;
  
  use vars qw/$VERSION/;
  $VERSION = '2016022601';
  
  use Time::Local;
  use Regexp::Common qw( Exim );
  
  my @indicators = ( '<=', '=>', '->', '>>', '*>', 'SMTP connection outbound', '**', '==', 'Completed' );
  my @statuses = qw( input output continued cutthrough inhibited connect deferred bounced complete );
  my @labels = qw( ident received_protocol auth_id auth_sender
                       helo_name host_address host_auth interface_address frozen);
  my @flags  = qw( deliver_firsttime host_lookup_failed local localerror );
  
  # https://github.com/mailcheck/mailcheck/wiki/List-of-Popular-Domains
  my ($dubious_domains) = map { qr/^(?:$_)$/i } join "|", map { quotemeta $_ } (
      qw( aol.com att.net comcast.net facebook.com gmail.com gmx.com googlemail.com
          google.com hotmail.com hotmail.co.uk mac.com me.com mail.com msn.com
          live.com sbcglobal.net verizon.net yahoo.com yahoo.co.uk ),
  
      # Other global domains
      qw( email.com games.com gmx.net hush.com hushmail.com icloud.com inbox.com
          lavabit.com love.com outlook.com pobox.com rocketmail.com
          safe-mail.net wow.com ygm.com ymail.com zoho.com fastmail.fm ),
  
      # United States ISP domains
      qw( bellsouth.net charter.net comcast.net cox.net earthlink.net juno.com ),
  
      # British ISP domains
      qw( btinternet.com virginmedia.com blueyonder.co.uk freeserve.co.uk live.co.uk
          ntlworld.com o2.co.uk orange.net sky.com talktalk.co.uk tiscali.co.uk
          virgin.net wanadoo.co.uk bt.com ),
  
      # Domains used in Asia
      qw( sina.com qq.com naver.com hanmail.net daum.net nate.com yahoo.co.jp
          yahoo.co.kr yahoo.co.id yahoo.co.in yahoo.com.sg yahoo.com.ph ),
  
      # French ISP domains
      qw( hotmail.fr live.fr laposte.net yahoo.fr wanadoo.fr orange.fr gmx.fr
          sfr.fr neuf.fr free.fr ),
  
      # German ISP domains
      qw( gmx.de hotmail.de live.de online.de t-online.de web.de yahoo.de ),
  
      # Russian ISP domains
      qw( mail.ru rambler.ru yandex.ru ya.ru list.ru ),
  
      # Belgian ISP domains
      qw( hotmail.be live.be skynet.be voo.be tvcablenet.be telenet.be ),
  
      # Argentinian ISP domains
      qw( hotmail.com.ar live.com.ar yahoo.com.ar fibertel.com.ar speedy.com.ar
          arnet.com.ar ),
  
      # Domains used in Mexico
      qw( hotmail.com gmail.com yahoo.com.mx live.com.mx yahoo.com hotmail.es
          live.com hotmail.com.mx prodigy.net.mx msn.com ),
  );
      
  
  # glob() performs unnecessary lstats for each file in the queue
  # -f and -M and -M for glob() -> up to four stat syscalls per file.
  # this subroutine performs no stats at all.
  # the time range checks are dropped: if it's in the queue, it's of interest
  sub email_header_files {
      my $queue_dir = '/var/spool/exim/input';
      my @headers;
      opendir my $d1, $queue_dir or die "Unable to open $queue_dir : $!";
      QUEUES: for my $subdir (readdir($d1)) {
          next if $subdir =~ /^\./;
          opendir my $d2, "$queue_dir/$subdir" or next;
          for (readdir($d2)) {
              if (/-H$/) {
                  push @headers, "$queue_dir/$subdir/$_";
              }
          }
          closedir $d2;
      }
      closedir $d1;
      @headers
  }
  
  sub parse_queued_mail_data {
      my ($start_time, $end_time) = @_;
  
      my @new_mail = email_header_files();
      for my $i (0..$#new_mail) {
          my $line_no = 0;
          my $tree_start = 0;
          my $eod = 0;
          my $num_recipients = 0;
          my @recipients;
          my ($mail_id) = $new_mail[$i] =~ m{/([^/]+)-H};
          my $new_email;
  
          # this rigamorale avoids: readline() on closed filehandle $fh at spamreport...
          my @lines;
          eval {
                  open my $fh, '<', $new_mail[$i];
                  @lines = <$fh>;
                  close $fh;
          }; next if $@;
  
          unless (exists $data->{'mail_ids'}{$mail_id}) {
              $new_email = 1;
          }
          %{$data->{'mail_ids'}{$mail_id}} = map {
              chomp;
              $line_no++;
      
              if ( m/^-(ident|received_protocol|auth_id|auth_sender|helo_name|host_address|host_auth|interface_address|frozen)\s+(.*)$/ ) {
                  my $key = $1;
                  my $val = lc($2);
                  $val =~ s/((?:\d{1,3}\.){3}\d{1,3})\.\d+/$1/ if ($key eq 'host_address');
                  ($key => $val);
              }
              elsif ( m/^-(deliver_firsttime|host_lookup_failed|local|localerror)/ ) {
                  ($1 => 1);
              }
              elsif ( $line_no == 3 ) {
                  my $sender = $_;
                  $sender =~ s/<|>//g;
                  ( 'sender' => lc($sender) || 'mailer-daemon' );
              }
              elsif ( m/^(?:[YN]{2}\s+|XX$)/ ) {
                  $tree_start = $line_no;
                  ();
              }
              elsif ( m/^(\d+)$/ and $tree_start ) {
                  $eod = $line_no;
                  $num_recipients = $1;
                  ('num_recipients' => $num_recipients);
              }
              elsif ( $eod and /^\d+\s+X-PHP-Script: (\S+) for (\S+)/ ) {
                  ('script' => $1, 'script_ip' => $2);
              }
              elsif ( $eod and /^\d+\s+X-Boxtrapper:/ ) {
                  ('boxtrapper' => 1);
              }
              elsif ( /^\d+\s+Subject: (.*)/ ) {
                  ('subject' => $1);
              }
              elsif ( $eod and ( $line_no - $eod <= $num_recipients) ) {
                  push @recipients, lc($_);
                  ();
              }
              elsif ( $eod and ( $line_no - $eod > $num_recipients) ) {
                  ('recipients' => \@recipients);
              }
              else {
                  ();
              }
              
          } @lines;
  
          if (exists $data->{'mail_ids'}{$mail_id}{'boxtrapper'}) {
              # we don't care about boxtrapper emails
              $data->{'boxtrapper_queue'}++;
              delete $data->{'mail_ids'}{$mail_id};
              next;
          }
  
          my $h_ref = $data->{'mail_ids'}{$mail_id};
          my ($type, $source) = $h_ref->{'sender'} eq 'mailer-daemon'   ? ('bounce', $h_ref->{'helo_name'})
                              : exists $h_ref->{'local'}                ? ('local', $h_ref->{'ident'})
                              : $h_ref->{'host_auth'} =~ m/^dovecot_.*/ ? ('login', $h_ref->{'auth_id'})
                                                                        : ('relay', $h_ref->{'helo_name'});
          $data->{'total_bounce'}++ if $type eq 'bounce';
  
          my $state = $h_ref->{'deliver_firsttime'} ? 'queued'
                    : $h_ref->{'frozen'}            ? 'frozen'
                                                    : 'thawed';
  
          $h_ref->{'type'} = $type;
          $h_ref->{'source'} = $source;
          $h_ref->{'state'} = $state;
          $h_ref->{'location'} = 'queue';
      
          ($h_ref->{'sender_domain'}) = $h_ref->{'sender'} =~ m/@(.*)$/;
  
          if ($h_ref->{'type'} ne 'bounce' && exists($data->{'domain2user'}{lc($h_ref->{'sender_domain'})})) {
              # not a bounce and for a local domain?  it may be an issue but we don't care here
              $data->{'local_queue'}++;
              delete $data->{'mail_ids'}{$mail_id};
              next;
          }
  
          for (@{$h_ref->{'recipients'}}) {
              if ( $_ =~ m/@(.*)$/ ) {
                  $h_ref->{'recipient_domains'}{$1}++;
                  if (exists $data->{'domain2user'}{$1}) {
                      $h_ref->{'recipient_users'}{$data->{'domain2user'}{$1}}++
                  }
              }
          }
      
          for (who($h_ref)) {
              $h_ref->{'who'} = $_;
              last if /@/ or !$new_email;
              $data->{'responsibility'}{$_}++;
              $data->{'owner_responsibility'}{$data->{'user2owner'}{$_}}++
                  if exists $data->{'user2owner'}{$_}
                  && $data->{'user2owner'}{$_} ne 'root'
          }
          $h_ref->{'in_queue'} = 1;
          $data->{'total_queue'}++;
      }
  }
  
  my $eximinfoscript = qr/$RE{'exim'}{'info'}{'script'}/;
  sub parse_exim_mainlog {
      my ($lines, $year, $end_time, $in_zone) = @_;
      my @lines = @$lines;
      my %days = %{$data->{'OPTS'}{'exim_days'}};
      if ($data->{'OPTS'}{'datelimit'} eq 'not today') {
          delete $days{$data->{'OPTS'}{'exim_today'}};
      }
      elsif ($data->{'OPTS'}{'datelimit'} eq 'only today') {
          %days = ($data->{'OPTS'}{'exim_today'} => 1);
      }
  
      unless ($in_zone->[0]) {
          if (exists $days{substr($lines[0],0,10)} or
              exists $days{substr($lines[$#lines],0,10)}) {
              $in_zone->[0] = 1
          }
          else {
              return
          }
      }
      for my $line ( @lines ) {
          unless (exists $days{substr($line,0,10)}) {
              $in_zone->[0] = 0;
              return
          }
  
          if ( substr($line,20,4) eq 'cwd=' && $line =~ $eximinfoscript ) {
              $data->{'scriptdirs'}{$1}++;
              next
          }
          my $mailid = substr($line,20,16);
          
          if (substr($line,37,24) eq 'SMTP connection outbound') {
              next unless $line =~ / I=(\S+) S=\S+ F=(.+)/;
              $data->{'outscript'}{$2}++;
              SpamReport::Tracking::Scripts::script($2, $1);
          }
          elsif (substr($line,37,5) eq '<= <>') {
              $line =~ s/T=".*?(?<!\\)" //;
              next unless $line =~ /.*for (.*)$/;  # leading .* causes it to backtrack from the right
              my @to = split / /, $1;
              $line =~ / S=(\S+)/; for my $script ($1) {
                  if (defined $script && $script !~ /@/ && $script =~ /\D/) {
                      $data->{'mail_ids'}{$mailid}{'script'} = $script;
                      $data->{'script'}{$script}++;
                  }
              }
              $data->{'mail_ids'}{$mailid}{'recipients'} = \@to;
              if (@to == 1 && $to[0] =~ /\@(\S+)/ and exists $data->{'domain2user'}{$1}) {
                  my $user = $data->{'domain2user'}{$1};
                  $data->{'domain_responsibility'}{$1}++;
                  $data->{'mailbox_responsibility'}{$to[0]}++;
                  $data->{'bounce_responsibility'}{$user}++;
                  $data->{'bounce_owner_responsibility'}{$data->{'user2owner'}{$user}}++
                          if exists $data->{'user2owner'}{$user}
  			&& $data->{'user2owner'}{$user} ne 'root';
                  $data->{'mail_ids'}{$mailid}{'recipient_users'}{$user}++;
                  $data->{'mail_ids'}{$mailid}{'who'} = $user;
              }
              $data->{'mail_ids'}{$mailid}{'type'} = 'bounce';
              $data->{'total_bounce'}++;
          }
          elsif (substr($line,37,2) eq '<=' && $line =~ s/T="(.*?)(?<!\\)" //) {
              my $subject = $1;
              $line =~ /<= (\S+)/;
              my $from = $1;
              $line =~ /.*for (.*)$/;  # .* causes it to backtrack from the right
              my $to = $1;
              my @to = split / /, $to;
              my @to_domain = grep { defined $_ } map { /@(.*)/ && $1 } @to;
              if ($to !~ tr/@//) {
                  # this is to a local users, only.  probably cronjob or like.
                  # discard.
                  delete $data->{'mail_ids'}{$mailid};
                  next;
              }
              $data->{'mail_ids'}{$mailid}{'recipients'} = \@to if @to;
              $data->{'mail_ids'}{$mailid}{'sender'} = $from;
              my $from_domain;
              if ($from =~ /\S+?[\@+](\S+)/) {
                  $from_domain = $1;
                  $data->{'mail_ids'}{$mailid}{'sender_domain'} = $from_domain;
              }
              $data->{'mail_ids'}{$mailid}{'subject'} = $subject;
              if ($line =~ / A=dovecot_\S+:(\S+(?:[\@+](\S+))?)/) {
                  $data->{'mail_ids'}{$mailid}{'auth_sender'} = $1;
                  $data->{'mail_ids'}{$mailid}{'auth_sender_domain'} = $2 if defined $2;
              }
              $data->{'mail_ids'}{$mailid}{'received_protocol'} = $1 if $line =~ / P=(\S+)/;
              $data->{'mail_ids'}{$mailid}{'ident'} = $1 if $line =~ / U=(\S+)/;
              $data->{'mail_ids'}{$mailid}{'who'} = who($data->{'mail_ids'}{$mailid});
  
              # this first test is a little unusual
              # 1. it prevents the following tests from deleting the email
              # 2. it assigns an IP, which is also the unique trigger for auth_mismatch
              # 3. it prevents the responsibility tracking in the final 'else'
              #
              if (exists $data->{'mail_ids'}{$mailid}{'sender_domain'} &&
                  exists $data->{'mail_ids'}{$mailid}{'auth_sender_domain'} &&
                  lc($data->{'mail_ids'}{$mailid}{'sender_domain'}) ne
                  lc($data->{'mail_ids'}{$mailid}{'auth_sender_domain'}) && 
                  $line =~ / A=dovecot/ &&
                  $line =~ /\[([^\s\]]+)\]:\d+ I=/) {
                  $data->{'mail_ids'}{$mailid}{'ip'} = $1;
              #}
              #elsif (!exists($data->{'mail_ids'}{$mailid}{'auth_sender'})  # not locally authed
              #    && !exists($data->{'mail_ids'}{$mailid}{'ident'})     # not ID'd as a local user
              #    && !exists($data->{'domain2user'}{lc($from)})  # sender domain is remote
              #    && !grep({ !exists($data->{'domain2user'}{lc($_)}) } @to_domain) ) {  # recipient domains are local
              #    # then this is an incoming email and we don't care about it
              #    delete $data->{'mail_ids'}{$mailid};
              #} elsif (@{$data->{'mail_ids'}{$mailid}{'recipients'}} ==
              #       grep { $_ =~ /\@\Q$data->{'mail_ids'}{$mailid}{'sender_domain'}\E$/i }
              #       @{$data->{'mail_ids'}{$mailid}{'recipients'}}) {
              #    # if the number of recipients is the same as the number of
              #    # recipients that are to the sender domain, which is local,
              #    # then we don't care.  people can spam themselves all they
              #    # want.
              #    delete $data->{'mail_ids'}{$mailid};
              } elsif (grep { exists($data->{'offserver_forwarders'}{$_}) } @to) {
                  for my $forwarder (grep { exists($data->{'offserver_forwarders'}{$_}) } @to) {
                      next unless $forwarder =~ /[\@+]([^\@+]+)$/ && exists $data->{'domain2user'}{$1};
                      $data->{'forwarder_responsibility'}{$data->{'domain2user'}{$1}}{$forwarder}++;
                  }
              } elsif (!grep({ !exists($data->{'domain2user'}{lc($_)}) } @to_domain)) {
                  # actually just go ahead and drop all mail that's only to local addresses
                  delete $data->{'mail_ids'}{$mailid};
              } else {
                  $data->{'mail_ids'}{$mailid}{'helo'} = $1 if $line =~ / H=(.*?)(?= [A-Z]=)/;
                  $data->{'total_outgoing'}++;
                  $data->{'domain_responsibility'}{lc($from_domain)}++ if defined $from_domain;
                  $data->{'mailbox_responsibility'}{lc($from)}++;
                  for ($data->{'mail_ids'}{$mailid}{'who'}) {
                      last if /@/;
                      $data->{'hourly_volume'}{$_}{substr($line,0,13)}++;
                      $data->{'responsibility'}{$_}++;
                      $data->{'owner_responsibility'}{$data->{'user2owner'}{$_}}++
                          if exists $data->{'user2owner'}{$_}
                          && $data->{'user2owner'}{$_} ne 'root'
                  }
              }
          }
          elsif (substr($line,37,2) eq '**') {
              if ($line =~ m,Domain (\S+) has exceeded the max emails per hour,) {
                  $data->{'discarded_users'}{$data->{'domain2user'}{$1}}++;
                  $data->{'mail_ids'}{$mailid}{'500_discarded'}++;
                  $data->{'total_discarded'}++;
              }
          }
      }
  }
  
  sub analyze_queued_mail_data {
      for my $email (values %{$data->{'mail_ids'}}) {
          next unless $email->{'in_queue'};
          $data->{'script'}{$email->{'script'}}++ if exists $email->{'script'};
          for (qw(source auth_id ident auth_sender sender sender_domain)) {
              next if $_ eq 'sender' && $email->{sender} eq 'mailer-daemon';
              next if $_ eq 'ident' && $email->{ident} eq 'mailnull';
              next if $_ eq 'source' && $email->{source} =~ /^gateway\d+\.websitewelcome\.com$/;
              $data->{'queue_top'}{$_}{$email->{$_}}++ if defined $email->{$_}
          }
          for my $field (qw(recipient_domains recipient_users)) {
              for (keys %{$email->{$field}}) {
                  $data->{'queue_top'}{$field}{$_}++
              }
          }
      }
  }
  
  sub who {
      my ($email) = @_;
      my $who = '(unknown)';
      for (qw(ident auth_id auth_sender source sender)) {
          if (exists $email->{$_}) {
              $who = $email->{$_};
              last
          }
      }
      if ($who =~ /@(.*)/ and exists $data->{'domain2user'}{$1}) {
          $who = $data->{'domain2user'}{$1};
      }
      $who
  }
  
  # sending 200 emails each to 2 of 2 total addresses = OK
  # sending 200 emails each to 2 of 400 total addresses = SUSPECT
  # sending 200 emails each to 2 of 201 total addresses = OK (self CC)
  # implemented: SUSP.NR1 suspect if total addresses / emails >= 1.20
  sub analyze_num_recipients {
      my %suspects;
      my %emails;
  
      # add suspect: anything with more than one recipient
      for my $email (values %{$data->{'mail_ids'}}) {
          next unless $email->{'num_recipients'} > 1;
          $suspects{$email->{'who'}}{$_} = 1 for @{$email->{'recipients'}};
          $emails{$email->{'who'}}++;
      }
  
      # confirm suspect: anything passing SUSP.NR1
      for (keys %suspects) {
          my $r = keys(%{$suspects{$_}}) / $emails{$_};
          if ($r >= 1.2) {
              $data->{'suspects'}{'num_recipients'}{$_} = {
                  addresses => scalar(keys(%{$suspects{$_}})),
                  emails => $emails{$_},
                  ratio => $r
              };
          }
      }
  }
  
  1;
PERL5_SPAMREPORT_EXIM

$fatpacked{"perl5/SpamReport/Exim/DB.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_SPAMREPORT_EXIM_DB';
  package SpamReport::Exim::DB;
  use SpamReport::Data;
  
  use strict;
  use warnings;
  
  use DB_File;
  use Tie::File;
  use Symbol ();
  use IO::File;
  use Fcntl qw(:flock O_RDWR O_RDONLY O_WRONLY O_CREAT);
  
  use vars qw/$VERSION/;
  $VERSION = '2016022601';
  
  my $db_dir = '/var/spool/exim/db';
  my $open_dbs = {};
  
  sub open {
      my ($db_name) = @_;
  
      my $db_file = $db_dir . '/' . $db_name;
      my $lock_file = $db_file . '.lockfile';
  
      return undef if exists $open_dbs->{$db_name};
  
      #die "Could not open $lock_file" if ( ! -r $lock_file );
      my $lock_file_fh = Symbol::gensym();
      sysopen($lock_file_fh, $lock_file, O_RDONLY|O_CREAT, 0640) or die "Could not lock database $db_name: $!\n";
  
      flock $lock_file_fh, LOCK_SH or die "Could not flock() lockfile $lock_file: $!\n";
  
      tie my %db_hash, 'DB_File', $db_file or die "Could not open $db_file: $!\n";
  
      $open_dbs->{$db_name}{'lock_fh'} = $lock_file_fh;
      $open_dbs->{$db_name}{'tie_hash'} = \%db_hash;
  
      1;
  }
  
  sub read {
      my ($db_name, $sub_ref) = @_;
  
      die "Attempted to read non-opened database $db_name" if not exists $open_dbs->{$db_name};
      die "Undefined reference to parser subroutine" if (not defined $sub_ref or ref $sub_ref ne 'CODE');
  
      while ( my ($key, $value) = each %{$open_dbs->{$db_name}{'tie_hash'}} ) {
          $key =~ s/\x00$//;
  
          &{$sub_ref}($key, $value);
      }
  
      1;
  }
  
  sub close {
      my ($db_name) = @_;
  
      return undef if not exists $open_dbs->{$db_name};
      undef $open_dbs->{$db_name}{'tie_hash'};
      untie $open_dbs->{$db_name}{'tie_hash'};
      close $open_dbs->{$db_name}{'lock_fh'};
      delete $open_dbs->{$db_name};
  
      1;
  }
  
  1;
PERL5_SPAMREPORT_EXIM_DB

$fatpacked{"perl5/SpamReport/GeoIP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_SPAMREPORT_GEOIP';
  package SpamReport::GeoIP;
  use Geo::IPfree;
  use IP::Country::Fast;
  use vars qw($VERSION);
  $VERSION = '2016022601';
  
  my ($geo, $ipc);
  
  sub init {
      $geo = Geo::IPfree->new;
      $geo->Faster;
      $ipc = IP::Country::Fast->new;
  }
  
  sub lookup {
      my ($ip) = @_;
      return $ipc->inet_atocc($ip) || ($geo->LookUp($ip))[0]
  }
  
  1;
  } # end module SpamReport::GeoIP
PERL5_SPAMREPORT_GEOIP

$fatpacked{"perl5/SpamReport/Maillog.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_SPAMREPORT_MAILLOG';
  package SpamReport::Maillog;
  use SpamReport::Data;
  
  use common::sense;
  
  use vars qw/$VERSION/;
  $VERSION = '2016022601';
  
  use Time::Local;
  use File::Basename;
  use Regexp::Common qw/ Maillog /;
  use Socket qw(inet_aton inet_ntoa);
  use Sys::Hostname::Long qw(hostname_long);
  
  my $hostname = hostname_long();
  my $main_ip = inet_ntoa(scalar gethostbyname($hostname || 'localhost') || pack("N", '127.0.0.1'));
  
  my @time = CORE::localtime(time);
  my $tz_offset = timegm(@time) - timelocal(@time);
  my @months = qw[Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec];
  my %month_to_ord = map {$months[$_] => $_} (0 .. $#months);
  
  sub find_dovecot_logins {
      my ($lines, $year, $end_time, $in_zone) = @_;
      my @lines = @$lines;
      my %days = %{$data->{'OPTS'}{'dovecot_days'}};
      if ($data->{'OPTS'}{'datelimit'} eq 'not today') {
          delete $days{$data->{'OPTS'}{'dovecot_today'}};
      }
      elsif ($data->{'OPTS'}{'datelimit'} eq 'only today') {
          %days = ($data->{'OPTS'}{'dovecot_today'} => 1);
      }
      
      unless ($in_zone->[0]) {
          if (exists $days{substr($lines[0],0,6)} or
              exists $days{substr($lines[$#lines],0,6)}) {
              $in_zone->[0] = 1
          }
          else {
              return
          }
      }
      for (@lines) {
          unless (exists $days{substr($_,0,6)}) {
              $in_zone->[0] = 0;
              return
          }
          if ( /Login: user=<(?!__cpanel)(\S+?)>/ ) {
              my $login = $1;
              $data->{'logins'}{$login}{'total_logins'}++;
              if ( /rip=(?!127\.0\.0\.1)(?!$main_ip)(\S+?),/ ) {
                  $data->{'logins'}{$login}{'logins_from'}{$1}++
              }
          }
      }
  }
  
  # implemented: SUSP.LOG1 account suspect if login IPs have >2 unique leading 3 octets
  # indicate on >10
  sub analyze_logins {
      for my $login (keys %{$data->{'logins'}}) {
          if (defined($data->{'OPTS'}{'user'})) {
              next if $login =~ /[\@+]([^\@+]+)/
                  && $data->{'OPTS'}{'user'} ne $data->{'domain2user'}{$1};
              next if $login !~ /[\@+]/;
          }
          my %prefix = map { /^(\d+\.\d+\.)/ or die $_; ($1, 1) } keys %{$data->{'logins'}{$login}{'logins_from'}};
          next unless scalar(keys %prefix) > 2;
          $data->{'logins'}{$login}{'suspect'} = 1;
          $data->{'logins'}{$login}{'indicate'} = 1 if scalar(keys %prefix) > 10;
          for (keys %{$data->{'logins'}{$login}{'logins_from'}}) {
              $data->{'logins'}{$login}{'country'}{SpamReport::GeoIP::lookup($_)}{$_} += $data->{'logins'}{$login}{'logins_from'}{$_};
          }
      }
  }
  
  1;
PERL5_SPAMREPORT_MAILLOG

$fatpacked{"perl5/SpamReport/Output.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_SPAMREPORT_OUTPUT';
  package SpamReport::Output;
  
  use common::sense;
  use SpamReport::Data;
  
  use vars qw/$VERSION/;
  $VERSION = '2016022601';
  
  use Time::Local;
  use List::Util qw(shuffle sum);
  use SpamReport::ANSIColor;
  use Regexp::Common qw(SpamReport);
  
  my @time = CORE::localtime(time);
  my $tz_offset = timegm(@time) - timelocal(@time);
  
  use Sys::Hostname::Long qw(hostname_long);
  my $hostname = hostname_long();
  
  sub head_info {
      my ($OPTS) = @_;
      my $search_delta = $OPTS->{'end_time'} - $OPTS->{'start_time'};
      my $hours = $search_delta / 3600;
  
      my $start_time = localtime($OPTS->{'start_time'});
      my $end_time = localtime($OPTS->{'end_time'});
      my $sections = join " ", @{ $OPTS->{'run_sections'} };
  
      print <<END_INFO
  
  SpamReport - Report suspicious mail activity
  Written By: Ryan Egesdahl and Julian Fondren
  
  Operation: $OPTS->{'op'}
  Load: @{[$OPTS->{'load'} || '(nothing)']}
  Want: @{[join " ", sort map { /_(.*)/; $1 } grep { /^want_/ && $OPTS->{$_} } keys %$OPTS]}
  @{[$OPTS->{'op'} ne 'report' ? '' :
      ("Report: " . ($OPTS->{'report'} ne 'summary' ? $OPTS->{'report'} :
      ("summary (" . join(" ", sort map { /_(.*)/; $1 } grep { /^with_/ && $OPTS->{$_} } keys %$OPTS) . ")"))
      . "\n")]}
  @{[$OPTS->{'load'} eq 'no' ? '' : "Searching $hours hours from [$start_time] to [$end_time] ...\n"]}
  END_INFO
  }
  
  # width $x => $y;   # same as:  for (length($x)) { $y = $x if $y < $x }
  # setmax $x => $y;  # same as:  for ($x) { $y = $x if $y < $x }
  # 
  # these replaced code such as:
  #   $widths[5] = length(keys(%{$latest->{$_}{'file_variations'}})) if length(keys(%{$latest->{$_}{'file_variations'}})) > $widths[4];
  # (which has a bug)
  sub width ($\$) { ${$_[1]} = length($_[0]) if ${$_[1]} < length($_[0]) }
  sub setmax ($\$) { ${$_[1]} = $_[0] if ${$_[1]} < $_[0] }
  
  sub email_search_results {
      my (@emails) = @_;
  
      if ( exists $data->{'logins'} and scalar keys %{ $data->{'logins'} } > 0 ) {
          if ( scalar @emails > 1 ) {
              map {
                  print "    Login:        $_\n";
                  print '    Created on:   ' . localtime($data->{'logins'}{$_}{'created_on'}) . "\n";
                  print '    Created by:   ' . $data->{'logins'}{$_}{'created_by'} . "\n";
                  print '    Created from: ' . $data->{'logins'}{$_}{'created_from'} . "\n\n";
              } keys %{ $data->{'logins'} };
          }
          else {
              if ( not exists $data->{'logins'}{$emails[0]} ) {
                  print "\nNot found.\n";
                  return
              }
  
              map {
                  print "    Login:        $_\n";
                  print '    Created on:   ' . localtime($data->{'logins'}{$_}{'created_on'}) . "\n";
                  print '    Created by:   ' . $data->{'logins'}{$_}{'created_by'} . "\n";
                  print '    Created from: ' . $data->{'logins'}{$_}{'created_from'} . "\n\n";
              } $emails[0];
          }
      }
      else {
          print "\nNot found.\n";
      }
  }
  
  sub analyze_results {
      SpamReport::Exim::analyze_queued_mail_data();
      #SpamReport::Exim::analyze_num_recipients();
      analyze_mailboxes();
      SpamReport::Maillog::analyze_logins();
      analyze_user_indicators();
      analyze_auth_mismatch();
  
      1;
  }
  
  sub print_results {
      print_queue_results() if exists $data->{'queue_top'};
      #print_recipient_results() if exists $data->{'suspects'}{'num_recipients'};
      print_script_results();
      print_responsibility_results() if $data->{'responsibility'};
      print_auth_mismatch() if $data->{'auth_mismatch'};
      note_forwarder_abuse();
  
      print "\n";
      1;
  }
  
  sub cache_ls {
      my @details;
      push @details, SpamReport::Data::details($_)
          for <$SpamReport::Data::cronpath*>,
              <$SpamReport::Data::logpath*>;
      my @legend = qw(NAME SIZE EMAILS OUTGOING START HOURS);
      my @widths = map { length($_) } @legend;
      for (@details) {
          $_->{'name'} =~ s/spamreport(cron)?\.dat//;
          $_->{'name'} .= "(cron)" if defined $1;
          width $_->{'name'} => $widths[6];
          width sprintf("%dM", $_->{'size'}/1024/1024) => $widths[0];
          width $_->{'emails'} => $widths[1];
          width $_->{'outgoing'} => $widths[2];
          #width $_->{'bounces'} => $widths[3];
          width ago($_->{'OPTS'}{'start_time'}, 1) => $widths[4];
          width $_->{'OPTS'}{'search_hours'} => $widths[5];
      }
      printf "%$widths[6]s %$widths[0]s %$widths[1]s %$widths[2]s %$widths[4]s %$widths[5]s\n",
          @legend;
      for (sort { $a->{'OPTS'}{'start_time'} <=> $b->{'OPTS'}{'start_time'} } @details) {
          my $line = sprintf "%$widths[6]s %$widths[0]dM %$widths[1]d %$widths[2]d %$widths[4]s %$widths[5]d :: %s -> %s\n",
              $_->{'name'} || 'cache',
              $_->{'size'}/1024/1024,
              $_->{'emails'},
              $_->{'outgoing'},
              #$_->{'bounces'},
              $_->{'OPTS'}{'start_time'} ? ago($_->{'OPTS'}{'start_time'}, 1) : '',
              $_->{'OPTS'}{'search_hours'},
              $_->{'OPTS'}{'start_time'} ? scalar(localtime($_->{'OPTS'}{'start_time'})) : '(unknown)',
              $_->{'OPTS'}{'end_time'} ? scalar(localtime($_->{'OPTS'}{'end_time'})) : '...';
          $line =~ s/(\(cron\))/$GREEN$1$NULL/g;
          print $line
      }
  }
  
  sub print_forwarder_abuse {
      my @abuse = sort { $b->[1] <=> $a->[1] } 
                  map { [$_, List::Util::sum(values %{$data->{'forwarder_responsibility'}{$_}})] }
                  keys %{$data->{'forwarder_responsibility'}};
      my $total = 0; $total += $_->[1] for @abuse;
      unless ($total) { print "No forward abusers found.\n"; return }
  
      my $omitted = @abuse;
      @abuse = grep { $_->[1]/$total > 0.01 } @abuse unless $data->{'OPTS'}{'full'};
      $omitted -= @abuse;
  
      my @width = (0, 0);
      for (@abuse) {
          width $_->[1] => $width[0];
          width $_->[0] => $width[1];
      }
      for (@abuse) {
          printf "%$width[0]d %.1f%% %$width[0]s",
              $_->[1], $_->[1]/$total*100, SpamReport::Annotate::user($_->[0]);
          my $tab; $tab++ if 1 < scalar(keys %{$data->{'forwarder_responsibility'}{$_->[0]}});
          for (keys %{$data->{'forwarder_responsibility'}{$_->[0]}}) {
              printf "%s$YELLOW%s$NULL -> $GREEN%s$NULL",
                  ($tab ? "\n\t" : " :: "),
                  $_,
                  join(" ", keys %{$data->{'offserver_forwarders'}{$_}})
          }
          print "\n";
      }
  
      if ($omitted) {
          print "\n$omitted users were hidden"
              . (defined $ENV{RUSER} ? "; re-run with --full to see them.\n" : ".\n")
      }
  }
  
  sub note_forwarder_abuse {
      my @abuse = sort { $b->[1] <=> $a->[1] }
                  map { [$_, List::Util::sum(values %{$data->{'forwarder_responsibility'}{$_}})] }
                  keys %{$data->{'forwarder_responsibility'}};
      my $total = 0; $total += $_->[1] for @abuse;
      return unless $total;
  
      printf "\nThere were %s emails (to %d accounts) that were forwarded off-server.\n"
          . (defined $ENV{RUSER} ? "(for details, re-run with --forwarders)\n" : ''),
          commify($total), scalar(@abuse);
  }
  
  sub print_script_report {
      my $latest = SpamReport::Tracking::Scripts::latest();
      my @widths = map { length $_ } qw(# IP /16 GEO PATH NAME);
      my $time = time();
      my $total = 0; for (values %$latest) { $total += $_->{'count'} }
      for (keys %$latest) {
          width $latest->{$_}{'count'} => $widths[0];
          width $latest->{$_}{'ips'} => $widths[1];
          width scalar(keys(%{$latest->{$_}{'geo'}})) => $widths[2];
          width scalar(keys(%{$latest->{$_}{'path_variations'}})) => $widths[3];
          width scalar(keys(%{$latest->{$_}{'file_variations'}})) => $widths[4];
      }
      my @scripts = sort { $latest->{$b}{'count'} <=> $latest->{$a}{'count'} } keys %$latest;
      my $omitted = @scripts;
      unless ($data->{'OPTS'}{'full'}) { @scripts = grep { $latest->{$_}{'count'}/$total > 0.01 } @scripts }
      $omitted -= @scripts;
      printf "%$widths[0]s %$widths[1]s %$widths[2]s %$widths[3]s %$widths[4]s %$widths[5]s\n", 
          ("#"x$widths[0]), qw(IP /16 GEO PATH NAME);
      for (@scripts) {
          printf "%$widths[0]d %$widths[1]d %$widths[2]d %$widths[3]d %$widths[4]d %$widths[5]d %32s $GREEN%s$NULL %s %s\n",
              $latest->{$_}{'count'}, $latest->{$_}{'ips'}, $latest->{$_}{'ip16'},
              scalar(keys %{$latest->{$_}{'geo'}}), $latest->{$_}{'path_variations'}, $latest->{$_}{'file_variations'},
              $_, $latest->{$_}{'file'}, top_country($latest->{$_}{'geo'}, 'direct'),
              (($time - $latest->{$_}{'latest'} < 24 * 3600)
                  ? ''
                  : sprintf("$YELLOW%dd ago$NULL", ($time - $latest->{$_}{'latest'}) / (24 * 3600)))
      }
      if ($omitted) {
          print "\n$omitted scripts were hidden"
              . (defined $ENV{RUSER} ? "; re-run with --full to see them.\n" : ".\n")
      }
  }
  
  sub analyze_helos {
      for (values %{$data->{'mail_ids'}}) {
          next unless exists $_->{'helo'} && exists $_->{'who'} && $_->{'who'} !~ /\@/;
          next if defined($data->{'OPTS'}{'user'}) && $_->{'who'} ne $data->{'OPTS'}{'user'};
          $data->{'total_helos'}++;
          $data->{'helos'}{$_->{'who'}}{'count'}++;
          $data->{'helos'}{$_->{'who'}}{'helo'}{$_->{'helo'}}++;
          $data->{'helos'}{$_->{'who'}}{'IP'}{$1}++ if $_->{'helo'} =~ / \[((\d+\.\d+)\.\d+\.\d+)\]:\d+/;
          $data->{'helos'}{$_->{'who'}}{'/16'}{$2}++ if defined $2;
          $data->{'helos'}{$_->{'who'}}{'GEO'}{SpamReport::GeoIP::lookup($1)}++ if defined $1;
          $data->{'helos'}{$_->{'who'}}{'from'}{$_->{'sender'}}++ if defined $_->{'sender'};
      }
  }
  
  sub print_helo_report {
      my @widths = map { length $_ } qw(# % IP /16 GEO FROM USER);
      unless ($data->{'total_helos'}) { print "Nothing to report.\n"; return }
      for (keys %{$data->{'helos'}}) {
          width $data->{'helos'}{$_}{'count'} => $widths[0];
          width sprintf("%.1f", $data->{'helos'}{$_}{'count'} / $data->{'total_helos'} * 100) => $widths[1];
          width scalar(keys(%{$data->{'helos'}{$_}{'IP'}})) => $widths[2];
          width scalar(keys(%{$data->{'helos'}{$_}{'/16'}})) => $widths[3];
          width scalar(keys(%{$data->{'helos'}{$_}{'GEO'}})) => $widths[4];
          width scalar(keys(%{$data->{'helos'}{$_}{'from'}})) => $widths[5];
          width $_ => $widths[6];
      }
      printf "%$widths[0]s %$widths[1]s %$widths[2]s %$widths[3]s %$widths[4]s %$widths[5]s\n",
          ("#"x$widths[0]), ("%"x$widths[1]), qw(IP /16 GEO FROM);
      my @helos = sort { $data->{'helos'}{$b}{'count'} <=> $data->{'helos'}{$a}{'count'} }
                  keys %{$data->{'helos'}};
      my $omitted = @helos;
      unless ($data->{'OPTS'}{'full'}) {
          @helos = grep { $data->{'helos'}{$_}{'count'} / $data->{'total_helos'} > 0.01 } @helos;
      }
      $omitted = @helos;
      for (@helos) {
          printf "%$widths[0]s %$widths[1].1f %$widths[2]s %$widths[3]s %$widths[4]s %$widths[5]s %$widths[6]s %s\n",
              $data->{'helos'}{$_}{'count'},
              $data->{'helos'}{$_}{'count'} / $data->{'total_helos'} * 100,
              scalar(keys(%{$data->{'helos'}{$_}{'IP'}})),
              scalar(keys(%{$data->{'helos'}{$_}{'/16'}})),
              scalar(keys(%{$data->{'helos'}{$_}{'GEO'}})),
              scalar(keys(%{$data->{'helos'}{$_}{'from'}})),
              $_,
              top_country($data->{'helos'}{$_}{'GEO'}, 'direct')
      }
      if ($omitted) {
          print "\n$omitted users were hidden"
              . (defined $ENV{RUSER} ? "; re-run with --full to see them.\n" : ".\n")
      }
  }
  
  sub print_script_info {
      my ($md5) = @_;
      my $tracking = SpamReport::Tracking::Scripts::paths($md5);
      my $width = 0;
      my $time = time();
      for (values %$tracking) { $width = length($_->{'count'}) if length($_->{'count'}) > $width }
      for (sort { $tracking->{$b}{'count'} <=> $tracking->{$a}{'count'} } keys %$tracking) {
          printf "%${width}d %s%s\n", $tracking->{$_}{'count'},
              SpamReport::Annotate::script($_),
              (($time - $tracking->{$_}{'latest'} < 24 * 3600)
                  ? ''
                  : sprintf(" $RED%dd ago$NULL", ($time - $tracking->{$_}{'latest'}) / (24 * 3600)))
      }
  }
  
  sub analyze_mailboxes {
      for my $mb (keys %{$data->{'mailbox_responsibility'}}) {
          next unless $mb =~ /(\S+?)@(\S+)/;
          my $user = $data->{'domain2user'}{$2};
          if ($user) {
              my $dir = "/home/$user/mail/$2/$1";
              if (-d $dir) {
                  if (-C $dir < 30) {
                      $data->{'young_mailboxes'}{$dir}++
                  }
              }
              else {
                  $data->{'nonexistent_mailboxes'}{$mb}++;
                  $data->{'nonexistent_mailbox_users'}{$user}++;
              }
          } else {
              $data->{'unhosted_domains'}{$mb}++;
          }
      }
  }
  
  sub percent_report {
      my ($h, $total, $limit, $title, $discarded, $annotate) = @_;
      return unless $total;
      my @list = sort { $h->{$a} <=> $h->{$b} } grep { $h->{$_} / $total > $limit } keys %$h;
      my @width = (0, 0);
      for (@list) {
          width $h->{$_} => $width[0];
          width sprintf("%.1f", 100*$h->{$_}/$total) => $width[1];
      }
  
      $discarded = sprintf(" (incl. %s emails discarded for hitting 500/hour limits)", commify($discarded))
          if $discarded;
      print "\nResponsibility for @{[commify($total)]} $title$discarded\n";
      for (reverse @list) {
          printf "%$width[0]d %$width[1].1f%% %s\n", $h->{$_}, 100*$h->{$_}/$total,
              $annotate->($_)
      }
  }
  
  sub print_responsibility_results {
      my ($emails, $bounces) = ($data->{'total_outgoing'}, $data->{'total_bounce'});
      my $cutoff = $data->{'OPTS'}{'r_cutoff'} / 100;
      my ($excl, $exclbounce);
      $excl = sprintf(" (excl. %s filtered emails)", commify($data->{'filtered_outgoing'}))
          if $data->{'filtered_outgoing'};
      $exclbounce = sprintf(" (excl. %s filtered bounces)", commify($data->{'filtered_bounce'}))
          if $data->{'filtered_bounce'};
  
      if (5 < keys(%{$data->{'owner_responsibility'}})) {
          # 5 to ignore random bad users on shared servers
          percent_report($data->{'owner_responsibility'}, $emails, $cutoff,
              "outgoing emails (owner)$excl", undef, sub {
                  SpamReport::Annotate::owner(@_, "owner_responsibility", "responsibility")
          });
          percent_report($data->{'bounce_owner_responsibility'}, $bounces, $cutoff,
              "bouncebacks (owner)$exclbounce", undef, sub {
                  SpamReport::Annotate::owner(@_, "bounce_owner_responsibility", "bounce_responsibility")
          });
      }
      percent_report($data->{'responsibility'}, $emails, $cutoff, "outgoing emails$excl", $data->{'total_discarded'}, \&SpamReport::Annotate::user);
      percent_report($data->{'bounce_responsibility'}, $bounces, $cutoff, "bouncebacks$exclbounce", undef, \&SpamReport::Annotate::user);
  }
  
  sub analyze_auth_mismatch {
      for (values %{$data->{'mail_ids'}}) {
          if (exists $_->{'ip'}) {
              $data->{'auth_mismatch'}{$_->{'sender'}}{'count'}++;
              $data->{'auth_mismatch'}{$_->{'sender'}}{'ip'}{$_->{'ip'}}++;
              $data->{'auth_mismatch'}{$_->{'sender'}}{'who'} = $_->{'who'};
              $data->{'auth_mismatch'}{$_->{'sender'}}{'country'}{SpamReport::GeoIP::lookup($_->{'ip'})}{$_->{'ip'}}++;
              $data->{'auth_mismatch'}{$_->{'sender'}}{'auth'}{$_->{'auth_sender'}}++
          }
      }
  }
  
  # $countries is a hashref of country names to
  #   $direct : a number of hits
  #  !$direct : a hash where the number of hits == keys of this hash
  sub top_country {
      my ($countries, $direct) = @_;
      my @countries;
      if ($direct) {
          @countries = grep { defined $_ }
              (sort { $countries->{$b} <=> $countries->{$a} } keys %$countries)[0..2];
      } else {
          @countries = grep { defined $_ }
              (sort { scalar(keys(%{$countries->{$b}})) <=>
                      scalar(keys(%{$countries->{$a}})) } keys %$countries)[0..2];
      }
      for my $embargo (grep { exists $SpamReport::Annotate::embargo{$_} } keys %$countries) {
          push @countries, $embargo unless grep { $embargo eq $_ } @countries
      }
      if ($direct) {
          join " ", map { SpamReport::Annotate::country($_) .  ":" . $countries->{$_} } @countries;
      } else {
          join " ", map { SpamReport::Annotate::country($_) .  ":" . scalar(keys(%{$countries->{$_}})) } @countries;
      }
  }
  
  sub top_auth {
      my ($auths) = @_;
      my @auths = grep { defined $_ } (sort { $auths->{$b} <=> $auths->{$a} } keys %$auths)[0..2];
      join " ", map { "$GREEN$_$NULL:$auths->{$_}" } @auths;
  }
  
  sub print_auth_mismatch {
      print "\n${GREEN}Authorization$NULL vs. sender domain mismatches\n";
      my @widths = (0, 0, 0, 0);
      for (keys %{$data->{'auth_mismatch'}}) {
          my ($s, $i, $c, $u) = map { length $_ } (
              $_,
              scalar(keys(%{$data->{'auth_mismatch'}{$_}{'ip'}})),
              $data->{'auth_mismatch'}{$_}{'count'},
              $data->{'auth_mismatch'}{$_}{'who'}
          );
          setmax $c => $widths[0];
          setmax $i => $widths[1];
          setmax $u => $widths[2];
          setmax $s => $widths[3];
      }
      for (sort { $data->{'auth_mismatch'}{$b}{'count'} <=>
                  $data->{'auth_mismatch'}{$a}{'count'} }
              keys %{$data->{'auth_mismatch'}}) {
          printf "%$widths[0]d %$widths[1]d %$widths[2]s %s %s %s\n",
              $data->{'auth_mismatch'}{$_}{'count'},
              scalar(keys(%{$data->{'auth_mismatch'}{$_}{'ip'}})),
              $data->{'auth_mismatch'}{$_}{'who'},
              $_,
              top_country($data->{'auth_mismatch'}{$_}{'country'}),
              top_auth($data->{'auth_mismatch'}{$_}{'auth'})
      }
  }
  
  my $hisource = qr/$RE{'spam'}{'hi_source'}/;
  my $spamtld  = qr/$RE{'spam'}{'spammy_tld'}/;
  my $hidest   = qr/$RE{'spam'}{'hi_destination'}/;
  sub analyze_user_indicators {
      my ($emails, $bounces) = ($data->{'total_outgoing'}, $data->{'total_bounce'});
      my %users;
      my $cutoff = $data->{'OPTS'}{'r_cutoff'} / 100;
      for (keys %{$data->{'responsibility'}}) {
          $users{$_} = undef if $emails && $data->{'responsibility'}{$_} / $emails > $cutoff;
      }
      for (keys %{$data->{'bounce_responsibility'}}) {
          $users{$_} = undef if $bounces && $data->{'bounce_responsibility'}{$_} / $bounces > $cutoff;
      }
      for (values %{$data->{'mail_ids'}}) {
          my $user = $_->{'who'};
          next unless exists $users{$user};
          next if $_->{'type'} eq 'bounce';
          $users{$user}{'total'}++;
          if ($_->{'subject'} =~ /^Account Details for |^Activate user account|^Welcome to/) {
              $users{$user}{'botmail'}++
          }
          if ($_->{'subject'} =~ /^Cron /) {
              $users{$user}{'cronmail'}++;
          }
          if ($_->{'sender'} =~ /[^\@_]+_/) {
              $users{$user}{'underbar_mail'}++;
          }
          #if ($_->{'subject'} =~ /^(?:hello|hi)!?$/i or $_->{'subject'} eq '') {
          #    $data->{'special_indicators'}{$user}{'hi_malware'}++;
          #}
          if ($_->{'sender_domain'} =~ $hisource or
              $_->{'sender_domain'} =~ $spamtld) {
              $users{$user}{'badsender'}++;
          }
          if (grep { $_ =~ $hidest } @{$_->{'recipients'}}) {
              $users{$user}{'badrecipient'}++;
          }
          if ($_->{'subject'} =~ /^Your email requires verification verify#/) {
              $users{$user}{'boxtrapper'}++;
          }
      }
      my $recently = time() - 7 * 24 * 3600;
      my @history = reverse history_since($recently);
      for my $user (keys %users) {
          for (keys %{$data->{'outscript'}}) {
              $users{$user}{'outscript'} += $data->{'outscript'}{$_} if m,/home\d*/\Q$user\E/,
          }
          for (scalar(SpamReport::Tracking::Suspensions::tickets($user))) {
              if ($_) {
                  $data->{'indicators'}{$user}{"abuse:$_"}++
              }
          }
          for (@history) {
              if ($_->[1] =~ /\Q$user/) {
                  $data->{'in_history'}{$user} = $_->[0];
                  last
              }
          }
          my $mtime = (stat("/home/$user/.security"))[9];
          if ($mtime > $recently) {
              $data->{'indicators'}{$user}{"security:" . ago($mtime, 1)}++;
          }
      }
      for my $login (keys %{$data->{'logins'}}) {
          next unless $data->{'logins'}{$login}{'indicate'};
          if ($login =~ /[\@+]([^\@+]+)$/ && exists $users{$data->{'domain2user'}{$1}}) {
              $data->{'indicators'}{$data->{'domain2user'}{$1}}{$login.':'.$data->{'logins'}{$login}{'total_logins'}."(IPs)"}++;
          }
      }
      for (keys %users) {
          next unless $users{$_}{'total'};
          if ($users{$_}{'botmail'} / $users{$_}{'total'} > 0.8) {
              $data->{'indicators'}{$_}{'bots?'}++;
          }
          if ($users{$_}{'underbar_mail'} / $users{$_}{'total'} > 0.8) {
              $data->{'indicators'}{$_}{'fake_accts?'}++;
          }
          if ($users{$_}{'badsender'} / $users{$_}{'total'} > 0.9) {
              $data->{'indicators'}{$_}{'bad_sender?'}++;
          }
          if ($users{$_}{'badrecipient'} / $users{$_}{'total'} > 0.9) {
              $data->{'indicators'}{$_}{'bad_recipients?'}++;
          }
          if ($users{$_}{'cronmail'} / $users{$_}{'total'} > 0.9) {
              $data->{'indicators'}{$_}{'cron?'}++;
          }
          if ($users{$_}{'outscript'} / $users{$_}{'total'} > 0.9) {
              $data->{'indicators'}{$_}{'script_comp?'}++;
          }
          for ($users{$_}{'boxtrapper'} / $users{$_}{'total'}) {
              if ($_ > 0.5) {
                  $data->{'indicators'}{$_}{sprintf("boxtrapper:%.1f%%", $_*100)}++;
              }
          }
          if ($data->{'discarded_users'}{$_}) {
              $data->{'indicators'}{$_}{sprintf("discard:%.1f%%", $data->{'discarded_users'}{$_}/$users{$_}{'total'}*100)}++;
          }
      }
  }
  
  sub history_since {
      my ($since) = @_;
      my @history;
      my $skip;
      open my $f, '<', '/root/.bash_history' or return;
      my $date = localtime();
      while ($_ = <$f>) {
          if (/^\#(\d+)/) { if ($1 < $since) { $skip++ } else { $date = $1 } next }
          if ($skip) { undef $skip; next }
          push @history, [$date, $_]
      }
      close $f;
      @history;
  }
  
  sub print_recipient_results {
      my @widths = (0, 0);
      for (values %{$data->{'suspects'}{'num_recipients'}}) {
          my ($em, $ad) = (length($_->{'emails'}), length($_->{'addresses'}));
          setmax $em => $widths[0];
          setmax $ad => $widths[1];
      }
      
      my %h = %{$data->{'suspects'}{'num_recipients'}};
      for (reverse sort { $h{$a}->{ratio} <=> $h{$b}->{ratio} } keys %h) {
          printf "%$widths[0]d %$widths[1]d %.4f num_recipients: $_\n",
              $h{$_}->{'emails'}, $h{$_}->{'addresses'}, $h{$_}->{'ratio'};
      }
  }
  
  sub scriptlimit {
      my ($h, $total, $per) = @_;
      return unless $total;
      my @r = grep { $h->{$_}/$total > $per } keys %$h;
      map { [$_, $h->{$_}, $total] } sort { $h->{$a} <=> $h->{$b} } grep { defined $_ } @r[0..4]
  }
  
  sub suppressed_scriptdirs {
      my ($h) = @_;
      DIR: for my $dir (keys %{$data->{'scriptdirs'}}) {
          for (keys %{$data->{'outscript'}}) {
              next DIR if $_ =~ m,^$dir/*[^/]+$,
                  # && $data->{'outscript'}{$_}/$data->{'scriptdirs'}{$dir} > 0.9
          }
          $h->{$dir} = $data->{'scriptdirs'}{$dir};
      }
  }
  
  sub print_script_results {
      my %dirs; suppressed_scriptdirs(\%dirs);
      my $scriptdirs = 0; $scriptdirs += $dirs{$_} for keys %dirs;
      my $script = 0; $script += $data->{'outscript'}{$_} for keys %{$data->{'outscript'}};
      my @r = (scriptlimit(\%dirs, $scriptdirs, 0.1),
               scriptlimit($data->{'outscript'}, $script, 0.1));
      my @width = (0, 0);
      for (@r) {
          my $frac = length(sprintf "%.1f", 100*$_->[1]/$_->[2]);
          width $_->[1] => $width[0];
          setmax $frac => $width[1];
      }
  
      print "\nResponsibility for @{[commify($scriptdirs)]} script dirs and @{[commify($script)]} scripts\n";
      for (reverse @r) {
          printf "%$width[0]d %$width[1].1f%% %s\n", $_->[1], 100*$_->[1]/$_->[2],
              SpamReport::Annotate::script($_->[0])
      }
      #for (sort { $data->{'script'}{$a} <=> $data->{'script'}{$b} } keys %{$data->{'script'}}) {
      #    print "$data->{'script'}{$_} $_\n"
      #}
      #for (sort { $data->{'script_ip'}{$a} <=> $data->{'script'}{$b} } keys %{$data->{'script_ip'}}) {
      #    print "$data->{'script_ip'}{$_} $_\n"
      #}
  }
  
  sub print_login_results {
      print "\nSuspect logins\n";
      my @width = (0, 0, 0, 0);
      my %h; $h{$_} = $data->{'logins'}{$_} for grep { $data->{'logins'}{$_}{'suspect'} } keys %{$data->{'logins'}};
      for (keys %h) {
          my ($lo, $pr) = map { length($_) } ($h{$_}{'total_logins'}, scalar(keys %{$h{$_}{'logins_from'}}));
          my $wh = /[\@+]([^\@+]+)/ ? length($h{$_}{'who'} = $data->{'domain2user'}{$1}) : 0;
          setmax $lo => $width[0];
          setmax $pr => $width[1];
          setmax $wh => $width[2];
          setmax $_ => $width[3];
      }
      $width[3] = 30 if $width[3] > 30;  # XXX
      for my $login (reverse sort { $h{$a}{'total_logins'} <=> $h{$b}{'total_logins'} } keys %h) {
          (my $short = $login) =~ s/^(.{27}).*/$1\e\e\e/; # XXX
          my @ips = sort { $h{$login}{'logins_from'}{$b} <=> $h{$login}{'logins_from'}{$a} } keys %{$h{$login}{'logins_from'}};
          my @counts = map { $h{$login}{'logins_from'}{$_} } @ips;
          my $line = sprintf "%$width[0]d %$width[2]s %$width[1]d %$width[3]s %s(%d) %s(%d) %s(%d) :: %s\n",
              $h{$login}{'total_logins'}, $h{$login}{'who'}, scalar(keys %{$h{$login}{'logins_from'}}),
              $short,
              "$MAGENTA$ips[0]$NULL", $counts[0],
              "$YELLOW$ips[1]$NULL", $counts[1],
              "$GREEN$ips[2]$NULL", $counts[2], # join(" ", map { $ips[$_].':'.$counts[$_] } 3..$#ips)
              top_country($h{$login}{'country'});
          $line =~ s/\e\e\e/$RED...$NULL/g;
          print $line
      }
  }
  
  sub print_queue_results {
      my @results;
      my $output;
  
      for my $field (keys %{$data->{'queue_top'}}) {
          push @results, top(fieldcolor($field) => $data->{'queue_top'}{$field})
      }
  
      print "\nResponsibility for @{[commify($data->{'total_queue'})]} queued emails (excl. @{[commify($data->{'boxtrapper_queue'})]} boxtrapper; @{[commify($data->{'local_queue'})]} local):\n";
      
      # display results with more related emails than 3% of the number of emails in the queue
      # ... or if this results in no output, display all fields
      for my $sig (0.03 * $data->{'total_queue'}, 1) {
          for (reverse sort { $a->[0] <=> $b->[0] } grep { $_->[0] > $sig } @results) {
              $output = 1;
              print "$_->[0] $_->[1]\n"
          }
          last if $output; 
      }
  }
  
  my %user_tests = (
      bounce_recipient => sub { exists $_[0]->{'recipient_users'}{$_[1]} },
      bounce_source => sub { exists $_[0]->{'source'}{$_[1]} },
      who => sub {
          return 1 if $_[0]->{'who'} eq $_[1];
          if ($_[1] eq $data->{'domain2user'}{$_[0]->{'sender_domain'}}) {
              $data->{'crossauth'}{$_[1]}{$_[0]->{'who'}}++;
              return 1;
          }
          undef;
      },
      path => sub { $_[0] =~ m,^/[^/]+/$_[1]/, }
  );
  my %root_tests = (
      bounce_recipient => sub { 1 },
      bounce_source => sub { 1 },
      who => sub { 1 },
      path => sub { 1 },
  );
  my %reseller_tests = do {
      my %resolds;
      (
          set_resolds => sub { %resolds = (); $resolds{$_} = 1 for @_ },
          bounce_recipient => sub {
              for (keys %{$_[0]->{'recipient_users'}}) {
                  return 1 if exists $resolds{$_}
              }
              return
          },
          bounce_source => sub {
              for (keys %{$_[0]->{'source'}}) {
                  return 1 if exists $resolds{$_}
              }
              return
          },
          who => sub { exists $resolds{$_[0]->{'who'}} },
          path => sub {
              return unless $_[0] =~ m,^/[^/]+/([^/]+)/,;
              return exists $resolds{$1}
          }
      )
  };
  
  sub analyze_user_results {
      my ($user, $isreseller) = @_;
      my ($sent, $bounce, $queued, $boxtrapper) = (0, 0, 0);
      my %sent;
      my %bounce;
      my %sent_as;
      my %ips;
      my %cwd;
      my %script;
      my %recip;
      my %subject;
      my $tests = \%user_tests;
      if ($user eq 'root') {
          $tests = \%root_tests
      } elsif ($isreseller) {
          $tests = \%reseller_tests;
          $tests->{'set_resolds'}(@{$data->{'owner2user'}{$user}});
      }
  
      my %dirs; suppressed_scriptdirs(\%dirs);
  
      for my $email (values %{$data->{'mail_ids'}}) {
          if ($email->{'type'} eq 'bounce' && $tests->{'bounce_recipient'}($email, $user)) {
              $bounce++;
              $bounce{$email->{'recipients'}->[0]}++;
              $queued++ if $email->{'in_queue'};
          }
          elsif ($email->{'type'} eq 'bounce' && $tests->{'bounce_source'}($email, $user)) {
              $bounce++;
              $bounce{$email->{'source'}}++;
              $queued++ if $email->{'in_queue'};
          }
          elsif ($tests->{'who'}($email, $user)) {
              $sent++;
              $sent_as{$email->{'sender'}}++;
              $queued++ if $email->{'in_queue'};
              $boxtrapper++ if $email->{'boxtrapper'};
              if ($email->{'host_auth'} =~ /^dovecot_/) {
                  $sent{$email->{'host_auth'} . ':' . $email->{'auth_sender'}}++;
              } elsif ($email->{'auth_sender'}) {
                  $sent{$email->{'auth_sender'}}++;
              } elsif ($email->{'received_protocol'} eq 'local' && $email->{'ident'}) {
                  $sent{$email->{'ident'}}++;
              }
              if (exists $email->{'host_address'}) {
                  $ips{$email->{'host_address'}}++
              }
              for (@{$email->{'recipients'}}) {
                  $recip{$_}++
              }
              if (exists $email->{'subject'}) {
                  $subject{$email->{'subject'}}++
              }
          }
      }
      for (keys %dirs) {
          next unless $tests->{'path'}($_, $user);
          $cwd{$_} += $dirs{$_}
      }
      for (keys %{$data->{'outscript'}}) {
          next unless $tests->{'path'}($_, $user);
          $script{$_} += $data->{'outscript'}{$_}
      }
  
      $data->{'suspects'}{'users'}{$user} = {
          sent => $sent || "NaN",
          bounce => $bounce,
          queued => $queued,
          boxtrapper => $boxtrapper,
          sent_accounts => \%sent,
          bounce_addresses => \%bounce,
          sent_addresses => \%sent_as,
          ips => \%ips,
          cwd => \%cwd,
          script => \%script,
          recipients => \%recip,
          subject => \%subject,
      };
  }
  
  # modified http://www.perlmonks.org/?node_id=653
  # if given a hashref, commify the number of keys
  sub commify {
      my $input = shift;
      $input = scalar(keys %$input) if ref $input eq 'HASH';
      $input = reverse $input;
      $input =~ s<(\d\d\d)(?=\d)(?!\d*\.)><$1,>g;
      $input = reverse $input;
      $input
  }
  
  sub sample {
      my ($h, $title) = @_;
      (join '' => 
          map { "$_: $h->{$_}\n" }
          grep { defined $_ }
          (sort { $h->{$b} <=> $h->{$a} } keys %$h)[0..14])
      . remainder($h, $title)
  }
  
  sub topsubjects {
      my ($h) = @_;
      my $width = 0;
      for (values %$h) { $width = length($_) if $width < length($_) }
      (join "\n",
          map { sprintf "%${width}d %s", $h->{$_}, $_ }
          grep { defined $_ }
          (sort { $h->{$b} <=> $h->{$a} } keys %$h)[0..14])
  }
  
  sub remainder {
      my ($h, $title) = @_;
      my $rest = keys(%$h) - 15;
      return if $rest < 1;
      return "\nThere were @{[commify($rest)]} additional $title trimmed.\n"
  }
  
  sub boxtrapper {
      my ($u, $total) = @_;
      return unless $u->{'boxtrapper'};
      return <<BOX
  Boxtrapper was responsible for @{[commify($u->{'boxtrapper'})]} sent emails, or @{[sprintf "%.2f%%", 100*$u->{'boxtrapper'}/$total]} of the emails.
  
  BOX
  }
  
  sub php_scripts {
      my ($u) = @_;
      my $r;
      if ((values(%{$u->{'cwd'}}))[0]) {
          $r .= <<PHP
  Current working directories:
  ------------
  @{[sample($u->{'cwd'}, "working directories")]}
  PHP
      }
      if ((values(%{$u->{'script'}}))[0]) {
          $r .= <<PHP
  PHP Scripts:
  ------------
  @{[sample($u->{'script'}, "PHP scripts")]}
  PHP
      }
      $r
  }
  
  {
      my $time = time();
      my %units = (
          0 => {days => " days", hours => " hours"},
          1 => {days => "d", hours => "h"}
      );
      sub ago {
          my $delta = ($time - $_[0]) / (24 * 3600);
          if ($delta > 1) {
              sprintf "%.1f$units{$_[1]}{days}", $delta
          } else {
              sprintf "%.1f$units{$_[1]}{hours}", ($time - $_[0]) / 3600
          }
      }
  }
  
  sub user_ticket_report {
      my ($user, $isreseller) = @_;
      $isreseller = 1 if $user eq 'root';
      my @tickets;
      my $r = "----------------------------------------\n\n";
      my @widths = (0, 0, 0, 0);
      for my $u (sort $user, @{$data->{'owner2user'}{$user}}) {
          my @t = SpamReport::Tracking::Suspensions::tickets($u);
          next unless @t;
          for my $t (@t) {
              if ($data->{'suspensions'}{$u}{$t}{'enable'} && $data->{'suspensions'}{$u}{$t}{'disable'}) {
                  push @tickets, [$u, $t, (map { ago($data->{'suspensions'}{$u}{$t}{$_}, 0) . " ago" } qw(enable disable)),
                                  $data->{'suspensions'}{$u}{$t}{'disable'}]
              }
              elsif ($data->{'suspensions'}{$u}{$t}{'disable'}) {
                  push @tickets, [$u, $t, ago($data->{'suspensions'}{$u}{$t}{'disable'}, 0) . " ago", '', 
                                  $data->{'suspensions'}{$u}{$t}{'disable'}]
              }
              else { # enable only --> disable predates abusetool logs
                  push @tickets, [$u, $t, '(prehistory)', ago($data->{'suspensions'}{$u}{$t}{'enable'}, 0) . " ago",
                                  $data->{'suspensions'}{$u}{$t}{'enable'}]
              }
          }
      }
      for (@tickets) {
          width $_->[0] => $widths[0];
          width $_->[1] => $widths[1];
          width $_->[2] => $widths[2];
          width $_->[3] => $widths[3];
      }
      for (sort { $a->[4] <=> $b->[4] } @tickets) {
          $r .= sprintf("%s%s%$widths[1]s$NULL : %$widths[2]s -> %$widths[3]s : %s\n",
                  ($isreseller ? sprintf("%$widths[0]s : ", $_->[0]) : ''),
                  ($_->[3] ? '' : $RED),
                  $_->[1], $_->[2], $_->[3], scalar(localtime($_->[4])))
      }
      $r .= "\n";
      $r
  }
  
  sub user_hour_report {
      my ($user, $isreseller) = @_;
      return unless $data->{'OPTS'}{'hourly_report'};
      my $r = "----------------------------------------\n\n";
      my $volumes;
      if ($user eq 'root') {
          for my $u (keys %{$data->{'hourly_volume'}}) {
              for (keys %{$data->{'hourly_volume'}{$u}}) {
                  $volumes->{$_} += $data->{'hourly_volume'}{$u}{$_}
              }
          }
      }
      elsif ($isreseller) {
          for my $resold ($user, @{$data->{'owner2user'}{$user}}) {
              for (keys %{$data->{'hourly_volume'}{$resold}}) {
                  $volumes->{$_} += $data->{'hourly_volume'}{$resold}{$_}
              }
          }
      }
      else { $volumes = $data->{'hourly_volume'}{$user} }
      for (sort keys %$volumes) {
          $r .= "$_: " . commify($volumes->{$_}) . "\n"
      }
      $r .= "\n";
      $r
  }
  
  sub print_user_results {
      my ($user, $isreseller) = @_;
      my $u = $data->{'suspects'}{'users'}{$user}
          or die "No information about $user";
  
      if (!$u->{'sent'}) {
          die "$user sent no emails in the period examined.\n"
      }
  
      my %sent_as = %{$u->{'sent_addresses'}};
      $sent_as{$_} += $u->{'bounce_addresses'}{$_} for keys %{$u->{'bounce_addresses'}};
  
      my $total = $u->{'sent'} + $u->{'bounce'};
      $total ||= 'NaN';
      $u->{'boxtrapper'} ||= 0;
  
      print <<"REPORT";
  Reference: spamreport
     Server: $hostname
       User: $user
  
  @{[user_ticket_report($user, $isreseller)]}@{[user_hour_report($user, $isreseller)]}----------------------------------------
  
  User sent approximately @{[commify($u->{'sent'})]} messages to @{[commify($u->{'recipients'})]} unique recipients.
  There were @{[commify($u->{'bounce'})]} bounces on @{[commify($u->{'bounce_addresses'})]} unique addresses, @{[sprintf "%.2f%%", 100*$u->{'bounce'}/$total]} of the emails.
  
  @{[boxtrapper($u, $total)]}Email addresses sent from:
  --------------------------
  @{[sample(\%sent_as, "sender addresses")]}
  Logins used to send mail:
  -------------------------
  @{[sample($u->{'sent_accounts'}, "logins")]}
  @{[php_scripts($u)]}Random recipient addresses:
  ---------------------------
  @{[join "\n",
      grep { defined $_ }
      (List::Util::shuffle(keys %{$u->{'recipients'}}))[0..15]]}
  
  Top recipients:
  ---------------
  @{[sample($u->{'recipients'}, "recipients")]}
  Top subjects:
  -------------
  @{[topsubjects($u->{'subject'})]}
  
  Total number of distinct subjects: @{[commify($u->{'subject'})]}
  
  Emails found in queue:
  ----------------------
  User: @{[commify($u->{'queued'})]}, Total: @{[commify($data->{'total_queue'})]}
  
  This user was responsible for @{[sprintf "%.2f%%", 100*($u->{'sent'}+$u->{'bounce'})/(scalar(keys %{$data->{'mail_ids'}}) || 'NaN')]} of the emails found.@{[scalar(keys(%{$data->{'crossauth'}{$user}})) ? "\n${MAGENTA}Some of this user's email may be getting authorized by an another user's credentials.$NULL" : '']}
  
  
  REPORT
  }
  
  sub top {
      my ($type, $h) = @_;
      map { [$h->{$_}, "$type: $_"] } keys %$h
  }
  
  {
      SpamReport::ANSIColor::suppress() if exists($ENV{nocolors}) || !-t\*STDOUT;
  
      my %fieldcolors = (
          source => $YELLOW,
          auth_id => $RED,
          ident => $YELLOW,
          auth_sender => $RED,
          sender_domain => $GREEN,
          sender => $GREEN,
          recipient_domains => $CYAN,
          recipient_users => $CYAN,
      );
  
      sub fieldcolor {
          my ($field) = @_;
          return $field unless exists $fieldcolors{$field};
          $fieldcolors{$field} . $field . $NULL
      }
  }
  
  1;
PERL5_SPAMREPORT_OUTPUT

$fatpacked{"perl5/SpamReport/Tracking/Performance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_SPAMREPORT_TRACKING_PERFORMANCE';
  package SpamReport::Tracking::Performance;
  use SpamReport::Data;
  use vars qw($VERSION);
  use common::sense;
  
  $VERSION = '2016022401';
  my $trackpath = "/opt/hgmods/logs/spamperformance.log";
  
  # 1MB is enough logs for anybody
  if (-s($trackpath) > 1024*1024) {
      my @lines;
      if (open my $f, '<', $trackpath) {
          while ($_ = <$f>) {
              last if @lines > 100;
              push @lines, $_
          }
          close $f;
      }
      if (@lines && open my $f, '>', $trackpath) {
          print {$f} @lines;
          close $f;
      }
  }
  
  my $start = time();
  my $ARGS = "@ARGV";
  
  END {
      my $end = time();
      if (open my $f, '>>', $trackpath) {
          printf {$f} "%s + %d secs : %d tracked emails : %s\n", 
              scalar(localtime($start)),
              $end - $start, 
              scalar(keys %{$data->{'mail_ids'}}),
              $ARGS;
          close $f;
      }
  }
  
  1;
  } # end module SpamReport::Tracking::Performance
PERL5_SPAMREPORT_TRACKING_PERFORMANCE

$fatpacked{"perl5/SpamReport/Tracking/Scripts.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_SPAMREPORT_TRACKING_SCRIPTS';
  package SpamReport::Tracking::Scripts;
  use YAML::Syck qw(DumpFile LoadFile);
  use vars qw($VERSION);
  use File::Which qw ( which );
  use Time::Local;
  use common::sense;
  
  $VERSION = '2016022401';
  my $md5sum = which('md5sum');
  my $trackpath = "/opt/hgmods/logs/spamscripts.dat";
  my $midnight = timelocal(0, 0, 0, (localtime)[3..8]);
  
  my $tracking;
  
  sub load { eval { $tracking = LoadFile($trackpath) } }
  sub save { if ($tracking) { prune(); DumpFile($trackpath, $tracking) } }
  
  my %cache;
  
  # script tracking is relatively expensive and probably
  # shouldn't happen except on --cron runs
  sub disable {
      *{"SpamReport::Tracking::Scripts::load"}
      = *{"SpamReport::Tracking::Scripts::save"}
      = *{"SpamReport::Tracking::Scripts::script"} = sub { }
  }
  
  my $time = time();
  sub script {
      my ($path, $ip) = @_;
      my $md5 = md5sum($path) || return;
      if ($md5 =~ /^[a-f0-9]{32}$/i) {
          $tracking->{$md5}{$midnight}{'ips'}{$ip}++;
          $tracking->{$md5}{$midnight}{'paths'}{$path}++;
      }
  }
  
  sub md5sum {
      my ($path) = @_;
      return $cache{$path} if exists $cache{$path};
      return unless -f $path;
      open my $f, '-|', $md5sum, $path or return;
      my $md5 = <$f>;
      close $f;
      $md5 =~ s/ .*//;
      chomp $md5;
      $md5
  }
  
  sub prune {
      my $cutoff = $midnight - (180 * 3600 * 24);  # 180 days ago
      for my $md5 (keys %$tracking) {
          for (keys %{$tracking->{$md5}}) {
              if ($_ < $cutoff) {
                  delete $tracking->{$md5}{$_}
              }
          }
      }
  }
  
  sub latest {
      my %r;
      for my $md5sum (keys %$tracking) {
          my $latest = (sort { $b <=> $a } keys %{$tracking->{$md5sum}})[0];
          my $ips = scalar(keys %{$tracking->{$md5sum}{$latest}{'ips'}});
          my %ip16; for (keys %{$tracking->{$md5sum}{$latest}{'ips'}}) { $ip16{$1}++ if /^(\d+\.\d+\.)/ }
          my %geo; for (keys %{$tracking->{$md5sum}{$latest}{'ips'}}) { $geo{SpamReport::GeoIP::lookup($_)}++ }
          my (%files, %paths);
          my $count = 0; for (values %{$tracking->{$md5sum}{$latest}{'ips'}}) { $count += $_ }
          for my $time (keys %{$tracking->{$md5sum}}) {
              for (keys %{$tracking->{$md5sum}{$time}{'paths'}}) {
                  $paths{$_} += $tracking->{$md5sum}{$time}{'paths'};
                  next unless m,/([^/]+)$,;
                  $files{$1} += $tracking->{$md5sum}{$time}{'paths'}
              }
          }
          $r{$md5sum} = {
              latest => $latest,
              count => $count,
              ips => $ips,
              ip16 => scalar(keys %ip16),
              geo => \%geo,
              file => (sort { $files{$b} <=> $files{$a} } keys %files)[0],
              path_variations => scalar(keys %paths),
              file_variations => scalar(keys %files),
          }
      }
      \%r
  }
  
  sub paths {
      my ($md5) = @_;
      my %r;
      for my $time (keys %{$tracking->{$md5}}) {
          for (keys %{$tracking->{$md5}{$time}{'paths'}}) {
              $r{$_}{'count'} += $tracking->{$md5}{$time}{'paths'}{$_};
              $r{$_}{'latest'} = $time if $time > $r{$_}{'latest'};
          }
      }
      \%r
  }
  
  sub get_md5 { return $tracking->{$_[0]} }
  
  # /usr/bin/time perl -MDigest::MD5 -le '$m = Digest::MD5->new; open my $f, "<", "bigfile"; $m->addfile($f); print $m->hexdigest'
  # cd573cfaace07e7949bc0c46028904ff
  # 3.86user 0.47system 0:04.34elapsed 99%CPU (0avgtext+0avgdata 2432maxresident)k
  # 0inputs+0outputs (0major+674minor)pagefaults 0swaps
  #
  # # /usr/bin/time md5sum bigfile 
  # cd573cfaace07e7949bc0c46028904ff  bigfile
  # 2.75user 0.41system 0:03.19elapsed 98%CPU (0avgtext+0avgdata 692maxresident)k
  # 0inputs+0outputs (0major+216minor)pagefaults 0swaps
  #
  # --
  # 1GB file.  md5sum: a bit faster, 700MB of RAM.
  # vs. Digest::MD5: a bit slower, 2500MB of RAM.
  
  1;
  } # end module SpamReport::Tracking::Scripts
PERL5_SPAMREPORT_TRACKING_SCRIPTS

$fatpacked{"perl5/SpamReport/Tracking/Suspensions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_SPAMREPORT_TRACKING_SUSPENSIONS';
  package SpamReport::Tracking::Suspensions;
  use vars qw($VERSION);
  use SpamReport::Data;
  use Time::Local;
  use common::sense;
  $VERSION = '2016022601';
  my $abusetool_log = '/var/log/abusetool.log';
  my $lockdown_log = '/var/log/lockdown.log';
  my $abusepath = '/opt/eig_linux/var/suspended/';
  my $midnight = timelocal(0, 0, 0, (localtime)[3..8]);
  my $cutoff = $midnight - (60 * 24 * 3600);  # 60 days ago
  
  sub load {
      load_abusetool();
      load_lockdown();
      opendir my $d, $abusepath or do { warn "Unable to open $abusepath : $!"; return };
      while ($_ = readdir($d)) {
          open my $f, '<', $abusepath.$_ or next;
          my $ctime = (stat($f))[10];
          chomp(my $ticket = <$f>);
          close $f;
          if ($ticket && $ctime) {
              $data->{'suspensions'}{$_}{"$ticket.http"}{'disable'} = $ctime
          }
      }
      close $d;
  }
  
  sub ticket {
      my ($user) = @_;
      grep { defined($data->{'suspensions'}{$user}{$_}{'disable'}) &&
            !defined($data->{'suspensions'}{$user}{$_}{'enable'}) }
          keys %{$data->{'suspensions'}{$_[0]}}
  }
  
  sub ticketed_users {
      my @users;
      for my $user (keys %{$data->{'suspensions'}}) {
          for my $susp (keys %{$data->{'suspensions'}{$user}}) {
              if (defined $data->{'suspensions'}{$user}{$susp}{'disable'} &&
                      !defined $data->{'suspensions'}{$user}{$susp}{'enable'}) {
                  push @users, $user;
                  last
              }
          }
      }
      @users
  }
  
  sub tickets { keys %{$data->{'suspensions'}{$_[0]}} }
  
  sub load_abusetool {
      logs_after(sub {
          my ($date, $type, $action, $user, $ticket) = split /:/, shift;
          $data->{'suspensions'}{$user}{"$ticket.$type"}{$action} = $date;
      }, $abusetool_log, $cutoff)
  }
  
  sub load_lockdown {
      logs_after(sub {
          my ($date, $type, $action, $ticket) = split /:/, shift;
          $data->{'suspensions'}{'root'}{"$ticket.$type"}{$action} = $date;
      }, $lockdown_log, $cutoff)
  }
  
  sub logs_after {
      my ($handler, $log, $time) = @_;
      my @r;
      return unless -f $log;
      open my $f, '<', $log or do { warn "Unable to open $log : $!"; return };
      while (defined($_ = <$f>)) {
          chomp;
          next unless /^(\d+):/ && $1 > $cutoff;
          $handler->($_);
      }
      close $f;
  }
  
  1;
  } # end module SpamReport::Tracking::Suspensions
PERL5_SPAMREPORT_TRACKING_SUSPENSIONS

$fatpacked{"perl5/Sys/Hostname/Long.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_SYS_HOSTNAME_LONG';
  package Sys::Hostname::Long;
  use strict;
  use Carp;
  
  require Exporter;
  use Sys::Hostname;
  
  # Use perl < 5.6 compatible methods for now, change to 'use base' soon
  @Sys::Hostname::Long::ISA     = qw/ Exporter Sys::Hostname /;
  
  # Use perl < 5.6 compatible methods for now, change to 'our' soon.
  use vars qw(@EXPORT $VERSION $hostlong %dispatch $lastdispatch);
  @EXPORT  = qw/ hostname_long /;
  $VERSION = '1.5';
  
  %dispatch = (
  
  	'gethostbyname' => {
  		'title' => 'Get Host by Name',
  		'description' => '',
  		'exec' => sub {
  			return gethostbyname('localhost');
  		},
  	},
  
  	'exec_hostname' => {
  		'title' => 'Execute "hostname"',
  		'description' => '',
  		'exec' => sub {
  			my $tmp = `hostname`;
  			$tmp =~ tr/\0\r\n//d;
  			return $tmp;
  		},
  	},
  
  	'win32_registry1' => {
  		'title' => 'WIN32 Registry',
  		'description' => 'LMachine/System/CurrentControlSet/Service/VxD/MSTCP/Domain',
  		'exec' => sub {
  			return eval q{
  				use Win32::TieRegistry ( TiedHash => '%RegistryHash' );
  				$RegistryHash{'LMachine'}{'System'}{'CurrentControlSet'}{'Services'}{'VxD'}{'MSTCP'}{'Domain'};
  			};
  		},
  	},
  
  	'uname' => {
  		'title' => 'POSIX::uname',
  		'description' => '',
  		'exec' => sub {
  			return eval {
  				local $SIG{__DIE__};
  				require POSIX;
  				(POSIX::uname())[1];
  			};
  		},
  	},
  
  	# XXX This is the same as above - what happened to the other one !!!
  	'win32_registry2' => {
  		'title' => 'WIN32 Registry',
  		'description' => 'LMachine/System/CurrentControlSet/Services/VxD/MSTCP/Domain',
  		'exec' => sub {
  			return eval q{
  				use Win32::TieRegistry ( TiedHash => '%RegistryHash' );
  				$RegistryHash{'LMachine'}{'System'}{'CurrentControlSet'}{'Services'}{'VxD'}{'MSTCP'}{'Domain'};
  			};
  		},
  	},
  
  	'exec_hostname_fqdn' => {
  		'title' => 'Execute "hostname --fqdn"',
  		'description' => '',
  		'exec' => sub {
  			# Skip for Solaris, and only run as non-root
  			# Skip for darwin (Mac OS X), RT#28894
  			my $tmp;
  			if ( $^O ne 'darwin' ) {
  				if ($< == 0) {
  					$tmp = `su nobody -c "hostname --fqdn"`;
  				} else {
  					$tmp = `hostname --fqdn`;
  				}
  				$tmp =~ tr/\0\r\n//d;
  			}
  			return $tmp;
  		},
  	},
  
  	'exec_hostname_domainname' => {
  		'title' => 'Execute "hostname" and "domainname"',
  		'description' => '',
  		'exec' => sub {
  			my $tmp = `hostname` . '.' . `domainname`;
  			$tmp =~ tr/\0\r\n//d;
  			return $tmp;
  		},
  	},
  
  
  	'network' => {
  		'title' => 'Network Socket hostname (not DNS)',
  		'description' => '',
  		'exec' => sub {
  			return eval q{
  				use IO::Socket;
  				my $s = IO::Socket::INET->new(
  					# m.root-servers.net (a remote IP number)
  					PeerAddr => '202.12.27.33',
  					# random safe port
  					PeerPort => 2000,
  					# We don't actually want to connect
  					Proto => 'udp',
  				) or die "Faile socket - $!";
  				gethostbyaddr($s->sockaddr(), AF_INET);
  			};
  		},
  	},
  
  	'ip' => {
  		'title' => 'Network Socket IP then Hostname via DNS',
  		'description' => '',
  		'exec' => sub {
  			return eval q{
  				use IO::Socket;
  				my $s = IO::Socket::INET->new(
  					# m.root-servers.net (a remote IP number)
  					PeerAddr => '202.12.27.33',
  					# random safe port
  					PeerPort => 2000,
  					# We don't actually want to connect
  					Proto => 'udp',
  				) or die "Faile socket - $!";
  				$s->sockhost;
  			};
  		},
  	},
  
  );
  
  # Dispatch from table
  sub dispatcher {
  	my ($method, @rest) = @_;
  	$lastdispatch = $method;
  	return $dispatch{$method}{exec}(@rest);
  }
  
  sub dispatch_keys {
  	return sort keys %dispatch;
  }
  
  sub dispatch_title {
  	return $dispatch{$_[0]}{title};
  }
  
  sub dispatch_description {
  	return $dispatch{$_[0]}{description};
  }
  
  sub hostname_long {
  	return $hostlong if defined $hostlong; 	# Cached copy (takes a while to lookup sometimes)
  	my ($ip, $debug) = @_;
  
  	$hostlong = dispatcher('uname');
  
  	unless ($hostlong =~ m|.*\..*|) {
  		if ($^O eq 'MacOS') {
  			# http://bumppo.net/lists/macperl/1999/03/msg00282.html
  			#	suggests that it will work (checking localhost) on both
  			#	Mac and Windows.
  			#	Personally this makes no sense what so ever as
  			$hostlong = dispatcher('gethostbyname');
  
  		} elsif ($^O eq 'IRIX') {	# XXX Patter match string !
  			$hostlong = dispatcher('exec_hostname');
  
  		} elsif ($^O eq 'cygwin') {
  			$hostlong = dispatcher('win32_registry1');
  
  		} elsif ($^O eq 'MSWin32') {
  			$hostlong = dispatcher('win32_registry2');
  
  		} elsif ($^O =~ m/(bsd|nto)/i) {
  			$hostlong = dispatcher('exec_hostname');
  
  		# (covered above) } elsif ($^O eq "darwin") {
  		#	$hostlong = dispatcher('uname');
  
  		} elsif ($^O eq 'solaris') {
  			$hostlong = dispatcher('exec_hostname_domainname');
  
  		} else {
  			$hostlong = dispatcher('exec_hostname_fqdn');
  		}
  
  		if (!defined($hostlong) || $hostlong eq "") {
  			# FALL BACK - Requires working internet and DNS and reverse
  			# lookups of your IP number.
  			$hostlong = dispatcher('network');
  		}
  
  		if ($ip && !defined($hostlong) || $hostlong eq "") {
  			$hostlong = dispatcher('ip');
  		}
  	}
  	warn "Sys::Hostname::Long - Last Dispatch method = $lastdispatch" if ($debug);
  	return $hostlong;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Sys::Hostname::Long - Try every conceivable way to get full hostname
  
  =head1 SYNOPSIS
  
      use Sys::Hostname::Long;
      $host_long = hostname_long;
  
  =head1 DESCRIPTION
  
  How to get the host full name in perl on multiple operating systems (mac,
  windows, unix* etc)
  
  =head1 DISCUSSION
  
  This is the SECOND release of this code. It has an improved set of tests and
  improved interfaces - but it is still often failing to get a full host name.
  This of course is the reason I wrote the module, it is difficult to get full
  host names accurately on each system. On some systems (eg: Linux) it is
  dependent on the order of the entries in /etc/hosts.
  
  To make it easier to test I have testall.pl to generate an output list of all
  methods. Thus even if the logic is incorrect, it may be possible to get the
  full name.
  
  Attempt via many methods to get the systems full name. The L<Sys::Hostname>
  class is the best and standard way to get the system hostname. However it is
  missing the long hostname.
  
  Special thanks to B<David Sundstrom> and B<Greg Bacon> for the original
  L<Sys::Hostname>
  
  =head1 SUPPORT
  
  This is the original list of platforms tested.
  
  	MacOS		Macintosh Classic		OK
  	Win32		MS Windows (95,98,nt,2000...)
  			98				OK
  	MacOS X		Macintosh 10			OK
  			(other darwin)			Probably OK (not tested)
  	Linux 		Linux UNIX OS			OK
  			Sparc				OK
  	HPUX		H.P. Unix 10?			Not Tested
  	Solaris		SUN Solaris 7?			OK (now)
  	Irix		SGI Irix 5?			Not Tested
  	FreeBSD		FreeBSD				OK
  
  A new list has now been compiled of all the operating systems so that I can
  individually keep information on their success.
  
  THIS IS IN NEED OF AN UPDATE AFTER NEXT RELEASE.
  
  =over 4
  
  =item Acorn - Not yet tested
  
  =item AIX - Not yet tested
  
  =item Amiga - Not yet tested
  
  =item Atari - Not yet tested
  
  =item AtheOS - Not yet tested
  
  =item BeOS - Not yet tested
  
  =item BSD - Not yet tested
  
  =item BSD/OS - Not yet tested
  
  =item Compaq - Not yet tested
  
  =item Cygwin - Not yet tested
  
  =item Concurrent - Not yet tested
  
  =item DG/UX - Not yet tested
  
  =item Digital - Not yet tested
  
  =item DEC OSF/1 - Not yet tested
  
  =item Digital UNIX - Not yet tested
  
  =item DYNIX/ptx - Not yet tested
  
  =item EPOC - Not yet tested
  
  =item FreeBSD - Not yet tested
  
  =item Fujitsu-Siemens - Not yet tested
  
  =item Guardian - Not yet tested
  
  =item HP - Not yet tested
  
  =item HP-UX - Not yet tested
  
  =item IBM - Not yet tested
  
  =item IRIX - Not yet tested - 3rd hand information might be ok.
  
  =item Japanese - Not yet tested
  
  =item JPerl - Not yet tested
  
  =item Linux
  
  =over 8
  
  =item Debian - Not yet tested
  
  =item Gentoo - Not yet tested
  
  =item Mandrake - Not yet tested
  
  =item Red Hat- Not yet tested
  
  =item Slackware - Not yet tested
  
  =item SuSe - Not yet tested
  
  =item Yellowdog - Not yet tested
  
  =back
  
  =item LynxOS - Not yet tested
  
  =item Mac OS - Not yet tested
  
  =item Mac OS X - OK 20040315 (v1.1)
  
  =item MachTen - Not yet tested
  
  =item Minix - Not yet tested
  
  =item MinGW - Not yet tested
  
  =item MiNT - Not yet tested
  
  =item MPE/iX - Not yet tested
  
  =item MS-DOS - Not yet tested
  
  =item MVS - Not yet tested
  
  =item NetBSD - Not yet tested
  
  =item NetWare - Not yet tested
  
  =item NEWS-OS - Not yet tested
  
  =item NextStep - Not yet tested
  
  =item Novell - Not yet tested
  
  =item NonStop - Not yet tested
  
  =item NonStop-UX - Not yet tested
  
  =item OpenBSD - Not yet tested
  
  =item ODT - Not yet tested
  
  =item OpenVMS - Not yet tested
  
  =item Open UNIX - Not yet tested
  
  =item OS/2 - Not yet tested
  
  =item OS/390 - Not yet tested
  
  =item OS/400 - Not yet tested
  
  =item OSF/1 - Not yet tested
  
  =item OSR - Not yet tested
  
  =item Plan 9 - Not yet tested
  
  =item Pocket PC - Not yet tested
  
  =item PowerMAX - Not yet tested
  
  =item Psion - Not yet tested
  
  =item QNX
  
  =over 8
  
  =item 4 - Not yet tested
  
  =item 6 (Neutrino) - Not yet tested
  
  =back
  
  =item Reliant UNIX - Not yet tested
  
  =item RISCOS - Not yet tested
  
  =item SCO - Not yet tested
  
  =item SGI - Not yet tested
  
  =item Symbian - Not yet tested
  
  =item Sequent - Not yet tested
  
  =item Siemens - Not yet tested
  
  =item SINIX - Not yet tested
  
  =item Solaris - Not yet tested
  
  =item SONY - Not yet tested
  
  =item Sun - Not yet tested
  
  =item Stratus - Not yet tested
  
  =item Tandem - Not yet tested
  
  =item Tru64 - Not yet tested
  
  =item Ultrix - Not yet tested
  
  =item UNIX - Not yet tested
  
  =item U/WIN - Not yet tested
  
  =item Unixware - Not yet tested
  
  =item VMS - Not yet tested
  
  =item VOS - Not yet tested
  
  =item Windows
  
  =over 8
  
  =item CE - Not yet tested
  
  =item 3.1 - Not yet tested
  
  =item 95 - Not yet tested
  
  =item 98 - Not yet tested
  
  =item Me - Not yet tested
  
  =item NT - Not yet tested
  
  =item 2000 - Not yet tested
  
  =item XP - Not yet tested
  
  =back
  
  =item z/OS - Not yet tested
  
  =back
  
  =head1 KNOWN LIMITATIONS
  
  =head2 Unix
  
  Most unix systems have trouble working out the fully qualified domain name as
  it to be configured somewhere in the system correctly. For example in most
  linux systems (debian, ?) the fully qualified name should be the first entry
  next to the ip number in /etc/hosts
  
  	192.168.0.1	fred.somwhere.special	fred
  
  If it is the other way around, it will fail.
  
  =head2 Mac
  
  =head1 TODO
  
  Contributions
  
  	David Dick
  	Graeme Hart
  	Piotr Klaban
  
  	* Extra code from G
  	* Dispatch table
  	* List of all operating systems.
  
  Solaris
  	* Fall back 2 - TCP with DNS works ok
  	* Also can read /etc/defaultdomain file
  
  =head1 SEE ALSO
  
  	L<Sys::Hostname>
  
  =head1 AUTHOR
  
  Originally by Scott Penrose E<lt>F<scottp@dd.com.au>E<gt>
  
  Contributions: Michiel Beijen E<lt>F<michiel.beijen@gmail.com>E<gt>
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2001,2004,2005,2015 Scott Penrose. All rights reserved.
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
PERL5_SYS_HOSTNAME_LONG

$fatpacked{"perl5/Test/Builder.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_TEST_BUILDER';
  package Test::Builder;
  
  use 5.006;
  use strict;
  use warnings;
  
  our $VERSION = '1.001014';
  $VERSION = eval $VERSION;    ## no critic (BuiltinFunctions::ProhibitStringyEval)
  
  BEGIN {
      if( $] < 5.008 ) {
          require Test::Builder::IO::Scalar;
      }
  }
  
  
  # Make Test::Builder thread-safe for ithreads.
  BEGIN {
      use Config;
      # Load threads::shared when threads are turned on.
      # 5.8.0's threads are so busted we no longer support them.
      if( $] >= 5.008001 && $Config{useithreads} && $INC{'threads.pm'} ) {
          require threads::shared;
  
          # Hack around YET ANOTHER threads::shared bug.  It would
          # occasionally forget the contents of the variable when sharing it.
          # So we first copy the data, then share, then put our copy back.
          *share = sub (\[$@%]) {
              my $type = ref $_[0];
              my $data;
  
              if( $type eq 'HASH' ) {
                  %$data = %{ $_[0] };
              }
              elsif( $type eq 'ARRAY' ) {
                  @$data = @{ $_[0] };
              }
              elsif( $type eq 'SCALAR' ) {
                  $$data = ${ $_[0] };
              }
              else {
                  die( "Unknown type: " . $type );
              }
  
              $_[0] = &threads::shared::share( $_[0] );
  
              if( $type eq 'HASH' ) {
                  %{ $_[0] } = %$data;
              }
              elsif( $type eq 'ARRAY' ) {
                  @{ $_[0] } = @$data;
              }
              elsif( $type eq 'SCALAR' ) {
                  ${ $_[0] } = $$data;
              }
              else {
                  die( "Unknown type: " . $type );
              }
  
              return $_[0];
          };
      }
      # 5.8.0's threads::shared is busted when threads are off
      # and earlier Perls just don't have that module at all.
      else {
          *share = sub { return $_[0] };
          *lock  = sub { 0 };
      }
  }
  
  =head1 NAME
  
  Test::Builder - Backend for building test libraries
  
  =head1 SYNOPSIS
  
    package My::Test::Module;
    use base 'Test::Builder::Module';
  
    my $CLASS = __PACKAGE__;
  
    sub ok {
        my($test, $name) = @_;
        my $tb = $CLASS->builder;
  
        $tb->ok($test, $name);
    }
  
  
  =head1 DESCRIPTION
  
  L<Test::Simple> and L<Test::More> have proven to be popular testing modules,
  but they're not always flexible enough.  Test::Builder provides a
  building block upon which to write your own test libraries I<which can
  work together>.
  
  =head2 Construction
  
  =over 4
  
  =item B<new>
  
    my $Test = Test::Builder->new;
  
  Returns a Test::Builder object representing the current state of the
  test.
  
  Since you only run one test per program C<new> always returns the same
  Test::Builder object.  No matter how many times you call C<new()>, you're
  getting the same object.  This is called a singleton.  This is done so that
  multiple modules share such global information as the test counter and
  where test output is going.
  
  If you want a completely new Test::Builder object different from the
  singleton, use C<create>.
  
  =cut
  
  our $Test = Test::Builder->new;
  
  sub new {
      my($class) = shift;
      $Test ||= $class->create;
      return $Test;
  }
  
  =item B<create>
  
    my $Test = Test::Builder->create;
  
  Ok, so there can be more than one Test::Builder object and this is how
  you get it.  You might use this instead of C<new()> if you're testing
  a Test::Builder based module, but otherwise you probably want C<new>.
  
  B<NOTE>: the implementation is not complete.  C<level>, for example, is
  still shared amongst B<all> Test::Builder objects, even ones created using
  this method.  Also, the method name may change in the future.
  
  =cut
  
  sub create {
      my $class = shift;
  
      my $self = bless {}, $class;
      $self->reset;
  
      return $self;
  }
  
  
  # Copy an object, currently a shallow.
  # This does *not* bless the destination.  This keeps the destructor from
  # firing when we're just storing a copy of the object to restore later.
  sub _copy {
      my($src, $dest) = @_;
  
      %$dest = %$src;
      _share_keys($dest);
  
      return;
  }
  
  
  =item B<child>
  
    my $child = $builder->child($name_of_child);
    $child->plan( tests => 4 );
    $child->ok(some_code());
    ...
    $child->finalize;
  
  Returns a new instance of C<Test::Builder>.  Any output from this child will
  be indented four spaces more than the parent's indentation.  When done, the
  C<finalize> method I<must> be called explicitly.
  
  Trying to create a new child with a previous child still active (i.e.,
  C<finalize> not called) will C<croak>.
  
  Trying to run a test when you have an open child will also C<croak> and cause
  the test suite to fail.
  
  =cut
  
  sub child {
      my( $self, $name ) = @_;
  
      if( $self->{Child_Name} ) {
          $self->croak("You already have a child named ($self->{Child_Name}) running");
      }
  
      my $parent_in_todo = $self->in_todo;
  
      # Clear $TODO for the child.
      my $orig_TODO = $self->find_TODO(undef, 1, undef);
  
      my $class = ref $self;
      my $child = $class->create;
  
      # Add to our indentation
      $child->_indent( $self->_indent . '    ' );
  
      # Make the child use the same outputs as the parent
      for my $method (qw(output failure_output todo_output)) {
          $child->$method( $self->$method );
      }
  
      # Ensure the child understands if they're inside a TODO
      if( $parent_in_todo ) {
          $child->failure_output( $self->todo_output );
      }
  
      # This will be reset in finalize. We do this here lest one child failure
      # cause all children to fail.
      $child->{Child_Error} = $?;
      $?                    = 0;
      $child->{Parent}      = $self;
      $child->{Parent_TODO} = $orig_TODO;
      $child->{Name}        = $name || "Child of " . $self->name;
      $self->{Child_Name}   = $child->name;
      return $child;
  }
  
  
  =item B<subtest>
  
      $builder->subtest($name, \&subtests, @args);
  
  See documentation of C<subtest> in Test::More.  
  
  C<subtest> also, and optionally, accepts arguments which will be passed to the
  subtests reference.
  
  =cut
  
  sub subtest {
      my $self = shift;
      my($name, $subtests, @args) = @_;
  
      if ('CODE' ne ref $subtests) {
          $self->croak("subtest()'s second argument must be a code ref");
      }
  
      # Turn the child into the parent so anyone who has stored a copy of
      # the Test::Builder singleton will get the child.
      my $error;
      my $child;
      my $parent = {};
      {
          # child() calls reset() which sets $Level to 1, so we localize
          # $Level first to limit the scope of the reset to the subtest.
          local $Test::Builder::Level = $Test::Builder::Level + 1;
  
          # Store the guts of $self as $parent and turn $child into $self.
          $child  = $self->child($name);
          _copy($self,  $parent);
          _copy($child, $self);
  
          my $run_the_subtests = sub {
              # Add subtest name for clarification of starting point
              $self->note("Subtest: $name");
              $subtests->(@args);
              $self->done_testing unless $self->_plan_handled;
              1;
          };
  
          if( !eval { $run_the_subtests->() } ) {
              $error = $@;
          }
      }
  
      # Restore the parent and the copied child.
      _copy($self,   $child);
      _copy($parent, $self);
  
      # Restore the parent's $TODO
      $self->find_TODO(undef, 1, $child->{Parent_TODO});
  
      # Die *after* we restore the parent.
      die $error if $error and !eval { $error->isa('Test::Builder::Exception') };
  
      local $Test::Builder::Level = $Test::Builder::Level + 1;
      my $finalize = $child->finalize;
  
      $self->BAIL_OUT($child->{Bailed_Out_Reason}) if $child->{Bailed_Out};
  
      return $finalize;
  }
  
  =begin _private
  
  =item B<_plan_handled>
  
      if ( $Test->_plan_handled ) { ... }
  
  Returns true if the developer has explicitly handled the plan via:
  
  =over 4
  
  =item * Explicitly setting the number of tests
  
  =item * Setting 'no_plan'
  
  =item * Set 'skip_all'.
  
  =back
  
  This is currently used in subtests when we implicitly call C<< $Test->done_testing >>
  if the developer has not set a plan.
  
  =end _private
  
  =cut
  
  sub _plan_handled {
      my $self = shift;
      return $self->{Have_Plan} || $self->{No_Plan} || $self->{Skip_All};
  }
  
  
  =item B<finalize>
  
    my $ok = $child->finalize;
  
  When your child is done running tests, you must call C<finalize> to clean up
  and tell the parent your pass/fail status.
  
  Calling C<finalize> on a child with open children will C<croak>.
  
  If the child falls out of scope before C<finalize> is called, a failure
  diagnostic will be issued and the child is considered to have failed.
  
  No attempt to call methods on a child after C<finalize> is called is
  guaranteed to succeed.
  
  Calling this on the root builder is a no-op.
  
  =cut
  
  sub finalize {
      my $self = shift;
  
      return unless $self->parent;
      if( $self->{Child_Name} ) {
          $self->croak("Can't call finalize() with child ($self->{Child_Name}) active");
      }
  
      local $? = 0;     # don't fail if $subtests happened to set $? nonzero
      $self->_ending;
  
      # XXX This will only be necessary for TAP envelopes (we think)
      #$self->_print( $self->is_passing ? "PASS\n" : "FAIL\n" );
  
      local $Test::Builder::Level = $Test::Builder::Level + 1;
      my $ok = 1;
      $self->parent->{Child_Name} = undef;
      unless ($self->{Bailed_Out}) {
          if ( $self->{Skip_All} ) {
              $self->parent->skip($self->{Skip_All}, $self->name);
          }
          elsif ( not @{ $self->{Test_Results} } ) {
              $self->parent->ok( 0, sprintf q[No tests run for subtest "%s"], $self->name );
          }
          else {
              $self->parent->ok( $self->is_passing, $self->name );
          }
      }
      $? = $self->{Child_Error};
      delete $self->{Parent};
  
      return $self->is_passing;
  }
  
  sub _indent      {
      my $self = shift;
  
      if( @_ ) {
          $self->{Indent} = shift;
      }
  
      return $self->{Indent};
  }
  
  =item B<parent>
  
   if ( my $parent = $builder->parent ) {
       ...
   }
  
  Returns the parent C<Test::Builder> instance, if any.  Only used with child
  builders for nested TAP.
  
  =cut
  
  sub parent { shift->{Parent} }
  
  =item B<name>
  
   diag $builder->name;
  
  Returns the name of the current builder.  Top level builders default to C<$0>
  (the name of the executable).  Child builders are named via the C<child>
  method.  If no name is supplied, will be named "Child of $parent->name".
  
  =cut
  
  sub name { shift->{Name} }
  
  sub DESTROY {
      my $self = shift;
      if ( $self->parent and $$ == $self->{Original_Pid} ) {
          my $name = $self->name;
          $self->diag(<<"FAIL");
  Child ($name) exited without calling finalize()
  FAIL
          $self->parent->{In_Destroy} = 1;
          $self->parent->ok(0, $name);
      }
  }
  
  =item B<reset>
  
    $Test->reset;
  
  Reinitializes the Test::Builder singleton to its original state.
  Mostly useful for tests run in persistent environments where the same
  test might be run multiple times in the same process.
  
  =cut
  
  our $Level;
  
  sub reset {    ## no critic (Subroutines::ProhibitBuiltinHomonyms)
      my($self) = @_;
  
      # We leave this a global because it has to be localized and localizing
      # hash keys is just asking for pain.  Also, it was documented.
      $Level = 1;
  
      $self->{Name}         = $0;
      $self->is_passing(1);
      $self->{Ending}       = 0;
      $self->{Have_Plan}    = 0;
      $self->{No_Plan}      = 0;
      $self->{Have_Output_Plan} = 0;
      $self->{Done_Testing} = 0;
  
      $self->{Original_Pid} = $$;
      $self->{Child_Name}   = undef;
      $self->{Indent}     ||= '';
  
      $self->{Curr_Test} = 0;
      $self->{Test_Results} = &share( [] );
  
      $self->{Exported_To}    = undef;
      $self->{Expected_Tests} = 0;
  
      $self->{Skip_All} = 0;
  
      $self->{Use_Nums} = 1;
  
      $self->{No_Header} = 0;
      $self->{No_Ending} = 0;
  
      $self->{Todo}       = undef;
      $self->{Todo_Stack} = [];
      $self->{Start_Todo} = 0;
      $self->{Opened_Testhandles} = 0;
  
      $self->_share_keys;
      $self->_dup_stdhandles;
  
      return;
  }
  
  
  # Shared scalar values are lost when a hash is copied, so we have
  # a separate method to restore them.
  # Shared references are retained across copies.
  sub _share_keys {
      my $self = shift;
  
      share( $self->{Curr_Test} );
  
      return;
  }
  
  
  =back
  
  =head2 Setting up tests
  
  These methods are for setting up tests and declaring how many there
  are.  You usually only want to call one of these methods.
  
  =over 4
  
  =item B<plan>
  
    $Test->plan('no_plan');
    $Test->plan( skip_all => $reason );
    $Test->plan( tests => $num_tests );
  
  A convenient way to set up your tests.  Call this and Test::Builder
  will print the appropriate headers and take the appropriate actions.
  
  If you call C<plan()>, don't call any of the other methods below.
  
  If a child calls "skip_all" in the plan, a C<Test::Builder::Exception> is
  thrown.  Trap this error, call C<finalize()> and don't run any more tests on
  the child.
  
   my $child = $Test->child('some child');
   eval { $child->plan( $condition ? ( skip_all => $reason ) : ( tests => 3 )  ) };
   if ( eval { $@->isa('Test::Builder::Exception') } ) {
      $child->finalize;
      return;
   }
   # run your tests
  
  =cut
  
  my %plan_cmds = (
      no_plan     => \&no_plan,
      skip_all    => \&skip_all,
      tests       => \&_plan_tests,
  );
  
  sub plan {
      my( $self, $cmd, $arg ) = @_;
  
      return unless $cmd;
  
      local $Level = $Level + 1;
  
      $self->croak("You tried to plan twice") if $self->{Have_Plan};
  
      if( my $method = $plan_cmds{$cmd} ) {
          local $Level = $Level + 1;
          $self->$method($arg);
      }
      else {
          my @args = grep { defined } ( $cmd, $arg );
          $self->croak("plan() doesn't understand @args");
      }
  
      return 1;
  }
  
  
  sub _plan_tests {
      my($self, $arg) = @_;
  
      if($arg) {
          local $Level = $Level + 1;
          return $self->expected_tests($arg);
      }
      elsif( !defined $arg ) {
          $self->croak("Got an undefined number of tests");
      }
      else {
          $self->croak("You said to run 0 tests");
      }
  
      return;
  }
  
  =item B<expected_tests>
  
      my $max = $Test->expected_tests;
      $Test->expected_tests($max);
  
  Gets/sets the number of tests we expect this test to run and prints out
  the appropriate headers.
  
  =cut
  
  sub expected_tests {
      my $self = shift;
      my($max) = @_;
  
      if(@_) {
          $self->croak("Number of tests must be a positive integer.  You gave it '$max'")
            unless $max =~ /^\+?\d+$/;
  
          $self->{Expected_Tests} = $max;
          $self->{Have_Plan}      = 1;
  
          $self->_output_plan($max) unless $self->no_header;
      }
      return $self->{Expected_Tests};
  }
  
  =item B<no_plan>
  
    $Test->no_plan;
  
  Declares that this test will run an indeterminate number of tests.
  
  =cut
  
  sub no_plan {
      my($self, $arg) = @_;
  
      $self->carp("no_plan takes no arguments") if $arg;
  
      $self->{No_Plan}   = 1;
      $self->{Have_Plan} = 1;
  
      return 1;
  }
  
  =begin private
  
  =item B<_output_plan>
  
    $tb->_output_plan($max);
    $tb->_output_plan($max, $directive);
    $tb->_output_plan($max, $directive => $reason);
  
  Handles displaying the test plan.
  
  If a C<$directive> and/or C<$reason> are given they will be output with the
  plan.  So here's what skipping all tests looks like:
  
      $tb->_output_plan(0, "SKIP", "Because I said so");
  
  It sets C<< $tb->{Have_Output_Plan} >> and will croak if the plan was already
  output.
  
  =end private
  
  =cut
  
  sub _output_plan {
      my($self, $max, $directive, $reason) = @_;
  
      $self->carp("The plan was already output") if $self->{Have_Output_Plan};
  
      my $plan = "1..$max";
      $plan .= " # $directive" if defined $directive;
      $plan .= " $reason"      if defined $reason;
  
      $self->_print("$plan\n");
  
      $self->{Have_Output_Plan} = 1;
  
      return;
  }
  
  
  =item B<done_testing>
  
    $Test->done_testing();
    $Test->done_testing($num_tests);
  
  Declares that you are done testing, no more tests will be run after this point.
  
  If a plan has not yet been output, it will do so.
  
  $num_tests is the number of tests you planned to run.  If a numbered
  plan was already declared, and if this contradicts, a failing test
  will be run to reflect the planning mistake.  If C<no_plan> was declared,
  this will override.
  
  If C<done_testing()> is called twice, the second call will issue a
  failing test.
  
  If C<$num_tests> is omitted, the number of tests run will be used, like
  no_plan.
  
  C<done_testing()> is, in effect, used when you'd want to use C<no_plan>, but
  safer. You'd use it like so:
  
      $Test->ok($a == $b);
      $Test->done_testing();
  
  Or to plan a variable number of tests:
  
      for my $test (@tests) {
          $Test->ok($test);
      }
      $Test->done_testing(scalar @tests);
  
  =cut
  
  sub done_testing {
      my($self, $num_tests) = @_;
  
      # If done_testing() specified the number of tests, shut off no_plan.
      if( defined $num_tests ) {
          $self->{No_Plan} = 0;
      }
      else {
          $num_tests = $self->current_test;
      }
  
      if( $self->{Done_Testing} ) {
          my($file, $line) = @{$self->{Done_Testing}}[1,2];
          $self->ok(0, "done_testing() was already called at $file line $line");
          return;
      }
  
      $self->{Done_Testing} = [caller];
  
      if( $self->expected_tests && $num_tests != $self->expected_tests ) {
          $self->ok(0, "planned to run @{[ $self->expected_tests ]} ".
                       "but done_testing() expects $num_tests");
      }
      else {
          $self->{Expected_Tests} = $num_tests;
      }
  
      $self->_output_plan($num_tests) unless $self->{Have_Output_Plan};
  
      $self->{Have_Plan} = 1;
  
      # The wrong number of tests were run
      $self->is_passing(0) if $self->{Expected_Tests} != $self->{Curr_Test};
  
      # No tests were run
      $self->is_passing(0) if $self->{Curr_Test} == 0;
  
      return 1;
  }
  
  
  =item B<has_plan>
  
    $plan = $Test->has_plan
  
  Find out whether a plan has been defined. C<$plan> is either C<undef> (no plan
  has been set), C<no_plan> (indeterminate # of tests) or an integer (the number
  of expected tests).
  
  =cut
  
  sub has_plan {
      my $self = shift;
  
      return( $self->{Expected_Tests} ) if $self->{Expected_Tests};
      return('no_plan') if $self->{No_Plan};
      return(undef);
  }
  
  =item B<skip_all>
  
    $Test->skip_all;
    $Test->skip_all($reason);
  
  Skips all the tests, using the given C<$reason>.  Exits immediately with 0.
  
  =cut
  
  sub skip_all {
      my( $self, $reason ) = @_;
  
      $self->{Skip_All} = $self->parent ? $reason : 1;
  
      $self->_output_plan(0, "SKIP", $reason) unless $self->no_header;
      if ( $self->parent ) {
          die bless {} => 'Test::Builder::Exception';
      }
      exit(0);
  }
  
  =item B<exported_to>
  
    my $pack = $Test->exported_to;
    $Test->exported_to($pack);
  
  Tells Test::Builder what package you exported your functions to.
  
  This method isn't terribly useful since modules which share the same
  Test::Builder object might get exported to different packages and only
  the last one will be honored.
  
  =cut
  
  sub exported_to {
      my( $self, $pack ) = @_;
  
      if( defined $pack ) {
          $self->{Exported_To} = $pack;
      }
      return $self->{Exported_To};
  }
  
  =back
  
  =head2 Running tests
  
  These actually run the tests, analogous to the functions in Test::More.
  
  They all return true if the test passed, false if the test failed.
  
  C<$name> is always optional.
  
  =over 4
  
  =item B<ok>
  
    $Test->ok($test, $name);
  
  Your basic test.  Pass if C<$test> is true, fail if $test is false.  Just
  like Test::Simple's C<ok()>.
  
  =cut
  
  sub ok {
      my( $self, $test, $name ) = @_;
  
      if ( $self->{Child_Name} and not $self->{In_Destroy} ) {
          $name = 'unnamed test' unless defined $name;
          $self->is_passing(0);
          $self->croak("Cannot run test ($name) with active children");
      }
      # $test might contain an object which we don't want to accidentally
      # store, so we turn it into a boolean.
      $test = $test ? 1 : 0;
  
      lock $self->{Curr_Test};
      $self->{Curr_Test}++;
  
      # In case $name is a string overloaded object, force it to stringify.
      $self->_unoverload_str( \$name );
  
      $self->diag(<<"ERR") if defined $name and $name =~ /^[\d\s]+$/;
      You named your test '$name'.  You shouldn't use numbers for your test names.
      Very confusing.
  ERR
  
      # Capture the value of $TODO for the rest of this ok() call
      # so it can more easily be found by other routines.
      my $todo    = $self->todo();
      my $in_todo = $self->in_todo;
      local $self->{Todo} = $todo if $in_todo;
  
      $self->_unoverload_str( \$todo );
  
      my $out;
      my $result = &share( {} );
  
      unless($test) {
          $out .= "not ";
          @$result{ 'ok', 'actual_ok' } = ( ( $self->in_todo ? 1 : 0 ), 0 );
      }
      else {
          @$result{ 'ok', 'actual_ok' } = ( 1, $test );
      }
  
      $out .= "ok";
      $out .= " $self->{Curr_Test}" if $self->use_numbers;
  
      if( defined $name ) {
          $name =~ s|#|\\#|g;    # # in a name can confuse Test::Harness.
          $out .= " - $name";
          $result->{name} = $name;
      }
      else {
          $result->{name} = '';
      }
  
      if( $self->in_todo ) {
          $out .= " # TODO $todo";
          $result->{reason} = $todo;
          $result->{type}   = 'todo';
      }
      else {
          $result->{reason} = '';
          $result->{type}   = '';
      }
  
      $self->{Test_Results}[ $self->{Curr_Test} - 1 ] = $result;
      $out .= "\n";
  
      $self->_print($out);
  
      unless($test) {
          my $msg = $self->in_todo ? "Failed (TODO)" : "Failed";
          $self->_print_to_fh( $self->_diag_fh, "\n" ) if $ENV{HARNESS_ACTIVE};
  
          my( undef, $file, $line ) = $self->caller;
          if( defined $name ) {
              $self->diag(qq[  $msg test '$name'\n]);
              $self->diag(qq[  at $file line $line.\n]);
          }
          else {
              $self->diag(qq[  $msg test at $file line $line.\n]);
          }
      }
  
      $self->is_passing(0) unless $test || $self->in_todo;
  
      # Check that we haven't violated the plan
      $self->_check_is_passing_plan();
  
      return $test ? 1 : 0;
  }
  
  
  # Check that we haven't yet violated the plan and set
  # is_passing() accordingly
  sub _check_is_passing_plan {
      my $self = shift;
  
      my $plan = $self->has_plan;
      return unless defined $plan;        # no plan yet defined
      return unless $plan !~ /\D/;        # no numeric plan
      $self->is_passing(0) if $plan < $self->{Curr_Test};
  }
  
  
  sub _unoverload {
      my $self = shift;
      my $type = shift;
  
      $self->_try(sub { require overload; }, die_on_fail => 1);
  
      foreach my $thing (@_) {
          if( $self->_is_object($$thing) ) {
              if( my $string_meth = overload::Method( $$thing, $type ) ) {
                  $$thing = $$thing->$string_meth();
              }
          }
      }
  
      return;
  }
  
  sub _is_object {
      my( $self, $thing ) = @_;
  
      return $self->_try( sub { ref $thing && $thing->isa('UNIVERSAL') } ) ? 1 : 0;
  }
  
  sub _unoverload_str {
      my $self = shift;
  
      return $self->_unoverload( q[""], @_ );
  }
  
  sub _unoverload_num {
      my $self = shift;
  
      $self->_unoverload( '0+', @_ );
  
      for my $val (@_) {
          next unless $self->_is_dualvar($$val);
          $$val = $$val + 0;
      }
  
      return;
  }
  
  # This is a hack to detect a dualvar such as $!
  sub _is_dualvar {
      my( $self, $val ) = @_;
  
      # Objects are not dualvars.
      return 0 if ref $val;
  
      no warnings 'numeric';
      my $numval = $val + 0;
      return ($numval != 0 and $numval ne $val ? 1 : 0);
  }
  
  =item B<is_eq>
  
    $Test->is_eq($got, $expected, $name);
  
  Like Test::More's C<is()>.  Checks if C<$got eq $expected>.  This is the
  string version.
  
  C<undef> only ever matches another C<undef>.
  
  =item B<is_num>
  
    $Test->is_num($got, $expected, $name);
  
  Like Test::More's C<is()>.  Checks if C<$got == $expected>.  This is the
  numeric version.
  
  C<undef> only ever matches another C<undef>.
  
  =cut
  
  sub is_eq {
      my( $self, $got, $expect, $name ) = @_;
      local $Level = $Level + 1;
  
      if( !defined $got || !defined $expect ) {
          # undef only matches undef and nothing else
          my $test = !defined $got && !defined $expect;
  
          $self->ok( $test, $name );
          $self->_is_diag( $got, 'eq', $expect ) unless $test;
          return $test;
      }
  
      return $self->cmp_ok( $got, 'eq', $expect, $name );
  }
  
  sub is_num {
      my( $self, $got, $expect, $name ) = @_;
      local $Level = $Level + 1;
  
      if( !defined $got || !defined $expect ) {
          # undef only matches undef and nothing else
          my $test = !defined $got && !defined $expect;
  
          $self->ok( $test, $name );
          $self->_is_diag( $got, '==', $expect ) unless $test;
          return $test;
      }
  
      return $self->cmp_ok( $got, '==', $expect, $name );
  }
  
  sub _diag_fmt {
      my( $self, $type, $val ) = @_;
  
      if( defined $$val ) {
          if( $type eq 'eq' or $type eq 'ne' ) {
              # quote and force string context
              $$val = "'$$val'";
          }
          else {
              # force numeric context
              $self->_unoverload_num($val);
          }
      }
      else {
          $$val = 'undef';
      }
  
      return;
  }
  
  sub _is_diag {
      my( $self, $got, $type, $expect ) = @_;
  
      $self->_diag_fmt( $type, $_ ) for \$got, \$expect;
  
      local $Level = $Level + 1;
      return $self->diag(<<"DIAGNOSTIC");
           got: $got
      expected: $expect
  DIAGNOSTIC
  
  }
  
  sub _isnt_diag {
      my( $self, $got, $type ) = @_;
  
      $self->_diag_fmt( $type, \$got );
  
      local $Level = $Level + 1;
      return $self->diag(<<"DIAGNOSTIC");
           got: $got
      expected: anything else
  DIAGNOSTIC
  }
  
  =item B<isnt_eq>
  
    $Test->isnt_eq($got, $dont_expect, $name);
  
  Like L<Test::More>'s C<isnt()>.  Checks if C<$got ne $dont_expect>.  This is
  the string version.
  
  =item B<isnt_num>
  
    $Test->isnt_num($got, $dont_expect, $name);
  
  Like L<Test::More>'s C<isnt()>.  Checks if C<$got ne $dont_expect>.  This is
  the numeric version.
  
  =cut
  
  sub isnt_eq {
      my( $self, $got, $dont_expect, $name ) = @_;
      local $Level = $Level + 1;
  
      if( !defined $got || !defined $dont_expect ) {
          # undef only matches undef and nothing else
          my $test = defined $got || defined $dont_expect;
  
          $self->ok( $test, $name );
          $self->_isnt_diag( $got, 'ne' ) unless $test;
          return $test;
      }
  
      return $self->cmp_ok( $got, 'ne', $dont_expect, $name );
  }
  
  sub isnt_num {
      my( $self, $got, $dont_expect, $name ) = @_;
      local $Level = $Level + 1;
  
      if( !defined $got || !defined $dont_expect ) {
          # undef only matches undef and nothing else
          my $test = defined $got || defined $dont_expect;
  
          $self->ok( $test, $name );
          $self->_isnt_diag( $got, '!=' ) unless $test;
          return $test;
      }
  
      return $self->cmp_ok( $got, '!=', $dont_expect, $name );
  }
  
  =item B<like>
  
    $Test->like($thing, qr/$regex/, $name);
    $Test->like($thing, '/$regex/', $name);
  
  Like L<Test::More>'s C<like()>.  Checks if $thing matches the given C<$regex>.
  
  =item B<unlike>
  
    $Test->unlike($thing, qr/$regex/, $name);
    $Test->unlike($thing, '/$regex/', $name);
  
  Like L<Test::More>'s C<unlike()>.  Checks if $thing B<does not match> the
  given C<$regex>.
  
  =cut
  
  sub like {
      my( $self, $thing, $regex, $name ) = @_;
  
      local $Level = $Level + 1;
      return $self->_regex_ok( $thing, $regex, '=~', $name );
  }
  
  sub unlike {
      my( $self, $thing, $regex, $name ) = @_;
  
      local $Level = $Level + 1;
      return $self->_regex_ok( $thing, $regex, '!~', $name );
  }
  
  =item B<cmp_ok>
  
    $Test->cmp_ok($thing, $type, $that, $name);
  
  Works just like L<Test::More>'s C<cmp_ok()>.
  
      $Test->cmp_ok($big_num, '!=', $other_big_num);
  
  =cut
  
  my %numeric_cmps = map { ( $_, 1 ) } ( "<", "<=", ">", ">=", "==", "!=", "<=>" );
  
  # Bad, these are not comparison operators. Should we include more?
  my %cmp_ok_bl = map { ( $_, 1 ) } ( "=", "+=", ".=", "x=", "^=", "|=", "||=", "&&=", "...");
  
  sub cmp_ok {
      my( $self, $got, $type, $expect, $name ) = @_;
  
      if ($cmp_ok_bl{$type}) {
          $self->croak("$type is not a valid comparison operator in cmp_ok()");
      }
  
      my ($test, $succ);
      my $error;
      {
          ## no critic (BuiltinFunctions::ProhibitStringyEval)
  
          local( $@, $!, $SIG{__DIE__} );    # isolate eval
  
          my($pack, $file, $line) = $self->caller();
  
          # This is so that warnings come out at the caller's level
          $succ = eval qq[
  #line $line "(eval in cmp_ok) $file"
  \$test = (\$got $type \$expect);
  1;
  ];
          $error = $@;
      }
      local $Level = $Level + 1;
      my $ok = $self->ok( $test, $name );
  
      # Treat overloaded objects as numbers if we're asked to do a
      # numeric comparison.
      my $unoverload
        = $numeric_cmps{$type}
        ? '_unoverload_num'
        : '_unoverload_str';
  
      $self->diag(<<"END") unless $succ;
  An error occurred while using $type:
  ------------------------------------
  $error
  ------------------------------------
  END
  
      unless($ok) {
          $self->$unoverload( \$got, \$expect );
  
          if( $type =~ /^(eq|==)$/ ) {
              $self->_is_diag( $got, $type, $expect );
          }
          elsif( $type =~ /^(ne|!=)$/ ) {
              $self->_isnt_diag( $got, $type );
          }
          else {
              $self->_cmp_diag( $got, $type, $expect );
          }
      }
      return $ok;
  }
  
  sub _cmp_diag {
      my( $self, $got, $type, $expect ) = @_;
  
      $got    = defined $got    ? "'$got'"    : 'undef';
      $expect = defined $expect ? "'$expect'" : 'undef';
  
      local $Level = $Level + 1;
      return $self->diag(<<"DIAGNOSTIC");
      $got
          $type
      $expect
  DIAGNOSTIC
  }
  
  sub _caller_context {
      my $self = shift;
  
      my( $pack, $file, $line ) = $self->caller(1);
  
      my $code = '';
      $code .= "#line $line $file\n" if defined $file and defined $line;
  
      return $code;
  }
  
  =back
  
  
  =head2 Other Testing Methods
  
  These are methods which are used in the course of writing a test but are not themselves tests.
  
  =over 4
  
  =item B<BAIL_OUT>
  
      $Test->BAIL_OUT($reason);
  
  Indicates to the L<Test::Harness> that things are going so badly all
  testing should terminate.  This includes running any additional test
  scripts.
  
  It will exit with 255.
  
  =cut
  
  sub BAIL_OUT {
      my( $self, $reason ) = @_;
  
      $self->{Bailed_Out} = 1;
  
      if ($self->parent) {
          $self->{Bailed_Out_Reason} = $reason;
          $self->no_ending(1);
          die bless {} => 'Test::Builder::Exception';
      }
  
      $self->_print("Bail out!  $reason");
      exit 255;
  }
  
  =for deprecated
  BAIL_OUT() used to be BAILOUT()
  
  =cut
  
  {
      no warnings 'once';
      *BAILOUT = \&BAIL_OUT;
  }
  
  =item B<skip>
  
      $Test->skip;
      $Test->skip($why);
  
  Skips the current test, reporting C<$why>.
  
  =cut
  
  sub skip {
      my( $self, $why, $name ) = @_;
      $why ||= '';
      $name = '' unless defined $name;
      $self->_unoverload_str( \$why );
  
      lock( $self->{Curr_Test} );
      $self->{Curr_Test}++;
  
      $self->{Test_Results}[ $self->{Curr_Test} - 1 ] = &share(
          {
              'ok'      => 1,
              actual_ok => 1,
              name      => $name,
              type      => 'skip',
              reason    => $why,
          }
      );
  
      my $out = "ok";
      $out .= " $self->{Curr_Test}" if $self->use_numbers;
      $out .= " # skip";
      $out .= " $why"               if length $why;
      $out .= "\n";
  
      $self->_print($out);
  
      return 1;
  }
  
  =item B<todo_skip>
  
    $Test->todo_skip;
    $Test->todo_skip($why);
  
  Like C<skip()>, only it will declare the test as failing and TODO.  Similar
  to
  
      print "not ok $tnum # TODO $why\n";
  
  =cut
  
  sub todo_skip {
      my( $self, $why ) = @_;
      $why ||= '';
  
      lock( $self->{Curr_Test} );
      $self->{Curr_Test}++;
  
      $self->{Test_Results}[ $self->{Curr_Test} - 1 ] = &share(
          {
              'ok'      => 1,
              actual_ok => 0,
              name      => '',
              type      => 'todo_skip',
              reason    => $why,
          }
      );
  
      my $out = "not ok";
      $out .= " $self->{Curr_Test}" if $self->use_numbers;
      $out .= " # TODO & SKIP $why\n";
  
      $self->_print($out);
  
      return 1;
  }
  
  =begin _unimplemented
  
  =item B<skip_rest>
  
    $Test->skip_rest;
    $Test->skip_rest($reason);
  
  Like C<skip()>, only it skips all the rest of the tests you plan to run
  and terminates the test.
  
  If you're running under C<no_plan>, it skips once and terminates the
  test.
  
  =end _unimplemented
  
  =back
  
  
  =head2 Test building utility methods
  
  These methods are useful when writing your own test methods.
  
  =over 4
  
  =item B<maybe_regex>
  
    $Test->maybe_regex(qr/$regex/);
    $Test->maybe_regex('/$regex/');
  
  This method used to be useful back when Test::Builder worked on Perls
  before 5.6 which didn't have qr//.  Now its pretty useless.
  
  Convenience method for building testing functions that take regular
  expressions as arguments.
  
  Takes a quoted regular expression produced by C<qr//>, or a string
  representing a regular expression.
  
  Returns a Perl value which may be used instead of the corresponding
  regular expression, or C<undef> if its argument is not recognised.
  
  For example, a version of C<like()>, sans the useful diagnostic messages,
  could be written as:
  
    sub laconic_like {
        my ($self, $thing, $regex, $name) = @_;
        my $usable_regex = $self->maybe_regex($regex);
        die "expecting regex, found '$regex'\n"
            unless $usable_regex;
        $self->ok($thing =~ m/$usable_regex/, $name);
    }
  
  =cut
  
  sub maybe_regex {
      my( $self, $regex ) = @_;
      my $usable_regex = undef;
  
      return $usable_regex unless defined $regex;
  
      my( $re, $opts );
  
      # Check for qr/foo/
      if( _is_qr($regex) ) {
          $usable_regex = $regex;
      }
      # Check for '/foo/' or 'm,foo,'
      elsif(( $re, $opts )        = $regex =~ m{^ /(.*)/ (\w*) $ }sx              or
            ( undef, $re, $opts ) = $regex =~ m,^ m([^\w\s]) (.+) \1 (\w*) $,sx
      )
      {
          $usable_regex = length $opts ? "(?$opts)$re" : $re;
      }
  
      return $usable_regex;
  }
  
  sub _is_qr {
      my $regex = shift;
  
      # is_regexp() checks for regexes in a robust manner, say if they're
      # blessed.
      return re::is_regexp($regex) if defined &re::is_regexp;
      return ref $regex eq 'Regexp';
  }
  
  sub _regex_ok {
      my( $self, $thing, $regex, $cmp, $name ) = @_;
  
      my $ok           = 0;
      my $usable_regex = $self->maybe_regex($regex);
      unless( defined $usable_regex ) {
          local $Level = $Level + 1;
          $ok = $self->ok( 0, $name );
          $self->diag("    '$regex' doesn't look much like a regex to me.");
          return $ok;
      }
  
      {
          my $test;
          my $context = $self->_caller_context;
  
          {
              ## no critic (BuiltinFunctions::ProhibitStringyEval)
  
              local( $@, $!, $SIG{__DIE__} );    # isolate eval
  
              # No point in issuing an uninit warning, they'll see it in the diagnostics
              no warnings 'uninitialized';
  
              $test = eval $context . q{$test = $thing =~ /$usable_regex/ ? 1 : 0};
          }
  
          $test = !$test if $cmp eq '!~';
  
          local $Level = $Level + 1;
          $ok = $self->ok( $test, $name );
      }
  
      unless($ok) {
          $thing = defined $thing ? "'$thing'" : 'undef';
          my $match = $cmp eq '=~' ? "doesn't match" : "matches";
  
          local $Level = $Level + 1;
          $self->diag( sprintf <<'DIAGNOSTIC', $thing, $match, $regex );
                    %s
      %13s '%s'
  DIAGNOSTIC
  
      }
  
      return $ok;
  }
  
  # I'm not ready to publish this.  It doesn't deal with array return
  # values from the code or context.
  
  =begin private
  
  =item B<_try>
  
      my $return_from_code          = $Test->try(sub { code });
      my($return_from_code, $error) = $Test->try(sub { code });
  
  Works like eval BLOCK except it ensures it has no effect on the rest
  of the test (ie. C<$@> is not set) nor is effected by outside
  interference (ie. C<$SIG{__DIE__}>) and works around some quirks in older
  Perls.
  
  C<$error> is what would normally be in C<$@>.
  
  It is suggested you use this in place of eval BLOCK.
  
  =cut
  
  sub _try {
      my( $self, $code, %opts ) = @_;
  
      my $error;
      my $return;
      {
          local $!;               # eval can mess up $!
          local $@;               # don't set $@ in the test
          local $SIG{__DIE__};    # don't trip an outside DIE handler.
          $return = eval { $code->() };
          $error = $@;
      }
  
      die $error if $error and $opts{die_on_fail};
  
      return wantarray ? ( $return, $error ) : $return;
  }
  
  =end private
  
  
  =item B<is_fh>
  
      my $is_fh = $Test->is_fh($thing);
  
  Determines if the given C<$thing> can be used as a filehandle.
  
  =cut
  
  sub is_fh {
      my $self     = shift;
      my $maybe_fh = shift;
      return 0 unless defined $maybe_fh;
  
      return 1 if ref $maybe_fh  eq 'GLOB';    # its a glob ref
      return 1 if ref \$maybe_fh eq 'GLOB';    # its a glob
  
      return eval { $maybe_fh->isa("IO::Handle") } ||
             eval { tied($maybe_fh)->can('TIEHANDLE') };
  }
  
  =back
  
  
  =head2 Test style
  
  
  =over 4
  
  =item B<level>
  
      $Test->level($how_high);
  
  How far up the call stack should C<$Test> look when reporting where the
  test failed.
  
  Defaults to 1.
  
  Setting L<$Test::Builder::Level> overrides.  This is typically useful
  localized:
  
      sub my_ok {
          my $test = shift;
  
          local $Test::Builder::Level = $Test::Builder::Level + 1;
          $TB->ok($test);
      }
  
  To be polite to other functions wrapping your own you usually want to increment C<$Level> rather than set it to a constant.
  
  =cut
  
  sub level {
      my( $self, $level ) = @_;
  
      if( defined $level ) {
          $Level = $level;
      }
      return $Level;
  }
  
  =item B<use_numbers>
  
      $Test->use_numbers($on_or_off);
  
  Whether or not the test should output numbers.  That is, this if true:
  
    ok 1
    ok 2
    ok 3
  
  or this if false
  
    ok
    ok
    ok
  
  Most useful when you can't depend on the test output order, such as
  when threads or forking is involved.
  
  Defaults to on.
  
  =cut
  
  sub use_numbers {
      my( $self, $use_nums ) = @_;
  
      if( defined $use_nums ) {
          $self->{Use_Nums} = $use_nums;
      }
      return $self->{Use_Nums};
  }
  
  =item B<no_diag>
  
      $Test->no_diag($no_diag);
  
  If set true no diagnostics will be printed.  This includes calls to
  C<diag()>.
  
  =item B<no_ending>
  
      $Test->no_ending($no_ending);
  
  Normally, Test::Builder does some extra diagnostics when the test
  ends.  It also changes the exit code as described below.
  
  If this is true, none of that will be done.
  
  =item B<no_header>
  
      $Test->no_header($no_header);
  
  If set to true, no "1..N" header will be printed.
  
  =cut
  
  foreach my $attribute (qw(No_Header No_Ending No_Diag)) {
      my $method = lc $attribute;
  
      my $code = sub {
          my( $self, $no ) = @_;
  
          if( defined $no ) {
              $self->{$attribute} = $no;
          }
          return $self->{$attribute};
      };
  
      no strict 'refs';    ## no critic
      *{ __PACKAGE__ . '::' . $method } = $code;
  }
  
  =back
  
  =head2 Output
  
  Controlling where the test output goes.
  
  It's ok for your test to change where STDOUT and STDERR point to,
  Test::Builder's default output settings will not be affected.
  
  =over 4
  
  =item B<diag>
  
      $Test->diag(@msgs);
  
  Prints out the given C<@msgs>.  Like C<print>, arguments are simply
  appended together.
  
  Normally, it uses the C<failure_output()> handle, but if this is for a
  TODO test, the C<todo_output()> handle is used.
  
  Output will be indented and marked with a # so as not to interfere
  with test output.  A newline will be put on the end if there isn't one
  already.
  
  We encourage using this rather than calling print directly.
  
  Returns false.  Why?  Because C<diag()> is often used in conjunction with
  a failing test (C<ok() || diag()>) it "passes through" the failure.
  
      return ok(...) || diag(...);
  
  =for blame transfer
  Mark Fowler <mark@twoshortplanks.com>
  
  =cut
  
  sub diag {
      my $self = shift;
  
      $self->_print_comment( $self->_diag_fh, @_ );
  }
  
  =item B<note>
  
      $Test->note(@msgs);
  
  Like C<diag()>, but it prints to the C<output()> handle so it will not
  normally be seen by the user except in verbose mode.
  
  =cut
  
  sub note {
      my $self = shift;
  
      $self->_print_comment( $self->output, @_ );
  }
  
  sub _diag_fh {
      my $self = shift;
  
      local $Level = $Level + 1;
      return $self->in_todo ? $self->todo_output : $self->failure_output;
  }
  
  sub _print_comment {
      my( $self, $fh, @msgs ) = @_;
  
      return if $self->no_diag;
      return unless @msgs;
  
      # Prevent printing headers when compiling (i.e. -c)
      return if $^C;
  
      # Smash args together like print does.
      # Convert undef to 'undef' so its readable.
      my $msg = join '', map { defined($_) ? $_ : 'undef' } @msgs;
  
      # Escape the beginning, _print will take care of the rest.
      $msg =~ s/^/# /;
  
      local $Level = $Level + 1;
      $self->_print_to_fh( $fh, $msg );
  
      return 0;
  }
  
  =item B<explain>
  
      my @dump = $Test->explain(@msgs);
  
  Will dump the contents of any references in a human readable format.
  Handy for things like...
  
      is_deeply($have, $want) || diag explain $have;
  
  or
  
      is_deeply($have, $want) || note explain $have;
  
  =cut
  
  sub explain {
      my $self = shift;
  
      return map {
          ref $_
            ? do {
              $self->_try(sub { require Data::Dumper }, die_on_fail => 1);
  
              my $dumper = Data::Dumper->new( [$_] );
              $dumper->Indent(1)->Terse(1);
              $dumper->Sortkeys(1) if $dumper->can("Sortkeys");
              $dumper->Dump;
            }
            : $_
      } @_;
  }
  
  =begin _private
  
  =item B<_print>
  
      $Test->_print(@msgs);
  
  Prints to the C<output()> filehandle.
  
  =end _private
  
  =cut
  
  sub _print {
      my $self = shift;
      return $self->_print_to_fh( $self->output, @_ );
  }
  
  sub _print_to_fh {
      my( $self, $fh, @msgs ) = @_;
  
      # Prevent printing headers when only compiling.  Mostly for when
      # tests are deparsed with B::Deparse
      return if $^C;
  
      my $msg = join '', @msgs;
      my $indent = $self->_indent;
  
      local( $\, $", $, ) = ( undef, ' ', '' );
  
      # Escape each line after the first with a # so we don't
      # confuse Test::Harness.
      $msg =~ s{\n(?!\z)}{\n$indent# }sg;
  
      # Stick a newline on the end if it needs it.
      $msg .= "\n" unless $msg =~ /\n\z/;
  
      return print $fh $indent, $msg;
  }
  
  =item B<output>
  
  =item B<failure_output>
  
  =item B<todo_output>
  
      my $filehandle = $Test->output;
      $Test->output($filehandle);
      $Test->output($filename);
      $Test->output(\$scalar);
  
  These methods control where Test::Builder will print its output.
  They take either an open C<$filehandle>, a C<$filename> to open and write to
  or a C<$scalar> reference to append to.  It will always return a C<$filehandle>.
  
  B<output> is where normal "ok/not ok" test output goes.
  
  Defaults to STDOUT.
  
  B<failure_output> is where diagnostic output on test failures and
  C<diag()> goes.  It is normally not read by Test::Harness and instead is
  displayed to the user.
  
  Defaults to STDERR.
  
  C<todo_output> is used instead of C<failure_output()> for the
  diagnostics of a failing TODO test.  These will not be seen by the
  user.
  
  Defaults to STDOUT.
  
  =cut
  
  sub output {
      my( $self, $fh ) = @_;
  
      if( defined $fh ) {
          $self->{Out_FH} = $self->_new_fh($fh);
      }
      return $self->{Out_FH};
  }
  
  sub failure_output {
      my( $self, $fh ) = @_;
  
      if( defined $fh ) {
          $self->{Fail_FH} = $self->_new_fh($fh);
      }
      return $self->{Fail_FH};
  }
  
  sub todo_output {
      my( $self, $fh ) = @_;
  
      if( defined $fh ) {
          $self->{Todo_FH} = $self->_new_fh($fh);
      }
      return $self->{Todo_FH};
  }
  
  sub _new_fh {
      my $self = shift;
      my($file_or_fh) = shift;
  
      my $fh;
      if( $self->is_fh($file_or_fh) ) {
          $fh = $file_or_fh;
      }
      elsif( ref $file_or_fh eq 'SCALAR' ) {
          # Scalar refs as filehandles was added in 5.8.
          if( $] >= 5.008 ) {
              open $fh, ">>", $file_or_fh
                or $self->croak("Can't open scalar ref $file_or_fh: $!");
          }
          # Emulate scalar ref filehandles with a tie.
          else {
              $fh = Test::Builder::IO::Scalar->new($file_or_fh)
                or $self->croak("Can't tie scalar ref $file_or_fh");
          }
      }
      else {
          open $fh, ">", $file_or_fh
            or $self->croak("Can't open test output log $file_or_fh: $!");
          _autoflush($fh);
      }
  
      return $fh;
  }
  
  sub _autoflush {
      my($fh) = shift;
      my $old_fh = select $fh;
      $| = 1;
      select $old_fh;
  
      return;
  }
  
  my( $Testout, $Testerr );
  
  sub _dup_stdhandles {
      my $self = shift;
  
      $self->_open_testhandles;
  
      # Set everything to unbuffered else plain prints to STDOUT will
      # come out in the wrong order from our own prints.
      _autoflush($Testout);
      _autoflush( \*STDOUT );
      _autoflush($Testerr);
      _autoflush( \*STDERR );
  
      $self->reset_outputs;
  
      return;
  }
  
  sub _open_testhandles {
      my $self = shift;
  
      return if $self->{Opened_Testhandles};
  
      # We dup STDOUT and STDERR so people can change them in their
      # test suites while still getting normal test output.
      open( $Testout, ">&STDOUT" ) or die "Can't dup STDOUT:  $!";
      open( $Testerr, ">&STDERR" ) or die "Can't dup STDERR:  $!";
  
      $self->_copy_io_layers( \*STDOUT, $Testout );
      $self->_copy_io_layers( \*STDERR, $Testerr );
  
      $self->{Opened_Testhandles} = 1;
  
      return;
  }
  
  sub _copy_io_layers {
      my( $self, $src, $dst ) = @_;
  
      $self->_try(
          sub {
              require PerlIO;
              my @src_layers = PerlIO::get_layers($src);
  
              _apply_layers($dst, @src_layers) if @src_layers;
          }
      );
  
      return;
  }
  
  sub _apply_layers {
      my ($fh, @layers) = @_;
      my %seen;
      my @unique = grep { $_ ne 'unix' and !$seen{$_}++ } @layers;
      binmode($fh, join(":", "", "raw", @unique));
  }
  
  
  =item reset_outputs
  
    $tb->reset_outputs;
  
  Resets all the output filehandles back to their defaults.
  
  =cut
  
  sub reset_outputs {
      my $self = shift;
  
      $self->output        ($Testout);
      $self->failure_output($Testerr);
      $self->todo_output   ($Testout);
  
      return;
  }
  
  =item carp
  
    $tb->carp(@message);
  
  Warns with C<@message> but the message will appear to come from the
  point where the original test function was called (C<< $tb->caller >>).
  
  =item croak
  
    $tb->croak(@message);
  
  Dies with C<@message> but the message will appear to come from the
  point where the original test function was called (C<< $tb->caller >>).
  
  =cut
  
  sub _message_at_caller {
      my $self = shift;
  
      local $Level = $Level + 1;
      my( $pack, $file, $line ) = $self->caller;
      return join( "", @_ ) . " at $file line $line.\n";
  }
  
  sub carp {
      my $self = shift;
      return warn $self->_message_at_caller(@_);
  }
  
  sub croak {
      my $self = shift;
      return die $self->_message_at_caller(@_);
  }
  
  
  =back
  
  
  =head2 Test Status and Info
  
  =over 4
  
  =item B<current_test>
  
      my $curr_test = $Test->current_test;
      $Test->current_test($num);
  
  Gets/sets the current test number we're on.  You usually shouldn't
  have to set this.
  
  If set forward, the details of the missing tests are filled in as 'unknown'.
  if set backward, the details of the intervening tests are deleted.  You
  can erase history if you really want to.
  
  =cut
  
  sub current_test {
      my( $self, $num ) = @_;
  
      lock( $self->{Curr_Test} );
      if( defined $num ) {
          $self->{Curr_Test} = $num;
  
          # If the test counter is being pushed forward fill in the details.
          my $test_results = $self->{Test_Results};
          if( $num > @$test_results ) {
              my $start = @$test_results ? @$test_results : 0;
              for( $start .. $num - 1 ) {
                  $test_results->[$_] = &share(
                      {
                          'ok'      => 1,
                          actual_ok => undef,
                          reason    => 'incrementing test number',
                          type      => 'unknown',
                          name      => undef
                      }
                  );
              }
          }
          # If backward, wipe history.  Its their funeral.
          elsif( $num < @$test_results ) {
              $#{$test_results} = $num - 1;
          }
      }
      return $self->{Curr_Test};
  }
  
  =item B<is_passing>
  
     my $ok = $builder->is_passing;
  
  Indicates if the test suite is currently passing.
  
  More formally, it will be false if anything has happened which makes
  it impossible for the test suite to pass.  True otherwise.
  
  For example, if no tests have run C<is_passing()> will be true because
  even though a suite with no tests is a failure you can add a passing
  test to it and start passing.
  
  Don't think about it too much.
  
  =cut
  
  sub is_passing {
      my $self = shift;
  
      if( @_ ) {
          $self->{Is_Passing} = shift;
      }
  
      return $self->{Is_Passing};
  }
  
  
  =item B<summary>
  
      my @tests = $Test->summary;
  
  A simple summary of the tests so far.  True for pass, false for fail.
  This is a logical pass/fail, so todos are passes.
  
  Of course, test #1 is $tests[0], etc...
  
  =cut
  
  sub summary {
      my($self) = shift;
  
      return map { $_->{'ok'} } @{ $self->{Test_Results} };
  }
  
  =item B<details>
  
      my @tests = $Test->details;
  
  Like C<summary()>, but with a lot more detail.
  
      $tests[$test_num - 1] = 
              { 'ok'       => is the test considered a pass?
                actual_ok  => did it literally say 'ok'?
                name       => name of the test (if any)
                type       => type of test (if any, see below).
                reason     => reason for the above (if any)
              };
  
  'ok' is true if Test::Harness will consider the test to be a pass.
  
  'actual_ok' is a reflection of whether or not the test literally
  printed 'ok' or 'not ok'.  This is for examining the result of 'todo'
  tests.
  
  'name' is the name of the test.
  
  'type' indicates if it was a special test.  Normal tests have a type
  of ''.  Type can be one of the following:
  
      skip        see skip()
      todo        see todo()
      todo_skip   see todo_skip()
      unknown     see below
  
  Sometimes the Test::Builder test counter is incremented without it
  printing any test output, for example, when C<current_test()> is changed.
  In these cases, Test::Builder doesn't know the result of the test, so
  its type is 'unknown'.  These details for these tests are filled in.
  They are considered ok, but the name and actual_ok is left C<undef>.
  
  For example "not ok 23 - hole count # TODO insufficient donuts" would
  result in this structure:
  
      $tests[22] =    # 23 - 1, since arrays start from 0.
        { ok        => 1,   # logically, the test passed since its todo
          actual_ok => 0,   # in absolute terms, it failed
          name      => 'hole count',
          type      => 'todo',
          reason    => 'insufficient donuts'
        };
  
  =cut
  
  sub details {
      my $self = shift;
      return @{ $self->{Test_Results} };
  }
  
  =item B<todo>
  
      my $todo_reason = $Test->todo;
      my $todo_reason = $Test->todo($pack);
  
  If the current tests are considered "TODO" it will return the reason,
  if any.  This reason can come from a C<$TODO> variable or the last call
  to C<todo_start()>.
  
  Since a TODO test does not need a reason, this function can return an
  empty string even when inside a TODO block.  Use C<< $Test->in_todo >>
  to determine if you are currently inside a TODO block.
  
  C<todo()> is about finding the right package to look for C<$TODO> in.  It's
  pretty good at guessing the right package to look at.  It first looks for
  the caller based on C<$Level + 1>, since C<todo()> is usually called inside
  a test function.  As a last resort it will use C<exported_to()>.
  
  Sometimes there is some confusion about where C<todo()> should be looking
  for the C<$TODO> variable.  If you want to be sure, tell it explicitly
  what $pack to use.
  
  =cut
  
  sub todo {
      my( $self, $pack ) = @_;
  
      return $self->{Todo} if defined $self->{Todo};
  
      local $Level = $Level + 1;
      my $todo = $self->find_TODO($pack);
      return $todo if defined $todo;
  
      return '';
  }
  
  =item B<find_TODO>
  
      my $todo_reason = $Test->find_TODO();
      my $todo_reason = $Test->find_TODO($pack);
  
  Like C<todo()> but only returns the value of C<$TODO> ignoring
  C<todo_start()>.
  
  Can also be used to set C<$TODO> to a new value while returning the
  old value:
  
      my $old_reason = $Test->find_TODO($pack, 1, $new_reason);
  
  =cut
  
  sub find_TODO {
      my( $self, $pack, $set, $new_value ) = @_;
  
      $pack = $pack || $self->caller(1) || $self->exported_to;
      return unless $pack;
  
      no strict 'refs';    ## no critic
      my $old_value = ${ $pack . '::TODO' };
      $set and ${ $pack . '::TODO' } = $new_value;
      return $old_value;
  }
  
  =item B<in_todo>
  
      my $in_todo = $Test->in_todo;
  
  Returns true if the test is currently inside a TODO block.
  
  =cut
  
  sub in_todo {
      my $self = shift;
  
      local $Level = $Level + 1;
      return( defined $self->{Todo} || $self->find_TODO ) ? 1 : 0;
  }
  
  =item B<todo_start>
  
      $Test->todo_start();
      $Test->todo_start($message);
  
  This method allows you declare all subsequent tests as TODO tests, up until
  the C<todo_end> method has been called.
  
  The C<TODO:> and C<$TODO> syntax is generally pretty good about figuring out
  whether or not we're in a TODO test.  However, often we find that this is not
  possible to determine (such as when we want to use C<$TODO> but
  the tests are being executed in other packages which can't be inferred
  beforehand).
  
  Note that you can use this to nest "todo" tests
  
   $Test->todo_start('working on this');
   # lots of code
   $Test->todo_start('working on that');
   # more code
   $Test->todo_end;
   $Test->todo_end;
  
  This is generally not recommended, but large testing systems often have weird
  internal needs.
  
  We've tried to make this also work with the TODO: syntax, but it's not
  guaranteed and its use is also discouraged:
  
   TODO: {
       local $TODO = 'We have work to do!';
       $Test->todo_start('working on this');
       # lots of code
       $Test->todo_start('working on that');
       # more code
       $Test->todo_end;
       $Test->todo_end;
   }
  
  Pick one style or another of "TODO" to be on the safe side.
  
  =cut
  
  sub todo_start {
      my $self = shift;
      my $message = @_ ? shift : '';
  
      $self->{Start_Todo}++;
      if( $self->in_todo ) {
          push @{ $self->{Todo_Stack} } => $self->todo;
      }
      $self->{Todo} = $message;
  
      return;
  }
  
  =item C<todo_end>
  
   $Test->todo_end;
  
  Stops running tests as "TODO" tests.  This method is fatal if called without a
  preceding C<todo_start> method call.
  
  =cut
  
  sub todo_end {
      my $self = shift;
  
      if( !$self->{Start_Todo} ) {
          $self->croak('todo_end() called without todo_start()');
      }
  
      $self->{Start_Todo}--;
  
      if( $self->{Start_Todo} && @{ $self->{Todo_Stack} } ) {
          $self->{Todo} = pop @{ $self->{Todo_Stack} };
      }
      else {
          delete $self->{Todo};
      }
  
      return;
  }
  
  =item B<caller>
  
      my $package = $Test->caller;
      my($pack, $file, $line) = $Test->caller;
      my($pack, $file, $line) = $Test->caller($height);
  
  Like the normal C<caller()>, except it reports according to your C<level()>.
  
  C<$height> will be added to the C<level()>.
  
  If C<caller()> winds up off the top of the stack it report the highest context.
  
  =cut
  
  sub caller {    ## no critic (Subroutines::ProhibitBuiltinHomonyms)
      my( $self, $height ) = @_;
      $height ||= 0;
  
      my $level = $self->level + $height + 1;
      my @caller;
      do {
          @caller = CORE::caller( $level );
          $level--;
      } until @caller;
      return wantarray ? @caller : $caller[0];
  }
  
  =back
  
  =cut
  
  =begin _private
  
  =over 4
  
  =item B<_sanity_check>
  
    $self->_sanity_check();
  
  Runs a bunch of end of test sanity checks to make sure reality came
  through ok.  If anything is wrong it will die with a fairly friendly
  error message.
  
  =cut
  
  #'#
  sub _sanity_check {
      my $self = shift;
  
      $self->_whoa( $self->{Curr_Test} < 0, 'Says here you ran a negative number of tests!' );
      $self->_whoa( $self->{Curr_Test} != @{ $self->{Test_Results} },
          'Somehow you got a different number of results than tests ran!' );
  
      return;
  }
  
  =item B<_whoa>
  
    $self->_whoa($check, $description);
  
  A sanity check, similar to C<assert()>.  If the C<$check> is true, something
  has gone horribly wrong.  It will die with the given C<$description> and
  a note to contact the author.
  
  =cut
  
  sub _whoa {
      my( $self, $check, $desc ) = @_;
      if($check) {
          local $Level = $Level + 1;
          $self->croak(<<"WHOA");
  WHOA!  $desc
  This should never happen!  Please contact the author immediately!
  WHOA
      }
  
      return;
  }
  
  =item B<_my_exit>
  
    _my_exit($exit_num);
  
  Perl seems to have some trouble with exiting inside an C<END> block.
  5.6.1 does some odd things.  Instead, this function edits C<$?>
  directly.  It should B<only> be called from inside an C<END> block.
  It doesn't actually exit, that's your job.
  
  =cut
  
  sub _my_exit {
      $? = $_[0];    ## no critic (Variables::RequireLocalizedPunctuationVars)
  
      return 1;
  }
  
  =back
  
  =end _private
  
  =cut
  
  sub _ending {
      my $self = shift;
      return if $self->no_ending;
      return if $self->{Ending}++;
  
      my $real_exit_code = $?;
  
      # Don't bother with an ending if this is a forked copy.  Only the parent
      # should do the ending.
      if( $self->{Original_Pid} != $$ ) {
          return;
      }
  
      # Ran tests but never declared a plan or hit done_testing
      if( !$self->{Have_Plan} and $self->{Curr_Test} ) {
          $self->is_passing(0);
          $self->diag("Tests were run but no plan was declared and done_testing() was not seen.");
  
          if($real_exit_code) {
              $self->diag(<<"FAIL");
  Looks like your test exited with $real_exit_code just after $self->{Curr_Test}.
  FAIL
              $self->is_passing(0);
              _my_exit($real_exit_code) && return;
          }
  
          # But if the tests ran, handle exit code.
          my $test_results = $self->{Test_Results};
          if(@$test_results) {
              my $num_failed = grep !$_->{'ok'}, @{$test_results}[ 0 .. $self->{Curr_Test} - 1 ];
              if ($num_failed > 0) {
  
                  my $exit_code = $num_failed <= 254 ? $num_failed : 254;
                  _my_exit($exit_code) && return;
              }
          }
          _my_exit(254) && return;
      }
  
      # Exit if plan() was never called.  This is so "require Test::Simple"
      # doesn't puke.
      if( !$self->{Have_Plan} ) {
          return;
      }
  
      # Don't do an ending if we bailed out.
      if( $self->{Bailed_Out} ) {
          $self->is_passing(0);
          return;
      }
      # Figure out if we passed or failed and print helpful messages.
      my $test_results = $self->{Test_Results};
      if(@$test_results) {
          # The plan?  We have no plan.
          if( $self->{No_Plan} ) {
              $self->_output_plan($self->{Curr_Test}) unless $self->no_header;
              $self->{Expected_Tests} = $self->{Curr_Test};
          }
  
          # Auto-extended arrays and elements which aren't explicitly
          # filled in with a shared reference will puke under 5.8.0
          # ithreads.  So we have to fill them in by hand. :(
          my $empty_result = &share( {} );
          for my $idx ( 0 .. $self->{Expected_Tests} - 1 ) {
              $test_results->[$idx] = $empty_result
                unless defined $test_results->[$idx];
          }
  
          my $num_failed = grep !$_->{'ok'}, @{$test_results}[ 0 .. $self->{Curr_Test} - 1 ];
  
          my $num_extra = $self->{Curr_Test} - $self->{Expected_Tests};
  
          if( $num_extra != 0 ) {
              my $s = $self->{Expected_Tests} == 1 ? '' : 's';
              $self->diag(<<"FAIL");
  Looks like you planned $self->{Expected_Tests} test$s but ran $self->{Curr_Test}.
  FAIL
              $self->is_passing(0);
          }
  
          if($num_failed) {
              my $num_tests = $self->{Curr_Test};
              my $s = $num_failed == 1 ? '' : 's';
  
              my $qualifier = $num_extra == 0 ? '' : ' run';
  
              $self->diag(<<"FAIL");
  Looks like you failed $num_failed test$s of $num_tests$qualifier.
  FAIL
              $self->is_passing(0);
          }
  
          if($real_exit_code) {
              $self->diag(<<"FAIL");
  Looks like your test exited with $real_exit_code just after $self->{Curr_Test}.
  FAIL
              $self->is_passing(0);
              _my_exit($real_exit_code) && return;
          }
  
          my $exit_code;
          if($num_failed) {
              $exit_code = $num_failed <= 254 ? $num_failed : 254;
          }
          elsif( $num_extra != 0 ) {
              $exit_code = 255;
          }
          else {
              $exit_code = 0;
          }
  
          _my_exit($exit_code) && return;
      }
      elsif( $self->{Skip_All} ) {
          _my_exit(0) && return;
      }
      elsif($real_exit_code) {
          $self->diag(<<"FAIL");
  Looks like your test exited with $real_exit_code before it could output anything.
  FAIL
          $self->is_passing(0);
          _my_exit($real_exit_code) && return;
      }
      else {
          $self->diag("No tests run!\n");
          $self->is_passing(0);
          _my_exit(255) && return;
      }
  
      $self->is_passing(0);
      $self->_whoa( 1, "We fell off the end of _ending()" );
  }
  
  END {
      $Test->_ending if defined $Test;
  }
  
  =head1 EXIT CODES
  
  If all your tests passed, Test::Builder will exit with zero (which is
  normal).  If anything failed it will exit with how many failed.  If
  you run less (or more) tests than you planned, the missing (or extras)
  will be considered failures.  If no tests were ever run Test::Builder
  will throw a warning and exit with 255.  If the test died, even after
  having successfully completed all its tests, it will still be
  considered a failure and will exit with 255.
  
  So the exit codes are...
  
      0                   all tests successful
      255                 test died or all passed but wrong # of tests run
      any other number    how many failed (including missing or extras)
  
  If you fail more than 254 tests, it will be reported as 254.
  
  =head1 THREADS
  
  In perl 5.8.1 and later, Test::Builder is thread-safe.  The test
  number is shared amongst all threads.  This means if one thread sets
  the test number using C<current_test()> they will all be effected.
  
  While versions earlier than 5.8.1 had threads they contain too many
  bugs to support.
  
  Test::Builder is only thread-aware if threads.pm is loaded I<before>
  Test::Builder.
  
  =head1 MEMORY
  
  An informative hash, accessible via C<details()>, is stored for each
  test you perform.  So memory usage will scale linearly with each test
  run. Although this is not a problem for most test suites, it can
  become an issue if you do large (hundred thousands to million)
  combinatorics tests in the same run.
  
  In such cases, you are advised to either split the test file into smaller
  ones, or use a reverse approach, doing "normal" (code) compares and
  triggering C<fail()> should anything go unexpected.
  
  Future versions of Test::Builder will have a way to turn history off.
  
  
  =head1 EXAMPLES
  
  CPAN can provide the best examples.  L<Test::Simple>, L<Test::More>,
  L<Test::Exception> and L<Test::Differences> all use Test::Builder.
  
  =head1 SEE ALSO
  
  L<Test::Simple>, L<Test::More>, L<Test::Harness>
  
  =head1 AUTHORS
  
  Original code by chromatic, maintained by Michael G Schwern
  E<lt>schwern@pobox.comE<gt>
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2002-2008 by chromatic E<lt>chromatic@wgz.orgE<gt> and
                         Michael G Schwern E<lt>schwern@pobox.comE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
  
  1;
  
PERL5_TEST_BUILDER

$fatpacked{"perl5/Test/Builder/IO/Scalar.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_TEST_BUILDER_IO_SCALAR';
  package Test::Builder::IO::Scalar;
  
  
  =head1 NAME
  
  Test::Builder::IO::Scalar - A copy of IO::Scalar for Test::Builder
  
  =head1 DESCRIPTION
  
  This is a copy of L<IO::Scalar> which ships with L<Test::Builder> to
  support scalar references as filehandles on Perl 5.6.  Newer
  versions of Perl simply use C<open()>'s built in support.
  
  L<Test::Builder> can not have dependencies on other modules without
  careful consideration, so its simply been copied into the distribution.
  
  =head1 COPYRIGHT and LICENSE
  
  This file came from the "IO-stringy" Perl5 toolkit.
  
  Copyright (c) 1996 by Eryq.  All rights reserved.
  Copyright (c) 1999,2001 by ZeeGee Software Inc.  All rights reserved.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  
  =cut
  
  # This is copied code, I don't care.
  ##no critic
  
  use Carp;
  use strict;
  use vars qw($VERSION @ISA);
  use IO::Handle;
  
  use 5.005;
  
  ### The package version, both in 1.23 style *and* usable by MakeMaker:
  $VERSION = "2.113";
  
  ### Inheritance:
  @ISA = qw(IO::Handle);
  
  #==============================
  
  =head2 Construction
  
  =over 4
  
  =cut
  
  #------------------------------
  
  =item new [ARGS...]
  
  I<Class method.>
  Return a new, unattached scalar handle.
  If any arguments are given, they're sent to open().
  
  =cut
  
  sub new {
      my $proto = shift;
      my $class = ref($proto) || $proto;
      my $self = bless \do { local *FH }, $class;
      tie *$self, $class, $self;
      $self->open(@_);   ### open on anonymous by default
      $self;
  }
  sub DESTROY {
      shift->close;
  }
  
  #------------------------------
  
  =item open [SCALARREF]
  
  I<Instance method.>
  Open the scalar handle on a new scalar, pointed to by SCALARREF.
  If no SCALARREF is given, a "private" scalar is created to hold
  the file data.
  
  Returns the self object on success, undefined on error.
  
  =cut
  
  sub open {
      my ($self, $sref) = @_;
  
      ### Sanity:
      defined($sref) or do {my $s = ''; $sref = \$s};
      (ref($sref) eq "SCALAR") or croak "open() needs a ref to a scalar";
  
      ### Setup:
      *$self->{Pos} = 0;          ### seek position
      *$self->{SR}  = $sref;      ### scalar reference
      $self;
  }
  
  #------------------------------
  
  =item opened
  
  I<Instance method.>
  Is the scalar handle opened on something?
  
  =cut
  
  sub opened {
      *{shift()}->{SR};
  }
  
  #------------------------------
  
  =item close
  
  I<Instance method.>
  Disassociate the scalar handle from its underlying scalar.
  Done automatically on destroy.
  
  =cut
  
  sub close {
      my $self = shift;
      %{*$self} = ();
      1;
  }
  
  =back
  
  =cut
  
  
  
  #==============================
  
  =head2 Input and output
  
  =over 4
  
  =cut
  
  
  #------------------------------
  
  =item flush
  
  I<Instance method.>
  No-op, provided for OO compatibility.
  
  =cut
  
  sub flush { "0 but true" }
  
  #------------------------------
  
  =item getc
  
  I<Instance method.>
  Return the next character, or undef if none remain.
  
  =cut
  
  sub getc {
      my $self = shift;
  
      ### Return undef right away if at EOF; else, move pos forward:
      return undef if $self->eof;
      substr(${*$self->{SR}}, *$self->{Pos}++, 1);
  }
  
  #------------------------------
  
  =item getline
  
  I<Instance method.>
  Return the next line, or undef on end of string.
  Can safely be called in an array context.
  Currently, lines are delimited by "\n".
  
  =cut
  
  sub getline {
      my $self = shift;
  
      ### Return undef right away if at EOF:
      return undef if $self->eof;
  
      ### Get next line:
      my $sr = *$self->{SR};
      my $i  = *$self->{Pos};	        ### Start matching at this point.
  
      ### Minimal impact implementation!
      ### We do the fast fast thing (no regexps) if using the
      ### classic input record separator.
  
      ### Case 1: $/ is undef: slurp all...
      if    (!defined($/)) {
  	*$self->{Pos} = length $$sr;
          return substr($$sr, $i);
      }
  
      ### Case 2: $/ is "\n": zoom zoom zoom...
      elsif ($/ eq "\012") {
  
          ### Seek ahead for "\n"... yes, this really is faster than regexps.
          my $len = length($$sr);
          for (; $i < $len; ++$i) {
             last if ord (substr ($$sr, $i, 1)) == 10;
          }
  
          ### Extract the line:
          my $line;
          if ($i < $len) {                ### We found a "\n":
              $line = substr ($$sr, *$self->{Pos}, $i - *$self->{Pos} + 1);
              *$self->{Pos} = $i+1;            ### Remember where we finished up.
          }
          else {                          ### No "\n"; slurp the remainder:
              $line = substr ($$sr, *$self->{Pos}, $i - *$self->{Pos});
              *$self->{Pos} = $len;
          }
          return $line;
      }
  
      ### Case 3: $/ is ref to int. Do fixed-size records.
      ###        (Thanks to Dominique Quatravaux.)
      elsif (ref($/)) {
          my $len = length($$sr);
  		my $i = ${$/} + 0;
  		my $line = substr ($$sr, *$self->{Pos}, $i);
  		*$self->{Pos} += $i;
          *$self->{Pos} = $len if (*$self->{Pos} > $len);
  		return $line;
      }
  
      ### Case 4: $/ is either "" (paragraphs) or something weird...
      ###         This is Graham's general-purpose stuff, which might be
      ###         a tad slower than Case 2 for typical data, because
      ###         of the regexps.
      else {
          pos($$sr) = $i;
  
  	### If in paragraph mode, skip leading lines (and update i!):
          length($/) or
  	    (($$sr =~ m/\G\n*/g) and ($i = pos($$sr)));
  
          ### If we see the separator in the buffer ahead...
          if (length($/)
  	    ?  $$sr =~ m,\Q$/\E,g          ###   (ordinary sep) TBD: precomp!
              :  $$sr =~ m,\n\n,g            ###   (a paragraph)
              ) {
              *$self->{Pos} = pos $$sr;
              return substr($$sr, $i, *$self->{Pos}-$i);
          }
          ### Else if no separator remains, just slurp the rest:
          else {
              *$self->{Pos} = length $$sr;
              return substr($$sr, $i);
          }
      }
  }
  
  #------------------------------
  
  =item getlines
  
  I<Instance method.>
  Get all remaining lines.
  It will croak() if accidentally called in a scalar context.
  
  =cut
  
  sub getlines {
      my $self = shift;
      wantarray or croak("can't call getlines in scalar context!");
      my ($line, @lines);
      push @lines, $line while (defined($line = $self->getline));
      @lines;
  }
  
  #------------------------------
  
  =item print ARGS...
  
  I<Instance method.>
  Print ARGS to the underlying scalar.
  
  B<Warning:> this continues to always cause a seek to the end
  of the string, but if you perform seek()s and tell()s, it is
  still safer to explicitly seek-to-end before subsequent print()s.
  
  =cut
  
  sub print {
      my $self = shift;
      *$self->{Pos} = length(${*$self->{SR}} .= join('', @_) . (defined($\) ? $\ : ""));
      1;
  }
  sub _unsafe_print {
      my $self = shift;
      my $append = join('', @_) . $\;
      ${*$self->{SR}} .= $append;
      *$self->{Pos}   += length($append);
      1;
  }
  sub _old_print {
      my $self = shift;
      ${*$self->{SR}} .= join('', @_) . $\;
      *$self->{Pos} = length(${*$self->{SR}});
      1;
  }
  
  
  #------------------------------
  
  =item read BUF, NBYTES, [OFFSET]
  
  I<Instance method.>
  Read some bytes from the scalar.
  Returns the number of bytes actually read, 0 on end-of-file, undef on error.
  
  =cut
  
  sub read {
      my $self = $_[0];
      my $n    = $_[2];
      my $off  = $_[3] || 0;
  
      my $read = substr(${*$self->{SR}}, *$self->{Pos}, $n);
      $n = length($read);
      *$self->{Pos} += $n;
      ($off ? substr($_[1], $off) : $_[1]) = $read;
      return $n;
  }
  
  #------------------------------
  
  =item write BUF, NBYTES, [OFFSET]
  
  I<Instance method.>
  Write some bytes to the scalar.
  
  =cut
  
  sub write {
      my $self = $_[0];
      my $n    = $_[2];
      my $off  = $_[3] || 0;
  
      my $data = substr($_[1], $off, $n);
      $n = length($data);
      $self->print($data);
      return $n;
  }
  
  #------------------------------
  
  =item sysread BUF, LEN, [OFFSET]
  
  I<Instance method.>
  Read some bytes from the scalar.
  Returns the number of bytes actually read, 0 on end-of-file, undef on error.
  
  =cut
  
  sub sysread {
    my $self = shift;
    $self->read(@_);
  }
  
  #------------------------------
  
  =item syswrite BUF, NBYTES, [OFFSET]
  
  I<Instance method.>
  Write some bytes to the scalar.
  
  =cut
  
  sub syswrite {
    my $self = shift;
    $self->write(@_);
  }
  
  =back
  
  =cut
  
  
  #==============================
  
  =head2 Seeking/telling and other attributes
  
  =over 4
  
  =cut
  
  
  #------------------------------
  
  =item autoflush
  
  I<Instance method.>
  No-op, provided for OO compatibility.
  
  =cut
  
  sub autoflush {}
  
  #------------------------------
  
  =item binmode
  
  I<Instance method.>
  No-op, provided for OO compatibility.
  
  =cut
  
  sub binmode {}
  
  #------------------------------
  
  =item clearerr
  
  I<Instance method.>  Clear the error and EOF flags.  A no-op.
  
  =cut
  
  sub clearerr { 1 }
  
  #------------------------------
  
  =item eof
  
  I<Instance method.>  Are we at end of file?
  
  =cut
  
  sub eof {
      my $self = shift;
      (*$self->{Pos} >= length(${*$self->{SR}}));
  }
  
  #------------------------------
  
  =item seek OFFSET, WHENCE
  
  I<Instance method.>  Seek to a given position in the stream.
  
  =cut
  
  sub seek {
      my ($self, $pos, $whence) = @_;
      my $eofpos = length(${*$self->{SR}});
  
      ### Seek:
      if    ($whence == 0) { *$self->{Pos} = $pos }             ### SEEK_SET
      elsif ($whence == 1) { *$self->{Pos} += $pos }            ### SEEK_CUR
      elsif ($whence == 2) { *$self->{Pos} = $eofpos + $pos}    ### SEEK_END
      else                 { croak "bad seek whence ($whence)" }
  
      ### Fixup:
      if (*$self->{Pos} < 0)       { *$self->{Pos} = 0 }
      if (*$self->{Pos} > $eofpos) { *$self->{Pos} = $eofpos }
      return 1;
  }
  
  #------------------------------
  
  =item sysseek OFFSET, WHENCE
  
  I<Instance method.> Identical to C<seek OFFSET, WHENCE>, I<q.v.>
  
  =cut
  
  sub sysseek {
      my $self = shift;
      $self->seek (@_);
  }
  
  #------------------------------
  
  =item tell
  
  I<Instance method.>
  Return the current position in the stream, as a numeric offset.
  
  =cut
  
  sub tell { *{shift()}->{Pos} }
  
  #------------------------------
  
  =item  use_RS [YESNO]
  
  I<Instance method.>
  B<Deprecated and ignored.>
  Obey the current setting of $/, like IO::Handle does?
  Default is false in 1.x, but cold-welded true in 2.x and later.
  
  =cut
  
  sub use_RS {
      my ($self, $yesno) = @_;
      carp "use_RS is deprecated and ignored; \$/ is always consulted\n";
   }
  
  #------------------------------
  
  =item setpos POS
  
  I<Instance method.>
  Set the current position, using the opaque value returned by C<getpos()>.
  
  =cut
  
  sub setpos { shift->seek($_[0],0) }
  
  #------------------------------
  
  =item getpos
  
  I<Instance method.>
  Return the current position in the string, as an opaque object.
  
  =cut
  
  *getpos = \&tell;
  
  
  #------------------------------
  
  =item sref
  
  I<Instance method.>
  Return a reference to the underlying scalar.
  
  =cut
  
  sub sref { *{shift()}->{SR} }
  
  
  #------------------------------
  # Tied handle methods...
  #------------------------------
  
  # Conventional tiehandle interface:
  sub TIEHANDLE {
      ((defined($_[1]) && UNIVERSAL::isa($_[1], __PACKAGE__))
       ? $_[1]
       : shift->new(@_));
  }
  sub GETC      { shift->getc(@_) }
  sub PRINT     { shift->print(@_) }
  sub PRINTF    { shift->print(sprintf(shift, @_)) }
  sub READ      { shift->read(@_) }
  sub READLINE  { wantarray ? shift->getlines(@_) : shift->getline(@_) }
  sub WRITE     { shift->write(@_); }
  sub CLOSE     { shift->close(@_); }
  sub SEEK      { shift->seek(@_); }
  sub TELL      { shift->tell(@_); }
  sub EOF       { shift->eof(@_); }
  
  #------------------------------------------------------------
  
  1;
  
  __END__
  
  
  
  =back
  
  =cut
  
  
  =head1 WARNINGS
  
  Perl's TIEHANDLE spec was incomplete prior to 5.005_57;
  it was missing support for C<seek()>, C<tell()>, and C<eof()>.
  Attempting to use these functions with an IO::Scalar will not work
  prior to 5.005_57. IO::Scalar will not have the relevant methods
  invoked; and even worse, this kind of bug can lie dormant for a while.
  If you turn warnings on (via C<$^W> or C<perl -w>),
  and you see something like this...
  
      attempt to seek on unopened filehandle
  
  ...then you are probably trying to use one of these functions
  on an IO::Scalar with an old Perl.  The remedy is to simply
  use the OO version; e.g.:
  
      $SH->seek(0,0);    ### GOOD: will work on any 5.005
      seek($SH,0,0);     ### WARNING: will only work on 5.005_57 and beyond
  
  
  =head1 VERSION
  
  $Id: Scalar.pm,v 1.6 2005/02/10 21:21:53 dfs Exp $
  
  
  =head1 AUTHORS
  
  =head2 Primary Maintainer
  
  David F. Skoll (F<dfs@roaringpenguin.com>).
  
  =head2 Principal author
  
  Eryq (F<eryq@zeegee.com>).
  President, ZeeGee Software Inc (F<http://www.zeegee.com>).
  
  
  =head2 Other contributors
  
  The full set of contributors always includes the folks mentioned
  in L<IO::Stringy/"CHANGE LOG">.  But just the same, special
  thanks to the following individuals for their invaluable contributions
  (if I've forgotten or misspelled your name, please email me!):
  
  I<Andy Glew,>
  for contributing C<getc()>.
  
  I<Brandon Browning,>
  for suggesting C<opened()>.
  
  I<David Richter,>
  for finding and fixing the bug in C<PRINTF()>.
  
  I<Eric L. Brine,>
  for his offset-using read() and write() implementations.
  
  I<Richard Jones,>
  for his patches to massively improve the performance of C<getline()>
  and add C<sysread> and C<syswrite>.
  
  I<B. K. Oxley (binkley),>
  for stringification and inheritance improvements,
  and sundry good ideas.
  
  I<Doug Wilson,>
  for the IO::Handle inheritance and automatic tie-ing.
  
  
  =head1 SEE ALSO
  
  L<IO::String>, which is quite similar but which was designed
  more-recently and with an IO::Handle-like interface in mind,
  so you could mix OO- and native-filehandle usage without using tied().
  
  I<Note:> as of version 2.x, these classes all work like
  their IO::Handle counterparts, so we have comparable
  functionality to IO::String.
  
  =cut
  
PERL5_TEST_BUILDER_IO_SCALAR

$fatpacked{"perl5/Test/Builder/Module.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_TEST_BUILDER_MODULE';
  package Test::Builder::Module;
  
  use strict;
  
  use Test::Builder 1.00;
  
  require Exporter;
  our @ISA = qw(Exporter);
  
  our $VERSION = '1.001014';
  $VERSION = eval $VERSION;      ## no critic (BuiltinFunctions::ProhibitStringyEval)
  
  
  =head1 NAME
  
  Test::Builder::Module - Base class for test modules
  
  =head1 SYNOPSIS
  
    # Emulates Test::Simple
    package Your::Module;
  
    my $CLASS = __PACKAGE__;
  
    use base 'Test::Builder::Module';
    @EXPORT = qw(ok);
  
    sub ok ($;$) {
        my $tb = $CLASS->builder;
        return $tb->ok(@_);
    }
    
    1;
  
  
  =head1 DESCRIPTION
  
  This is a superclass for L<Test::Builder>-based modules.  It provides a
  handful of common functionality and a method of getting at the underlying
  L<Test::Builder> object.
  
  
  =head2 Importing
  
  Test::Builder::Module is a subclass of L<Exporter> which means your
  module is also a subclass of Exporter.  @EXPORT, @EXPORT_OK, etc...
  all act normally.
  
  A few methods are provided to do the C<< use Your::Module tests => 23 >> part
  for you.
  
  =head3 import
  
  Test::Builder::Module provides an C<import()> method which acts in the
  same basic way as L<Test::More>'s, setting the plan and controlling
  exporting of functions and variables.  This allows your module to set
  the plan independent of L<Test::More>.
  
  All arguments passed to C<import()> are passed onto 
  C<< Your::Module->builder->plan() >> with the exception of 
  C<< import =>[qw(things to import)] >>.
  
      use Your::Module import => [qw(this that)], tests => 23;
  
  says to import the functions C<this()> and C<that()> as well as set the plan
  to be 23 tests.
  
  C<import()> also sets the C<exported_to()> attribute of your builder to be
  the caller of the C<import()> function.
  
  Additional behaviors can be added to your C<import()> method by overriding
  C<import_extra()>.
  
  =cut
  
  sub import {
      my($class) = shift;
  
      # Don't run all this when loading ourself.
      return 1 if $class eq 'Test::Builder::Module';
  
      my $test = $class->builder;
  
      my $caller = caller;
  
      $test->exported_to($caller);
  
      $class->import_extra( \@_ );
      my(@imports) = $class->_strip_imports( \@_ );
  
      $test->plan(@_);
  
      $class->export_to_level( 1, $class, @imports );
  }
  
  sub _strip_imports {
      my $class = shift;
      my $list  = shift;
  
      my @imports = ();
      my @other   = ();
      my $idx     = 0;
      while( $idx <= $#{$list} ) {
          my $item = $list->[$idx];
  
          if( defined $item and $item eq 'import' ) {
              push @imports, @{ $list->[ $idx + 1 ] };
              $idx++;
          }
          else {
              push @other, $item;
          }
  
          $idx++;
      }
  
      @$list = @other;
  
      return @imports;
  }
  
  =head3 import_extra
  
      Your::Module->import_extra(\@import_args);
  
  C<import_extra()> is called by C<import()>.  It provides an opportunity for you
  to add behaviors to your module based on its import list.
  
  Any extra arguments which shouldn't be passed on to C<plan()> should be
  stripped off by this method.
  
  See L<Test::More> for an example of its use.
  
  B<NOTE> This mechanism is I<VERY ALPHA AND LIKELY TO CHANGE> as it
  feels like a bit of an ugly hack in its current form.
  
  =cut
  
  sub import_extra { }
  
  =head2 Builder
  
  Test::Builder::Module provides some methods of getting at the underlying
  Test::Builder object.
  
  =head3 builder
  
    my $builder = Your::Class->builder;
  
  This method returns the L<Test::Builder> object associated with Your::Class.
  It is not a constructor so you can call it as often as you like.
  
  This is the preferred way to get the L<Test::Builder> object.  You should
  I<not> get it via C<< Test::Builder->new >> as was previously
  recommended.
  
  The object returned by C<builder()> may change at runtime so you should
  call C<builder()> inside each function rather than store it in a global.
  
    sub ok {
        my $builder = Your::Class->builder;
  
        return $builder->ok(@_);
    }
  
  
  =cut
  
  sub builder {
      return Test::Builder->new;
  }
  
  1;
PERL5_TEST_BUILDER_MODULE

$fatpacked{"perl5/Test/Builder/Tester.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_TEST_BUILDER_TESTER';
  package Test::Builder::Tester;
  
  use strict;
  our $VERSION = "1.28";
  
  use Test::Builder 0.99;
  use Symbol;
  use Carp;
  
  =head1 NAME
  
  Test::Builder::Tester - test testsuites that have been built with
  Test::Builder
  
  =head1 SYNOPSIS
  
      use Test::Builder::Tester tests => 1;
      use Test::More;
  
      test_out("not ok 1 - foo");
      test_fail(+1);
      fail("foo");
      test_test("fail works");
  
  =head1 DESCRIPTION
  
  A module that helps you test testing modules that are built with
  L<Test::Builder>.
  
  The testing system is designed to be used by performing a three step
  process for each test you wish to test.  This process starts with using
  C<test_out> and C<test_err> in advance to declare what the testsuite you
  are testing will output with L<Test::Builder> to stdout and stderr.
  
  You then can run the test(s) from your test suite that call
  L<Test::Builder>.  At this point the output of L<Test::Builder> is
  safely captured by L<Test::Builder::Tester> rather than being
  interpreted as real test output.
  
  The final stage is to call C<test_test> that will simply compare what you
  predeclared to what L<Test::Builder> actually outputted, and report the
  results back with a "ok" or "not ok" (with debugging) to the normal
  output.
  
  =cut
  
  ####
  # set up testing
  ####
  
  my $t = Test::Builder->new;
  
  ###
  # make us an exporter
  ###
  
  use Exporter;
  our @ISA = qw(Exporter);
  
  our @EXPORT = qw(test_out test_err test_fail test_diag test_test line_num);
  
  sub import {
      my $class = shift;
      my(@plan) = @_;
  
      my $caller = caller;
  
      $t->exported_to($caller);
      $t->plan(@plan);
  
      my @imports = ();
      foreach my $idx ( 0 .. $#plan ) {
          if( $plan[$idx] eq 'import' ) {
              @imports = @{ $plan[ $idx + 1 ] };
              last;
          }
      }
  
      __PACKAGE__->export_to_level( 1, __PACKAGE__, @imports );
  }
  
  ###
  # set up file handles
  ###
  
  # create some private file handles
  my $output_handle = gensym;
  my $error_handle  = gensym;
  
  # and tie them to this package
  my $out = tie *$output_handle, "Test::Builder::Tester::Tie", "STDOUT";
  my $err = tie *$error_handle,  "Test::Builder::Tester::Tie", "STDERR";
  
  ####
  # exported functions
  ####
  
  # for remembering that we're testing and where we're testing at
  my $testing = 0;
  my $testing_num;
  my $original_is_passing;
  
  # remembering where the file handles were originally connected
  my $original_output_handle;
  my $original_failure_handle;
  my $original_todo_handle;
  
  my $original_harness_env;
  
  # function that starts testing and redirects the filehandles for now
  sub _start_testing {
      # even if we're running under Test::Harness pretend we're not
      # for now.  This needed so Test::Builder doesn't add extra spaces
      $original_harness_env = $ENV{HARNESS_ACTIVE} || 0;
      $ENV{HARNESS_ACTIVE} = 0;
  
      # remember what the handles were set to
      $original_output_handle  = $t->output();
      $original_failure_handle = $t->failure_output();
      $original_todo_handle    = $t->todo_output();
  
      # switch out to our own handles
      $t->output($output_handle);
      $t->failure_output($error_handle);
      $t->todo_output($output_handle);
  
      # clear the expected list
      $out->reset();
      $err->reset();
  
      # remember that we're testing
      $testing     = 1;
      $testing_num = $t->current_test;
      $t->current_test(0);
      $original_is_passing  = $t->is_passing;
      $t->is_passing(1);
  
      # look, we shouldn't do the ending stuff
      $t->no_ending(1);
  }
  
  =head2 Functions
  
  These are the six methods that are exported as default.
  
  =over 4
  
  =item test_out
  
  =item test_err
  
  Procedures for predeclaring the output that your test suite is
  expected to produce until C<test_test> is called.  These procedures
  automatically assume that each line terminates with "\n".  So
  
     test_out("ok 1","ok 2");
  
  is the same as
  
     test_out("ok 1\nok 2");
  
  which is even the same as
  
     test_out("ok 1");
     test_out("ok 2");
  
  Once C<test_out> or C<test_err> (or C<test_fail> or C<test_diag>) have
  been called, all further output from L<Test::Builder> will be
  captured by L<Test::Builder::Tester>.  This means that you will not
  be able perform further tests to the normal output in the normal way
  until you call C<test_test> (well, unless you manually meddle with the
  output filehandles)
  
  =cut
  
  sub test_out {
      # do we need to do any setup?
      _start_testing() unless $testing;
  
      $out->expect(@_);
  }
  
  sub test_err {
      # do we need to do any setup?
      _start_testing() unless $testing;
  
      $err->expect(@_);
  }
  
  =item test_fail
  
  Because the standard failure message that L<Test::Builder> produces
  whenever a test fails will be a common occurrence in your test error
  output, and because it has changed between Test::Builder versions, rather
  than forcing you to call C<test_err> with the string all the time like
  so
  
      test_err("# Failed test ($0 at line ".line_num(+1).")");
  
  C<test_fail> exists as a convenience function that can be called
  instead.  It takes one argument, the offset from the current line that
  the line that causes the fail is on.
  
      test_fail(+1);
  
  This means that the example in the synopsis could be rewritten
  more simply as:
  
     test_out("not ok 1 - foo");
     test_fail(+1);
     fail("foo");
     test_test("fail works");
  
  =cut
  
  sub test_fail {
      # do we need to do any setup?
      _start_testing() unless $testing;
  
      # work out what line we should be on
      my( $package, $filename, $line ) = caller;
      $line = $line + ( shift() || 0 );    # prevent warnings
  
      # expect that on stderr
      $err->expect("#     Failed test ($filename at line $line)");
  }
  
  =item test_diag
  
  As most of the remaining expected output to the error stream will be
  created by L<Test::Builder>'s C<diag> function, L<Test::Builder::Tester>
  provides a convenience function C<test_diag> that you can use instead of
  C<test_err>.
  
  The C<test_diag> function prepends comment hashes and spacing to the
  start and newlines to the end of the expected output passed to it and
  adds it to the list of expected error output.  So, instead of writing
  
     test_err("# Couldn't open file");
  
  you can write
  
     test_diag("Couldn't open file");
  
  Remember that L<Test::Builder>'s diag function will not add newlines to
  the end of output and test_diag will. So to check
  
     Test::Builder->new->diag("foo\n","bar\n");
  
  You would do
  
    test_diag("foo","bar")
  
  without the newlines.
  
  =cut
  
  sub test_diag {
      # do we need to do any setup?
      _start_testing() unless $testing;
  
      # expect the same thing, but prepended with "#     "
      local $_;
      $err->expect( map { "# $_" } @_ );
  }
  
  =item test_test
  
  Actually performs the output check testing the tests, comparing the
  data (with C<eq>) that we have captured from L<Test::Builder> against
  what was declared with C<test_out> and C<test_err>.
  
  This takes name/value pairs that effect how the test is run.
  
  =over
  
  =item title (synonym 'name', 'label')
  
  The name of the test that will be displayed after the C<ok> or C<not
  ok>.
  
  =item skip_out
  
  Setting this to a true value will cause the test to ignore if the
  output sent by the test to the output stream does not match that
  declared with C<test_out>.
  
  =item skip_err
  
  Setting this to a true value will cause the test to ignore if the
  output sent by the test to the error stream does not match that
  declared with C<test_err>.
  
  =back
  
  As a convenience, if only one argument is passed then this argument
  is assumed to be the name of the test (as in the above examples.)
  
  Once C<test_test> has been run test output will be redirected back to
  the original filehandles that L<Test::Builder> was connected to
  (probably STDOUT and STDERR,) meaning any further tests you run
  will function normally and cause success/errors for L<Test::Harness>.
  
  =cut
  
  sub test_test {
      # decode the arguments as described in the pod
      my $mess;
      my %args;
      if( @_ == 1 ) {
          $mess = shift
      }
      else {
          %args = @_;
          $mess = $args{name} if exists( $args{name} );
          $mess = $args{title} if exists( $args{title} );
          $mess = $args{label} if exists( $args{label} );
      }
  
      # er, are we testing?
      croak "Not testing.  You must declare output with a test function first."
        unless $testing;
  
      # okay, reconnect the test suite back to the saved handles
      $t->output($original_output_handle);
      $t->failure_output($original_failure_handle);
      $t->todo_output($original_todo_handle);
  
      # restore the test no, etc, back to the original point
      $t->current_test($testing_num);
      $testing = 0;
      $t->is_passing($original_is_passing);
  
      # re-enable the original setting of the harness
      $ENV{HARNESS_ACTIVE} = $original_harness_env;
  
      # check the output we've stashed
      unless( $t->ok( ( $args{skip_out} || $out->check ) &&
                      ( $args{skip_err} || $err->check ), $mess ) 
      )
      {
          # print out the diagnostic information about why this
          # test failed
  
          local $_;
  
          $t->diag( map { "$_\n" } $out->complaint )
            unless $args{skip_out} || $out->check;
  
          $t->diag( map { "$_\n" } $err->complaint )
            unless $args{skip_err} || $err->check;
      }
  }
  
  =item line_num
  
  A utility function that returns the line number that the function was
  called on.  You can pass it an offset which will be added to the
  result.  This is very useful for working out the correct text of
  diagnostic functions that contain line numbers.
  
  Essentially this is the same as the C<__LINE__> macro, but the
  C<line_num(+3)> idiom is arguably nicer.
  
  =cut
  
  sub line_num {
      my( $package, $filename, $line ) = caller;
      return $line + ( shift() || 0 );    # prevent warnings
  }
  
  =back
  
  In addition to the six exported functions there exists one
  function that can only be accessed with a fully qualified function
  call.
  
  =over 4
  
  =item color
  
  When C<test_test> is called and the output that your tests generate
  does not match that which you declared, C<test_test> will print out
  debug information showing the two conflicting versions.  As this
  output itself is debug information it can be confusing which part of
  the output is from C<test_test> and which was the original output from
  your original tests.  Also, it may be hard to spot things like
  extraneous whitespace at the end of lines that may cause your test to
  fail even though the output looks similar.
  
  To assist you C<test_test> can colour the background of the debug
  information to disambiguate the different types of output. The debug
  output will have its background coloured green and red.  The green
  part represents the text which is the same between the executed and
  actual output, the red shows which part differs.
  
  The C<color> function determines if colouring should occur or not.
  Passing it a true or false value will enable or disable colouring
  respectively, and the function called with no argument will return the
  current setting.
  
  To enable colouring from the command line, you can use the
  L<Text::Builder::Tester::Color> module like so:
  
     perl -Mlib=Text::Builder::Tester::Color test.t
  
  Or by including the L<Test::Builder::Tester::Color> module directly in
  the PERL5LIB.
  
  =cut
  
  my $color;
  
  sub color {
      $color = shift if @_;
      $color;
  }
  
  =back
  
  =head1 BUGS
  
  Calls C<< Test::Builder->no_ending >> turning off the ending tests.
  This is needed as otherwise it will trip out because we've run more
  tests than we strictly should have and it'll register any failures we
  had that we were testing for as real failures.
  
  The color function doesn't work unless L<Term::ANSIColor> is
  compatible with your terminal.
  
  Bugs (and requests for new features) can be reported to the author
  though the CPAN RT system:
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Builder-Tester>
  
  =head1 AUTHOR
  
  Copyright Mark Fowler E<lt>mark@twoshortplanks.comE<gt> 2002, 2004.
  
  Some code taken from L<Test::More> and L<Test::Catch>, written by
  Michael G Schwern E<lt>schwern@pobox.comE<gt>.  Hence, those parts
  Copyright Micheal G Schwern 2001.  Used and distributed with
  permission.
  
  This program is free software; you can redistribute it
  and/or modify it under the same terms as Perl itself.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 NOTES
  
  Thanks to Richard Clamp E<lt>richardc@unixbeard.netE<gt> for letting
  me use his testing system to try this module out on.
  
  =head1 SEE ALSO
  
  L<Test::Builder>, L<Test::Builder::Tester::Color>, L<Test::More>.
  
  =cut
  
  1;
  
  ####################################################################
  # Helper class that is used to remember expected and received data
  
  package Test::Builder::Tester::Tie;
  
  ##
  # add line(s) to be expected
  
  sub expect {
      my $self = shift;
  
      my @checks = @_;
      foreach my $check (@checks) {
          $check = $self->_account_for_subtest($check);
          $check = $self->_translate_Failed_check($check);
          push @{ $self->{wanted} }, ref $check ? $check : "$check\n";
      }
  }
  
  sub _account_for_subtest {
      my( $self, $check ) = @_;
  
      # Since we ship with Test::Builder, calling a private method is safe...ish.
      return ref($check) ? $check : $t->_indent . $check;
  }
  
  sub _translate_Failed_check {
      my( $self, $check ) = @_;
  
      if( $check =~ /\A(.*)#     (Failed .*test) \((.*?) at line (\d+)\)\Z(?!\n)/ ) {
          $check = "/\Q$1\E#\\s+\Q$2\E.*?\\n?.*?\Qat $3\E line \Q$4\E.*\\n?/";
      }
  
      return $check;
  }
  
  ##
  # return true iff the expected data matches the got data
  
  sub check {
      my $self = shift;
  
      # turn off warnings as these might be undef
      local $^W = 0;
  
      my @checks = @{ $self->{wanted} };
      my $got    = $self->{got};
      foreach my $check (@checks) {
          $check = "\Q$check\E" unless( $check =~ s,^/(.*)/$,$1, or ref $check );
          return 0 unless $got =~ s/^$check//;
      }
  
      return length $got == 0;
  }
  
  ##
  # a complaint message about the inputs not matching (to be
  # used for debugging messages)
  
  sub complaint {
      my $self   = shift;
      my $type   = $self->type;
      my $got    = $self->got;
      my $wanted = join '', @{ $self->wanted };
  
      # are we running in colour mode?
      if(Test::Builder::Tester::color) {
          # get color
          eval { require Term::ANSIColor };
          unless($@) {
              # colours
  
              my $green = Term::ANSIColor::color("black") . Term::ANSIColor::color("on_green");
              my $red   = Term::ANSIColor::color("black") . Term::ANSIColor::color("on_red");
              my $reset = Term::ANSIColor::color("reset");
  
              # work out where the two strings start to differ
              my $char = 0;
              $char++ while substr( $got, $char, 1 ) eq substr( $wanted, $char, 1 );
  
              # get the start string and the two end strings
              my $start = $green . substr( $wanted, 0, $char );
              my $gotend    = $red . substr( $got,    $char ) . $reset;
              my $wantedend = $red . substr( $wanted, $char ) . $reset;
  
              # make the start turn green on and off
              $start =~ s/\n/$reset\n$green/g;
  
              # make the ends turn red on and off
              $gotend    =~ s/\n/$reset\n$red/g;
              $wantedend =~ s/\n/$reset\n$red/g;
  
              # rebuild the strings
              $got    = $start . $gotend;
              $wanted = $start . $wantedend;
          }
      }
  
      return "$type is:\n" . "$got\nnot:\n$wanted\nas expected";
  }
  
  ##
  # forget all expected and got data
  
  sub reset {
      my $self = shift;
      %$self = (
          type   => $self->{type},
          got    => '',
          wanted => [],
      );
  }
  
  sub got {
      my $self = shift;
      return $self->{got};
  }
  
  sub wanted {
      my $self = shift;
      return $self->{wanted};
  }
  
  sub type {
      my $self = shift;
      return $self->{type};
  }
  
  ###
  # tie interface
  ###
  
  sub PRINT {
      my $self = shift;
      $self->{got} .= join '', @_;
  }
  
  sub TIEHANDLE {
      my( $class, $type ) = @_;
  
      my $self = bless { type => $type }, $class;
  
      $self->reset;
  
      return $self;
  }
  
  sub READ     { }
  sub READLINE { }
  sub GETC     { }
  sub FILENO   { }
  
  1;
PERL5_TEST_BUILDER_TESTER

$fatpacked{"perl5/Test/Builder/Tester/Color.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_TEST_BUILDER_TESTER_COLOR';
  package Test::Builder::Tester::Color;
  
  use strict;
  our $VERSION = "1.290001";
  
  require Test::Builder::Tester;
  
  
  =head1 NAME
  
  Test::Builder::Tester::Color - turn on colour in Test::Builder::Tester
  
  =head1 SYNOPSIS
  
     When running a test script
  
       perl -MTest::Builder::Tester::Color test.t
  
  =head1 DESCRIPTION
  
  Importing this module causes the subroutine color in Test::Builder::Tester
  to be called with a true value causing colour highlighting to be turned
  on in debug output.
  
  The sole purpose of this module is to enable colour highlighting
  from the command line.
  
  =cut
  
  sub import {
      Test::Builder::Tester::color(1);
  }
  
  =head1 AUTHOR
  
  Copyright Mark Fowler E<lt>mark@twoshortplanks.comE<gt> 2002.
  
  This program is free software; you can redistribute it
  and/or modify it under the same terms as Perl itself.
  
  =head1 BUGS
  
  This module will have no effect unless Term::ANSIColor is installed.
  
  =head1 SEE ALSO
  
  L<Test::Builder::Tester>, L<Term::ANSIColor>
  
  =cut
  
  1;
PERL5_TEST_BUILDER_TESTER_COLOR

$fatpacked{"perl5/Test/More.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_TEST_MORE';
  package Test::More;
  
  use 5.006;
  use strict;
  use warnings;
  
  #---- perlcritic exemptions. ----#
  
  # We use a lot of subroutine prototypes
  ## no critic (Subroutines::ProhibitSubroutinePrototypes)
  
  # Can't use Carp because it might cause C<use_ok()> to accidentally succeed
  # even though the module being used forgot to use Carp.  Yes, this
  # actually happened.
  sub _carp {
      my( $file, $line ) = ( caller(1) )[ 1, 2 ];
      return warn @_, " at $file line $line\n";
  }
  
  our $VERSION = '1.001014';
  $VERSION = eval $VERSION;    ## no critic (BuiltinFunctions::ProhibitStringyEval)
  
  use Test::Builder::Module 0.99;
  our @ISA    = qw(Test::Builder::Module);
  our @EXPORT = qw(ok use_ok require_ok
    is isnt like unlike is_deeply
    cmp_ok
    skip todo todo_skip
    pass fail
    eq_array eq_hash eq_set
    $TODO
    plan
    done_testing
    can_ok isa_ok new_ok
    diag note explain
    subtest
    BAIL_OUT
  );
  
  =head1 NAME
  
  Test::More - yet another framework for writing test scripts
  
  =head1 SYNOPSIS
  
    use Test::More tests => 23;
    # or
    use Test::More skip_all => $reason;
    # or
    use Test::More;   # see done_testing()
  
    require_ok( 'Some::Module' );
  
    # Various ways to say "ok"
    ok($got eq $expected, $test_name);
  
    is  ($got, $expected, $test_name);
    isnt($got, $expected, $test_name);
  
    # Rather than print STDERR "# here's what went wrong\n"
    diag("here's what went wrong");
  
    like  ($got, qr/expected/, $test_name);
    unlike($got, qr/expected/, $test_name);
  
    cmp_ok($got, '==', $expected, $test_name);
  
    is_deeply($got_complex_structure, $expected_complex_structure, $test_name);
  
    SKIP: {
        skip $why, $how_many unless $have_some_feature;
  
        ok( foo(),       $test_name );
        is( foo(42), 23, $test_name );
    };
  
    TODO: {
        local $TODO = $why;
  
        ok( foo(),       $test_name );
        is( foo(42), 23, $test_name );
    };
  
    can_ok($module, @methods);
    isa_ok($object, $class);
  
    pass($test_name);
    fail($test_name);
  
    BAIL_OUT($why);
  
    # UNIMPLEMENTED!!!
    my @status = Test::More::status;
  
  
  =head1 DESCRIPTION
  
  B<STOP!> If you're just getting started writing tests, have a look at
  L<Test::Simple> first.  This is a drop in replacement for Test::Simple
  which you can switch to once you get the hang of basic testing.
  
  The purpose of this module is to provide a wide range of testing
  utilities.  Various ways to say "ok" with better diagnostics,
  facilities to skip tests, test future features and compare complicated
  data structures.  While you can do almost anything with a simple
  C<ok()> function, it doesn't provide good diagnostic output.
  
  
  =head2 I love it when a plan comes together
  
  Before anything else, you need a testing plan.  This basically declares
  how many tests your script is going to run to protect against premature
  failure.
  
  The preferred way to do this is to declare a plan when you C<use Test::More>.
  
    use Test::More tests => 23;
  
  There are cases when you will not know beforehand how many tests your
  script is going to run.  In this case, you can declare your tests at
  the end.
  
    use Test::More;
  
    ... run your tests ...
  
    done_testing( $number_of_tests_run );
  
  Sometimes you really don't know how many tests were run, or it's too
  difficult to calculate.  In which case you can leave off
  $number_of_tests_run.
  
  In some cases, you'll want to completely skip an entire testing script.
  
    use Test::More skip_all => $skip_reason;
  
  Your script will declare a skip with the reason why you skipped and
  exit immediately with a zero (success).  See L<Test::Harness> for
  details.
  
  If you want to control what functions Test::More will export, you
  have to use the 'import' option.  For example, to import everything
  but 'fail', you'd do:
  
    use Test::More tests => 23, import => ['!fail'];
  
  Alternatively, you can use the C<plan()> function.  Useful for when you
  have to calculate the number of tests.
  
    use Test::More;
    plan tests => keys %Stuff * 3;
  
  or for deciding between running the tests at all:
  
    use Test::More;
    if( $^O eq 'MacOS' ) {
        plan skip_all => 'Test irrelevant on MacOS';
    }
    else {
        plan tests => 42;
    }
  
  =cut
  
  sub plan {
      my $tb = Test::More->builder;
  
      return $tb->plan(@_);
  }
  
  # This implements "use Test::More 'no_diag'" but the behavior is
  # deprecated.
  sub import_extra {
      my $class = shift;
      my $list  = shift;
  
      my @other = ();
      my $idx   = 0;
      while( $idx <= $#{$list} ) {
          my $item = $list->[$idx];
  
          if( defined $item and $item eq 'no_diag' ) {
              $class->builder->no_diag(1);
          }
          else {
              push @other, $item;
          }
  
          $idx++;
      }
  
      @$list = @other;
  
      return;
  }
  
  =over 4
  
  =item B<done_testing>
  
      done_testing();
      done_testing($number_of_tests);
  
  If you don't know how many tests you're going to run, you can issue
  the plan when you're done running tests.
  
  $number_of_tests is the same as C<plan()>, it's the number of tests you
  expected to run.  You can omit this, in which case the number of tests
  you ran doesn't matter, just the fact that your tests ran to
  conclusion.
  
  This is safer than and replaces the "no_plan" plan.
  
  =back
  
  =cut
  
  sub done_testing {
      my $tb = Test::More->builder;
      $tb->done_testing(@_);
  }
  
  =head2 Test names
  
  By convention, each test is assigned a number in order.  This is
  largely done automatically for you.  However, it's often very useful to
  assign a name to each test.  Which would you rather see:
  
    ok 4
    not ok 5
    ok 6
  
  or
  
    ok 4 - basic multi-variable
    not ok 5 - simple exponential
    ok 6 - force == mass * acceleration
  
  The later gives you some idea of what failed.  It also makes it easier
  to find the test in your script, simply search for "simple
  exponential".
  
  All test functions take a name argument.  It's optional, but highly
  suggested that you use it.
  
  =head2 I'm ok, you're not ok.
  
  The basic purpose of this module is to print out either "ok #" or "not
  ok #" depending on if a given test succeeded or failed.  Everything
  else is just gravy.
  
  All of the following print "ok" or "not ok" depending on if the test
  succeeded or failed.  They all also return true or false,
  respectively.
  
  =over 4
  
  =item B<ok>
  
    ok($got eq $expected, $test_name);
  
  This simply evaluates any expression (C<$got eq $expected> is just a
  simple example) and uses that to determine if the test succeeded or
  failed.  A true expression passes, a false one fails.  Very simple.
  
  For example:
  
      ok( $exp{9} == 81,                   'simple exponential' );
      ok( Film->can('db_Main'),            'set_db()' );
      ok( $p->tests == 4,                  'saw tests' );
      ok( !grep(!defined $_, @items),      'all items defined' );
  
  (Mnemonic:  "This is ok.")
  
  $test_name is a very short description of the test that will be printed
  out.  It makes it very easy to find a test in your script when it fails
  and gives others an idea of your intentions.  $test_name is optional,
  but we B<very> strongly encourage its use.
  
  Should an C<ok()> fail, it will produce some diagnostics:
  
      not ok 18 - sufficient mucus
      #   Failed test 'sufficient mucus'
      #   in foo.t at line 42.
  
  This is the same as L<Test::Simple>'s C<ok()> routine.
  
  =cut
  
  sub ok ($;$) {
      my( $test, $name ) = @_;
      my $tb = Test::More->builder;
  
      return $tb->ok( $test, $name );
  }
  
  =item B<is>
  
  =item B<isnt>
  
    is  ( $got, $expected, $test_name );
    isnt( $got, $expected, $test_name );
  
  Similar to C<ok()>, C<is()> and C<isnt()> compare their two arguments
  with C<eq> and C<ne> respectively and use the result of that to
  determine if the test succeeded or failed.  So these:
  
      # Is the ultimate answer 42?
      is( ultimate_answer(), 42,          "Meaning of Life" );
  
      # $foo isn't empty
      isnt( $foo, '',     "Got some foo" );
  
  are similar to these:
  
      ok( ultimate_answer() eq 42,        "Meaning of Life" );
      ok( $foo ne '',     "Got some foo" );
  
  C<undef> will only ever match C<undef>.  So you can test a value
  against C<undef> like this:
  
      is($not_defined, undef, "undefined as expected");
  
  (Mnemonic:  "This is that."  "This isn't that.")
  
  So why use these?  They produce better diagnostics on failure.  C<ok()>
  cannot know what you are testing for (beyond the name), but C<is()> and
  C<isnt()> know what the test was and why it failed.  For example this
  test:
  
      my $foo = 'waffle';  my $bar = 'yarblokos';
      is( $foo, $bar,   'Is foo the same as bar?' );
  
  Will produce something like this:
  
      not ok 17 - Is foo the same as bar?
      #   Failed test 'Is foo the same as bar?'
      #   in foo.t at line 139.
      #          got: 'waffle'
      #     expected: 'yarblokos'
  
  So you can figure out what went wrong without rerunning the test.
  
  You are encouraged to use C<is()> and C<isnt()> over C<ok()> where possible,
  however do not be tempted to use them to find out if something is
  true or false!
  
    # XXX BAD!
    is( exists $brooklyn{tree}, 1, 'A tree grows in Brooklyn' );
  
  This does not check if C<exists $brooklyn{tree}> is true, it checks if
  it returns 1.  Very different.  Similar caveats exist for false and 0.
  In these cases, use C<ok()>.
  
    ok( exists $brooklyn{tree},    'A tree grows in Brooklyn' );
  
  A simple call to C<isnt()> usually does not provide a strong test but there
  are cases when you cannot say much more about a value than that it is
  different from some other value:
  
    new_ok $obj, "Foo";
  
    my $clone = $obj->clone;
    isa_ok $obj, "Foo", "Foo->clone";
  
    isnt $obj, $clone, "clone() produces a different object";
  
  For those grammatical pedants out there, there's an C<isn't()>
  function which is an alias of C<isnt()>.
  
  =cut
  
  sub is ($$;$) {
      my $tb = Test::More->builder;
  
      return $tb->is_eq(@_);
  }
  
  sub isnt ($$;$) {
      my $tb = Test::More->builder;
  
      return $tb->isnt_eq(@_);
  }
  
  *isn't = \&isnt;
  # ' to unconfuse syntax higlighters
  
  =item B<like>
  
    like( $got, qr/expected/, $test_name );
  
  Similar to C<ok()>, C<like()> matches $got against the regex C<qr/expected/>.
  
  So this:
  
      like($got, qr/expected/, 'this is like that');
  
  is similar to:
  
      ok( $got =~ m/expected/, 'this is like that');
  
  (Mnemonic "This is like that".)
  
  The second argument is a regular expression.  It may be given as a
  regex reference (i.e. C<qr//>) or (for better compatibility with older
  perls) as a string that looks like a regex (alternative delimiters are
  currently not supported):
  
      like( $got, '/expected/', 'this is like that' );
  
  Regex options may be placed on the end (C<'/expected/i'>).
  
  Its advantages over C<ok()> are similar to that of C<is()> and C<isnt()>.  Better
  diagnostics on failure.
  
  =cut
  
  sub like ($$;$) {
      my $tb = Test::More->builder;
  
      return $tb->like(@_);
  }
  
  =item B<unlike>
  
    unlike( $got, qr/expected/, $test_name );
  
  Works exactly as C<like()>, only it checks if $got B<does not> match the
  given pattern.
  
  =cut
  
  sub unlike ($$;$) {
      my $tb = Test::More->builder;
  
      return $tb->unlike(@_);
  }
  
  =item B<cmp_ok>
  
    cmp_ok( $got, $op, $expected, $test_name );
  
  Halfway between C<ok()> and C<is()> lies C<cmp_ok()>.  This allows you
  to compare two arguments using any binary perl operator.  The test
  passes if the comparison is true and fails otherwise.
  
      # ok( $got eq $expected );
      cmp_ok( $got, 'eq', $expected, 'this eq that' );
  
      # ok( $got == $expected );
      cmp_ok( $got, '==', $expected, 'this == that' );
  
      # ok( $got && $expected );
      cmp_ok( $got, '&&', $expected, 'this && that' );
      ...etc...
  
  Its advantage over C<ok()> is when the test fails you'll know what $got
  and $expected were:
  
      not ok 1
      #   Failed test in foo.t at line 12.
      #     '23'
      #         &&
      #     undef
  
  It's also useful in those cases where you are comparing numbers and
  C<is()>'s use of C<eq> will interfere:
  
      cmp_ok( $big_hairy_number, '==', $another_big_hairy_number );
  
  It's especially useful when comparing greater-than or smaller-than 
  relation between values:
  
      cmp_ok( $some_value, '<=', $upper_limit );
  
  
  =cut
  
  sub cmp_ok($$$;$) {
      my $tb = Test::More->builder;
  
      return $tb->cmp_ok(@_);
  }
  
  =item B<can_ok>
  
    can_ok($module, @methods);
    can_ok($object, @methods);
  
  Checks to make sure the $module or $object can do these @methods
  (works with functions, too).
  
      can_ok('Foo', qw(this that whatever));
  
  is almost exactly like saying:
  
      ok( Foo->can('this') && 
          Foo->can('that') && 
          Foo->can('whatever') 
        );
  
  only without all the typing and with a better interface.  Handy for
  quickly testing an interface.
  
  No matter how many @methods you check, a single C<can_ok()> call counts
  as one test.  If you desire otherwise, use:
  
      foreach my $meth (@methods) {
          can_ok('Foo', $meth);
      }
  
  =cut
  
  sub can_ok ($@) {
      my( $proto, @methods ) = @_;
      my $class = ref $proto || $proto;
      my $tb = Test::More->builder;
  
      unless($class) {
          my $ok = $tb->ok( 0, "->can(...)" );
          $tb->diag('    can_ok() called with empty class or reference');
          return $ok;
      }
  
      unless(@methods) {
          my $ok = $tb->ok( 0, "$class->can(...)" );
          $tb->diag('    can_ok() called with no methods');
          return $ok;
      }
  
      my @nok = ();
      foreach my $method (@methods) {
          $tb->_try( sub { $proto->can($method) } ) or push @nok, $method;
      }
  
      my $name = (@methods == 1) ? "$class->can('$methods[0]')" :
                                   "$class->can(...)"           ;
  
      my $ok = $tb->ok( !@nok, $name );
  
      $tb->diag( map "    $class->can('$_') failed\n", @nok );
  
      return $ok;
  }
  
  =item B<isa_ok>
  
    isa_ok($object,   $class, $object_name);
    isa_ok($subclass, $class, $object_name);
    isa_ok($ref,      $type,  $ref_name);
  
  Checks to see if the given C<< $object->isa($class) >>.  Also checks to make
  sure the object was defined in the first place.  Handy for this sort
  of thing:
  
      my $obj = Some::Module->new;
      isa_ok( $obj, 'Some::Module' );
  
  where you'd otherwise have to write
  
      my $obj = Some::Module->new;
      ok( defined $obj && $obj->isa('Some::Module') );
  
  to safeguard against your test script blowing up.
  
  You can also test a class, to make sure that it has the right ancestor:
  
      isa_ok( 'Vole', 'Rodent' );
  
  It works on references, too:
  
      isa_ok( $array_ref, 'ARRAY' );
  
  The diagnostics of this test normally just refer to 'the object'.  If
  you'd like them to be more specific, you can supply an $object_name
  (for example 'Test customer').
  
  =cut
  
  sub isa_ok ($$;$) {
      my( $thing, $class, $thing_name ) = @_;
      my $tb = Test::More->builder;
  
      my $whatami;
      if( !defined $thing ) {
          $whatami = 'undef';
      }
      elsif( ref $thing ) {
          $whatami = 'reference';
  
          local($@,$!);
          require Scalar::Util;
          if( Scalar::Util::blessed($thing) ) {
              $whatami = 'object';
          }
      }
      else {
          $whatami = 'class';
      }
  
      # We can't use UNIVERSAL::isa because we want to honor isa() overrides
      my( $rslt, $error ) = $tb->_try( sub { $thing->isa($class) } );
  
      if($error) {
          die <<WHOA unless $error =~ /^Can't (locate|call) method "isa"/;
  WHOA! I tried to call ->isa on your $whatami and got some weird error.
  Here's the error.
  $error
  WHOA
      }
  
      # Special case for isa_ok( [], "ARRAY" ) and like
      if( $whatami eq 'reference' ) {
          $rslt = UNIVERSAL::isa($thing, $class);
      }
  
      my($diag, $name);
      if( defined $thing_name ) {
          $name = "'$thing_name' isa '$class'";
          $diag = defined $thing ? "'$thing_name' isn't a '$class'" : "'$thing_name' isn't defined";
      }
      elsif( $whatami eq 'object' ) {
          my $my_class = ref $thing;
          $thing_name = qq[An object of class '$my_class'];
          $name = "$thing_name isa '$class'";
          $diag = "The object of class '$my_class' isn't a '$class'";
      }
      elsif( $whatami eq 'reference' ) {
          my $type = ref $thing;
          $thing_name = qq[A reference of type '$type'];
          $name = "$thing_name isa '$class'";
          $diag = "The reference of type '$type' isn't a '$class'";
      }
      elsif( $whatami eq 'undef' ) {
          $thing_name = 'undef';
          $name = "$thing_name isa '$class'";
          $diag = "$thing_name isn't defined";
      }
      elsif( $whatami eq 'class' ) {
          $thing_name = qq[The class (or class-like) '$thing'];
          $name = "$thing_name isa '$class'";
          $diag = "$thing_name isn't a '$class'";
      }
      else {
          die;
      }
  
      my $ok;
      if($rslt) {
          $ok = $tb->ok( 1, $name );
      }
      else {
          $ok = $tb->ok( 0, $name );
          $tb->diag("    $diag\n");
      }
  
      return $ok;
  }
  
  =item B<new_ok>
  
    my $obj = new_ok( $class );
    my $obj = new_ok( $class => \@args );
    my $obj = new_ok( $class => \@args, $object_name );
  
  A convenience function which combines creating an object and calling
  C<isa_ok()> on that object.
  
  It is basically equivalent to:
  
      my $obj = $class->new(@args);
      isa_ok $obj, $class, $object_name;
  
  If @args is not given, an empty list will be used.
  
  This function only works on C<new()> and it assumes C<new()> will return
  just a single object which isa C<$class>.
  
  =cut
  
  sub new_ok {
      my $tb = Test::More->builder;
      $tb->croak("new_ok() must be given at least a class") unless @_;
  
      my( $class, $args, $object_name ) = @_;
  
      $args ||= [];
  
      my $obj;
      my( $success, $error ) = $tb->_try( sub { $obj = $class->new(@$args); 1 } );
      if($success) {
          local $Test::Builder::Level = $Test::Builder::Level + 1;
          isa_ok $obj, $class, $object_name;
      }
      else {
          $class = 'undef' if !defined $class;
          $tb->ok( 0, "$class->new() died" );
          $tb->diag("    Error was:  $error");
      }
  
      return $obj;
  }
  
  =item B<subtest>
  
      subtest $name => \&code;
  
  C<subtest()> runs the &code as its own little test with its own plan and
  its own result.  The main test counts this as a single test using the
  result of the whole subtest to determine if its ok or not ok.
  
  For example...
  
    use Test::More tests => 3;
   
    pass("First test");
  
    subtest 'An example subtest' => sub {
        plan tests => 2;
  
        pass("This is a subtest");
        pass("So is this");
    };
  
    pass("Third test");
  
  This would produce.
  
    1..3
    ok 1 - First test
        # Subtest: An example subtest
        1..2
        ok 1 - This is a subtest
        ok 2 - So is this
    ok 2 - An example subtest
    ok 3 - Third test
  
  A subtest may call C<skip_all>.  No tests will be run, but the subtest is
  considered a skip.
  
    subtest 'skippy' => sub {
        plan skip_all => 'cuz I said so';
        pass('this test will never be run');
    };
  
  Returns true if the subtest passed, false otherwise.
  
  Due to how subtests work, you may omit a plan if you desire.  This adds an
  implicit C<done_testing()> to the end of your subtest.  The following two
  subtests are equivalent:
  
    subtest 'subtest with implicit done_testing()', sub {
        ok 1, 'subtests with an implicit done testing should work';
        ok 1, '... and support more than one test';
        ok 1, '... no matter how many tests are run';
    };
  
    subtest 'subtest with explicit done_testing()', sub {
        ok 1, 'subtests with an explicit done testing should work';
        ok 1, '... and support more than one test';
        ok 1, '... no matter how many tests are run';
        done_testing();
    };
  
  =cut
  
  sub subtest {
      my ($name, $subtests) = @_;
  
      my $tb = Test::More->builder;
      return $tb->subtest(@_);
  }
  
  =item B<pass>
  
  =item B<fail>
  
    pass($test_name);
    fail($test_name);
  
  Sometimes you just want to say that the tests have passed.  Usually
  the case is you've got some complicated condition that is difficult to
  wedge into an C<ok()>.  In this case, you can simply use C<pass()> (to
  declare the test ok) or fail (for not ok).  They are synonyms for
  C<ok(1)> and C<ok(0)>.
  
  Use these very, very, very sparingly.
  
  =cut
  
  sub pass (;$) {
      my $tb = Test::More->builder;
  
      return $tb->ok( 1, @_ );
  }
  
  sub fail (;$) {
      my $tb = Test::More->builder;
  
      return $tb->ok( 0, @_ );
  }
  
  =back
  
  
  =head2 Module tests
  
  Sometimes you want to test if a module, or a list of modules, can
  successfully load.  For example, you'll often want a first test which
  simply loads all the modules in the distribution to make sure they
  work before going on to do more complicated testing.
  
  For such purposes we have C<use_ok> and C<require_ok>.
  
  =over 4
  
  =item B<require_ok>
  
     require_ok($module);
     require_ok($file);
  
  Tries to C<require> the given $module or $file.  If it loads
  successfully, the test will pass.  Otherwise it fails and displays the
  load error.
  
  C<require_ok> will guess whether the input is a module name or a
  filename.
  
  No exception will be thrown if the load fails.
  
      # require Some::Module
      require_ok "Some::Module";
  
      # require "Some/File.pl";
      require_ok "Some/File.pl";
  
      # stop testing if any of your modules will not load
      for my $module (@module) {
          require_ok $module or BAIL_OUT "Can't load $module";
      }
  
  =cut
  
  sub require_ok ($) {
      my($module) = shift;
      my $tb = Test::More->builder;
  
      my $pack = caller;
  
      # Try to determine if we've been given a module name or file.
      # Module names must be barewords, files not.
      $module = qq['$module'] unless _is_module_name($module);
  
      my $code = <<REQUIRE;
  package $pack;
  require $module;
  1;
  REQUIRE
  
      my( $eval_result, $eval_error ) = _eval($code);
      my $ok = $tb->ok( $eval_result, "require $module;" );
  
      unless($ok) {
          chomp $eval_error;
          $tb->diag(<<DIAGNOSTIC);
      Tried to require '$module'.
      Error:  $eval_error
  DIAGNOSTIC
  
      }
  
      return $ok;
  }
  
  sub _is_module_name {
      my $module = shift;
  
      # Module names start with a letter.
      # End with an alphanumeric.
      # The rest is an alphanumeric or ::
      $module =~ s/\b::\b//g;
  
      return $module =~ /^[a-zA-Z]\w*$/ ? 1 : 0;
  }
  
  
  =item B<use_ok>
  
     BEGIN { use_ok($module); }
     BEGIN { use_ok($module, @imports); }
  
  Like C<require_ok>, but it will C<use> the $module in question and
  only loads modules, not files.
  
  If you just want to test a module can be loaded, use C<require_ok>.
  
  If you just want to load a module in a test, we recommend simply using
  C<use> directly.  It will cause the test to stop.
  
  It's recommended that you run C<use_ok()> inside a BEGIN block so its
  functions are exported at compile-time and prototypes are properly
  honored.
  
  If @imports are given, they are passed through to the use.  So this:
  
     BEGIN { use_ok('Some::Module', qw(foo bar)) }
  
  is like doing this:
  
     use Some::Module qw(foo bar);
  
  Version numbers can be checked like so:
  
     # Just like "use Some::Module 1.02"
     BEGIN { use_ok('Some::Module', 1.02) }
  
  Don't try to do this:
  
     BEGIN {
         use_ok('Some::Module');
  
         ...some code that depends on the use...
         ...happening at compile time...
     }
  
  because the notion of "compile-time" is relative.  Instead, you want:
  
    BEGIN { use_ok('Some::Module') }
    BEGIN { ...some code that depends on the use... }
  
  If you want the equivalent of C<use Foo ()>, use a module but not
  import anything, use C<require_ok>.
  
    BEGIN { require_ok "Foo" }
  
  =cut
  
  sub use_ok ($;@) {
      my( $module, @imports ) = @_;
      @imports = () unless @imports;
      my $tb = Test::More->builder;
  
      my( $pack, $filename, $line ) = caller;
      $filename =~ y/\n\r/_/; # so it doesn't run off the "#line $line $f" line
  
      my $code;
      if( @imports == 1 and $imports[0] =~ /^\d+(?:\.\d+)?$/ ) {
          # probably a version check.  Perl needs to see the bare number
          # for it to work with non-Exporter based modules.
          $code = <<USE;
  package $pack;
  
  #line $line $filename
  use $module $imports[0];
  1;
  USE
      }
      else {
          $code = <<USE;
  package $pack;
  
  #line $line $filename
  use $module \@{\$args[0]};
  1;
  USE
      }
  
      my( $eval_result, $eval_error ) = _eval( $code, \@imports );
      my $ok = $tb->ok( $eval_result, "use $module;" );
  
      unless($ok) {
          chomp $eval_error;
          $@ =~ s{^BEGIN failed--compilation aborted at .*$}
                  {BEGIN failed--compilation aborted at $filename line $line.}m;
          $tb->diag(<<DIAGNOSTIC);
      Tried to use '$module'.
      Error:  $eval_error
  DIAGNOSTIC
  
      }
  
      return $ok;
  }
  
  sub _eval {
      my( $code, @args ) = @_;
  
      # Work around oddities surrounding resetting of $@ by immediately
      # storing it.
      my( $sigdie, $eval_result, $eval_error );
      {
          local( $@, $!, $SIG{__DIE__} );    # isolate eval
          $eval_result = eval $code;              ## no critic (BuiltinFunctions::ProhibitStringyEval)
          $eval_error  = $@;
          $sigdie      = $SIG{__DIE__} || undef;
      }
      # make sure that $code got a chance to set $SIG{__DIE__}
      $SIG{__DIE__} = $sigdie if defined $sigdie;
  
      return( $eval_result, $eval_error );
  }
  
  
  =back
  
  
  =head2 Complex data structures
  
  Not everything is a simple eq check or regex.  There are times you
  need to see if two data structures are equivalent.  For these
  instances Test::More provides a handful of useful functions.
  
  B<NOTE> I'm not quite sure what will happen with filehandles.
  
  =over 4
  
  =item B<is_deeply>
  
    is_deeply( $got, $expected, $test_name );
  
  Similar to C<is()>, except that if $got and $expected are references, it
  does a deep comparison walking each data structure to see if they are
  equivalent.  If the two structures are different, it will display the
  place where they start differing.
  
  C<is_deeply()> compares the dereferenced values of references, the
  references themselves (except for their type) are ignored.  This means
  aspects such as blessing and ties are not considered "different".
  
  C<is_deeply()> currently has very limited handling of function reference
  and globs.  It merely checks if they have the same referent.  This may
  improve in the future.
  
  L<Test::Differences> and L<Test::Deep> provide more in-depth functionality
  along these lines.
  
  =cut
  
  our( @Data_Stack, %Refs_Seen );
  my $DNE = bless [], 'Does::Not::Exist';
  
  sub _dne {
      return ref $_[0] eq ref $DNE;
  }
  
  ## no critic (Subroutines::RequireArgUnpacking)
  sub is_deeply {
      my $tb = Test::More->builder;
  
      unless( @_ == 2 or @_ == 3 ) {
          my $msg = <<'WARNING';
  is_deeply() takes two or three args, you gave %d.
  This usually means you passed an array or hash instead 
  of a reference to it
  WARNING
          chop $msg;    # clip off newline so carp() will put in line/file
  
          _carp sprintf $msg, scalar @_;
  
          return $tb->ok(0);
      }
  
      my( $got, $expected, $name ) = @_;
  
      $tb->_unoverload_str( \$expected, \$got );
  
      my $ok;
      if( !ref $got and !ref $expected ) {    # neither is a reference
          $ok = $tb->is_eq( $got, $expected, $name );
      }
      elsif( !ref $got xor !ref $expected ) {    # one's a reference, one isn't
          $ok = $tb->ok( 0, $name );
          $tb->diag( _format_stack({ vals => [ $got, $expected ] }) );
      }
      else {                                     # both references
          local @Data_Stack = ();
          if( _deep_check( $got, $expected ) ) {
              $ok = $tb->ok( 1, $name );
          }
          else {
              $ok = $tb->ok( 0, $name );
              $tb->diag( _format_stack(@Data_Stack) );
          }
      }
  
      return $ok;
  }
  
  sub _format_stack {
      my(@Stack) = @_;
  
      my $var       = '$FOO';
      my $did_arrow = 0;
      foreach my $entry (@Stack) {
          my $type = $entry->{type} || '';
          my $idx = $entry->{'idx'};
          if( $type eq 'HASH' ) {
              $var .= "->" unless $did_arrow++;
              $var .= "{$idx}";
          }
          elsif( $type eq 'ARRAY' ) {
              $var .= "->" unless $did_arrow++;
              $var .= "[$idx]";
          }
          elsif( $type eq 'REF' ) {
              $var = "\${$var}";
          }
      }
  
      my @vals = @{ $Stack[-1]{vals} }[ 0, 1 ];
      my @vars = ();
      ( $vars[0] = $var ) =~ s/\$FOO/     \$got/;
      ( $vars[1] = $var ) =~ s/\$FOO/\$expected/;
  
      my $out = "Structures begin differing at:\n";
      foreach my $idx ( 0 .. $#vals ) {
          my $val = $vals[$idx];
          $vals[$idx]
            = !defined $val ? 'undef'
            : _dne($val)    ? "Does not exist"
            : ref $val      ? "$val"
            :                 "'$val'";
      }
  
      $out .= "$vars[0] = $vals[0]\n";
      $out .= "$vars[1] = $vals[1]\n";
  
      $out =~ s/^/    /msg;
      return $out;
  }
  
  sub _type {
      my $thing = shift;
  
      return '' if !ref $thing;
  
      for my $type (qw(Regexp ARRAY HASH REF SCALAR GLOB CODE)) {
          return $type if UNIVERSAL::isa( $thing, $type );
      }
  
      return '';
  }
  
  =back
  
  
  =head2 Diagnostics
  
  If you pick the right test function, you'll usually get a good idea of
  what went wrong when it failed.  But sometimes it doesn't work out
  that way.  So here we have ways for you to write your own diagnostic
  messages which are safer than just C<print STDERR>.
  
  =over 4
  
  =item B<diag>
  
    diag(@diagnostic_message);
  
  Prints a diagnostic message which is guaranteed not to interfere with
  test output.  Like C<print> @diagnostic_message is simply concatenated
  together.
  
  Returns false, so as to preserve failure.
  
  Handy for this sort of thing:
  
      ok( grep(/foo/, @users), "There's a foo user" ) or
          diag("Since there's no foo, check that /etc/bar is set up right");
  
  which would produce:
  
      not ok 42 - There's a foo user
      #   Failed test 'There's a foo user'
      #   in foo.t at line 52.
      # Since there's no foo, check that /etc/bar is set up right.
  
  You might remember C<ok() or diag()> with the mnemonic C<open() or
  die()>.
  
  B<NOTE> The exact formatting of the diagnostic output is still
  changing, but it is guaranteed that whatever you throw at it won't
  interfere with the test.
  
  =item B<note>
  
    note(@diagnostic_message);
  
  Like C<diag()>, except the message will not be seen when the test is run
  in a harness.  It will only be visible in the verbose TAP stream.
  
  Handy for putting in notes which might be useful for debugging, but
  don't indicate a problem.
  
      note("Tempfile is $tempfile");
  
  =cut
  
  sub diag {
      return Test::More->builder->diag(@_);
  }
  
  sub note {
      return Test::More->builder->note(@_);
  }
  
  =item B<explain>
  
    my @dump = explain @diagnostic_message;
  
  Will dump the contents of any references in a human readable format.
  Usually you want to pass this into C<note> or C<diag>.
  
  Handy for things like...
  
      is_deeply($have, $want) || diag explain $have;
  
  or
  
      note explain \%args;
      Some::Class->method(%args);
  
  =cut
  
  sub explain {
      return Test::More->builder->explain(@_);
  }
  
  =back
  
  
  =head2 Conditional tests
  
  Sometimes running a test under certain conditions will cause the
  test script to die.  A certain function or method isn't implemented
  (such as C<fork()> on MacOS), some resource isn't available (like a 
  net connection) or a module isn't available.  In these cases it's
  necessary to skip tests, or declare that they are supposed to fail
  but will work in the future (a todo test).
  
  For more details on the mechanics of skip and todo tests see
  L<Test::Harness>.
  
  The way Test::More handles this is with a named block.  Basically, a
  block of tests which can be skipped over or made todo.  It's best if I
  just show you...
  
  =over 4
  
  =item B<SKIP: BLOCK>
  
    SKIP: {
        skip $why, $how_many if $condition;
  
        ...normal testing code goes here...
    }
  
  This declares a block of tests that might be skipped, $how_many tests
  there are, $why and under what $condition to skip them.  An example is
  the easiest way to illustrate:
  
      SKIP: {
          eval { require HTML::Lint };
  
          skip "HTML::Lint not installed", 2 if $@;
  
          my $lint = new HTML::Lint;
          isa_ok( $lint, "HTML::Lint" );
  
          $lint->parse( $html );
          is( $lint->errors, 0, "No errors found in HTML" );
      }
  
  If the user does not have HTML::Lint installed, the whole block of
  code I<won't be run at all>.  Test::More will output special ok's
  which Test::Harness interprets as skipped, but passing, tests.
  
  It's important that $how_many accurately reflects the number of tests
  in the SKIP block so the # of tests run will match up with your plan.
  If your plan is C<no_plan> $how_many is optional and will default to 1.
  
  It's perfectly safe to nest SKIP blocks.  Each SKIP block must have
  the label C<SKIP>, or Test::More can't work its magic.
  
  You don't skip tests which are failing because there's a bug in your
  program, or for which you don't yet have code written.  For that you
  use TODO.  Read on.
  
  =cut
  
  ## no critic (Subroutines::RequireFinalReturn)
  sub skip {
      my( $why, $how_many ) = @_;
      my $tb = Test::More->builder;
  
      unless( defined $how_many ) {
          # $how_many can only be avoided when no_plan is in use.
          _carp "skip() needs to know \$how_many tests are in the block"
            unless $tb->has_plan eq 'no_plan';
          $how_many = 1;
      }
  
      if( defined $how_many and $how_many =~ /\D/ ) {
          _carp
            "skip() was passed a non-numeric number of tests.  Did you get the arguments backwards?";
          $how_many = 1;
      }
  
      for( 1 .. $how_many ) {
          $tb->skip($why);
      }
  
      no warnings 'exiting';
      last SKIP;
  }
  
  =item B<TODO: BLOCK>
  
      TODO: {
          local $TODO = $why if $condition;
  
          ...normal testing code goes here...
      }
  
  Declares a block of tests you expect to fail and $why.  Perhaps it's
  because you haven't fixed a bug or haven't finished a new feature:
  
      TODO: {
          local $TODO = "URI::Geller not finished";
  
          my $card = "Eight of clubs";
          is( URI::Geller->your_card, $card, 'Is THIS your card?' );
  
          my $spoon;
          URI::Geller->bend_spoon;
          is( $spoon, 'bent',    "Spoon bending, that's original" );
      }
  
  With a todo block, the tests inside are expected to fail.  Test::More
  will run the tests normally, but print out special flags indicating
  they are "todo".  L<Test::Harness> will interpret failures as being ok.
  Should anything succeed, it will report it as an unexpected success.
  You then know the thing you had todo is done and can remove the
  TODO flag.
  
  The nice part about todo tests, as opposed to simply commenting out a
  block of tests, is it's like having a programmatic todo list.  You know
  how much work is left to be done, you're aware of what bugs there are,
  and you'll know immediately when they're fixed.
  
  Once a todo test starts succeeding, simply move it outside the block.
  When the block is empty, delete it.
  
  
  =item B<todo_skip>
  
      TODO: {
          todo_skip $why, $how_many if $condition;
  
          ...normal testing code...
      }
  
  With todo tests, it's best to have the tests actually run.  That way
  you'll know when they start passing.  Sometimes this isn't possible.
  Often a failing test will cause the whole program to die or hang, even
  inside an C<eval BLOCK> with and using C<alarm>.  In these extreme
  cases you have no choice but to skip over the broken tests entirely.
  
  The syntax and behavior is similar to a C<SKIP: BLOCK> except the
  tests will be marked as failing but todo.  L<Test::Harness> will
  interpret them as passing.
  
  =cut
  
  sub todo_skip {
      my( $why, $how_many ) = @_;
      my $tb = Test::More->builder;
  
      unless( defined $how_many ) {
          # $how_many can only be avoided when no_plan is in use.
          _carp "todo_skip() needs to know \$how_many tests are in the block"
            unless $tb->has_plan eq 'no_plan';
          $how_many = 1;
      }
  
      for( 1 .. $how_many ) {
          $tb->todo_skip($why);
      }
  
      no warnings 'exiting';
      last TODO;
  }
  
  =item When do I use SKIP vs. TODO?
  
  B<If it's something the user might not be able to do>, use SKIP.
  This includes optional modules that aren't installed, running under
  an OS that doesn't have some feature (like C<fork()> or symlinks), or maybe
  you need an Internet connection and one isn't available.
  
  B<If it's something the programmer hasn't done yet>, use TODO.  This
  is for any code you haven't written yet, or bugs you have yet to fix,
  but want to put tests in your testing script (always a good idea).
  
  
  =back
  
  
  =head2 Test control
  
  =over 4
  
  =item B<BAIL_OUT>
  
      BAIL_OUT($reason);
  
  Indicates to the harness that things are going so badly all testing
  should terminate.  This includes the running of any additional test scripts.
  
  This is typically used when testing cannot continue such as a critical
  module failing to compile or a necessary external utility not being
  available such as a database connection failing.
  
  The test will exit with 255.
  
  For even better control look at L<Test::Most>.
  
  =cut
  
  sub BAIL_OUT {
      my $reason = shift;
      my $tb     = Test::More->builder;
  
      $tb->BAIL_OUT($reason);
  }
  
  =back
  
  
  =head2 Discouraged comparison functions
  
  The use of the following functions is discouraged as they are not
  actually testing functions and produce no diagnostics to help figure
  out what went wrong.  They were written before C<is_deeply()> existed
  because I couldn't figure out how to display a useful diff of two
  arbitrary data structures.
  
  These functions are usually used inside an C<ok()>.
  
      ok( eq_array(\@got, \@expected) );
  
  C<is_deeply()> can do that better and with diagnostics.  
  
      is_deeply( \@got, \@expected );
  
  They may be deprecated in future versions.
  
  =over 4
  
  =item B<eq_array>
  
    my $is_eq = eq_array(\@got, \@expected);
  
  Checks if two arrays are equivalent.  This is a deep check, so
  multi-level structures are handled correctly.
  
  =cut
  
  #'#
  sub eq_array {
      local @Data_Stack = ();
      _deep_check(@_);
  }
  
  sub _eq_array {
      my( $a1, $a2 ) = @_;
  
      if( grep _type($_) ne 'ARRAY', $a1, $a2 ) {
          warn "eq_array passed a non-array ref";
          return 0;
      }
  
      return 1 if $a1 eq $a2;
  
      my $ok = 1;
      my $max = $#$a1 > $#$a2 ? $#$a1 : $#$a2;
      for( 0 .. $max ) {
          my $e1 = $_ > $#$a1 ? $DNE : $a1->[$_];
          my $e2 = $_ > $#$a2 ? $DNE : $a2->[$_];
  
          next if _equal_nonrefs($e1, $e2);
  
          push @Data_Stack, { type => 'ARRAY', idx => $_, vals => [ $e1, $e2 ] };
          $ok = _deep_check( $e1, $e2 );
          pop @Data_Stack if $ok;
  
          last unless $ok;
      }
  
      return $ok;
  }
  
  sub _equal_nonrefs {
      my( $e1, $e2 ) = @_;
  
      return if ref $e1 or ref $e2;
  
      if ( defined $e1 ) {
          return 1 if defined $e2 and $e1 eq $e2;
      }
      else {
          return 1 if !defined $e2;
      }
  
      return;
  }
  
  sub _deep_check {
      my( $e1, $e2 ) = @_;
      my $tb = Test::More->builder;
  
      my $ok = 0;
  
      # Effectively turn %Refs_Seen into a stack.  This avoids picking up
      # the same referenced used twice (such as [\$a, \$a]) to be considered
      # circular.
      local %Refs_Seen = %Refs_Seen;
  
      {
          $tb->_unoverload_str( \$e1, \$e2 );
  
          # Either they're both references or both not.
          my $same_ref = !( !ref $e1 xor !ref $e2 );
          my $not_ref = ( !ref $e1 and !ref $e2 );
  
          if( defined $e1 xor defined $e2 ) {
              $ok = 0;
          }
          elsif( !defined $e1 and !defined $e2 ) {
              # Shortcut if they're both undefined.
              $ok = 1;
          }
          elsif( _dne($e1) xor _dne($e2) ) {
              $ok = 0;
          }
          elsif( $same_ref and( $e1 eq $e2 ) ) {
              $ok = 1;
          }
          elsif($not_ref) {
              push @Data_Stack, { type => '', vals => [ $e1, $e2 ] };
              $ok = 0;
          }
          else {
              if( $Refs_Seen{$e1} ) {
                  return $Refs_Seen{$e1} eq $e2;
              }
              else {
                  $Refs_Seen{$e1} = "$e2";
              }
  
              my $type = _type($e1);
              $type = 'DIFFERENT' unless _type($e2) eq $type;
  
              if( $type eq 'DIFFERENT' ) {
                  push @Data_Stack, { type => $type, vals => [ $e1, $e2 ] };
                  $ok = 0;
              }
              elsif( $type eq 'ARRAY' ) {
                  $ok = _eq_array( $e1, $e2 );
              }
              elsif( $type eq 'HASH' ) {
                  $ok = _eq_hash( $e1, $e2 );
              }
              elsif( $type eq 'REF' ) {
                  push @Data_Stack, { type => $type, vals => [ $e1, $e2 ] };
                  $ok = _deep_check( $$e1, $$e2 );
                  pop @Data_Stack if $ok;
              }
              elsif( $type eq 'SCALAR' ) {
                  push @Data_Stack, { type => 'REF', vals => [ $e1, $e2 ] };
                  $ok = _deep_check( $$e1, $$e2 );
                  pop @Data_Stack if $ok;
              }
              elsif($type) {
                  push @Data_Stack, { type => $type, vals => [ $e1, $e2 ] };
                  $ok = 0;
              }
              else {
                  _whoa( 1, "No type in _deep_check" );
              }
          }
      }
  
      return $ok;
  }
  
  sub _whoa {
      my( $check, $desc ) = @_;
      if($check) {
          die <<"WHOA";
  WHOA!  $desc
  This should never happen!  Please contact the author immediately!
  WHOA
      }
  }
  
  =item B<eq_hash>
  
    my $is_eq = eq_hash(\%got, \%expected);
  
  Determines if the two hashes contain the same keys and values.  This
  is a deep check.
  
  =cut
  
  sub eq_hash {
      local @Data_Stack = ();
      return _deep_check(@_);
  }
  
  sub _eq_hash {
      my( $a1, $a2 ) = @_;
  
      if( grep _type($_) ne 'HASH', $a1, $a2 ) {
          warn "eq_hash passed a non-hash ref";
          return 0;
      }
  
      return 1 if $a1 eq $a2;
  
      my $ok = 1;
      my $bigger = keys %$a1 > keys %$a2 ? $a1 : $a2;
      foreach my $k ( keys %$bigger ) {
          my $e1 = exists $a1->{$k} ? $a1->{$k} : $DNE;
          my $e2 = exists $a2->{$k} ? $a2->{$k} : $DNE;
  
          next if _equal_nonrefs($e1, $e2);
  
          push @Data_Stack, { type => 'HASH', idx => $k, vals => [ $e1, $e2 ] };
          $ok = _deep_check( $e1, $e2 );
          pop @Data_Stack if $ok;
  
          last unless $ok;
      }
  
      return $ok;
  }
  
  =item B<eq_set>
  
    my $is_eq = eq_set(\@got, \@expected);
  
  Similar to C<eq_array()>, except the order of the elements is B<not>
  important.  This is a deep check, but the irrelevancy of order only
  applies to the top level.
  
      ok( eq_set(\@got, \@expected) );
  
  Is better written:
  
      is_deeply( [sort @got], [sort @expected] );
  
  B<NOTE> By historical accident, this is not a true set comparison.
  While the order of elements does not matter, duplicate elements do.
  
  B<NOTE> C<eq_set()> does not know how to deal with references at the top
  level.  The following is an example of a comparison which might not work:
  
      eq_set([\1, \2], [\2, \1]);
  
  L<Test::Deep> contains much better set comparison functions.
  
  =cut
  
  sub eq_set {
      my( $a1, $a2 ) = @_;
      return 0 unless @$a1 == @$a2;
  
      no warnings 'uninitialized';
  
      # It really doesn't matter how we sort them, as long as both arrays are
      # sorted with the same algorithm.
      #
      # Ensure that references are not accidentally treated the same as a
      # string containing the reference.
      #
      # Have to inline the sort routine due to a threading/sort bug.
      # See [rt.cpan.org 6782]
      #
      # I don't know how references would be sorted so we just don't sort
      # them.  This means eq_set doesn't really work with refs.
      return eq_array(
          [ grep( ref, @$a1 ), sort( grep( !ref, @$a1 ) ) ],
          [ grep( ref, @$a2 ), sort( grep( !ref, @$a2 ) ) ],
      );
  }
  
  =back
  
  
  =head2 Extending and Embedding Test::More
  
  Sometimes the Test::More interface isn't quite enough.  Fortunately,
  Test::More is built on top of L<Test::Builder> which provides a single,
  unified backend for any test library to use.  This means two test
  libraries which both use <Test::Builder> B<can> be used together in the
  same program>.
  
  If you simply want to do a little tweaking of how the tests behave,
  you can access the underlying L<Test::Builder> object like so:
  
  =over 4
  
  =item B<builder>
  
      my $test_builder = Test::More->builder;
  
  Returns the L<Test::Builder> object underlying Test::More for you to play
  with.
  
  
  =back
  
  
  =head1 EXIT CODES
  
  If all your tests passed, L<Test::Builder> will exit with zero (which is
  normal).  If anything failed it will exit with how many failed.  If
  you run less (or more) tests than you planned, the missing (or extras)
  will be considered failures.  If no tests were ever run L<Test::Builder>
  will throw a warning and exit with 255.  If the test died, even after
  having successfully completed all its tests, it will still be
  considered a failure and will exit with 255.
  
  So the exit codes are...
  
      0                   all tests successful
      255                 test died or all passed but wrong # of tests run
      any other number    how many failed (including missing or extras)
  
  If you fail more than 254 tests, it will be reported as 254.
  
  B<NOTE>  This behavior may go away in future versions.
  
  
  =head1 COMPATIBILITY
  
  Test::More works with Perls as old as 5.8.1.
  
  Thread support is not very reliable before 5.10.1, but that's
  because threads are not very reliable before 5.10.1.
  
  Although Test::More has been a core module in versions of Perl since 5.6.2, Test::More has evolved since then, and not all of the features you're used to will be present in the shipped version of Test::More. If you are writing a module, don't forget to indicate in your package metadata the minimum version of Test::More that you require. For instance, if you want to use C<done_testing()> but want your test script to run on Perl 5.10.0, you will need to explicitly require Test::More > 0.88.
  
  Key feature milestones include:
  
  =over 4
  
  =item subtests
  
  Subtests were released in Test::More 0.94, which came with Perl 5.12.0. Subtests did not implicitly call C<done_testing()> until 0.96; the first Perl with that fix was Perl 5.14.0 with 0.98.
  
  =item C<done_testing()>
  
  This was released in Test::More 0.88 and first shipped with Perl in 5.10.1 as part of Test::More 0.92. 
  
  =item C<cmp_ok()>
  
  Although C<cmp_ok()> was introduced in 0.40, 0.86 fixed an important bug to make it safe for overloaded objects; the fixed first shipped with Perl in 5.10.1 as part of Test::More 0.92.
  
  =item C<new_ok()> C<note()> and C<explain()>
  
  These were was released in Test::More 0.82, and first shipped with Perl in 5.10.1 as part of Test::More 0.92. 
  
  =back
  
  There is a full version history in the Changes file, and the Test::More versions included as core can be found using L<Module::CoreList>:
  
      $ corelist -a Test::More
  
  
  =head1 CAVEATS and NOTES
  
  =over 4
  
  =item utf8 / "Wide character in print"
  
  If you use utf8 or other non-ASCII characters with Test::More you
  might get a "Wide character in print" warning.  Using
  C<< binmode STDOUT, ":utf8" >> will not fix it.
  L<Test::Builder> (which powers
  Test::More) duplicates STDOUT and STDERR.  So any changes to them,
  including changing their output disciplines, will not be seem by
  Test::More.
  
  One work around is to apply encodings to STDOUT and STDERR as early
  as possible and before Test::More (or any other Test module) loads.
  
      use open ':std', ':encoding(utf8)';
      use Test::More;
  
  A more direct work around is to change the filehandles used by
  L<Test::Builder>.
  
      my $builder = Test::More->builder;
      binmode $builder->output,         ":encoding(utf8)";
      binmode $builder->failure_output, ":encoding(utf8)";
      binmode $builder->todo_output,    ":encoding(utf8)";
  
  
  =item Overloaded objects
  
  String overloaded objects are compared B<as strings> (or in C<cmp_ok()>'s
  case, strings or numbers as appropriate to the comparison op).  This
  prevents Test::More from piercing an object's interface allowing
  better blackbox testing.  So if a function starts returning overloaded
  objects instead of bare strings your tests won't notice the
  difference.  This is good.
  
  However, it does mean that functions like C<is_deeply()> cannot be used to
  test the internals of string overloaded objects.  In this case I would
  suggest L<Test::Deep> which contains more flexible testing functions for
  complex data structures.
  
  
  =item Threads
  
  Test::More will only be aware of threads if C<use threads> has been done
  I<before> Test::More is loaded.  This is ok:
  
      use threads;
      use Test::More;
  
  This may cause problems:
  
      use Test::More
      use threads;
  
  5.8.1 and above are supported.  Anything below that has too many bugs.
  
  =back
  
  
  =head1 HISTORY
  
  This is a case of convergent evolution with Joshua Pritikin's L<Test>
  module.  I was largely unaware of its existence when I'd first
  written my own C<ok()> routines.  This module exists because I can't
  figure out how to easily wedge test names into Test's interface (along
  with a few other problems).
  
  The goal here is to have a testing utility that's simple to learn,
  quick to use and difficult to trip yourself up with while still
  providing more flexibility than the existing Test.pm.  As such, the
  names of the most common routines are kept tiny, special cases and
  magic side-effects are kept to a minimum.  WYSIWYG.
  
  
  =head1 SEE ALSO
  
  =head2
  
  =head2 ALTERNATIVES
  
  L<Test::Simple> if all this confuses you and you just want to write
  some tests.  You can upgrade to Test::More later (it's forward
  compatible).
  
  L<Test::Legacy> tests written with Test.pm, the original testing
  module, do not play well with other testing libraries.  Test::Legacy
  emulates the Test.pm interface and does play well with others.
  
  =head2 TESTING FRAMEWORKS
  
  L<Fennec> The Fennec framework is a testers toolbox. It uses L<Test::Builder>
  under the hood. It brings enhancements for forking, defining state, and
  mocking. Fennec enhances several modules to work better together than they
  would if you loaded them individually on your own.
  
  L<Fennec::Declare> Provides enhanced (L<Devel::Declare>) syntax for Fennec.
  
  =head2 ADDITIONAL LIBRARIES
  
  L<Test::Differences> for more ways to test complex data structures.
  And it plays well with Test::More.
  
  L<Test::Class> is like xUnit but more perlish.
  
  L<Test::Deep> gives you more powerful complex data structure testing.
  
  L<Test::Inline> shows the idea of embedded testing.
  
  L<Mock::Quick> The ultimate mocking library. Easily spawn objects defined on
  the fly. Can also override, block, or reimplement packages as needed.
  
  L<Test::FixtureBuilder> Quickly define fixture data for unit tests.
  
  =head2 OTHER COMPONENTS
  
  L<Test::Harness> is the test runner and output interpreter for Perl.
  It's the thing that powers C<make test> and where the C<prove> utility
  comes from.
  
  =head2 BUNDLES
  
  L<Bundle::Test> installs a whole bunch of useful test modules.
  
  L<Test::Most> Most commonly needed test functions and features.
  
  =head1 AUTHORS
  
  Michael G Schwern E<lt>schwern@pobox.comE<gt> with much inspiration
  from Joshua Pritikin's Test module and lots of help from Barrie
  Slaymaker, Tony Bowden, blackstar.co.uk, chromatic, Fergal Daly and
  the perl-qa gang.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  
  =head1 BUGS
  
  See F<http://rt.cpan.org> to report and view bugs.
  
  
  =head1 SOURCE
  
  The source code repository for Test::More can be found at
  F<http://github.com/Test-More/test-more/>.
  
  
  =head1 COPYRIGHT
  
  Copyright 2001-2008 by Michael G Schwern E<lt>schwern@pobox.comE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
  
  1;
PERL5_TEST_MORE

$fatpacked{"perl5/Test/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_TEST_SIMPLE';
  package Test::Simple;
  
  use 5.006;
  
  use strict;
  
  our $VERSION = '1.001014';
  $VERSION = eval $VERSION;    ## no critic (BuiltinFunctions::ProhibitStringyEval)
  
  use Test::Builder::Module 0.99;
  our @ISA    = qw(Test::Builder::Module);
  our @EXPORT = qw(ok);
  
  my $CLASS = __PACKAGE__;
  
  =head1 NAME
  
  Test::Simple - Basic utilities for writing tests.
  
  =head1 SYNOPSIS
  
    use Test::Simple tests => 1;
  
    ok( $foo eq $bar, 'foo is bar' );
  
  
  =head1 DESCRIPTION
  
  ** If you are unfamiliar with testing B<read L<Test::Tutorial> first!> **
  
  This is an extremely simple, extremely basic module for writing tests
  suitable for CPAN modules and other pursuits.  If you wish to do more
  complicated testing, use the Test::More module (a drop-in replacement
  for this one).
  
  The basic unit of Perl testing is the ok.  For each thing you want to
  test your program will print out an "ok" or "not ok" to indicate pass
  or fail.  You do this with the C<ok()> function (see below).
  
  The only other constraint is you must pre-declare how many tests you
  plan to run.  This is in case something goes horribly wrong during the
  test and your test program aborts, or skips a test or whatever.  You
  do this like so:
  
      use Test::Simple tests => 23;
  
  You must have a plan.
  
  
  =over 4
  
  =item B<ok>
  
    ok( $foo eq $bar, $name );
    ok( $foo eq $bar );
  
  C<ok()> is given an expression (in this case C<$foo eq $bar>).  If it's
  true, the test passed.  If it's false, it didn't.  That's about it.
  
  C<ok()> prints out either "ok" or "not ok" along with a test number (it
  keeps track of that for you).
  
    # This produces "ok 1 - Hell not yet frozen over" (or not ok)
    ok( get_temperature($hell) > 0, 'Hell not yet frozen over' );
  
  If you provide a $name, that will be printed along with the "ok/not
  ok" to make it easier to find your test when if fails (just search for
  the name).  It also makes it easier for the next guy to understand
  what your test is for.  It's highly recommended you use test names.
  
  All tests are run in scalar context.  So this:
  
      ok( @stuff, 'I have some stuff' );
  
  will do what you mean (fail if stuff is empty)
  
  =cut
  
  sub ok ($;$) {    ## no critic (Subroutines::ProhibitSubroutinePrototypes)
      return $CLASS->builder->ok(@_);
  }
  
  =back
  
  Test::Simple will start by printing number of tests run in the form
  "1..M" (so "1..5" means you're going to run 5 tests).  This strange
  format lets L<Test::Harness> know how many tests you plan on running in
  case something goes horribly wrong.
  
  If all your tests passed, Test::Simple will exit with zero (which is
  normal).  If anything failed it will exit with how many failed.  If
  you run less (or more) tests than you planned, the missing (or extras)
  will be considered failures.  If no tests were ever run Test::Simple
  will throw a warning and exit with 255.  If the test died, even after
  having successfully completed all its tests, it will still be
  considered a failure and will exit with 255.
  
  So the exit codes are...
  
      0                   all tests successful
      255                 test died or all passed but wrong # of tests run
      any other number    how many failed (including missing or extras)
  
  If you fail more than 254 tests, it will be reported as 254.
  
  This module is by no means trying to be a complete testing system.
  It's just to get you started.  Once you're off the ground its
  recommended you look at L<Test::More>.
  
  
  =head1 EXAMPLE
  
  Here's an example of a simple .t file for the fictional Film module.
  
      use Test::Simple tests => 5;
  
      use Film;  # What you're testing.
  
      my $btaste = Film->new({ Title    => 'Bad Taste',
                               Director => 'Peter Jackson',
                               Rating   => 'R',
                               NumExplodingSheep => 1
                             });
      ok( defined($btaste) && ref $btaste eq 'Film',     'new() works' );
  
      ok( $btaste->Title      eq 'Bad Taste',     'Title() get'    );
      ok( $btaste->Director   eq 'Peter Jackson', 'Director() get' );
      ok( $btaste->Rating     eq 'R',             'Rating() get'   );
      ok( $btaste->NumExplodingSheep == 1,        'NumExplodingSheep() get' );
  
  It will produce output like this:
  
      1..5
      ok 1 - new() works
      ok 2 - Title() get
      ok 3 - Director() get
      not ok 4 - Rating() get
      #   Failed test 'Rating() get'
      #   in t/film.t at line 14.
      ok 5 - NumExplodingSheep() get
      # Looks like you failed 1 tests of 5
  
  Indicating the Film::Rating() method is broken.
  
  
  =head1 CAVEATS
  
  Test::Simple will only report a maximum of 254 failures in its exit
  code.  If this is a problem, you probably have a huge test script.
  Split it into multiple files.  (Otherwise blame the Unix folks for
  using an unsigned short integer as the exit status).
  
  Because VMS's exit codes are much, much different than the rest of the
  universe, and perl does horrible mangling to them that gets in my way,
  it works like this on VMS.
  
      0     SS$_NORMAL        all tests successful
      4     SS$_ABORT         something went wrong
  
  Unfortunately, I can't differentiate any further.
  
  
  =head1 NOTES
  
  Test::Simple is B<explicitly> tested all the way back to perl 5.6.0.
  
  Test::Simple is thread-safe in perl 5.8.1 and up.
  
  =head1 HISTORY
  
  This module was conceived while talking with Tony Bowden in his
  kitchen one night about the problems I was having writing some really
  complicated feature into the new Testing module.  He observed that the
  main problem is not dealing with these edge cases but that people hate
  to write tests B<at all>.  What was needed was a dead simple module
  that took all the hard work out of testing and was really, really easy
  to learn.  Paul Johnson simultaneously had this idea (unfortunately,
  he wasn't in Tony's kitchen).  This is it.
  
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<Test::More>
  
  More testing functions!  Once you outgrow Test::Simple, look at
  L<Test::More>.  Test::Simple is 100% forward compatible with L<Test::More>
  (i.e. you can just use L<Test::More> instead of Test::Simple in your
  programs and things will still work).
  
  =back
  
  Look in L<Test::More>'s SEE ALSO for more testing modules.
  
  
  =head1 AUTHORS
  
  Idea by Tony Bowden and Paul Johnson, code by Michael G Schwern
  E<lt>schwern@pobox.comE<gt>, wardrobe by Calvin Klein.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2001-2008 by Michael G Schwern E<lt>schwern@pobox.comE<gt>.
  
  This program is free software; you can redistribute it and/or 
  modify it under the same terms as Perl itself.
  
  See F<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
  
  1;
PERL5_TEST_SIMPLE

$fatpacked{"perl5/Test/Tester.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_TEST_TESTER';
  use strict;
  
  package Test::Tester;
  
  BEGIN
  {
  	if (*Test::Builder::new{CODE})
  	{
  		warn "You should load Test::Tester before Test::Builder (or anything that loads Test::Builder)" 
  	}
  }
  
  use Test::Builder;
  use Test::Tester::CaptureRunner;
  use Test::Tester::Delegate;
  
  require Exporter;
  
  use vars qw( @ISA @EXPORT $VERSION );
  
  $VERSION = "0.114";
  @EXPORT = qw( run_tests check_tests check_test cmp_results show_space );
  @ISA = qw( Exporter );
  
  my $Test = Test::Builder->new;
  my $Capture = Test::Tester::Capture->new;
  my $Delegator = Test::Tester::Delegate->new;
  $Delegator->{Object} = $Test;
  
  my $runner = Test::Tester::CaptureRunner->new;
  
  my $want_space = $ENV{TESTTESTERSPACE};
  
  sub show_space
  {
  	$want_space = 1;
  }
  
  my $colour = '';
  my $reset = '';
  
  if (my $want_colour = $ENV{TESTTESTERCOLOUR} || $ENV{TESTTESTERCOLOUR})
  {
  	if (eval "require Term::ANSIColor")
  	{
  		my ($f, $b) = split(",", $want_colour);
  		$colour = Term::ANSIColor::color($f).Term::ANSIColor::color("on_$b");
  		$reset = Term::ANSIColor::color("reset");
  	}
  
  }
  
  sub new_new
  {
  	return $Delegator;
  }
  
  sub capture
  {
  	return Test::Tester::Capture->new;
  }
  
  sub fh
  {
  	# experiment with capturing output, I don't like it
  	$runner = Test::Tester::FHRunner->new;
  
  	return $Test;
  }
  
  sub find_run_tests
  {
  	my $d = 1;
  	my $found = 0;
  	while ((not $found) and (my ($sub) = (caller($d))[3]) )
  	{
  #		print "$d: $sub\n";
  		$found = ($sub eq "Test::Tester::run_tests");
  		$d++;
  	}
  
  #	die "Didn't find 'run_tests' in caller stack" unless $found;
  	return $d;
  }
  
  sub run_tests
  {
  	local($Delegator->{Object}) = $Capture;
  
  	$runner->run_tests(@_);
  
  	return ($runner->get_premature, $runner->get_results);
  }
  
  sub check_test
  {
  	my $test = shift;
  	my $expect = shift;
  	my $name = shift;
  	$name = "" unless defined($name);
  
  	@_ = ($test, [$expect], $name);
  	goto &check_tests;
  }
  
  sub check_tests
  {
  	my $test = shift;
  	my $expects = shift;
  	my $name = shift;
  	$name = "" unless defined($name);
  
  	my ($prem, @results) = eval { run_tests($test, $name) };
  
  	$Test->ok(! $@, "Test '$name' completed") || $Test->diag($@);
  	$Test->ok(! length($prem), "Test '$name' no premature diagnostication") ||
  		$Test->diag("Before any testing anything, your tests said\n$prem");
  
  	local $Test::Builder::Level = $Test::Builder::Level + 1;
  	cmp_results(\@results, $expects, $name);
  	return ($prem, @results);
  }
  
  sub cmp_field
  {
  	my ($result, $expect, $field, $desc) = @_;
  
  	if (defined $expect->{$field})
  	{
  		$Test->is_eq($result->{$field}, $expect->{$field},
  			"$desc compare $field");
  	}
  }
  
  sub cmp_result
  {
  	my ($result, $expect, $name) = @_;
  
  	my $sub_name = $result->{name};
  	$sub_name = "" unless defined($name);
  
  	my $desc = "subtest '$sub_name' of '$name'";
  
  	{
  		local $Test::Builder::Level = $Test::Builder::Level + 1;
  
  		cmp_field($result, $expect, "ok", $desc);
  
  		cmp_field($result, $expect, "actual_ok", $desc);
  
  		cmp_field($result, $expect, "type", $desc);
  
  		cmp_field($result, $expect, "reason", $desc);
  
  		cmp_field($result, $expect, "name", $desc);
  	}
  
  	# if we got no depth then default to 1
  	my $depth = 1;
  	if (exists $expect->{depth})
  	{
  		$depth = $expect->{depth};
  	}
  
  	# if depth was explicitly undef then don't test it
  	if (defined $depth)
  	{
  		$Test->is_eq($result->{depth}, $depth, "checking depth") ||
  			$Test->diag('You need to change $Test::Builder::Level');
  	}
  
  	if (defined(my $exp = $expect->{diag}))
  	{
  		# if there actually is some diag then put a \n on the end if it's not
  		# there already
  
  		$exp .= "\n" if (length($exp) and $exp !~ /\n$/);
  		if (not $Test->ok($result->{diag} eq $exp,
  			"subtest '$sub_name' of '$name' compare diag")
  		)
  		{
  			my $got = $result->{diag};
  			my $glen = length($got);
  			my $elen = length($exp);
  			for ($got, $exp)
  			{
  				my @lines = split("\n", $_);
  	 			$_ = join("\n", map {
  					if ($want_space)
  					{
  						$_ = $colour.escape($_).$reset;
  					}
  					else
  					{
  						"'$colour$_$reset'"
  					}
  				} @lines);
  			}
  
  			$Test->diag(<<EOM);
  Got diag ($glen bytes):
  $got
  Expected diag ($elen bytes):
  $exp
  EOM
  
  		}
  	}
  }
  
  sub escape
  {
  	my $str = shift;
  	my $res = '';
  	for my $char (split("", $str))
  	{
  		my $c = ord($char);
  		if(($c>32 and $c<125) or $c == 10)
  		{
  			$res .= $char;
  		}
  		else
  		{
  			$res .= sprintf('\x{%x}', $c)
  		}
  	}
  	return $res;
  }
  
  sub cmp_results
  {
  	my ($results, $expects, $name) = @_;
  
  	$Test->is_num(scalar @$results, scalar @$expects, "Test '$name' result count");
  
  	for (my $i = 0; $i < @$expects; $i++)
  	{
  		my $expect = $expects->[$i];
  		my $result = $results->[$i];
  
  		local $Test::Builder::Level = $Test::Builder::Level + 1;
  		cmp_result($result, $expect, $name);
  	}
  }
  
  ######## nicked from Test::More
  sub plan {
  	my(@plan) = @_;
  
  	my $caller = caller;
  
  	$Test->exported_to($caller);
  
  	my @imports = ();
  	foreach my $idx (0..$#plan) {
  		if( $plan[$idx] eq 'import' ) {
  			my($tag, $imports) = splice @plan, $idx, 2;
  			@imports = @$imports;
  			last;
  		}
  	}
  
  	$Test->plan(@plan);
  
  	__PACKAGE__->_export_to_level(1, __PACKAGE__, @imports);
  }
  
  sub import {
  	my($class) = shift;
  		{
  			no warnings 'redefine';
  			*Test::Builder::new = \&new_new;
  		}
  	goto &plan;
  }
  
  sub _export_to_level
  {
          my $pkg = shift;
  	my $level = shift;
  	(undef) = shift;	# redundant arg
  	my $callpkg = caller($level);
  	$pkg->export($callpkg, @_);
  }
  
  
  ############
  
  1;
  
  __END__
  
  =head1 NAME
  
  Test::Tester - Ease testing test modules built with Test::Builder
  
  =head1 SYNOPSIS
  
    use Test::Tester tests => 6;
  
    use Test::MyStyle;
  
    check_test(
      sub {
        is_mystyle_eq("this", "that", "not eq");
      },
      {
        ok => 0, # expect this to fail
        name => "not eq",
        diag => "Expected: 'this'\nGot: 'that'",
      }
    );
  
  or
  
    use Test::Tester;
  
    use Test::More tests => 3;
    use Test::MyStyle;
  
    my ($premature, @results) = run_tests(
      sub {
        is_database_alive("dbname");
      }
    );
  
    # now use Test::More::like to check the diagnostic output
  
    like($results[0]->{diag}, "/^Database ping took \\d+ seconds$"/, "diag");
  
  =head1 DESCRIPTION
  
  If you have written a test module based on Test::Builder then Test::Tester
  allows you to test it with the minimum of effort.
  
  =head1 HOW TO USE (THE EASY WAY)
  
  From version 0.08 Test::Tester no longer requires you to included anything
  special in your test modules. All you need to do is
  
    use Test::Tester;
  
  in your test script B<before> any other Test::Builder based modules and away
  you go.
  
  Other modules based on Test::Builder can be used to help with the
  testing.  In fact you can even use functions from your module to test
  other functions from the same module (while this is possible it is
  probably not a good idea, if your module has bugs, then
  using it to test itself may give the wrong answers).
  
  The easiest way to test is to do something like
  
    check_test(
      sub { is_mystyle_eq("this", "that", "not eq") },
      {
        ok => 0, # we expect the test to fail
        name => "not eq",
        diag => "Expected: 'this'\nGot: 'that'",
      }
    );
  
  this will execute the is_mystyle_eq test, capturing it's results and
  checking that they are what was expected.
  
  You may need to examine the test results in a more flexible way, for
  example, the diagnostic output may be quite long or complex or it may involve
  something that you cannot predict in advance like a timestamp. In this case
  you can get direct access to the test results:
  
    my ($premature, @results) = run_tests(
      sub {
        is_database_alive("dbname");
      }
    );
  
    like($result[0]->{diag}, "/^Database ping took \\d+ seconds$"/, "diag");
  
  
  We cannot predict how long the database ping will take so we use
  Test::More's like() test to check that the diagnostic string is of the right
  form.
  
  =head1 HOW TO USE (THE HARD WAY)
  
  I<This is here for backwards compatibility only>
  
  Make your module use the Test::Tester::Capture object instead of the
  Test::Builder one. How to do this depends on your module but assuming that
  your module holds the Test::Builder object in $Test and that all your test
  routines access it through $Test then providing a function something like this
  
    sub set_builder
    {
      $Test = shift;
    }
  
  should allow your test scripts to do
  
    Test::YourModule::set_builder(Test::Tester->capture);
  
  and after that any tests inside your module will captured.
  
  =head1 TEST RESULTS
  
  The result of each test is captured in a hash. These hashes are the same as
  the hashes returned by Test::Builder->details but with a couple of extra
  fields.
  
  These fields are documented in L<Test::Builder> in the details() function
  
  =over 2
  
  =item ok
  
  Did the test pass?
  
  =item actual_ok
  
  Did the test really pass? That is, did the pass come from
  Test::Builder->ok() or did it pass because it was a TODO test?
  
  =item name
  
  The name supplied for the test.
  
  =item type
  
  What kind of test? Possibilities include, skip, todo etc. See
  L<Test::Builder> for more details.
  
  =item reason
  
  The reason for the skip, todo etc. See L<Test::Builder> for more details.
  
  =back
  
  These fields are exclusive to Test::Tester.
  
  =over 2
  
  =item diag
  
  Any diagnostics that were output for the test. This only includes
  diagnostics output B<after> the test result is declared.
  
  Note that Test::Builder ensures that any diagnostics end in a \n and
  it in earlier versions of Test::Tester it was essential that you have
  the final \n in your expected diagnostics. From version 0.10 onwards,
  Test::Tester will add the \n if you forgot it. It will not add a \n if
  you are expecting no diagnostics. See below for help tracking down
  hard to find space and tab related problems.
  
  =item depth
  
  This allows you to check that your test module is setting the correct value
  for $Test::Builder::Level and thus giving the correct file and line number
  when a test fails. It is calculated by looking at caller() and
  $Test::Builder::Level. It should count how many subroutines there are before
  jumping into the function you are testing. So for example in
  
    run_tests( sub { my_test_function("a", "b") } );
  
  the depth should be 1 and in
  
    sub deeper { my_test_function("a", "b") }
  
    run_tests(sub { deeper() });
  
  depth should be 2, that is 1 for the sub {} and one for deeper(). This
  might seem a little complex but if your tests look like the simple
  examples in this doc then you don't need to worry as the depth will
  always be 1 and that's what Test::Tester expects by default.
  
  B<Note>: if you do not specify a value for depth in check_test() then it
  automatically compares it against 1, if you really want to skip the depth
  test then pass in undef.
  
  B<Note>: depth will not be correctly calculated for tests that run from a
  signal handler or an END block or anywhere else that hides the call stack.
  
  =back
  
  Some of Test::Tester's functions return arrays of these hashes, just
  like Test::Builder->details. That is, the hash for the first test will
  be array element 1 (not 0). Element 0 will not be a hash it will be a
  string which contains any diagnostic output that came before the first
  test. This should usually be empty, if it's not, it means something
  output diagnostics before any test results showed up.
  
  =head1 SPACES AND TABS
  
  Appearances can be deceptive, especially when it comes to emptiness. If you
  are scratching your head trying to work out why Test::Tester is saying that
  your diagnostics are wrong when they look perfectly right then the answer is
  probably whitespace. From version 0.10 on, Test::Tester surrounds the
  expected and got diag values with single quotes to make it easier to spot
  trailing whitesapce. So in this example
  
    # Got diag (5 bytes):
    # 'abcd '
    # Expected diag (4 bytes):
    # 'abcd'
  
  it is quite clear that there is a space at the end of the first string.
  Another way to solve this problem is to use colour and inverse video on an
  ANSI terminal, see below COLOUR below if you want this.
  
  Unfortunately this is sometimes not enough, neither colour nor quotes will
  help you with problems involving tabs, other non-printing characters and
  certain kinds of problems inherent in Unicode. To deal with this, you can
  switch Test::Tester into a mode whereby all "tricky" characters are shown as
  \{xx}. Tricky characters are those with ASCII code less than 33 or higher
  than 126. This makes the output more difficult to read but much easier to
  find subtle differences between strings. To turn on this mode either call
  show_space() in your test script or set the TESTTESTERSPACE environment
  variable to be a true value. The example above would then look like
  
    # Got diag (5 bytes):
    # abcd\x{20}
    # Expected diag (4 bytes):
    # abcd
  
  =head1 COLOUR
  
  If you prefer to use colour as a means of finding tricky whitespace
  characters then you can set the TESTTESTCOLOUR environment variable to a
  comma separated pair of colours, the first for the foreground, the second
  for the background. For example "white,red" will print white text on a red
  background. This requires the Term::ANSIColor module. You can specify any
  colour that would be acceptable to the Term::ANSIColor::color function.
  
  If you spell colour differently, that's no problem. The TESTTESTERCOLOR
  variable also works (if both are set then the British spelling wins out).
  
  =head1 EXPORTED FUNCTIONS
  
  =head3 ($premature, @results) = run_tests(\&test_sub)
  
  \&test_sub is a reference to a subroutine.
  
  run_tests runs the subroutine in $test_sub and captures the results of any
  tests inside it. You can run more than 1 test inside this subroutine if you
  like.
  
  $premature is a string containing any diagnostic output from before
  the first test.
  
  @results is an array of test result hashes.
  
  =head3 cmp_result(\%result, \%expect, $name)
  
  \%result is a ref to a test result hash.
  
  \%expect is a ref to a hash of expected values for the test result.
  
  cmp_result compares the result with the expected values. If any differences
  are found it outputs diagnostics. You may leave out any field from the
  expected result and cmp_result will not do the comparison of that field.
  
  =head3 cmp_results(\@results, \@expects, $name)
  
  \@results is a ref to an array of test results.
  
  \@expects is a ref to an array of hash refs.
  
  cmp_results checks that the results match the expected results and if any
  differences are found it outputs diagnostics. It first checks that the
  number of elements in \@results and \@expects is the same. Then it goes
  through each result checking it against the expected result as in
  cmp_result() above.
  
  =head3 ($premature, @results) = check_tests(\&test_sub, \@expects, $name)
  
  \&test_sub is a reference to a subroutine.
  
  \@expect is a ref to an array of hash refs which are expected test results.
  
  check_tests combines run_tests and cmp_tests into a single call. It also
  checks if the tests died at any stage.
  
  It returns the same values as run_tests, so you can further examine the test
  results if you need to.
  
  =head3 ($premature, @results) = check_test(\&test_sub, \%expect, $name)
  
  \&test_sub is a reference to a subroutine.
  
  \%expect is a ref to an hash of expected values for the test result.
  
  check_test is a wrapper around check_tests. It combines run_tests and
  cmp_tests into a single call, checking if the test died. It assumes
  that only a single test is run inside \&test_sub and include a test to
  make sure this is true.
  
  It returns the same values as run_tests, so you can further examine the test
  results if you need to.
  
  =head3 show_space()
  
  Turn on the escaping of characters as described in the SPACES AND TABS
  section.
  
  =head1 HOW IT WORKS
  
  Normally, a test module (let's call it Test:MyStyle) calls
  Test::Builder->new to get the Test::Builder object. Test::MyStyle calls
  methods on this object to record information about test results. When
  Test::Tester is loaded, it replaces Test::Builder's new() method with one
  which returns a Test::Tester::Delegate object. Most of the time this object
  behaves as the real Test::Builder object. Any methods that are called are
  delegated to the real Test::Builder object so everything works perfectly.
  However once we go into test mode, the method calls are no longer passed to
  the real Test::Builder object, instead they go to the Test::Tester::Capture
  object. This object seems exactly like the real Test::Builder object,
  except, instead of outputting test results and diagnostics, it just records
  all the information for later analysis.
  
  =head1 CAVEATS
  
  Support for calling Test::Builder->note is minimal. It's implemented
  as an empty stub, so modules that use it will not crash but the calls
  are not recorded for testing purposes like the others. Patches
  welcome.
  
  =head1 SEE ALSO
  
  L<Test::Builder> the source of testing goodness. L<Test::Builder::Tester>
  for an alternative approach to the problem tackled by Test::Tester -
  captures the strings output by Test::Builder. This means you cannot get
  separate access to the individual pieces of information and you must predict
  B<exactly> what your test will output.
  
  =head1 AUTHOR
  
  This module is copyright 2005 Fergal Daly <fergal@esatclear.ie>, some parts
  are based on other people's work.
  
  Plan handling lifted from Test::More. written by Michael G Schwern
  <schwern@pobox.com>.
  
  Test::Tester::Capture is a cut down and hacked up version of Test::Builder.
  Test::Builder was written by chromatic <chromatic@wgz.org> and Michael G
  Schwern <schwern@pobox.com>.
  
  =head1 LICENSE
  
  Under the same license as Perl itself
  
  See http://www.perl.com/perl/misc/Artistic.html
  
  =cut
PERL5_TEST_TESTER

$fatpacked{"perl5/Test/Tester/Capture.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_TEST_TESTER_CAPTURE';
  use strict;
  
  package Test::Tester::Capture;
  
  use Test::Builder;
  
  use vars qw( @ISA );
  @ISA = qw( Test::Builder );
  
  # Make Test::Tester::Capture thread-safe for ithreads.
  BEGIN {
  	use Config;
  	if( $] >= 5.008 && $Config{useithreads} ) {
  		require threads::shared;
  		threads::shared->import;
  	}
  	else {
  		*share = sub { 0 };
  		*lock  = sub { 0 };
  	}
  }
  
  my $Curr_Test = 0;      share($Curr_Test);
  my @Test_Results = ();  share(@Test_Results);
  my $Prem_Diag = {diag => ""};	 share($Curr_Test);
  
  sub new
  {
    # Test::Tester::Capgture::new used to just return __PACKAGE__
    # because Test::Builder::new enforced it's singleton nature by
    # return __PACKAGE__. That has since changed, Test::Builder::new now
    # returns a blessed has and around version 0.78, Test::Builder::todo
    # started wanting to modify $self. To cope with this, we now return
    # a blessed hash. This is a short-term hack, the correct thing to do
    # is to detect which style of Test::Builder we're dealing with and
    # act appropriately.
  
    my $class = shift;
    return bless {}, $class;
  }
  
  sub ok {
  	my($self, $test, $name) = @_;
  
  	# $test might contain an object which we don't want to accidentally
  	# store, so we turn it into a boolean.
  	$test = $test ? 1 : 0;
  
  	lock $Curr_Test;
  	$Curr_Test++;
  
  	my($pack, $file, $line) = $self->caller;
  
  	my $todo = $self->todo($pack);
  
  	my $result = {};
  	share($result);
  
  	unless( $test ) {
  		@$result{ 'ok', 'actual_ok' } = ( ( $todo ? 1 : 0 ), 0 );
  	}
  	else {
  		@$result{ 'ok', 'actual_ok' } = ( 1, $test );
  	}
  
  	if( defined $name ) {
  		$name =~ s|#|\\#|g;	 # # in a name can confuse Test::Harness.
  		$result->{name} = $name;
  	}
  	else {
  		$result->{name} = '';
  	}
  
  	if( $todo ) {
  		my $what_todo = $todo;
  		$result->{reason} = $what_todo;
  		$result->{type}   = 'todo';
  	}
  	else {
  		$result->{reason} = '';
  		$result->{type}   = '';
  	}
  
  	$Test_Results[$Curr_Test-1] = $result;
  
  	unless( $test ) {
  		my $msg = $todo ? "Failed (TODO)" : "Failed";
  		$result->{fail_diag} = ("	$msg test ($file at line $line)\n");
  	} 
  
  	$result->{diag} = "";
  	$result->{_level} = $Test::Builder::Level;
  	$result->{_depth} = Test::Tester::find_run_tests();
  
  	return $test ? 1 : 0;
  }
  
  sub skip {
  	my($self, $why) = @_;
  	$why ||= '';
  
  	lock($Curr_Test);
  	$Curr_Test++;
  
  	my %result;
  	share(%result);
  	%result = (
  		'ok'	  => 1,
  		actual_ok => 1,
  		name	  => '',
  		type	  => 'skip',
  		reason	=> $why,
  		diag    => "",
  		_level   => $Test::Builder::Level,
  		_depth => Test::Tester::find_run_tests(),
  	);
  	$Test_Results[$Curr_Test-1] = \%result;
  
  	return 1;
  }
  
  sub todo_skip {
  	my($self, $why) = @_;
  	$why ||= '';
  
  	lock($Curr_Test);
  	$Curr_Test++;
  
  	my %result;
  	share(%result);
  	%result = (
  		'ok'	  => 1,
  		actual_ok => 0,
  		name	  => '',
  		type	  => 'todo_skip',
  		reason	=> $why,
  		diag    => "",
  		_level   => $Test::Builder::Level,
  		_depth => Test::Tester::find_run_tests(),
  	);
  
  	$Test_Results[$Curr_Test-1] = \%result;
  
  	return 1;
  }
  
  sub diag {
  	my($self, @msgs) = @_;
  	return unless @msgs;
  
  	# Prevent printing headers when compiling (i.e. -c)
  	return if $^C;
  
  	# Escape each line with a #.
  	foreach (@msgs) {
  		$_ = 'undef' unless defined;
  	}
  
  	push @msgs, "\n" unless $msgs[-1] =~ /\n\Z/;
  
  	my $result = $Curr_Test ? $Test_Results[$Curr_Test - 1] : $Prem_Diag;
  
  	$result->{diag} .= join("", @msgs);
  
  	return 0;
  }
  
  sub details {
  	return @Test_Results;
  }
  
  
  # Stub. Feel free to send me a patch to implement this.
  sub note {
  }
  
  sub explain {
  	return Test::Builder::explain(@_);
  }
  
  sub premature
  {
  	return $Prem_Diag->{diag};
  }
  
  sub current_test
  {
  	if (@_ > 1)
  	{
  		die "Don't try to change the test number!";
  	}
  	else
  	{
  		return $Curr_Test;
  	}
  }
  
  sub reset
  {
  	$Curr_Test = 0;
  	@Test_Results = ();
  	$Prem_Diag = {diag => ""};
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Test::Tester::Capture - Help testing test modules built with Test::Builder
  
  =head1 DESCRIPTION
  
  This is a subclass of Test::Builder that overrides many of the methods so
  that they don't output anything. It also keeps track of it's own set of test
  results so that you can use Test::Builder based modules to perform tests on
  other Test::Builder based modules.
  
  =head1 AUTHOR
  
  Most of the code here was lifted straight from Test::Builder and then had
  chunks removed by Fergal Daly <fergal@esatclear.ie>.
  
  =head1 LICENSE
  
  Under the same license as Perl itself
  
  See http://www.perl.com/perl/misc/Artistic.html
  
  =cut
PERL5_TEST_TESTER_CAPTURE

$fatpacked{"perl5/Test/Tester/CaptureRunner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_TEST_TESTER_CAPTURERUNNER';
  # $Header: /home/fergal/my/cvs/Test-Tester/lib/Test/Tester/CaptureRunner.pm,v 1.3 2003/03/05 01:07:55 fergal Exp $
  use strict;
  
  package Test::Tester::CaptureRunner;
  
  use Test::Tester::Capture;
  require Exporter;
  
  sub new
  {
  	my $pkg = shift;
  	my $self = bless {}, $pkg;
  	return $self;
  }
  
  sub run_tests
  {
  	my $self = shift;
  
  	my $test = shift;
  
  	capture()->reset;
  
  	$self->{StartLevel} = $Test::Builder::Level;
  	&$test();
  }
  
  sub get_results
  {
  	my $self = shift;
  	my @results = capture()->details;
  
  	my $start = $self->{StartLevel};
  	foreach my $res (@results)
  	{
  		next if defined $res->{depth};
  		my $depth = $res->{_depth} - $res->{_level} - $start - 3;
  #		print "my $depth = $res->{_depth} - $res->{_level} - $start - 1\n";
  		$res->{depth} = $depth;
  	}
  
  	return @results;
  }
  
  sub get_premature
  {
  	return capture()->premature;
  }
  
  sub capture
  {
  	return Test::Tester::Capture->new;
  }
  
  __END__
  
  =head1 NAME
  
  Test::Tester::CaptureRunner - Help testing test modules built with Test::Builder
  
  =head1 DESCRIPTION
  
  This stuff if needed to allow me to play with other ways of monitoring the
  test results.
  
  =head1 AUTHOR
  
  Copyright 2003 by Fergal Daly <fergal@esatclear.ie>.
  
  =head1 LICENSE
  
  Under the same license as Perl itself
  
  See http://www.perl.com/perl/misc/Artistic.html
  
  =cut
PERL5_TEST_TESTER_CAPTURERUNNER

$fatpacked{"perl5/Test/Tester/Delegate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_TEST_TESTER_DELEGATE';
  use strict;
  use warnings;
  
  package Test::Tester::Delegate;
  
  use vars '$AUTOLOAD';
  
  sub new
  {
  	my $pkg = shift;
  
  	my $obj = shift;
  	my $self = bless {}, $pkg;
  
  	return $self;
  }
  
  sub AUTOLOAD
  {
  	my ($sub) = $AUTOLOAD =~ /.*::(.*?)$/;
  
  	return if $sub eq "DESTROY";
  
  	my $obj = $_[0]->{Object};
  
  	my $ref = $obj->can($sub);
  	shift(@_);
  	unshift(@_, $obj);
  	goto &$ref;
  }
  
  1;
PERL5_TEST_TESTER_DELEGATE

$fatpacked{"perl5/Test/use/ok.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_TEST_USE_OK';
  package Test::use::ok;
  use 5.005;
  $Test::use::ok::VERSION = '0.16';
  
  __END__
  
  =head1 NAME
  
  Test::use::ok - Alternative to Test::More::use_ok
  
  =head1 SYNOPSIS
  
      use ok 'Some::Module';
  
  =head1 DESCRIPTION
  
  According to the B<Test::More> documentation, it is recommended to run
  C<use_ok()> inside a C<BEGIN> block, so functions are exported at
  compile-time and prototypes are properly honored.
  
  That is, instead of writing this:
  
      use_ok( 'Some::Module' );
      use_ok( 'Other::Module' );
  
  One should write this:
  
      BEGIN { use_ok( 'Some::Module' ); }
      BEGIN { use_ok( 'Other::Module' ); }
  
  However, people often either forget to add C<BEGIN>, or mistakenly group
  C<use_ok> with other tests in a single C<BEGIN> block, which can create subtle
  differences in execution order.
  
  With this module, simply change all C<use_ok> in test scripts to C<use ok>,
  and they will be executed at C<BEGIN> time.  The explicit space after C<use>
  makes it clear that this is a single compile-time action.
  
  =head1 SEE ALSO
  
  L<Test::More>
  
  =head1 MAINTAINER
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =encoding utf8
  
  =head1 CC0 1.0 Universal
  
  To the extent possible under law, 唐鳳 has waived all copyright and related
  or neighboring rights to L<Test-use-ok>.
  
  This work is published from Taiwan.
  
  L<http://creativecommons.org/publicdomain/zero/1.0>
  
  =cut
PERL5_TEST_USE_OK

$fatpacked{"perl5/ok.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_OK';
  package ok;
  $ok::VERSION = '0.16';
  
  use strict;
  use Test::More ();
  
  sub import {
      shift;
  
      if (@_) {
          goto &Test::More::pass if $_[0] eq 'ok';
          goto &Test::More::use_ok;
      }
  
      # No argument list - croak as if we are prototyped like use_ok()
      my (undef, $file, $line) = caller();
      ($file =~ /^\(eval/) or die "Not enough arguments for 'use ok' at $file line $line\n";
  }
  
  
  __END__
  
  =head1 NAME
  
  ok - Alternative to Test::More::use_ok
  
  =head1 SYNOPSIS
  
      use ok 'Some::Module';
  
  =head1 DESCRIPTION
  
  With this module, simply change all C<use_ok> in test scripts to C<use ok>,
  and they will be executed at C<BEGIN> time.
  
  Please see L<Test::use::ok> for the full description.
  
  =head1 CC0 1.0 Universal
  
  To the extent possible under law, 唐鳳 has waived all copyright and related
  or neighboring rights to L<Test-use-ok>.
  
  This work is published from Taiwan.
  
  L<http://creativecommons.org/publicdomain/zero/1.0>
  
  =cut
PERL5_OK

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

package SpamReport;
use SpamReport::Data;
use SpamReport::ANSIColor;

use common::sense;
use 5.008_008; use v5.8.8;

use vars qw/$VERSION/;
$VERSION = '2016022601';

use Time::Local;
use Time::localtime;
use POSIX qw(strftime);
use Date::Parse;

use Getopt::Long qw(GetOptions HelpMessage VersionMessage);
use Pod::Usage;

use File::Basename;
use IO::Handle;

use Socket qw(inet_aton inet_ntoa);
use Sys::Hostname::Long qw(hostname_long);

use Regexp::Common qw/Exim Maillog SpamReport/;
use YAML::Syck qw(DumpFile);  # only for --dump

use base qw(
    SpamReport::Output
    SpamReport::Cpanel
    SpamReport::Exim
    SpamReport::Maillog
    SpamReport::Exim::DB
    File::Nonblock
);

# Bypass using timelocal to calculate the timezone offset
my @time = CORE::localtime(time);
my $tz_offset = timegm(@time) - timelocal(@time);
my $now = strftime("%s", @time);
my @months = qw[Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec];
my %month_to_ord = map {$months[$_] => $_} (0 .. $#months);

my %OPTS = (
    'search_hours'  => 72,
    'start_time'    => 0,
    'end_time'      => scalar CORE::localtime($now),
    'time_override' => undef,
    'read_lines'    => 10000,
    'r_cutoff'      => 1.0,

    'report'        => 'summary',
    # other values: user, script, md5, logins, forwarders, helos, cachelist

    # summary categories
    'with_queue'    => 1,
    'with_scripts'  => 1,
    'with_mail'     => 1,
    'with_auth'     => 1,
    'with_forward'  => 1,

    # work categories
    'want_queue'    => 0,
    'want_maillog'  => 0,
    'want_eximlog'  => 0,
    'want_scripts'  => 0,
    'want_eximdb'   => 0,

    # operation modes
    'op'            => 'report',
    # other values: 'cron', 'update'
    
    # data modes
    'load'          => 'cron',
    # other values: 'cache', undef
    'save'          => 1,
);

END {
    DumpFile($OPTS{'dump'}.".post", $data) if $OPTS{'dump'};
}

my @SAVED_OPTS = qw(search_hours start_time end_time timespec);

my $hostname = hostname_long();
my $main_ip = inet_ntoa(scalar gethostbyname($hostname || 'localhost'));

my %factories;
my %sections;

sub run_ecpp {
    Getopt::Long::Configure(qw(gnu_getopt auto_version auto_help));
    my $result;
    my $time_changed;

    $OPTS{'report'} = 'user';
    $OPTS{'load'} = 'cache';
    $OPTS{'user'} = $ARGV[0];
    $OPTS{'full'} = 1;
    $result = GetOptions(
        'start|s=s'   => sub { $time_changed++; $OPTS{'start_time'} = $_[1]; },
        'end|e=s'     => sub { $time_changed++; $OPTS{'end_time'} = $_[1]; },
        'hours|h=i'   => sub { $time_changed++; $OPTS{'search_hours'} = $_[1]; },
#        'created|c=s' => sub { $OPTS{'report'} = 'acctls'; $OPTS{'email'} = $_[1]; },
        'reseller|r'  => \$OPTS{'reseller'},
        'help|?'      => sub { HelpMessage() },
        'version'     => sub { VersionMessage(module_versions()) },
    );

    HelpMessage() if (not defined ${OPTS}{'user'});

    return $result;
}

sub check_options {
    Getopt::Long::Configure(qw(gnu_getopt auto_version auto_help));
    my $time_changed;
    my $tag_flag;

    return run_ecpp() if (basename($0) =~ m/^ec|ecpp$/);

    my $result = GetOptions(
        'start|s=s'   => sub { $time_changed++; $OPTS{'start_time'} = $_[1]; },
        'end|e=s'     => sub { $time_changed++; $OPTS{'end_time'} = $_[1]; },
        'hours|h=i'   => sub { $time_changed++; $OPTS{'search_hours'} = $_[1]; },
#        'created|c=s' => sub { $OPTS{'report'} = 'acctls'; $OPTS{'email'} = $_[1]; },
#        'time|t=s'    => \$OPTS{'timespec'},
        'override|o'  => \$OPTS{'time_override'},
        'read=i'      => \$OPTS{'read_lines'},
        'uncached'    => \$OPTS{'uncached'},  # experimental, undocumented
        'cutoff=i'    => \$OPTS{'r_cutoff'},  # experimental, undocumented

        'without|w=s' => \$OPTS{'without'},
        'full|f'      => \$OPTS{'full'},
        'user|u=s'    => sub { if ($OPTS{'report'} eq 'summary') { $OPTS{'report'} = 'user'; $OPTS{'load'} = 'cache' } $OPTS{'user'} = $_[1]; $OPTS{'full'} = 1 },
        'hourly'      => \$OPTS{'hourly_report'},
        'reseller|r'  => \$OPTS{'reseller'},

        'scripts'     => sub { $OPTS{'report'} = 'script'; $OPTS{'load'} = 'no' },
        'md5=s'       => sub { $OPTS{'report'} = 'md5'; $OPTS{'scriptmd5report'} = $_[1]; $OPTS{'load'} = 'no' },
        'logins'      => sub { $OPTS{'report'} = 'logins' },
        'helos'       => sub { $OPTS{'report'} = 'helos' },
        'forwarders'  => sub { $OPTS{'report'} = 'forwarders' },

        'load=s'      => sub { $OPTS{'load'} = 'cache'; SpamReport::Data::resolve($_[1]); $OPTS{'save'} = 0 },
        'loadcron=s'  => sub { $OPTS{'load'} = 'cron'; SpamReport::Data::resolvecron($_[1]); $OPTS{'save'} = 0 },
        'save'        => \$OPTS{'save'},  # undocumented
        'dump=s'      => \$OPTS{'dump'},
        'keep=i'      => \$SpamReport::Data::MAX_RETAINED,

        'tag=s'       => sub { $SpamReport::Data::logpath .= ".$_[1]";
                               $SpamReport::Data::cronpath .= ".$_[1]";
                               $tag_flag = 1; },
        'ls'          => sub { $OPTS{'report'} = 'cachels'; $OPTS{'load'} = 'no' },
        'cron'        => sub { $OPTS{'op'} = 'cron'; $OPTS{'load'} = undef },
        'update'      => sub { $OPTS{'op'} = 'update' },
        'latest'      => sub { $OPTS{'load'} = 'cache' },

        'help|?'      => sub { HelpMessage() },
        'man'         => sub { pod2usage(-exitval => 0, -verbose => 2) },
        'version'     => sub { VersionMessage(module_versions()) },
    );

    # XXX: reports that don't work with cache currently
    if ($OPTS{'load'} eq 'cache' && $OPTS{'report'} eq 'forwarders') {
        $OPTS{'load'} = 'cron';
    }
    if ($OPTS{'op'} eq 'report' && $time_changed) {
        die "${RED}[FAULT] Non-default times requested without --override flag!$NULL\n",
             "\n",
             "* spamreport uses daily and hourly cache to speed up normal usage.\n",
             "*\n",
             "* Using non-default times can slow spamreport down by a factor of 60x or more.\n",
             "*\n",
             "* If you really mean to do this, pass the --override flag.\n",
             "*\n",
             "* (or c.f CREATING NONDEFAULT CACHE in spamreport --man)\n\n"
            unless $OPTS{'time_override'};
        $OPTS{'load'} = undef;
        SpamReport::Data::disable() unless $tag_flag;
    } elsif ($time_changed) {
        warn "${RED}[WARN] Saving over default cache with non-default time arguments (did you mean to use --tag?)$NULL\n"
            unless $tag_flag;
        $OPTS{'load'} = undef;
    }
    
    $OPTS{'want_queue'} = 1 if $OPTS{'op'} ne 'cron' && $OPTS{'with_queue'};
    $OPTS{'want_maillog'} = 1 if $OPTS{'op'} ne 'report' or $OPTS{'report'} eq 'logins';
    $OPTS{'want_eximlog'} = 1 unless $OPTS{'report'} eq 'md5'
                                  or $OPTS{'report'} eq 'logins';
    $OPTS{'want_scripts'} = 1 if $OPTS{'want_eximlog'} or $OPTS{'report'} eq 'md5';
    # eximdb: unused

    if ( $OPTS{'start_time'} && $OPTS{'start_time'} !~ m/^\d+$/ ) {
        $OPTS{'start_time'} = str2time($OPTS{'start_time'}) or die "Invalid start time";
    }

    if ( $OPTS{'end_time'} && $OPTS{'end_time'} !~ m/^\d+$/ ) {
        $OPTS{'end_time'} = str2time($OPTS{'end_time'}) or die "Invalid end time";
    }

    if ( $OPTS{'start_time'} && $OPTS{'end_time'} ) {

        ($OPTS{'start_time'}, $OPTS{'end_time'}) = ($OPTS{'end_time'}, $OPTS{'start_time'})
            if ( $OPTS{'start_time'} > $OPTS{'end_time'} );

    }

    # filesystem security, if we're putting dumps somewhere
    # 1. ensure that the directory exists (just a way of ensuring that the path is sensible)
    # 2. ensure that the directory is owned by root
    # 3. ensure that created files don't have group or other perms
    #    (and make them non-executable for root as well)
    for (defined($OPTS{'dump'}) ? $OPTS{'dump'} : ()) {
        my $d;
        if (-d $_) { $d = $_ }
        elsif (m,^(/.*)/[^/]+$, && -d $1) { $d = $1 }
        elsif ($_ !~ m,/,) { $d = '.' }
        else { die "Directory doesn't exist for --dump target: $_" }

        if (! -o $d) {
            die "--dump target must be owned by root: $d"
        }
    }
    umask 0177;
    mkdir "/opt/hgmods/logs/", 0700;

    $OPTS{'start_time'} = $OPTS{'end_time'} - ($OPTS{'search_hours'} * 3600) if ( ! $OPTS{'start_time'} );

    die "Invalid number of lines to read: " . $OPTS{'read_lines'} if ( $OPTS{'read_lines'} <= 0 );


    my (%dovecot, %exim);
    for (my $i = $OPTS{'end_time'}; $i >= $OPTS{'start_time'}; $i -= 3600 * 24) {
        $exim{POSIX::strftime("%F", CORE::localtime($i))}++;
        $dovecot{POSIX::strftime("%b %d", CORE::localtime($i))}++;
    }
    $OPTS{'dovecot_days'} = \%dovecot;
    $OPTS{'exim_days'} = \%exim;
    $OPTS{'exim_today'} = POSIX::strftime("%F", CORE::localtime());
    $OPTS{'dovecot_today'} = POSIX::strftime("%b %d", CORE::localtime());

    my (%dovecotpost, %eximpost);
    for (my $i = $OPTS{'end_time'} + 3600 * 24; $i < $OPTS{'end_time'} + 3600 * 24 * 4; $i += 3600 * 24) {
        $eximpost{POSIX::strftime("%F", CORE::localtime($i))}++;
        $dovecotpost{POSIX::strftime("%b %d", CORE::localtime($i))}++;
    }
    $OPTS{'dovecot_postdays'} = \%dovecotpost;
    $OPTS{'exim_postdays'} = \%eximpost;

    return $result;
}

sub parse_retries {

    my ($key, $value) = @_;

    # typedef struct {
    #   time_t time_stamp;
    #   /*************/
    #   time_t first_failed;    /* Time of first failure */
    #   time_t last_try;        /* Time of last try */
    #   time_t next_try;        /* Time of next try */
    #   BOOL   expired;         /* Retry time has expired */
    #   int    basic_errno;     /* Errno of last failure */
    #   int    more_errno;      /* Additional information */
    #   uschar text[1];         /* Text message for last failure */
    # } dbdata_retry;

    my ($type, $address, $log_data) = split /:/, $key;

    if ( $type eq 'R' and $log_data and not $log_data =~ m/H=cm\.websitewelcome\.com/ ) {
        my ($time_stamp, $first_failed, $last_try, $next_try, $expired, $basic_errno, $more_errno, $text)
            = unpack ('l x4 l x4 l x4 l x7 b1 i i Z*', $value);
        if ( not $expired and ($last_try >= $OPTS{'start_time'}) and ($last_try < $OPTS{'end_time'}) ) {
            $log_data =~ s/<|>//g;
            my ($mail_username, $mail_hostname) = split /@/, $log_data;
            $data->{'senders'}{$mail_username}{'retries'}++ if ( $mail_hostname eq $hostname );
        }
    }

    1;
}

sub parse_ratelimit {

    my ($key, $value) = @_;

    # typedef struct {
    #   time_t time_stamp;
    #   /*************/
    #   int    time_usec;       /* Fractional part of time, from gettimeofday() */
    #   double rate;            /* Smoothed sending rate at that time */
    # } dbdata_ratelimit;

    my (undef, $unit, $conn_ip) = split /\//, $key;

    my ($time_stamp, $time_usec, $rate) = unpack ('l x4 i x4 d', $value);
    $data->{'ip_addresses'}{$conn_ip}{'conn_rate'} = $rate
        if ($time_stamp >= $OPTS{'start_time'} and $time_stamp < $OPTS{'end_time'} );

    1;

}

my $hidesti = qr/$RE{'spam'}{'hi_destination'}/i;
sub parse_wait {
 
    my ($key, $value) = @_;

    # typedef struct {
    #   time_t time_stamp;
    #   /*************/
    #   int    count;           /* Count of message ids */
    #   int    sequence;        /* Sequence for continued records */
    #   uschar text[1];         /* One long character string */
    # } dbdata_wait;
    
    my ($host) = split /:/, $key;

    my ($time_stamp, $count, $sequence) = unpack ('l x4 i i', $value);
    my @mail_ids = unpack ("x[l] x4 x[i] x[i] (A16)$count", $value);

    if ($host =~ $hidesti) {
        $data->{'mail_ids'}{$_}{'send_delays'}++ for (@mail_ids);
        $data->{'dest_domains'}{$1}{'delays'}++ for (@mail_ids);
    }

    1;
}

sub show_progress {
    my ($file_handle, $new_text, $threshold, $increment) = @_;

    $new_text ||= File::Nonblock::progress_state($file_handle);
    $threshold ||= 1;
    $increment ||= 10;

    my $file_name = File::Nonblock::name($file_handle) or die "Non-open file handle";
    my $change = File::Nonblock::new_progress($file_handle, $threshold);
    my $cur_text = File::Nonblock::progress_state($file_handle);

    if ( $change
         or File::Nonblock::tell($file_handle) == 0
         or $cur_text ne $new_text ) {

        my $text = $cur_text eq $new_text ? $cur_text
                                          : File::Nonblock::set_progress_state($file_handle, $new_text);

        my $percentage = int(File::Nonblock::progress($file_handle) * 100);

        if ( -t STDOUT ) {
            print "\r\e[K\r$text $file_name: ($percentage%)";
        }
        else {
            if ( $percentage == 0 ) {
                print "$text $file_name: ";
            }
            elsif ( $cur_text ne $new_text ) {
                print " $text ";
            }

            if ( ($percentage % $increment ) + $change > $increment ) {
                $percentage = $percentage + $change - $increment;
                $change -= $increment;
            }

            if ( ( $percentage == 0) || ($percentage % $increment == 0) ) {
                print "$percentage%";
            }
            else {
                print "." x $change;
            }
        }
    }

    1;
}

sub get_next_lines {
    my ($log_fh, $year, $allow_year_dec) = @_;
    my $lines = File::Nonblock::read_lines($log_fh, $OPTS{'read_lines'});
    $lines && return ($year, $lines)
}

sub parse_exim_dbs {
    my %db_parsers = (
        'retry'            => \&parse_retries,
        'ratelimit'        => \&parse_ratelimit,
        'wait-remote_smtp' => \&parse_wait,
    );

    for my $db_name ( keys %db_parsers ) {
        SpamReport::Exim::DB::open($db_name);
        SpamReport::Exim::DB::read($db_name, $db_parsers{$db_name});
        SpamReport::Exim::DB::close($db_name);
    }

    1;
}

sub parse_exim_queue {
    SpamReport::Exim::parse_queued_mail_data($OPTS{'start_time'}, $OPTS{'end_time'});
}

sub parse_logs {
    my ($handler, @logs) = @_;
    if ($data->{'OPTS'}{'datelimit'} eq 'only today') {
        @logs = grep { -M $_ < 1 } @logs
    }

    for my $logfile (sort { -M $b <=> -M $a } @logs) {
        my $end_reached;
        my $mtime = (stat($logfile))[9];
        next if ( $mtime < $OPTS{'start_time'} );
        my $year = (CORE::localtime($mtime))[5];
        my $allow_year_dec = 1;
        my $lines;
        my $in_zone = [0];

        my $log = File::Nonblock::open($logfile, 8*1024) or die "Could not open $logfile";

        while (not File::Nonblock::eof($log)) {
            ($year, $lines) = get_next_lines($log, $year, $allow_year_dec) or $end_reached = 1;
            last if $end_reached;

            if ( File::Nonblock::tell($log) != 0 ) {
                show_progress($log, 'Reading')
            }

            $handler->($lines, $year, $OPTS{'end_time'}, $in_zone);

            $allow_year_dec = 0;
        }

        File::Nonblock::close($log);
        print "\n";

        last if $end_reached;
    }

    1;
}

sub parse_cpanel_logs {
    return if $data->{'OPTS'}{'datelimit'} eq 'not today';
    parse_logs(\&SpamReport::Cpanel::find_email_creation, glob '/usr/local/cpanel/logs/{access_log,archive/access_log-*.gz}');
}

sub parse_exim_logs {
    parse_logs(\&SpamReport::Exim::parse_exim_mainlog, glob '/var/log/exim_mainlog{,{-*,.?}.gz}');
}
sub parse_dovecot_logs {
    parse_logs(\&SpamReport::Maillog::find_dovecot_logins, glob '/var/log/maillog{,{-*,.?}.gz}');
}

sub setup_cpanel {
    my $new;

    my $userdomains_path = '/etc/userdomains';
    my $trueuserowners_path = '/etc/trueuserowners';
    my $valiases_path = '/etc/valiases';

    %factories = (
        'user:domain' => \&SpamReport::Cpanel::map_userdomains,
        'user:owner' => \&SpamReport::Cpanel::map_userowners,
        'alias:dest'  => \&SpamReport::Cpanel::map_valiases,
    );

    %{ $new } = map {

        my $data_path = $_ eq 'user:domain' ? $userdomains_path
                      : $_ eq 'user:owner'  ? $trueuserowners_path
                      : $_ eq 'alias:dest'  ? $valiases_path
                                            : die 'Unexpected error';

        my @map_names = split ':';
        my @map_data = $factories{$_}($data_path);

        my $map1 = $map_names[0] . '2' . $map_names[1];
        my $map2 = $map_names[1] . '2' . $map_names[0];

        ($map1 => $map_data[0], $map2 => $map_data[1]);

    } keys %factories;

    $data->{$_} = $new->{$_} for keys %$new;

    1;
}

sub user {
    my ($user) = @_;
    if (exists $data->{'domain2user'}{$user}) {
        print "Assuming you mean $data->{'domain2user'}{$user} by $user\n";
        $user = $data->{'domain2user'}{$user};
    }
    die "No such user: $user" unless getpwnam($user);
    $user
}

sub purge {
    my %users = map { ($_, 1) } @_;
    for (keys %{$data->{'mail_ids'}}) {
        if (exists $users{$data->{'mail_ids'}{$_}{'who'}}) {
            if ($data->{'mail_ids'}{$_}{'type'} eq 'bounce') {
                $data->{'total_bounce'}--;
                $data->{'filtered_bounce'}++;
            } else {
                $data->{'total_outgoing'}--;
                $data->{'filtered_outgoing'}++;
            }
            delete $data->{'mail_ids'}{$_};
        }
    }
    for (keys %users) {
        delete $data->{'responsibility'}{$_};
        delete $data->{'owner_responsibility'}{$_};
        delete $data->{'bounce_responsibility'}{$_};
        delete $data->{'bounce_owner_responsibility'}{$_};
    }
    for (keys %{$data->{'outscript'}}) {
        delete $data->{'outscript'}{$_} if m,^/[^/]+/([^/]+)/, && exists $users{$1}
    }
    for (keys %{$data->{'scriptdirs'}}) {
        delete $data->{'scriptdirs'}{$_} if m,^/[^/]+/([^/]+)/, && exists $users{$1}
    }
}

sub userfy_args {
    $OPTS{'without'} = [map { user($_) } split ' ', $OPTS{'without'}]
        if defined $OPTS{'without'};
    $OPTS{'user'} = user($OPTS{'user'})
        if $OPTS{'report'} eq 'user' && $OPTS{'user'} ne 'root';
}

sub main {
    my $loadedcron;

    STDOUT->autoflush(1);
    STDERR->autoflush(1);

    die "This script only supports cPanel at this time."
        unless -r '/etc/userdomains' && -d '/etc/valiases';
    check_options() or pod2usage(2);

    SpamReport::Tracking::Scripts::disable() unless $OPTS{'want_scripts'};
    SpamReport::Data::disable() if $OPTS{'uncached'};
    SpamReport::Tracking::Scripts::load();

    if ($OPTS{'load'} eq 'cron') {
        SpamReport::Data::loadcron();
        $OPTS{$_} = $data->{'OPTS'}{$_} for @SAVED_OPTS;
        if (keys %$data) {
            $loadedcron = 1;
        } else {
            warn "${RED}daily cache not not loaded! $SpamReport::Data::loadcronfail\n"
               . "This run will take much longer than normal$NULL\n"
        }
    }
    DumpFile($OPTS{'dump'}.".cron", $data) if $loadedcron && $OPTS{'dump'};

    $data->{'OPTS'} = \%OPTS;

    if ($OPTS{'op'} eq 'cron' or $OPTS{'op'} eq 'update') {
        SpamReport::Output::head_info(\%OPTS);
        setup_cpanel();
        if ($OPTS{'op'} eq 'cron' || !$loadedcron) {
            $OPTS{'datelimit'} = 'not today';
            parse_exim_dbs() if $OPTS{'want_eximdb'};
            parse_exim_logs() if $OPTS{'want_eximlog'};
            parse_dovecot_logs() if $OPTS{'want_maillog'};
        }
        if ($OPTS{'op'} eq 'update') {
            SpamReport::Data::savecron() if !$loadedcron && $OPTS{'save'};
            $OPTS{'datelimit'} = 'only today' if $loadedcron;
            parse_exim_dbs() if $OPTS{'want_eximdb'};
            parse_exim_logs() if $OPTS{'want_eximlog'};
            parse_exim_queue() if $OPTS{'want_queue'};
            parse_dovecot_logs() if $OPTS{'want_maillog'};
            DumpFile($OPTS{'dump'}.".scan", $data) if $OPTS{'dump'};
        }
        SpamReport::Cpanel::young_users();
        SpamReport::Tracking::Scripts::save() if $OPTS{'save'};
        SpamReport::Data::exitsavecron() if $OPTS{'op'} eq 'cron';
        SpamReport::Cpanel::offserver_forwarders();
        SpamReport::Data::save() if $OPTS{'save'};
        exit
    }

    # op: report


    if ($OPTS{'load'} eq 'no') {
        # no need to load data
        SpamReport::Output::head_info($data->{'OPTS'});
        SpamReport::Tracking::Scripts::save() if $OPTS{'save'};
    } elsif ($OPTS{'load'} eq 'cache') {
        SpamReport::Data::load();
        userfy_args();
        $OPTS{$_} = $data->{'OPTS'}{$_} for @SAVED_OPTS;
        $data->{'OPTS'} = \%OPTS;
        SpamReport::Output::head_info($data->{'OPTS'});
    } else {
        SpamReport::Output::head_info($data->{'OPTS'});
        setup_cpanel();
        userfy_args();
        SpamReport::Cpanel::offserver_forwarders();
        $OPTS{'datelimit'} = 'only today' if $loadedcron;
        parse_exim_dbs() if $OPTS{'want_eximdb'};
        parse_exim_queue() if $OPTS{'want_queue'};
        parse_exim_logs() if $OPTS{'want_eximlog'};
        parse_dovecot_logs() if $OPTS{'want_maillog'};
        SpamReport::Data::save() if $OPTS{'save'} && !($OPTS{'load'} eq 'cache'
            or defined($OPTS{'user'})
            or defined($OPTS{'without'}));
        SpamReport::Tracking::Scripts::save() if $OPTS{'save'};
    }
    SpamReport::Tracking::Suspensions::load();
    SpamReport::GeoIP::init();

    my @to_purge;
    push @to_purge, @{$OPTS{'without'}} if $OPTS{'without'};
    push @to_purge, SpamReport::Tracking::Suspensions::ticketed_users() unless $OPTS{'full'};
    purge(@to_purge) if @to_purge;
    
    if ($OPTS{'report'} eq 'user') {
        my $isreseller = $OPTS{'reseller'} || $OPTS{'user'} eq 'root';
        SpamReport::Output::analyze_user_results($OPTS{'user'}, $isreseller);
        SpamReport::Output::print_user_results($OPTS{'user'}, $isreseller);
        exit;
    }

    if ($OPTS{'report'} eq 'acctls') {
        
        SpamReport::Output::email_search_results($OPTS{'email'});
        exit;
    }

    if ($OPTS{'report'} eq 'script') {
        SpamReport::Output::print_script_report();
        exit;
    }

    if ($OPTS{'report'} eq 'md5') {
        SpamReport::Output::print_script_info($OPTS{'scriptmd5report'});
        exit
    }

    if ($OPTS{'report'} eq 'logins') {
        SpamReport::Maillog::analyze_logins();
        SpamReport::Output::print_login_results(); 
        exit;
    }

    if ($OPTS{'report'} eq 'helos') {
        SpamReport::Output::analyze_helos();
        SpamReport::Output::print_helo_report();
        exit;
    }

    if ($OPTS{'report'} eq 'forwarders') {
        SpamReport::Cpanel::offserver_forwarders();
        SpamReport::Output::print_forwarder_abuse();
        exit;
    }

    if ($OPTS{'report'} eq 'cachels') {
        SpamReport::Output::cache_ls();
        exit;
    }

    die "Invalid \$OPTS{'report'} : $OPTS{'report'}"
        unless $OPTS{'report'} eq 'summary';

    SpamReport::Output::analyze_results(); 
    SpamReport::Output::print_results(); 
}

sub module_versions {
    my $output;
    for (qw(SpamReport::GeoIP
            SpamReport::Data
            SpamReport::Tracking::Scripts
            SpamReport::Tracking::Suspensions
            SpamReport::Tracking::Performance
            Regexp::Common::Exim
            Regexp::Common::Maillog
            Regexp::Common::SpamReport
            SpamReport::ANSIColor
            SpamReport::Annotate
            SpamReport::Output
            File::Nonblock
            SpamReport::Cpanel
            SpamReport::Exim
            SpamReport::Exim::DB
            SpamReport::Maillog
            SpamReport)) {
        my $v = ${$_."::VERSION"};
        if ($v =~ /^(\d{4}) (\d{2}) (\d{2}) (\d{2})$/x) {
            $v = $months[$2-1] . " $3, $1 rev. " . (0+$4)
        }
        $output .= "($v) $_\n"
    }
    $output
}

__PACKAGE__->main unless caller; # call main function unless we were included as a module

1;

__END__

=head1 NAME

spamreport - Quickly report suspicious mail behavior on a server

=head1 SYNOPSIS

spamreport [--current] [--dbs] [-sehmn] [other long options...]

options:

    -s <time>   | --start=<time>
    -e <time>   | --end=<time>
    -h <hours>  | --hours=<hours>
        (default: 72 hours)
        (NB. spamreport has a minimum granularity of one calendar day)

    -u <user>   | --user=<user>         : report on a user, implies --latest
                | --hourly              : add emails/hour to --user output
    -r          | --reseller            : include user's resold accounts

                | --logins              : print login report
                | --forwarders          : print forwarder reporter
                | --scripts             : print scripts report
                | --md5 <md5sum>        : print details about a script md5sum
                | --helos               : print HELO report

    -w          | --without=<u1 u2 ..>  : remove users' email before reporting
    -f          | --full                : don't remove ticketed users' email

                | --cron                : gather crondata, save it, and exit
                | --update              : gather fulldata, save it, and exit
                | --latest              : use fulldata if present
                | --load=path/to/file   : load data from file
                | --keep=<number>       : preserve # of rotated logs
                | --tag=<tag>           : use tagged instead of default cache
                | --ls                  : show available cache files

                | --dump=path/to/file   : save (human-readable) YAML files to
                                          $path.cron  : --cron seeded data
                                          $path.scan  : pre-analysis data
                                          $path.post  : post-analysis data

                | --help
                | --man
                | --version

Usage:

    spamreport [--full]
    spamreport -u <user> [--hourly]
    spamreport -u <reseller> -r
    spamreport -u root

    spamreport --logins [-u <user>]
    spamreport --forwarders [--full] [-u <user>]
    spamreport --scripts [--full]
    spamreport --md5 <md5sum>
    spamreport --helos [--full] [-u <user>]

    spamreport --without "baduser boringuser checkeduser" [...]

    spamreport --cron     # update previous-days' cache (cache used by default)
    spamreport --update   # update today's cache (cache ignored by default)
    spamreport --latest   # use today's cache

Indicator key:

    ABC-12341234.http  | a ticket ID in an active abusetool suspension
    abuse:#            | user was abusetool'd # times in the last 60 days
    security:12h       | ~user/.security was modified $time ago
    discard:22.3%      | % of user's email that hit the 500/hr limit

    seen:              | first root history mention of user within last week
    (user age)         | user was added to cPanel <2 weeks ago
    stale:             | <10% of user's email was sent in last 24 hours
    recent:            | >80% of user's email was sent in last 24 hours

    fake_accts?        | >80% of email sent by underbar_accounts@domain.com
    bad_sender?        | >90% of email has a suspect domain or spam TLD
    bad_recipients?    | >90% of email intended for critical destinations
    cron?              | >90% of email has subjects suggesting crond mail
    script_comp?       | >90% of email sent by a script
    bots?              | >80% of email has subjects resembling CMS mail
                         e.g. Account Details for ...

    boxtrapper:        | >50% of email has subjects suggesting boxtrapper
  bob@domain.com(IPs)  | mailbox has more than 10 /16 IPs authenticating as it

=head1 CREATING NONDEFAULT CACHE

    The intent is that a once-daily cron will update daily cache, and that a
    once-hourly cron will update cache over the course of the day, and that
    most queries can make use the hourly cache to provide useful and timely
    information about the server's last few days.

    On a VPS or dedicated server, you won't have the cache to use.  On a shared
    server, you may to perform a series of historical queries -- f.e., get a
    general report about a week-long period a month ago, and then get a user
    report from that period.  To speed up multiple queries you can create the
    cache to use yourself.  So as to not confuse the next admin that comes
    along (and, potentially, to keep the data for further investigation), you
    should tag your cache.

    For example:

      # spamreport --start '14 Feb' --end '17 Feb' --update --tag bad

    This will read files twice, first to create the daily cache and then to
    create the hourly cache.  Subsequent usage:

      # spamreport --load .bad
      # spamreport --load .bad -u badguy
      # spamreport --load .bad -u root
      # spamreport --load .bad --without "good1 good2"
      # spamreport   # a normal run, not using this cache

      # spamreport --ls   # see available cache

=head1 EXPLORING ON YOUR OWN

    You can pass spamreport, with --dump, a path to store YAML dumps of most of
    its data at several stages of operation.  You can then load this YAML with a
    normal oneliner and perform your own ad-hoc analysis of it, or otherwise
    explore it in ways not anticipated by spamreport's options.

      # perl spamreport --latest --tag '14-17feb2016' --dump=yaml
      ...
      # ls yaml*
      yaml.post
  
      # perl spamreport --dump=dump
      ...
      # ls dump*
      dump.cron  dump.post
  
      # egrep '^[^ ]' dump.cron
      --- 
      bounce_owner_responsibility: 
      bounce_responsibility: 
      domain_responsibility: 
      hourly_volume: 
      logins: 
      mail_ids: 
      mailbox_responsibility: 
      outscript: 
      owner_responsibility: 
      responsibility: 
      scriptdirs: 
      total_bounce: 10755
      total_outgoing: 16286
      # egrep -c '^[^ ]' dump.post
      40

    FILE.post is saved right before spamreport halts, and contains the most
    information.  It can also include analysis performed on behalf of the flags
    given along with the --dump flag.

      # perl -MYAML::Syck=LoadFile -le '$email = LoadFile("dump.post")->{"mail_ids"}; print $_->{"subject"} for values %$email'|grep -i paypal|sort|uniq -c|sort -nr|head
         8000 [Paypal-lnc] - Account Has Closed !
           15 [Team Paypal] : Your Account has limited
           12 [Paypal-lnc] : Account Has Closed !
            5 [Paypal-lnc] : Update Your Account !
            4 [Paypal-lnc] - Account Has Limeted !
            1 Paypal - Account Has Limeted !
      # perl -MYAML::Syck=LoadFile -le 'print join " " => sort keys %{LoadFile("dump.post")->{'young_users'}}'
ab7029 ab7266 adeola72 bodynas cameranclick cjzgproducciones done donex dpianes effacorg emege fassad75 ff ff1 ff2 ff3 ff4 ff5 ff6 fitter handhcom insidenwa jeune jmdproduction kamaracafe kcnasmedia lim lnc matrizbiotech maynaronline modoc nawboraleigh passinglane peakworx polygraphsa prestigetoy producershybrids prologues qashif rangpurstore rdnyc salahox santibibiloni scagrisolutions scamps seand secutronca shakespeares shivpuri speedkills uysys vfiber

=head1 FILES

    /opt/hgmods/logs/spamreportcron.dat  (and .1, .2, ...)

        Storable cache of data drawn from prior calendar days' email logs.
    
    /opt/hgmods/logs/spamreport.dat      (and .1, .2, ...)

        Storable cache of pre-analysis data drawn from prior runs.

    /opt/hgmods/logs/spamscripts.dat

        YAML script tracking data.

        "md5sum" -> "ips" -> (ips -> # hits by IP against md5sum)
                    "paths" -> (script paths -> # hits against path)

    /opt/hgmods/logs/spamperformance.log

        Text log of spamreport performance data.

        $date + $runtime secs : $email tracked emails : @ARGV

=head1 MODULES

=head2 package SpamReport;

=head3 check_options

    Argument handling.  Most flags result in modifications to %OPTS hash, which
    is duplicated in $data->{'OPTS'}, which is what every other package uses
    instead of %SpamReport::OPTS directly.

    Argument sanity checking, "x implies y", and date calculations are in this
    subroutine as well.

=head3 setup_cpanel

    Populate %data with cPanel information, such as user ownership & domain
    ownership.

=head3 main

    Toplevel function.  This governs cache loading and saving (now how this is
    done (that's in SpamReport::Data) but when it should be done) and fires off
    analysis and reporting functions as required by the current run.

=head2 package SpamReport::Output;

    Primary output and reporting module.  Of program output, only warnings,
    errors, progress updates, and ::Data loading messages are elsewhere.

=head2 package File::Nonblock;

    Reads log files in batches of lines, compressed or otherwise, with support
    for accurate progress indicators.

